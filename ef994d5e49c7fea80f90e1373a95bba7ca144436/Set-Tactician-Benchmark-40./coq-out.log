Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 37 - 66 [Require~Export~Category.Core.] 0.028 secs (0.019u,0.008s)
Chars 68 - 94 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 95 - 118 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 119 - 147 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 148 - 172 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 217 - 235 [Section~internals.] 0. secs (0.u,0.s)
Chars 238 - 266 [Variables~(C~D~:~PreCategory).] 0. secs (0.u,0.s)
Chars 270 - 458 [Definition~sum_morphism~(s~d~:...] 0.002 secs (0.002u,0.s)
Chars 462 - 499 [#[global]Arguments~sum_morphis...] 0. secs (0.u,0.s)
Chars 503 - 651 [Definition~sum_identity~(x~:~C...] 0.001 secs (0.001u,0.s)
Chars 655 - 690 [#[global]Arguments~sum_identit...] 0. secs (0.u,0.s)
Chars 694 - 818 [Definition~sum_compose~(s~d~d'...] 0.001 secs (0.001u,0.s)
Chars 821 - 827 [Proof.] 0. secs (0.u,0.s)
Chars 832 - 941 [(destruct~s,~d,~d';~simpl~in~*...] 0.072 secs (0.011u,0.011s)
Chars 832 - 941 [(destruct~s,~d,~d';~simpl~in~*...] 0.003 secs (0.003u,0.s)
Chars 944 - 952 [Defined.] 0.002 secs (0.002u,0.s)
Chars 956 - 1000 [#[global]Arguments~sum_compose...] 0. secs (0.u,0.s)
Chars 1001 - 1015 [End~internals.] 0.007 secs (0.006u,0.s)
Chars 1017 - 1066 [Definition~sum~(C~D~:~PreCateg...] 0. secs (0.u,0.s)
Chars 1067 - 1073 [Proof.] 0. secs (0.u,0.s)
Chars 1076 - 1391 [(refine~~~(@Build_PreCategory~...] 0.338 secs (0.17u,0.121s)
Chars 1076 - 1391 [(refine~~~(@Build_PreCategory~...] 0.001 secs (0.u,0.001s)
Chars 1392 - 1400 [Defined.] 0.023 secs (0.021u,0.001s)
Chars 1402 - 1437 [Module~Export~CategorySumNotat...] 0. secs (0.u,0.s)
Chars 1440 - 1474 [Infix~"+"~:=~sum~:~category_sc...] 0. secs (0.u,0.s)
Chars 1475 - 1500 [End~CategorySumNotations.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 44 - 176 [Require~Import~Basics.Overture...] 0.318 secs (0.24u,0.077s)
Chars 177 - 206 [#[local]Open~Scope~trunc_scope.] 0. secs (0.u,0.s)
Chars 207 - 235 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 433 - 481 [Class~Decidable~(A~:~Type)~:=~...] 0.001 secs (0.001u,0.s)
Chars 482 - 502 [Arguments~dec~A~{_}.] 0. secs (0.u,0.s)
Chars 654 - 777 [Ltac~~decide_type~A~:=~~~let~K...] 0. secs (0.u,0.s)
Chars 779 - 847 [Ltac~decide~:=~match~goal~with...] 0. secs (0.u,0.s)
Chars 849 - 934 [Class~DecidablePaths~(A~:~Type...] 0.001 secs (0.u,0.s)
Chars 935 - 970 [#[global]Existing~Instance~dec...] 0. secs (0.u,0.s)
Chars 972 - 1008 [Class~Stable~P~:=~~~~~stable~:...] 0. secs (0.u,0.s)
Chars 1010 - 1072 [#[global]Instance~stable_decid...] 0. secs (0.u,0.s)
Chars 1073 - 1079 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.343 secs (0.253u,0.088s)
Chars 23 - 51 [Require~Import~WildCat.Core.] 0.05 secs (0.042u,0.008s)
Chars 52 - 81 [Require~Import~WildCat.Equiv.] 0.12 secs (0.088u,0.031s)
Chars 116 - 204 [#[global]~Instance~isgraph_typ...] 0.001 secs (0.u,0.001s)
Chars 206 - 250 [#[global]Instance~is01cat_type...] 0. secs (0.u,0.s)
Chars 251 - 257 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 67 - 115 [Require~Import~Category.Core~C...] 1.779 secs (1.592u,0.183s)
Chars 116 - 150 [Require~Import~Category.Unival...] 0.002 secs (0.002u,0.s)
Chars 151 - 238 [Require~Import~Category.Sigma....] 0.139 secs (0.135u,0.003s)
Chars 239 - 290 [Require~Import~HoTT.Types~HoTT...] 0.025 secs (0.022u,0.002s)
Chars 292 - 318 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 319 - 342 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 343 - 371 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 372 - 396 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 398 - 453 [#[local]Notation~pr1_type~:=~O...] 0. secs (0.u,0.s)
Chars 455 - 483 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 484 - 516 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 518 - 550 [#[local]Open~Scope~function_sc...] 0. secs (0.u,0.s)
Chars 941 - 959 [Section~onobjects.] 0. secs (0.u,0.s)
Chars 962 - 987 [Variable~(A~:~PreCategory).] 0.027 secs (0.02u,0.006s)
Chars 990 - 1016 [Variable~(Pobj~:~A~->~Type).] 0. secs (0.u,0.s)
Chars 1020 - 1139 [#[global]~Instance~iscategory_...] 0.001 secs (0.001u,0.s)
Chars 1142 - 1148 [Proof.] 0. secs (0.u,0.s)
Chars 1153 - 1164 [(intros~s~d).] 5.11 secs (2.828u,0.151s)
Chars 260 - 273 [econstructor.] 27.947 secs (0.001u,0.017s)
Chars 276 - 277 [+] 0. secs (0.u,0.s)
Chars 278 - 297 [(intro;~exact~idmap).] 0. secs (0.u,0.s)
Chars 300 - 301 [+] 0. secs (0.u,0.s)
Chars 302 - 333 [exact~(fun~a~b~c~g~f~=>~g~o~f).] 0.001 secs (0.u,0.s)
Chars 260 - 273 [econstructor.] 0. secs (0.u,0.s)
Chars 278 - 297 [(intro;~exact~idmap).] 0. secs (0.u,0.s)
Chars 302 - 333 [exact~(fun~a~b~c~g~f~=>~g~o~f).] 0. secs (0.u,0.s)
Chars 334 - 342 [Defined.] 0. secs (0.u,0.s)
Chars 344 - 442 [#[global]~Instance~is2graph_ty...] 0.001 secs (0.001u,0.s)
Chars 584 - 667 [#[global]~Instance~isgraph_arr...] 0.001 secs (0.001u,0.s)
Chars 669 - 732 [#[global]Instance~is01cat_arro...] 0.001 secs (0.u,0.s)
Chars 733 - 739 [Proof.] 0. secs (0.u,0.s)
Chars 1082 - 1118 [(intros~dn;~destruct~(dec~P)~a...] 40.082 secs (0.u,0.012s)
Chars 1121 - 1122 [-] 0. secs (0.u,0.s)
Chars 1123 - 1134 [assumption.] 0. secs (0.u,0.s)
Chars 1137 - 1138 [-] 0. secs (0.u,0.s)
Chars 1139 - 1161 [(apply~Empty_rect,~dn,~n).] 0. secs (0.u,0.s)
Chars 1082 - 1118 [(intros~dn;~destruct~(dec~P)~a...] 0. secs (0.u,0.s)
Chars 1123 - 1134 [assumption.] 0. secs (0.u,0.s)
Chars 1139 - 1161 [(apply~Empty_rect,~dn,~n).] 0. secs (0.u,0.s)
Chars 1162 - 1166 [Qed.] 0. secs (0.u,0.s)
Chars 1744 - 1884 [Definition~decide_rel~{A}~{B}~...] 0.001 secs (0.001u,0.s)
Chars 1956 - 2035 [#[global]~Instance~decidable_c...] 0.001 secs (0.u,0.s)
Chars 2083 - 2182 [#[global]~Instance~decidablepa...] 0.002 secs (0.002u,0.s)
Chars 2217 - 2282 [#[global]Instance~decidable_em...] 0. secs (0.u,0.s)
Chars 2324 - 2432 [Definition~decidable_equiv~(A~...] 0. secs (0.u,0.s)
Chars 2433 - 2439 [Proof.] 0. secs (0.u,0.s)
Chars 1153 - 1164 [(intros~s~d).] 40.039 secs (0.u,0.02s)
Chars 1218 - 1240 [(pose~@isequiv_compose).] 0.001 secs (0.001u,0.s)
Chars 1245 - 1452 [refine~~(isequiv_homotopic~~~~...] 0.079 secs (0.067u,0.01s)
Chars 1457 - 1477 [(intro~x;~destruct~x).] 0.012 secs (0.011u,0.001s)
Chars 1482 - 1494 [reflexivity.] 0.004 secs (0.004u,0.s)
Chars 1153 - 1164 [(intros~s~d).] 0. secs (0.u,0.s)
Chars 1218 - 1240 [(pose~@isequiv_compose).] 0. secs (0.u,0.s)
Chars 1245 - 1452 [refine~~(isequiv_homotopic~~~~...] 0. secs (0.u,0.s)
Chars 1457 - 1477 [(intro~x;~destruct~x).] 0.004 secs (0.004u,0.s)
Chars 1482 - 1494 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 1497 - 1505 [Defined.] 0.053 secs (0.044u,0.008s)
Chars 1577 - 1591 [End~onobjects.] 0.023 secs (0.021u,0.001s)
Chars 1712 - 1732 [Section~onmorphisms.] 0. secs (0.u,0.s)
Chars 1735 - 1760 [Variable~(A~:~PreCategory).] 0. secs (0.u,0.s)
Chars 1763 - 1814 [Variable~(Pmor~:~forall~s~d,~m...] 0. secs (0.u,0.s)
Chars 1818 - 1872 [#[local]Notation~mor~s~d:=~{m~...] 0. secs (0.u,0.s)
Chars 1875 - 1923 [Context~`(HPmor~:~forall~s~d,~...] 0. secs (0.u,0.s)
Chars 1927 - 1984 [Variable~(Pidentity~:~forall~x...] 0. secs (0.u,0.s)
Chars 1987 - 2154 [Variable~~~(Pcompose~:~~~~~~fo...] 0.001 secs (0.u,0.s)
Chars 2158 - 2217 [#[local]Notation~identity~x:=~...] 0. secs (0.u,0.s)
Chars 2220 - 2312 [#[local]~Notation~compose~m1~m...] 0. secs (0.u,0.s)
Chars 2316 - 2480 [Hypothesis~~~(P_associativity~...] 0.02 secs (0.018u,0.s)
Chars 2484 - 2574 [Hypothesis~~~(P_left_identity~...] 0.003 secs (0.002u,0.s)
Chars 2578 - 2669 [Hypothesis~~~(P_right_identity...] 0.069 secs (0.058u,0.01s)
Chars 2673 - 2787 [#[local]~Notation~A'~:=~~~(@si...] 0. secs (0.u,0.s)
Chars 2952 - 3015 [Context~`{forall~s~d~m,~IsIsom...] 0.001 secs (0.001u,0.s)
Chars 3019 - 3106 [Definition~iscategory_sig_mor_...] 0.002 secs (0.002u,0.s)
Chars 3109 - 3115 [Proof.] 0. secs (0.u,0.s)
Chars 742 - 755 [econstructor.] 40.095 secs (0.001u,0.016s)
Chars 758 - 759 [-] 0. secs (0.u,0.s)
Chars 760 - 786 [exact~(fun~f~a~=>~idpath).] 0.001 secs (0.001u,0.s)
Chars 789 - 790 [-] 0. secs (0.u,0.s)
Chars 791 - 828 [exact~(fun~f~g~h~p~q~a~=>~q~a~...] 0.001 secs (0.001u,0.s)
Chars 742 - 755 [econstructor.] 0. secs (0.u,0.s)
Chars 760 - 786 [exact~(fun~f~a~=>~idpath).] 0. secs (0.u,0.s)
Chars 791 - 828 [exact~(fun~f~g~h~p~q~a~=>~q~a~...] 0. secs (0.u,0.s)
Chars 829 - 837 [Defined.] 0. secs (0.u,0.s)
Chars 839 - 899 [#[global]Instance~is0gpd_arrow...] 0.001 secs (0.001u,0.s)
Chars 900 - 906 [Proof.] 0. secs (0.u,0.s)
Chars 909 - 928 [(apply~Build_Is0Gpd).] 3.314 secs (0.001u,0.017s)
Chars 931 - 961 [(intros~f~g~p~a;~exact~(p~a)^).] 0.001 secs (0.001u,0.s)
Chars 909 - 928 [(apply~Build_Is0Gpd).] 0. secs (0.u,0.s)
Chars 931 - 961 [(intros~f~g~p~a;~exact~(p~a)^).] 0. secs (0.u,0.s)
Chars 962 - 970 [Defined.] 0. secs (0.u,0.s)
Chars 972 - 1075 [#[global]~Instance~is0functor_...] 0.001 secs (0.001u,0.s)
Chars 1076 - 1082 [Proof.] 0. secs (0.u,0.s)
Chars 2442 - 2456 [(intros~[a|~na]).] 40.073 secs (0.001u,0.01s)
Chars 2459 - 2460 [-] 0. secs (0.u,0.s)
Chars 2461 - 2479 [exact~(inl~(f~a)).] 0. secs (0.u,0.s)
Chars 2482 - 2483 [-] 0. secs (0.u,0.s)
Chars 2484 - 2519 [exact~(inr~(fun~b~=>~na~(f^-1~...] 0.001 secs (0.001u,0.s)
Chars 2442 - 2456 [(intros~[a|~na]).] 0. secs (0.u,0.s)
Chars 2461 - 2479 [exact~(inl~(f~a)).] 0. secs (0.u,0.s)
Chars 2484 - 2519 [exact~(inr~(fun~b~=>~na~(f^-1~...] 0. secs (0.u,0.s)
Chars 2520 - 2528 [Defined.] 0. secs (0.u,0.s)
Chars 2530 - 2648 [Definition~decidable_equiv'~(A...] 0.001 secs (0.001u,0.s)
Chars 2650 - 2784 [Definition~decidablepaths_equi...] 0. secs (0.u,0.s)
Chars 2785 - 2791 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 176 [Require~Import~HoTT.Basics.Equ...] 10.015 secs (9.406u,0.573s)
Chars 178 - 221 [Import~algebra_notations~ne_li...] 0. secs (0.u,0.s)
Chars 223 - 242 [Section~congruence.] 0. secs (0.u,0.s)
Chars 245 - 316 [Context~{σ~:~Signature}~(A~:~A...] 0. secs (0.u,0.s)
Chars 568 - 805 [Definition~OpCompatible~{w~:~S...] 0.002 secs (0.002u,0.s)
Chars 809 - 899 [Class~OpsCompatible~:~Type~:=~...] 0.001 secs (0.001u,0.s)
Chars 903 - 1038 [#[global]~Instance~trunc_ops_c...] 0. secs (0.u,0.s)
Chars 1041 - 1047 [Proof.] 0. secs (0.u,0.s)
Chars 1052 - 1073 [(apply~istrunc_forall).] 0.126 secs (0.011u,0.036s)
Chars 1052 - 1073 [(apply~istrunc_forall).] 0. secs (0.u,0.s)
Chars 1076 - 1080 [Qed.] 0.003 secs (0.003u,0.s)
Chars 1224 - 1449 [Class~IsCongruence~:~Type~:=~~...] 0.004 secs (0.004u,0.s)
Chars 1453 - 1625 [#[global]~Arguments~BuildIsCon...] 0. secs (0.u,0.s)
Chars 1629 - 1676 [#[global]Existing~Instance~is_...] 0. secs (0.u,0.s)
Chars 1680 - 1720 [#[global]Existing~Instance~equ...] 0. secs (0.u,0.s)
Chars 1724 - 1769 [#[global]Existing~Instance~ops...] 0. secs (0.u,0.s)
Chars 1773 - 1842 [#[global]Instance~hprop_is_con...] 0. secs (0.u,0.s)
Chars 1845 - 1851 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 55 [Require~Import~HoTT.Basics.Dec...] 0.328 secs (0.249u,0.078s)
Chars 3120 - 3199 [refine~(issig_full_isomorphic~...] 40.499 secs (0.325u,0.079s)
Chars 3204 - 3468 [exact~~(functor_sigma~pr1_type...] 0.023 secs (0.021u,0.001s)
Chars 3120 - 3199 [refine~(issig_full_isomorphic~...] 0.002 secs (0.002u,0.s)
Chars 3204 - 3468 [exact~~(functor_sigma~pr1_type...] 0.003 secs (0.002u,0.s)
Chars 3471 - 3479 [Defined.] 0.072 secs (0.059u,0.012s)
Chars 3483 - 3581 [#[local]~Instance~isequiv_isca...] 0.002 secs (0.002u,0.s)
Chars 3584 - 3590 [Proof.] 0. secs (0.u,0.s)
Chars 56 - 179 [Require~Import~HoTT.Classes.in...] 9.476 secs (8.95u,0.501s)
Chars 181 - 207 [Generalizable~Variable~A.] 0. secs (0.u,0.s)
Chars 209 - 294 [Lemma~irrefl_neq~`{R~:~Relatio...] 0. secs (0.u,0.s)
Chars 295 - 301 [Proof.] 0. secs (0.u,0.s)
Chars 1856 - 1889 [(apply~(equiv_hprop_allpath~_)...] 20.352 secs (9.906u,0.125s)
Chars 1085 - 1108 [(apply~Build_Is0Functor).] 40.121 secs (0.u,0.017s)
Chars 1111 - 1146 [(intros~f~g~p~a;~exact~(ap~h~(...] 0.001 secs (0.001u,0.s)
Chars 1085 - 1108 [(apply~Build_Is0Functor).] 0. secs (0.u,0.s)
Chars 1111 - 1146 [(intros~f~g~p~a;~exact~(ap~h~(...] 0. secs (0.u,0.s)
Chars 1147 - 1155 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1157 - 1258 [#[global]~Instance~is0functor_...] 0.002 secs (0.002u,0.s)
Chars 1259 - 1265 [Proof.] 0. secs (0.u,0.s)
Chars 2794 - 2807 [(intros~d~x~y).] 40.085 secs (0.u,0.01s)
Chars 2810 - 2851 [(destruct~(d~(f^-1~x)~(f^-1~y)...] 0.003 secs (0.003u,0.s)
Chars 2854 - 2855 [-] 0. secs (0.u,0.s)
Chars 2856 - 2866 [(apply~inl).] 0.001 secs (0.001u,0.s)
Chars 2867 - 2913 [exact~(((eisretr~f~x)^~@~ap~f~...] 0.002 secs (0.u,0.001s)
Chars 2916 - 2917 [-] 0. secs (0.u,0.s)
Chars 2918 - 2938 [(apply~inr;~intros~p).] 0.001 secs (0.001u,0.s)
Chars 2939 - 2955 [(apply~ne,~ap,~p).] 0.001 secs (0.u,0.001s)
Chars 2794 - 2807 [(intros~d~x~y).] 0. secs (0.u,0.s)
Chars 2810 - 2851 [(destruct~(d~(f^-1~x)~(f^-1~y)...] 0. secs (0.u,0.s)
Chars 2856 - 2866 [(apply~inl).] 0. secs (0.u,0.s)
Chars 2867 - 2913 [exact~(((eisretr~f~x)^~@~ap~f~...] 0. secs (0.u,0.s)
Chars 2918 - 2938 [(apply~inr;~intros~p).] 0. secs (0.u,0.s)
Chars 2939 - 2955 [(apply~ne,~ap,~p).] 0. secs (0.u,0.s)
Chars 2956 - 2964 [Defined.] 0.001 secs (0.u,0.s)
Chars 2966 - 3104 [Definition~decidablepaths_equi...] 0.001 secs (0.001u,0.s)
Chars 3272 - 3348 [Class~WeaklyConstant~{A}~{B}~(...] 0.001 secs (0.u,0.s)
Chars 3415 - 3530 [Definition~wconst_through_hpro...] 0.001 secs (0.u,0.s)
Chars 3531 - 3537 [Proof.] 0. secs (0.u,0.s)
Chars 1856 - 1889 [(apply~(equiv_hprop_allpath~_)...] 40.07 secs (0.005u,0.032s)
Chars 1894 - 1923 [(intros~[C1~C2~C3]~[D1~D2~D3]).] 0.001 secs (0.001u,0.s)
Chars 1928 - 2037 [by~destruct~(path_ishprop~C1~D...] 0.062 secs (0.053u,0.008s)
Chars 1856 - 1889 [(apply~(equiv_hprop_allpath~_)...] 0. secs (0.u,0.s)
Chars 1894 - 1923 [(intros~[C1~C2~C3]~[D1~D2~D3]).] 0. secs (0.u,0.s)
Chars 1928 - 2037 [by~destruct~(path_ishprop~C1~D...] 0. secs (0.u,0.s)
Chars 2040 - 2048 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2050 - 2065 [End~congruence.] 0.008 secs (0.008u,0.s)
Chars 2252 - 2494 [Lemma~op_compatible_cons~{σ~:~...] 0.002 secs (0.002u,0.s)
Chars 2495 - 2501 [Proof.] 0. secs (0.u,0.s)
Chars 3540 - 3579 [(intros~x~y;~apply~(ap~g),~pat...] 22.192 secs (0.u,0.013s)
Chars 3540 - 3579 [(intros~x~y;~apply~(ap~g),~pat...] 0. secs (0.u,0.s)
Chars 3580 - 3588 [Defined.] 0. secs (0.u,0.s)
Chars 3659 - 3765 [Class~Collapsible~(A~:~Type)~:...] 0.002 secs (0.002u,0.s)
Chars 3766 - 3807 [#[global]Existing~Instance~wco...] 0. secs (0.u,0.s)
Chars 3809 - 3897 [Class~PathCollapsible~(A~:~Typ...] 0.001 secs (0.u,0.s)
Chars 3898 - 3933 [#[global]Existing~Instance~pat...] 0. secs (0.u,0.s)
Chars 3935 - 4015 [#[global]~Instance~collapsible...] 0. secs (0.u,0.s)
Chars 4016 - 4022 [Proof.] 0. secs (0.u,0.s)
Chars 3595 - 3638 [simple~refine~(isequiv_adjoint...] 40.118 secs (0.005u,0.022s)
Chars 3643 - 3644 [{] 0. secs (0.u,0.s)
Chars 3645 - 3653 [intro~e.] 0.037 secs (0.029u,0.007s)
Chars 3660 - 3698 [exists~(e~:~morphism~_~_~_;~ce...] 0.043 secs (0.035u,0.007s)
Chars 3705 - 3896 [(exists~((e^-1)%morphism;~cent...] 0.142 secs (0.118u,0.023s)
Chars 3897 - 3898 [}] 0. secs (0.u,0.s)
Chars 3903 - 3904 [{] 0. secs (0.u,0.s)
Chars 3905 - 3937 [(intro;~by~apply~path_isomorph...] 0.016 secs (0.013u,0.002s)
Chars 3938 - 3939 [}] 0. secs (0.u,0.s)
Chars 3944 - 3945 [{] 0. secs (0.u,0.s)
Chars 3946 - 3978 [(intros~x;~apply~path_isomorph...] 0.013 secs (0.01u,0.002s)
Chars 3985 - 4019 [exact~(path_sigma'~_~1~(contr~...] 0.008 secs (0.007u,0.s)
Chars 4020 - 4021 [}] 0. secs (0.u,0.s)
Chars 3595 - 3638 [simple~refine~(isequiv_adjoint...] 0.002 secs (0.002u,0.s)
Chars 3645 - 3653 [intro~e.] 0.002 secs (0.002u,0.s)
Chars 3660 - 3698 [exists~(e~:~morphism~_~_~_;~ce...] 0.002 secs (0.002u,0.s)
Chars 3705 - 3896 [(exists~((e^-1)%morphism;~cent...] 0.025 secs (0.023u,0.001s)
Chars 3905 - 3937 [(intro;~by~apply~path_isomorph...] 0.009 secs (0.008u,0.001s)
Chars 3946 - 3978 [(intros~x;~apply~path_isomorph...] 0.01 secs (0.009u,0.s)
Chars 3985 - 4019 [exact~(path_sigma'~_~1~(contr~...] 0.004 secs (0.004u,0.s)
Chars 4024 - 4032 [Defined.] 0.119 secs (0.107u,0.011s)
Chars 4036 - 4113 [#[global]~Instance~iscategory_...] 0.005 secs (0.003u,0.001s)
Chars 4116 - 4122 [Proof.] 0. secs (0.u,0.s)
Chars 4127 - 4138 [(intros~s~d).] 0.068 secs (-2.887u,-0.488s)
Chars 302 - 331 [(intros~?~?~E~e;~rewrite~e~in~E).] 40.159 secs (0.001u,0.033s)
Chars 332 - 360 [(apply~(irreflexivity~_~_~E)).] 0.001 secs (0.u,0.s)
Chars 302 - 331 [(intros~?~?~E~e;~rewrite~e~in~E).] 0. secs (0.u,0.s)
Chars 332 - 360 [(apply~(irreflexivity~_~_~E)).] 0. secs (0.u,0.s)
Chars 361 - 365 [Qed.] 0. secs (0.u,0.s)
Chars 367 - 441 [Lemma~le_flip~`{Le~A}~`{!Total...] 0.002 secs (0.001u,0.s)
Chars 442 - 448 [Proof.] 0. secs (0.u,0.s)
Chars 1268 - 1291 [(apply~Build_Is0Functor).] 40.105 secs (0.001u,0.017s)
Chars 1294 - 1326 [(intros~f~g~p~a;~exact~(p~(h~a...] 0.001 secs (0.u,0.s)
Chars 1268 - 1291 [(apply~Build_Is0Functor).] 0. secs (0.u,0.s)
Chars 1294 - 1326 [(intros~f~g~p~a;~exact~(p~(h~a...] 0. secs (0.u,0.s)
Chars 1327 - 1335 [Defined.] 0.001 secs (0.u,0.s)
Chars 1337 - 1393 [#[global]Instance~is1cat_stron...] 0. secs (0.u,0.s)
Chars 1394 - 1400 [Proof.] 0. secs (0.u,0.s)
Chars 2504 - 2517 [(intros~a~b~R).] 40.15 secs (0.u,0.033s)
Chars 2520 - 2568 [exact~(P~(x,~a)~(x,~b)~(EquivR...] 0.004 secs (0.004u,0.s)
Chars 2504 - 2517 [(intros~a~b~R).] 0. secs (0.u,0.s)
Chars 2520 - 2568 [exact~(P~(x,~a)~(x,~b)~(EquivR...] 0. secs (0.u,0.s)
Chars 2569 - 2577 [Defined.] 0.003 secs (0.001u,0.001s)
Chars 4025 - 4054 [(destruct~(dec~A)~as~[a|~na]).] 40.086 secs (0.002u,0.01s)
Chars 4057 - 4058 [-] 0. secs (0.u,0.s)
Chars 4059 - 4076 [exists~(const~a).] 0. secs (0.u,0.s)
Chars 4081 - 4105 [(intros~x~y;~reflexivity).] 0. secs (0.u,0.s)
Chars 4108 - 4109 [-] 0. secs (0.u,0.s)
Chars 4110 - 4123 [exists~idmap.] 0. secs (0.u,0.s)
Chars 4128 - 4156 [(intros~x~y;~destruct~(na~x)).] 0.001 secs (0.001u,0.s)
Chars 4025 - 4054 [(destruct~(dec~A)~as~[a|~na]).] 0. secs (0.u,0.s)
Chars 4059 - 4076 [exists~(const~a).] 0. secs (0.u,0.s)
Chars 4081 - 4105 [(intros~x~y;~reflexivity).] 0. secs (0.u,0.s)
Chars 4110 - 4123 [exists~idmap.] 0. secs (0.u,0.s)
Chars 4128 - 4156 [(intros~x~y;~destruct~(na~x)).] 0. secs (0.u,0.s)
Chars 4157 - 4165 [Defined.] 0. secs (0.u,0.s)
Chars 4167 - 4252 [#[global]~Instance~pathcoll_de...] 0. secs (0.u,0.s)
Chars 4253 - 4259 [Proof.] 0. secs (0.u,0.s)
Chars 4262 - 4282 [(intros~x~y;~exact~_).] 0.645 secs (0.003u,0.014s)
Chars 4262 - 4282 [(intros~x~y;~exact~_).] 0. secs (0.u,0.s)
Chars 4283 - 4291 [Defined.] 0. secs (0.u,0.s)
Chars 4430 - 4510 [#[global]~Instance~hset_pathco...] 0. secs (0.u,0.s)
Chars 4511 - 4517 [Proof.] 0. secs (0.u,0.s)
Chars 4127 - 4138 [(intros~s~d).] 40.047 secs (0.001u,0.021s)
Chars 4219 - 4338 [refine~~(isequiv_homotopic~~~~...] 0.015 secs (0.014u,0.s)
Chars 4343 - 4379 [(intro~x;~apply~path_isomorphi...] 0.01 secs (0.008u,0.001s)
Chars 4384 - 4431 [(destruct~x;~refine~(path_sigm...] 0.01 secs (0.008u,0.001s)
Chars 4127 - 4138 [(intros~s~d).] 0.002 secs (0.002u,0.s)
Chars 4219 - 4338 [refine~~(isequiv_homotopic~~~~...] 0.002 secs (0.002u,0.s)
Chars 4343 - 4379 [(intro~x;~apply~path_isomorphi...] 0.02 secs (0.019u,0.s)
Chars 4384 - 4431 [(destruct~x;~refine~(path_sigm...] 0.005 secs (0.003u,0.001s)
Chars 4434 - 4442 [Defined.] 0.021 secs (0.017u,0.003s)
Chars 4446 - 4524 [Definition~iscategory_from_sig...] 0.004 secs (0.004u,0.s)
Chars 4527 - 4533 [Proof.] 0. secs (0.u,0.s)
Chars 449 - 460 [(intros~nle).] 40.157 secs (0.u,0.032s)
Chars 461 - 499 [(destruct~(total~_~x~y)~as~[?|...] 0.016 secs (0.013u,0.002s)
Chars 500 - 518 [(destruct~(nle~le)).] 0.001 secs (0.001u,0.s)
Chars 449 - 460 [(intros~nle).] 0. secs (0.u,0.s)
Chars 461 - 499 [(destruct~(total~_~x~y)~as~[?|...] 0. secs (0.u,0.s)
Chars 500 - 518 [(destruct~(nle~le)).] 0. secs (0.u,0.s)
Chars 519 - 523 [Qed.] 0. secs (0.u,0.s)
Chars 525 - 547 [Section~partial_order.] 0. secs (0.u,0.s)
Chars 550 - 576 [Context~`{PartialOrder~A}.] 0. secs (0.u,0.s)
Chars 580 - 615 [Lemma~eq_le~x~y~:~x~=~y~->~x~≤~y.] 0. secs (0.u,0.s)
Chars 618 - 624 [Proof.] 0. secs (0.u,0.s)
Chars 1403 - 1457 [(srapply~Build_Is1Cat_Strong;~...] 40.26 secs (0.098u,0.063s)
Chars 1403 - 1457 [(srapply~Build_Is1Cat_Strong;~...] 0.001 secs (0.001u,0.s)
Chars 1458 - 1466 [Defined.] 0.001 secs (0.u,0.s)
Chars 1468 - 1526 [#[global]Instance~hasmorext_ty...] 0.001 secs (0.u,0.001s)
Chars 1527 - 1533 [Proof.] 0. secs (0.u,0.s)
Chars 4520 - 4531 [(intros~x~y).] 40.098 secs (0.u,0.012s)
Chars 4534 - 4601 [(assert~(h~:~forall~p~:~x~=~y,...] 0.021 secs (0.013u,0.008s)
Chars 4604 - 4605 [{] 0. secs (0.u,0.s)
Chars 4606 - 4646 [(intros~[];~symmetry;~by~apply...] 0.004 secs (0.003u,0.s)
Chars 4647 - 4648 [}] 0. secs (0.u,0.s)
Chars 4651 - 4683 [(apply~hprop_allpath;~intros~p...] 0.001 secs (0.u,0.001s)
Chars 4686 - 4712 [refine~((h~p~@~_)~@~(h~q)^).] 0.002 secs (0.001u,0.s)
Chars 4715 - 4730 [(apply~whiskerL).] 0.001 secs (0.001u,0.s)
Chars 4733 - 4746 [(apply~wconst).] 0.001 secs (0.001u,0.s)
Chars 4520 - 4531 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 4534 - 4601 [(assert~(h~:~forall~p~:~x~=~y,...] 0. secs (0.u,0.s)
Chars 4606 - 4646 [(intros~[];~symmetry;~by~apply...] 0.001 secs (0.001u,0.s)
Chars 4651 - 4683 [(apply~hprop_allpath;~intros~p...] 0.001 secs (0.u,0.s)
Chars 4686 - 4712 [refine~((h~p~@~_)~@~(h~q)^).] 0. secs (0.u,0.s)
Chars 4715 - 4730 [(apply~whiskerL).] 0. secs (0.u,0.s)
Chars 4733 - 4746 [(apply~wconst).] 0. secs (0.u,0.s)
Chars 4747 - 4755 [Defined.] 0.002 secs (0.001u,0.001s)
Chars 4757 - 4826 [Definition~collapsible_hprop~(...] 0. secs (0.u,0.s)
Chars 4827 - 4833 [Proof.] 0. secs (0.u,0.s)
Chars 627 - 636 [(intros~E).] 32.413 secs (0.u,0.032s)
Chars 639 - 649 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 652 - 670 [(apply~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 627 - 636 [(intros~E).] 0. secs (0.u,0.s)
Chars 639 - 649 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 652 - 670 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 673 - 677 [Qed.] 0. secs (0.u,0.s)
Chars 681 - 721 [Lemma~eq_le_flip~x~y~:~x~=~y~-...] 0. secs (0.u,0.s)
Chars 724 - 730 [Proof.] 0. secs (0.u,0.s)
Chars 733 - 742 [(intros~E).] 0.111 secs (0.u,0.033s)
Chars 745 - 755 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 758 - 776 [(apply~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 733 - 742 [(intros~E).] 0. secs (0.u,0.s)
Chars 745 - 755 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 758 - 776 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 779 - 783 [Qed.] 0. secs (0.u,0.s)
Chars 787 - 830 [Lemma~not_le_ne~x~y~:~~~(x~≤~y...] 0.001 secs (0.001u,0.s)
Chars 833 - 839 [Proof.] 0. secs (0.u,0.s)
Chars 4836 - 4849 [exists~idmap.] 1.998 secs (0.u,0.014s)
Chars 4852 - 4883 [(intros~x~y;~apply~path_ishprop).] 0.001 secs (0.001u,0.s)
Chars 4836 - 4849 [exists~idmap.] 0. secs (0.u,0.s)
Chars 4852 - 4883 [(intros~x~y;~apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 4884 - 4892 [Defined.] 0. secs (0.u,0.s)
Chars 4894 - 4962 [Definition~pathcoll_hset~(A~:~...] 0. secs (0.u,0.s)
Chars 4963 - 4969 [Proof.] 0. secs (0.u,0.s)
Chars 4538 - 4549 [(intros~s~d).] 40.115 secs (0.001u,0.021s)
Chars 4554 - 4676 [refine~(isequiv_homotopic~(isc...] 0.095 secs (0.085u,0.01s)
Chars 4681 - 4717 [(intro~x;~apply~path_isomorphi...] 0.011 secs (0.01u,0.s)
Chars 4722 - 4746 [(destruct~x;~reflexivity).] 0.009 secs (0.008u,0.001s)
Chars 4538 - 4549 [(intros~s~d).] 0.002 secs (0.u,0.001s)
Chars 4554 - 4676 [refine~(isequiv_homotopic~(isc...] 0.002 secs (0.002u,0.s)
Chars 4681 - 4717 [(intro~x;~apply~path_isomorphi...] 0.008 secs (0.008u,0.s)
Chars 4722 - 4746 [(destruct~x;~reflexivity).] 0.005 secs (0.004u,0.s)
Chars 4749 - 4757 [Defined.] 0.019 secs (0.016u,0.003s)
Chars 4761 - 4848 [#[global]~Instance~isequiv_isc...] 0.004 secs (0.003u,0.s)
Chars 4851 - 4857 [Proof.] 0. secs (0.u,0.s)
Chars 4972 - 5017 [(intros~x~y;~apply~collapsible...] 7.088 secs (0.003u,0.013s)
Chars 4972 - 5017 [(intros~x~y;~apply~collapsible...] 0. secs (0.u,0.s)
Chars 5018 - 5026 [Defined.] 0. secs (0.u,0.s)
Chars 5028 - 5094 [Corollary~hset_decpaths~(A~:~T...] 0. secs (0.u,0.s)
Chars 5095 - 5101 [Proof.] 0. secs (0.u,0.s)
Chars 5104 - 5112 [exact~_.] 0.403 secs (0.002u,0.015s)
Chars 5104 - 5112 [exact~_.] 0. secs (0.u,0.s)
Chars 5113 - 5121 [Defined.] 0. secs (0.u,0.s)
Chars 5257 - 5340 [#[global]~Instance~ishprop_dec...] 0. secs (0.u,0.s)
Chars 5341 - 5347 [Proof.] 0. secs (0.u,0.s)
Chars 1536 - 1560 [srapply~Build_HasMorExt.] 40.153 secs (0.024u,0.026s)
Chars 1563 - 1588 [(intros~A~B~f~g;~cbn~in~*).] 0.002 secs (0.001u,0.s)
Chars 1591 - 1648 [refine~(isequiv_homotopic~(@ap...] 0.017 secs (0.002u,0.015s)
Chars 1651 - 1660 [(intros~p).] 0. secs (0.u,0.s)
Chars 1663 - 1687 [(destruct~p;~reflexivity).] 0.007 secs (0.002u,0.004s)
Chars 1536 - 1560 [srapply~Build_HasMorExt.] 0. secs (0.u,0.s)
Chars 1563 - 1588 [(intros~A~B~f~g;~cbn~in~*).] 0. secs (0.u,0.s)
Chars 1591 - 1648 [refine~(isequiv_homotopic~(@ap...] 0. secs (0.u,0.s)
Chars 1651 - 1660 [(intros~p).] 0. secs (0.u,0.s)
Chars 1663 - 1687 [(destruct~p;~reflexivity).] 0. secs (0.u,0.s)
Chars 1688 - 1696 [Defined.] 0.003 secs (0.003u,0.s)
Chars 1698 - 1746 [#[global]Instance~hasequivs_ty...] 0.001 secs (0.001u,0.s)
Chars 1747 - 1753 [Proof.] 0. secs (0.u,0.s)
Chars 4862 - 4918 [refine~(isequiv_iff_hprop~_~(@...] 16.834 secs (13.008u,0.038s)
Chars 842 - 855 [(intros~E1~E2).] 40.161 secs (0.001u,0.032s)
Chars 858 - 867 [(apply~E1).] 0. secs (0.u,0.s)
Chars 870 - 881 [(rewrite~E2).] 0. secs (0.u,0.s)
Chars 884 - 902 [(apply~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 842 - 855 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 858 - 867 [(apply~E1).] 0. secs (0.u,0.s)
Chars 870 - 881 [(rewrite~E2).] 0. secs (0.u,0.s)
Chars 884 - 902 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 905 - 909 [Qed.] 0. secs (0.u,0.s)
Chars 913 - 964 [Lemma~eq_iff_le~x~y~:~x~=~y~<-...] 0.001 secs (0.u,0.s)
Chars 967 - 973 [Proof.] 0. secs (0.u,0.s)
Chars 4862 - 4918 [refine~(isequiv_iff_hprop~_~(@...] 40.129 secs (0.069u,0.034s)
Chars 4862 - 4918 [refine~(isequiv_iff_hprop~_~(@...] 0.002 secs (0.001u,0.s)
Chars 4921 - 4929 [Defined.] 0.014 secs (0.013u,0.s)
Chars 4930 - 4946 [End~onmorphisms.] 0.135 secs (0.123u,0.01s)
Chars 5013 - 5029 [Section~on_both.] 0. secs (0.u,0.s)
Chars 5032 - 5057 [Variable~(A~:~PreCategory).] 0. secs (0.u,0.s)
Chars 5060 - 5086 [Variable~(Pobj~:~A~->~Type).] 0. secs (0.u,0.s)
Chars 5090 - 5151 [#[local]Notation~obj~:=~{x~:~_...] 0. secs (0.u,0.s)
Chars 5155 - 5216 [Variable~(Pmor~:~forall~s~d~:~...] 0.001 secs (0.001u,0.s)
Chars 5220 - 5289 [#[local]Notation~mor~s~d:=~{m~...] 0. secs (0.u,0.s)
Chars 5292 - 5340 [Context~`(HPmor~:~forall~s~d,~...] 0.001 secs (0.001u,0.s)
Chars 5344 - 5401 [Variable~(Pidentity~:~forall~x...] 0. secs (0.u,0.s)
Chars 5404 - 5571 [Variable~~~(Pcompose~:~~~~~~fo...] 0.001 secs (0.001u,0.s)
Chars 5575 - 5636 [#[local]Notation~identity~x:=~...] 0. secs (0.u,0.s)
Chars 5639 - 5731 [#[local]~Notation~compose~m1~m...] 0. secs (0.u,0.s)
Chars 5735 - 5899 [Hypothesis~~~(P_associativity~...] 0.022 secs (0.02u,0.001s)
Chars 5903 - 5993 [Hypothesis~~~(P_left_identity~...] 0.004 secs (0.003u,0.s)
Chars 5997 - 6088 [Hypothesis~~~(P_right_identity...] 0.005 secs (0.004u,0.s)
Chars 6092 - 6207 [#[local]~Notation~A'~:=~~~(@si...] 0. secs (0.u,0.s)
Chars 6399 - 6696 [#[local]~Definition~Pmor_iso_T...] 0.005 secs (0.003u,0.002s)
Chars 6700 - 6731 [#[global]Arguments~Pmor_iso_T~/.] 0. secs (0.u,0.s)
Chars 6735 - 7003 [#[local]~Definition~Pmor_iso_T...] 0.01 secs (0.01u,0.s)
Chars 7007 - 7039 [#[global]Arguments~Pmor_iso_T'~/.] 0. secs (0.u,0.s)
Chars 7043 - 7127 [#[local]~Definition~Pidtoiso~x...] 0. secs (0.u,0.s)
Chars 7130 - 7136 [Proof.] 0. secs (0.u,0.s)
Chars 5350 - 5388 [(apply~hprop_inhabited_contr;~...] 40.093 secs (0.001u,0.013s)
Chars 5391 - 5420 [(assert~(IsHSet~A)~by~exact~_).] 0.004 secs (0.002u,0.002s)
Chars 5423 - 5443 [(exists~d;~intros~d').] 0.001 secs (0.001u,0.s)
Chars 5446 - 5503 [(apply~path_forall;~intros~x;~...] 0.003 secs (0.002u,0.s)
Chars 5506 - 5544 [(generalize~(d~x~y);~clear~d;~...] 0.002 secs (0.002u,0.s)
Chars 5547 - 5588 [(generalize~(d'~x~y);~clear~d'...] 0.002 secs (0.001u,0.s)
Chars 5591 - 5637 [(destruct~d~as~[d|~nd];~destru...] 0.005 secs (0.003u,0.001s)
Chars 5640 - 5641 [-] 0. secs (0.u,0.s)
Chars 5642 - 5665 [(apply~ap,~path_ishprop).] 0.004 secs (0.003u,0.s)
Chars 5668 - 5669 [-] 0. secs (0.u,0.s)
Chars 5670 - 5683 [(elim~(nd'~d)).] 0.001 secs (0.u,0.001s)
Chars 5686 - 5687 [-] 0. secs (0.u,0.s)
Chars 5688 - 5701 [(elim~(nd~d')).] 0.001 secs (0.001u,0.s)
Chars 5704 - 5705 [-] 0. secs (0.u,0.s)
Chars 5706 - 5751 [(apply~ap,~path_forall;~intros...] 0.003 secs (0.003u,0.s)
Chars 5350 - 5388 [(apply~hprop_inhabited_contr;~...] 0. secs (0.u,0.s)
Chars 5391 - 5420 [(assert~(IsHSet~A)~by~exact~_).] 0. secs (0.u,0.s)
Chars 5423 - 5443 [(exists~d;~intros~d').] 0. secs (0.u,0.s)
Chars 5446 - 5503 [(apply~path_forall;~intros~x;~...] 0.001 secs (0.001u,0.s)
Chars 5506 - 5544 [(generalize~(d~x~y);~clear~d;~...] 0. secs (0.u,0.s)
Chars 5547 - 5588 [(generalize~(d'~x~y);~clear~d'...] 0.001 secs (0.u,0.s)
Chars 5591 - 5637 [(destruct~d~as~[d|~nd];~destru...] 0.001 secs (0.001u,0.s)
Chars 5642 - 5665 [(apply~ap,~path_ishprop).] 0. secs (0.u,0.s)
Chars 5670 - 5683 [(elim~(nd'~d)).] 0. secs (0.u,0.s)
Chars 5688 - 5701 [(elim~(nd~d')).] 0. secs (0.u,0.s)
Chars 5706 - 5751 [(apply~ap,~path_forall;~intros...] 0.001 secs (0.001u,0.s)
Chars 5752 - 5760 [Defined.] 0.003 secs (0.u,0.002s)
Chars 1756 - 1840 [(srefine~(Build_HasEquivs~Type...] 40.15 secs (0.017u,0.022s)
Chars 1843 - 1856 [all:~(intros~f).] 0.003 secs (0.003u,0.s)
Chars 1859 - 1860 [-] 0. secs (0.u,0.s)
Chars 1861 - 1869 [exact~f.] 0. secs (0.u,0.s)
Chars 1872 - 1873 [-] 0. secs (0.u,0.s)
Chars 1874 - 1882 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 1885 - 1886 [-] 0. secs (0.u,0.s)
Chars 1887 - 1905 [(apply~Build_Equiv).] 0. secs (0.u,0.s)
Chars 1908 - 1909 [-] 0. secs (0.u,0.s)
Chars 1910 - 1930 [(intros;~reflexivity).] 0.004 secs (0.004u,0.s)
Chars 1933 - 1934 [-] 0. secs (0.u,0.s)
Chars 1935 - 1956 [(intros;~exact~f^-1).] 0.001 secs (0.001u,0.s)
Chars 1959 - 1960 [-] 0. secs (0.u,0.s)
Chars 1961 - 1965 [(cbn).] 0. secs (0.u,0.s)
Chars 1966 - 1990 [(intros~?;~apply~eissect).] 0.001 secs (0.u,0.s)
Chars 1993 - 1994 [-] 0. secs (0.u,0.s)
Chars 1995 - 1999 [(cbn).] 0. secs (0.u,0.s)
Chars 2000 - 2024 [(intros~?;~apply~eisretr).] 0.001 secs (0.001u,0.s)
Chars 2027 - 2028 [-] 0. secs (0.u,0.s)
Chars 2029 - 2079 [(intros~g~r~s;~refine~(isequiv...] 0.002 secs (0.002u,0.s)
Chars 1756 - 1840 [(srefine~(Build_HasEquivs~Type...] 0.001 secs (0.001u,0.s)
Chars 1843 - 1856 [all:~(intros~f).] 0.002 secs (0.002u,0.s)
Chars 1861 - 1869 [exact~f.] 0. secs (0.u,0.s)
Chars 1874 - 1882 [exact~_.] 0. secs (0.u,0.s)
Chars 1887 - 1905 [(apply~Build_Equiv).] 0. secs (0.u,0.s)
Chars 1910 - 1930 [(intros;~reflexivity).] 0. secs (0.u,0.s)
Chars 1935 - 1956 [(intros;~exact~f^-1).] 0. secs (0.u,0.s)
Chars 1961 - 1965 [(cbn).] 0. secs (0.u,0.s)
Chars 1966 - 1990 [(intros~?;~apply~eissect).] 0. secs (0.u,0.s)
Chars 1995 - 1999 [(cbn).] 0. secs (0.u,0.s)
Chars 2000 - 2024 [(intros~?;~apply~eisretr).] 0. secs (0.u,0.s)
Chars 2029 - 2079 [(intros~g~r~s;~refine~(isequiv...] 0. secs (0.u,0.s)
Chars 2080 - 2088 [Defined.] 0.003 secs (0.001u,0.001s)
Chars 2090 - 2181 [Definition~catie_isequiv~{A~B~...] 0.001 secs (0.001u,0.s)
Chars 2182 - 2188 [Proof.] 0. secs (0.u,0.s)
     = 3
     : positive
     = fun (A : Type) (x : Fkont A) (x0 : A) =>
       x1 <--- x0 times x0;
       x2 <--- x1 times x0; x3 <--- x2 times x2; x4 <--- x3 times x2; x x4
     : Fchain
     = fun (A : Type) (x : Fkont A) (x0 : A) =>
       x1 <--- x0 times x0;
       x2 <--- x1 times x1; x3 <--- x2 times x2; x4 <--- x3 times x3; x x4
     : Fchain
     = 16
     : positive
     = 9
     : positive
Chars 2191 - 2202 [assumption.] 9.462 secs (0.u,0.022s)
Chars 2191 - 2202 [assumption.] 0. secs (0.u,0.s)
Chars 2203 - 2211 [Defined.] 0. secs (0.u,0.s)
Chars 2213 - 2274 [#[export]Hint~Immediate~catie_...] 0. secs (0.u,0.s)
Chars 2276 - 2325 [#[global]Instance~isinitial_ze...] 0.001 secs (0.001u,0.s)
Chars 2326 - 2332 [Proof.] 0. secs (0.u,0.s)
Chars 976 - 992 [(split;~intros~E).] 40.155 secs (0.u,0.035s)
Chars 995 - 996 [-] 0. secs (0.u,0.s)
Chars 997 - 1007 [(rewrite~E).] 0.001 secs (0.001u,0.s)
Chars 1008 - 1032 [(split;~apply~reflexivity).] 0.004 secs (0.004u,0.s)
Chars 1035 - 1036 [-] 0. secs (0.u,0.s)
Chars 1037 - 1076 [(apply~(antisymmetry~(≤)~x~y);...] 0.003 secs (0.002u,0.s)
Chars 976 - 992 [(split;~intros~E).] 0. secs (0.u,0.s)
Chars 997 - 1007 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 1008 - 1032 [(split;~apply~reflexivity).] 0. secs (0.u,0.s)
Chars 1037 - 1076 [(apply~(antisymmetry~(≤)~x~y);...] 0. secs (0.u,0.s)
Chars 1079 - 1083 [Qed.] 0.001 secs (0.001u,0.s)
Chars 1084 - 1102 [End~partial_order.] 0.005 secs (0.003u,0.001s)
Chars 1104 - 1125 [Section~strict_order.] 0. secs (0.u,0.s)
Chars 1128 - 1153 [Context~`{StrictOrder~A}.] 0. secs (0.u,0.s)
Chars 1157 - 1195 [Lemma~lt_flip~x~y~:~x~<~y~->~~...] 0.001 secs (0.001u,0.s)
Chars 1198 - 1204 [Proof.] 0. secs (0.u,0.s)
Chars 7141 - 7152 [(destruct~H).] 40.12 secs (0.003u,0.02s)
Chars 7157 - 7178 [exists~(Pidentity~_).] 0.005 secs (0.005u,0.s)
Chars 7183 - 7204 [exists~(Pidentity~_).] 0.007 secs (0.006u,0.s)
Chars 7209 - 7228 [(split;~reflexivity).] 0.013 secs (0.013u,0.s)
Chars 7141 - 7152 [(destruct~H).] 0.002 secs (0.002u,0.s)
Chars 7157 - 7178 [exists~(Pidentity~_).] 0.002 secs (0.002u,0.s)
Chars 7183 - 7204 [exists~(Pidentity~_).] 0.004 secs (0.004u,0.s)
Chars 7209 - 7228 [(split;~reflexivity).] 0.009 secs (0.008u,0.s)
Chars 7231 - 7239 [Defined.] 0.009 secs (0.006u,0.003s)
Chars 7243 - 7272 [#[global]Arguments~Pidtoiso~/.] 0. secs (0.u,0.s)
Chars 7419 - 7476 [#[local]Instance~ishset_pmor~~...] 0. secs (0.u,0.s)
Chars 7479 - 7485 [Proof.] 0. secs (0.u,0.s)
Chars 7490 - 7501 [(intros~p~q).] 11.84 secs (7.809u,-0.156s)
Chars 2335 - 2343 [intro~A.] 40.106 secs (0.001u,0.021s)
Chars 2346 - 2367 [exists~(Empty_rec~_).] 0.001 secs (0.001u,0.s)
Chars 2370 - 2379 [(intros~g).] 0. secs (0.u,0.s)
Chars 2382 - 2399 [rapply~Empty_ind.] 0. secs (0.u,0.s)
Chars 2335 - 2343 [intro~A.] 0. secs (0.u,0.s)
Chars 2346 - 2367 [exists~(Empty_rec~_).] 0. secs (0.u,0.s)
Chars 2370 - 2379 [(intros~g).] 0. secs (0.u,0.s)
Chars 2382 - 2399 [rapply~Empty_ind.] 0. secs (0.u,0.s)
Chars 2400 - 2408 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2410 - 2460 [#[global]Instance~isterminal_u...] 0.001 secs (0.u,0.s)
Chars 2461 - 2467 [Proof.] 0. secs (0.u,0.s)
Chars 1207 - 1220 [(intros~E1~E2).] 40.17 secs (0.u,0.032s)
Chars 1223 - 1251 [(apply~(irreflexivity~(<)~x)).] 0.002 secs (0.001u,0.s)
Chars 1254 - 1280 [(transitivity~y;~assumption).] 0.002 secs (0.002u,0.s)
Chars 1207 - 1220 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 1223 - 1251 [(apply~(irreflexivity~(<)~x)).] 0. secs (0.u,0.s)
Chars 1254 - 1280 [(transitivity~y;~assumption).] 0. secs (0.u,0.s)
Chars 1283 - 1287 [Qed.] 0. secs (0.u,0.s)
Chars 1291 - 1327 [Lemma~lt_antisym~x~y~:~~~(x~<~...] 0.001 secs (0.001u,0.s)
Chars 1330 - 1336 [Proof.] 0. secs (0.u,0.s)
Chars 1339 - 1354 [(intros~[E1~E2]).] 0.13 secs (0.001u,0.032s)
Chars 1357 - 1391 [(destruct~(lt_flip~x~y);~assum...] 0.001 secs (0.001u,0.s)
Chars 1339 - 1354 [(intros~[E1~E2]).] 0. secs (0.u,0.s)
Chars 1357 - 1391 [(destruct~(lt_flip~x~y);~assum...] 0. secs (0.u,0.s)
Chars 1394 - 1398 [Qed.] 0. secs (0.u,0.s)
Chars 1402 - 1436 [Lemma~lt_ne~x~y~:~x~<~y~->~x~<...] 0.001 secs (0.001u,0.s)
Chars 1439 - 1445 [Proof.] 0. secs (0.u,0.s)
Chars 1448 - 1461 [(intros~E1~E2).] 0.461 secs (0.u,0.032s)
Chars 1464 - 1481 [(rewrite~E2~in~E1).] 0. secs (0.u,0.s)
Chars 1484 - 1512 [(apply~(irreflexivity~(<)~y)).] 0.002 secs (0.002u,0.s)
Chars 1513 - 1524 [assumption.] 0. secs (0.u,0.s)
Chars 1448 - 1461 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 1464 - 1481 [(rewrite~E2~in~E1).] 0. secs (0.u,0.s)
Chars 1484 - 1512 [(apply~(irreflexivity~(<)~y)).] 0. secs (0.u,0.s)
Chars 1513 - 1524 [assumption.] 0. secs (0.u,0.s)
Chars 1527 - 1531 [Qed.] 0. secs (0.u,0.s)
Chars 1535 - 1574 [Lemma~lt_ne_flip~x~y~:~x~<~y~-...] 0.001 secs (0.001u,0.s)
Chars 1577 - 1583 [Proof.] 0. secs (0.u,0.s)
Chars 1586 - 1592 [intro.] 0.409 secs (0.u,0.035s)
Chars 1595 - 1622 [(apply~symmetric_neq,~lt_ne).] 0. secs (0.u,0.s)
Chars 1625 - 1636 [assumption.] 0. secs (0.u,0.s)
Chars 1586 - 1592 [intro.] 0. secs (0.u,0.s)
Chars 1595 - 1622 [(apply~symmetric_neq,~lt_ne).] 0. secs (0.u,0.s)
Chars 1625 - 1636 [assumption.] 0. secs (0.u,0.s)
Chars 1639 - 1643 [Qed.] 0. secs (0.u,0.s)
Chars 1647 - 1687 [Lemma~eq_not_lt~x~y~:~x~=~y~->...] 0.001 secs (0.001u,0.s)
Chars 1690 - 1696 [Proof.] 0. secs (0.u,0.s)
Chars 7490 - 7501 [(intros~p~q).] 40.046 secs (0.002u,0.02s)
Chars 7506 - 7526 [(apply~hprop_allpath).] 0.003 secs (0.003u,0.s)
Chars 7531 - 7651 [(let~H~:=~constr:((_~:~forall~...] 0.039 secs (0.033u,0.005s)
Chars 7656 - 7667 [(intros~x~y).] 0.003 secs (0.003u,0.s)
Chars 7672 - 7728 [specialize~(H'~(path_sigma'~_~...] 0.006 secs (0.006u,0.s)
Chars 7733 - 7770 [(unfold~path_sigma',~path_sigm...] 0.003 secs (0.003u,0.s)
Chars 7775 - 7843 [(apply~(ap~(path_sigma_uncurri...] 1.359 secs (1.3u,0.055s)
Chars 7848 - 7900 [(assert~(H''~:~H'~..1~=~idpath...] 0.095 secs (0.094u,0.s)
Chars 7905 - 7968 [exact~(transport~(fun~H'1~=>~t...] 0.013 secs (0.013u,0.s)
Chars 7490 - 7501 [(intros~p~q).] 0.001 secs (0.001u,0.s)
Chars 7506 - 7526 [(apply~hprop_allpath).] 0.001 secs (0.u,0.001s)
Chars 7531 - 7651 [(let~H~:=~constr:((_~:~forall~...] 0.001 secs (0.001u,0.s)
Chars 7656 - 7667 [(intros~x~y).] 0.002 secs (0.002u,0.s)
Chars 7672 - 7728 [specialize~(H'~(path_sigma'~_~...] 0.002 secs (0.002u,0.s)
Chars 7733 - 7770 [(unfold~path_sigma',~path_sigm...] 0.002 secs (0.002u,0.s)
Chars 7775 - 7843 [(apply~(ap~(path_sigma_uncurri...] 0.003 secs (0.003u,0.s)
Chars 7848 - 7900 [(assert~(H''~:~H'~..1~=~idpath...] 0.003 secs (0.003u,0.s)
Chars 7905 - 7968 [exact~(transport~(fun~H'1~=>~t...] 0.004 secs (0.004u,0.s)
Chars 7971 - 7979 [Defined.] 0.022 secs (0.021u,0.s)
Chars 7983 - 8141 [#[local]~Definition~Pmor_iso_a...] 0.002 secs (0.002u,0.s)
Chars 8144 - 8150 [Proof.] 0. secs (0.u,0.s)
Chars 2470 - 2479 [(intros~A).] 40.114 secs (0.u,0.021s)
Chars 2482 - 2503 [exists~(fun~_~=>~tt).] 0.001 secs (0.001u,0.s)
Chars 2506 - 2517 [(intros~f~x).] 0. secs (0.u,0.s)
Chars 2520 - 2538 [by~destruct~(f~x).] 0.001 secs (0.001u,0.s)
Chars 2470 - 2479 [(intros~A).] 0. secs (0.u,0.s)
Chars 2482 - 2503 [exists~(fun~_~=>~tt).] 0. secs (0.u,0.s)
Chars 2506 - 2517 [(intros~f~x).] 0. secs (0.u,0.s)
Chars 2520 - 2538 [by~destruct~(f~x).] 0. secs (0.u,0.s)
Chars 2539 - 2547 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1699 - 1708 [(intros~E).] 40.161 secs (0.001u,0.033s)
Chars 1711 - 1721 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 1724 - 1750 [(apply~(irreflexivity~(<))).] 0.002 secs (0.001u,0.s)
Chars 1699 - 1708 [(intros~E).] 0. secs (0.u,0.s)
Chars 1711 - 1721 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 1724 - 1750 [(apply~(irreflexivity~(<))).] 0. secs (0.u,0.s)
Chars 1753 - 1757 [Qed.] 0. secs (0.u,0.s)
Chars 1758 - 1775 [End~strict_order.] 0.005 secs (0.005u,0.s)
Chars 1777 - 1798 [Section~pseudo_order.] 0. secs (0.u,0.s)
Chars 1801 - 1826 [Context~`{PseudoOrder~A}.] 0. secs (0.u,0.s)
Chars 1830 - 1873 [#[local]Existing~Instance~pseu...] 0. secs (0.u,0.s)
Chars 1877 - 1931 [Lemma~apart_total_lt~x~y~:~x~≶...] 0.001 secs (0.001u,0.s)
Chars 1934 - 1940 [Proof.] 0. secs (0.u,0.s)
Chars 8155 - 8196 [(refine~(equiv_functor_sigma_i...] 40.104 secs (0.009u,0.021s)
Chars 8201 - 8242 [(refine~(equiv_functor_sigma_i...] 0.013 secs (0.011u,0.001s)
Chars 8247 - 8676 [(refine~~~(equiv_functor_sigma...] 0.593 secs (0.496u,0.095s)
Chars 8155 - 8196 [(refine~(equiv_functor_sigma_i...] 0.006 secs (0.006u,0.s)
Chars 8201 - 8242 [(refine~(equiv_functor_sigma_i...] 0.008 secs (0.008u,0.s)
Chars 8247 - 8676 [(refine~~~(equiv_functor_sigma...] 0.093 secs (0.09u,0.002s)
Chars 8679 - 8687 [Defined.] 0.213 secs (0.203u,0.009s)
Chars 8691 - 8727 [#[global]Arguments~Pmor_iso_ad...] 0. secs (0.u,0.s)
Chars 8731 - 8899 [#[local]~Definition~iso_A'_cod...] 0.005 secs (0.005u,0.s)
Chars 8902 - 8908 [Proof.] 0. secs (0.u,0.s)
Chars 1943 - 1950 [(intros).] 40.165 secs (0.001u,0.032s)
Chars 1953 - 1978 [(apply~apart_iff_total_lt).] 0.002 secs (0.002u,0.s)
Chars 1981 - 1992 [assumption.] 0. secs (0.u,0.s)
Chars 1943 - 1950 [(intros).] 0. secs (0.u,0.s)
Chars 1953 - 1978 [(apply~apart_iff_total_lt).] 0. secs (0.u,0.s)
Chars 1981 - 1992 [assumption.] 0. secs (0.u,0.s)
Chars 1995 - 1999 [Qed.] 0. secs (0.u,0.s)
Chars 2003 - 2054 [Lemma~pseudo_order_lt_apart~x~...] 0.001 secs (0.001u,0.s)
Chars 2057 - 2063 [Proof.] 0. secs (0.u,0.s)
Chars 8913 - 8921 [intro~e.] 40.122 secs (0.014u,0.024s)
Chars 8926 - 8947 [simple~refine~(_;~_).] 0.008 secs (0.007u,0.s)
Chars 8952 - 8953 [{] 0. secs (0.u,0.s)
Chars 8954 - 8984 [exists~(e~:~morphism~_~_~_).1.] 0.005 secs (0.005u,0.s)
Chars 8991 - 9016 [exists~(e^-1)%morphism.1.] 0.011 secs (0.009u,0.001s)
Chars 9023 - 9024 [-] 0. secs (0.u,0.s)
Chars 9025 - 9060 [exact~(@left_inverse~_~_~_~e~e...] 0.005 secs (0.005u,0.s)
Chars 9067 - 9068 [-] 0. secs (0.u,0.s)
Chars 9069 - 9105 [exact~(@right_inverse~_~_~_~e~...] 0.004 secs (0.004u,0.s)
Chars 9106 - 9107 [}] 0. secs (0.u,0.s)
Chars 9112 - 9113 [{] 0. secs (0.u,0.s)
Chars 9114 - 9144 [exists~(e~:~morphism~_~_~_).2.] 0.011 secs (0.009u,0.001s)
Chars 9151 - 9181 [(exists~(e^-1)%morphism.2;~cbn).] 0.026 secs (0.023u,0.002s)
Chars 9188 - 9228 [exists~(@left_inverse~_~_~_~e~...] 0.008 secs (0.006u,0.001s)
Chars 9235 - 9271 [exact~(@right_inverse~_~_~_~e~...] 0.005 secs (0.005u,0.s)
Chars 9272 - 9273 [}] 0. secs (0.u,0.s)
Chars 8913 - 8921 [intro~e.] 0.002 secs (0.001u,0.s)
Chars 8926 - 8947 [simple~refine~(_;~_).] 0.002 secs (0.002u,0.s)
Chars 8954 - 8984 [exists~(e~:~morphism~_~_~_).1.] 0.002 secs (0.002u,0.s)
Chars 8991 - 9016 [exists~(e^-1)%morphism.1.] 0.002 secs (0.002u,0.s)
Chars 9025 - 9060 [exact~(@left_inverse~_~_~_~e~e...] 0.002 secs (0.001u,0.s)
Chars 9069 - 9105 [exact~(@right_inverse~_~_~_~e~...] 0.002 secs (0.002u,0.s)
Chars 9114 - 9144 [exists~(e~:~morphism~_~_~_).2.] 0.003 secs (0.003u,0.s)
Chars 9151 - 9181 [(exists~(e^-1)%morphism.2;~cbn).] 0.016 secs (0.012u,0.003s)
Chars 9188 - 9228 [exists~(@left_inverse~_~_~_~e~...] 0.004 secs (0.004u,0.s)
Chars 9235 - 9271 [exact~(@right_inverse~_~_~_~e~...] 0.003 secs (0.003u,0.s)
Chars 9276 - 9284 [Defined.] 0.277 secs (0.244u,0.032s)
Chars 9288 - 9513 [#[local]~Definition~iso_A'_dec...] 0.006 secs (0.006u,0.s)
Chars 9516 - 9522 [Proof.] 0. secs (0.u,0.s)
Chars 2066 - 2073 [(intros).] 20.44 secs (0.u,0.034s)
Chars 2076 - 2101 [(apply~apart_iff_total_lt).] 0.002 secs (0.001u,0.s)
Chars 2104 - 2109 [auto.] 0.001 secs (0.001u,0.s)
Chars 2066 - 2073 [(intros).] 0. secs (0.u,0.s)
Chars 2076 - 2101 [(apply~apart_iff_total_lt).] 0. secs (0.u,0.s)
Chars 2104 - 2109 [auto.] 0. secs (0.u,0.s)
Chars 2112 - 2116 [Qed.] 0. secs (0.u,0.s)
Chars 2120 - 2176 [Lemma~pseudo_order_lt_apart_fl...] 0.001 secs (0.001u,0.s)
Chars 2179 - 2185 [Proof.] 0. secs (0.u,0.s)
Chars 2188 - 2195 [(intros).] 0.173 secs (0.u,0.033s)
Chars 2198 - 2223 [(apply~apart_iff_total_lt).] 0.002 secs (0.001u,0.s)
Chars 2226 - 2231 [auto.] 0. secs (0.u,0.s)
Chars 2188 - 2195 [(intros).] 0. secs (0.u,0.s)
Chars 2198 - 2223 [(apply~apart_iff_total_lt).] 0. secs (0.u,0.s)
Chars 2226 - 2231 [auto.] 0. secs (0.u,0.s)
Chars 2234 - 2238 [Qed.] 0. secs (0.u,0.s)
Chars 2242 - 2304 [Lemma~not_lt_apart_lt_flip~x~y...] 0.001 secs (0.001u,0.s)
Chars 2307 - 2313 [Proof.] 0. secs (0.u,0.s)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣0⟩⟨0∣)
Crunching: (list2D_to_matrix [[0; 0]; [0; C1]] = bool_to_matrix' true)
Crunching: (list2D_to_matrix [[C1; 0]; [0; 0]] = bool_to_matrix' false)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 bool_to_ket contra × (bool_to_ket contra) †)
Crunching:
(list2D_to_matrix
   [[bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*;
    bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra 1%nat 0%nat) ^*];
   [bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*;
   bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra 1%nat 0%nat) ^*]] =
 bool_to_matrix contra)
Crunching:
(0 = bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra 2%nat 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra (S (S (S y))) 0%nat) ^*)
Crunching:
(0 = bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra 2%nat 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra (S (S (S y))) 0%nat) ^*)
Crunching:
(0 = bool_to_ket contra 2%nat 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*)
Crunching:
(0 = bool_to_ket contra 2%nat 0%nat * (bool_to_ket contra (S y) 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra (S (S (S x))) 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra (S (S (S x))) 0%nat * (bool_to_ket contra (S y) 0%nat) ^*)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 bool_to_ket contra × (bool_to_ket contra) †)
Crunching:
(list2D_to_matrix
   [[bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*;
    bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra 1%nat 0%nat) ^*];
   [bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*;
   bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra 1%nat 0%nat) ^*]] =
 bool_to_matrix contra)
Crunching:
(0 = bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra 2%nat 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra (S (S (S y))) 0%nat) ^*)
Crunching:
(0 = bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra 2%nat 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra (S (S (S y))) 0%nat) ^*)
Crunching:
(0 = bool_to_ket contra 2%nat 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*)
Crunching:
(0 = bool_to_ket contra 2%nat 0%nat * (bool_to_ket contra (S y) 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra (S (S (S x))) 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra (S (S (S x))) 0%nat * (bool_to_ket contra (S y) 0%nat) ^*)
Chars 9527 - 9535 [eexists.] 40.121 secs (0.002u,0.022s)
Chars 9536 - 9545 [Unshelve.] 0. secs (0.u,0.s)
Chars 9550 - 9585 [3:~exact~(((e.1)^-1)%morphism;...] 0.005 secs (0.005u,0.s)
Chars 9590 - 9591 [{] 0. secs (0.u,0.s)
Chars 9592 - 9638 [refine~(path_sigma'~_~left_inv...] 0.005 secs (0.005u,0.s)
Chars 9639 - 9640 [}] 0. secs (0.u,0.s)
Chars 9645 - 9646 [{] 0. secs (0.u,0.s)
Chars 9647 - 9694 [refine~(path_sigma'~_~right_in...] 0.005 secs (0.005u,0.s)
Chars 9695 - 9696 [}] 0. secs (0.u,0.s)
Chars 9527 - 9535 [eexists.] 0.002 secs (0.002u,0.s)
Chars 9550 - 9585 [3:~exact~(((e.1)^-1)%morphism;...] 0.002 secs (0.002u,0.s)
Chars 9592 - 9638 [refine~(path_sigma'~_~left_inv...] 0.002 secs (0.u,0.001s)
Chars 9647 - 9694 [refine~(path_sigma'~_~right_in...] 0.002 secs (0.001u,0.s)
Chars 9699 - 9707 [Defined.] 0.003 secs (0.002u,0.s)
Chars 9711 - 9878 [#[local]~Definition~iso_A'_dec...] 0.004 secs (0.003u,0.001s)
Chars 9881 - 9887 [Proof.] 0. secs (0.u,0.s)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 bool_to_ket contra × (bool_to_ket contra) †)
Crunching:
(list2D_to_matrix
   [[bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*;
    bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra 1%nat 0%nat) ^*];
   [bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*;
   bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra 1%nat 0%nat) ^*]] =
 bool_to_matrix contra)
Crunching:
(0 = bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra 2%nat 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra 0%nat 0%nat * (bool_to_ket contra (S (S (S y))) 0%nat) ^*)
Crunching:
(0 = bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra 2%nat 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra 1%nat 0%nat * (bool_to_ket contra (S (S (S y))) 0%nat) ^*)
Crunching:
(0 = bool_to_ket contra 2%nat 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*)
Crunching:
(0 = bool_to_ket contra 2%nat 0%nat * (bool_to_ket contra (S y) 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra (S (S (S x))) 0%nat * (bool_to_ket contra 0%nat 0%nat) ^*)
Crunching:
(0 =
 bool_to_ket contra (S (S (S x))) 0%nat * (bool_to_ket contra (S y) 0%nat) ^*)
Chars 2316 - 2331 [(intros~nlt~neq).] 40.161 secs (0.u,0.033s)
Chars 2332 - 2364 [(apply~apart_iff_total_lt~in~n...] 0.001 secs (0.001u,0.s)
Chars 2367 - 2380 [(destruct~neq).] 0.001 secs (0.001u,0.s)
Chars 2383 - 2384 [-] 0. secs (0.u,0.s)
Chars 2385 - 2403 [(destruct~nlt;~auto).] 0.002 secs (0.001u,0.s)
Chars 2406 - 2407 [-] 0. secs (0.u,0.s)
Chars 2408 - 2413 [auto.] 0. secs (0.u,0.s)
Chars 2316 - 2331 [(intros~nlt~neq).] 0. secs (0.u,0.s)
Chars 2332 - 2364 [(apply~apart_iff_total_lt~in~n...] 0. secs (0.u,0.s)
Chars 2367 - 2380 [(destruct~neq).] 0. secs (0.u,0.s)
Chars 2385 - 2403 [(destruct~nlt;~auto).] 0. secs (0.u,0.s)
Chars 2408 - 2413 [auto.] 0. secs (0.u,0.s)
Chars 2416 - 2420 [Qed.] 0.001 secs (0.u,0.s)
Chars 2424 - 2551 [Lemma~pseudo_order_cotrans_twi...] 0.002 secs (0.002u,0.s)
Chars 2554 - 2560 [Proof.] 0. secs (0.u,0.s)
Chars 2563 - 2573 [(intros~E1).] 5.649 secs (-4.292u,-0.769s)
Chars 9892 - 9900 [intro~e.] 40.12 secs (0.002u,0.021s)
Chars 9905 - 9913 [eexists.] 0.003 secs (0.002u,0.001s)
Chars 9914 - 9923 [Unshelve.] 0. secs (0.u,0.s)
Chars 9928 - 9966 [2:~exact~(e.1~:~morphism~_~_~_...] 0.004 secs (0.004u,0.s)
Chars 9971 - 9998 [(apply~iso_A'_decode_helper).] 0.004 secs (0.003u,0.s)
Chars 9892 - 9900 [intro~e.] 0.002 secs (0.002u,0.s)
Chars 9905 - 9913 [eexists.] 0.002 secs (0.002u,0.s)
Chars 9928 - 9966 [2:~exact~(e.1~:~morphism~_~_~_...] 0.002 secs (0.002u,0.s)
Chars 9971 - 9998 [(apply~iso_A'_decode_helper).] 0.002 secs (0.002u,0.s)
Chars 10001 - 10009 [Defined.] 0.002 secs (0.002u,0.s)
Chars 10013 - 10412 [#[local]~Definition~equiv_iso_...] 0.016 secs (0.013u,0.002s)
Chars 10415 - 10421 [Proof.] 0. secs (0.u,0.s)
Chars 10426 - 10472 [(simple~refine~(path_sigma~_~_...] 0.701 secs (-5.89u,-0.776s)
Chars 2563 - 2573 [(intros~E1).] 40.064 secs (0.u,0.032s)
Chars 2576 - 2666 [(apply~(merely_destruct~(cotra...] 0.011 secs (0.009u,0.001s)
Chars 2669 - 2743 [(apply~(merely_destruct~(cotra...] 0.01 secs (0.009u,0.001s)
Chars 2563 - 2573 [(intros~E1).] 0. secs (0.u,0.s)
Chars 2576 - 2666 [(apply~(merely_destruct~(cotra...] 0.001 secs (0.001u,0.s)
Chars 2669 - 2743 [(apply~(merely_destruct~(cotra...] 0.002 secs (0.002u,0.s)
Chars 2746 - 2750 [Qed.] 0.003 secs (0.002u,0.001s)
Chars 2754 - 2878 [Lemma~pseudo_order_lt_ext~x₁~y...] 0.002 secs (0.002u,0.s)
Chars 2881 - 2887 [Proof.] 0. secs (0.u,0.s)
Chars 10426 - 10472 [(simple~refine~(path_sigma~_~_...] 40.06 secs (0.012u,0.021s)
Chars 10514 - 10618 [1:~~(pose~@istrunc_sigma;~pose...] 0.157 secs (0.131u,0.025s)
Chars 10623 - 12205 [all:~~(repeat~~~~match~goal~wi...] 0.538 secs (0.513u,0.024s)
Chars 10426 - 10472 [(simple~refine~(path_sigma~_~_...] 0.009 secs (0.009u,0.s)
Chars 10514 - 10618 [1:~~(pose~@istrunc_sigma;~pose...] 0.012 secs (0.012u,0.s)
Chars 10623 - 12205 [all:~~(repeat~~~~match~goal~wi...] 0.006 secs (0.006u,0.s)
Chars 12208 - 12212 [Qed.] 0.279 secs (0.277u,0.001s)
Chars 12216 - 12391 [#[local]~Definition~equiv_iso_...] 0.004 secs (0.004u,0.s)
Chars 12394 - 12400 [Proof.] 0. secs (0.u,0.s)
Chars 2890 - 2899 [(intros~E).] 26.993 secs (16.557u,-0.432s)
Chars 2890 - 2899 [(intros~E).] 40.064 secs (0.u,0.032s)
Chars 2902 - 3042 [(apply~(merely_destruct~(pseud...] 0.015 secs (0.015u,0.s)
Chars 2890 - 2899 [(intros~E).] 0. secs (0.u,0.s)
Chars 2902 - 3042 [(apply~(merely_destruct~(pseud...] 0.003 secs (0.002u,0.s)
Chars 3045 - 3049 [Qed.] 0.002 secs (0.002u,0.s)
Chars 3053 - 3118 [#[global]Instance~pseudoorder_...] 0. secs (0.u,0.s)
Chars 3121 - 3127 [Proof.] 0. secs (0.u,0.s)
Chars 12405 - 12461 [refine~(equiv_adjointify~iso_A...] 22.645 secs (14.626u,-0.466s)
Chars 12405 - 12461 [refine~(equiv_adjointify~iso_A...] 40.051 secs (0.003u,0.025s)
Chars 12466 - 12467 [{] 0. secs (0.u,0.s)
Chars 12468 - 12474 [intro.] 0.003 secs (0.003u,0.s)
Chars 12481 - 12518 [simple~refine~(path_sigma~_~_~...] 0.003 secs (0.003u,0.s)
Chars 12525 - 12526 [{] 0. secs (0.u,0.s)
Chars 12527 - 12562 [(apply~path_isomorphic;~reflex...] 0.007 secs (0.006u,0.s)
Chars 12563 - 12564 [}] 0. secs (0.u,0.s)
Chars 12571 - 12572 [{] 0. secs (0.u,0.s)
Chars 12573 - 12607 [(apply~equiv_iso_A'_eisretr_he...] 0.015 secs (0.014u,0.s)
Chars 12608 - 12609 [}] 0. secs (0.u,0.s)
Chars 12611 - 12612 [}] 0. secs (0.u,0.s)
Chars 12617 - 12618 [{] 0. secs (0.u,0.s)
Chars 12619 - 12625 [intro.] 0.002 secs (0.002u,0.s)
Chars 12632 - 12654 [(apply~path_isomorphic).] 0.003 secs (0.003u,0.s)
Chars 12661 - 12673 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 12674 - 12675 [}] 0. secs (0.u,0.s)
Chars 12405 - 12461 [refine~(equiv_adjointify~iso_A...] 0.002 secs (0.002u,0.s)
Chars 12468 - 12474 [intro.] 0.002 secs (0.002u,0.s)
Chars 12481 - 12518 [simple~refine~(path_sigma~_~_~...] 0.002 secs (0.002u,0.s)
Chars 12527 - 12562 [(apply~path_isomorphic;~reflex...] 0.004 secs (0.004u,0.s)
Chars 12573 - 12607 [(apply~equiv_iso_A'_eisretr_he...] 0.002 secs (0.002u,0.s)
Chars 12619 - 12625 [intro.] 0.002 secs (0.002u,0.s)
Chars 12632 - 12654 [(apply~path_isomorphic).] 0.002 secs (0.002u,0.s)
Chars 12661 - 12673 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 12678 - 12686 [Defined.] 0.016 secs (0.01u,0.005s)
Chars 12690 - 12758 [Context~`{Pisotoid~:~forall~x~...] 0. secs (0.u,0.s)
Chars 12762 - 12803 [#[local]Arguments~Pmor_iso_T~:...] 0. secs (0.u,0.s)
Chars 12807 - 12880 [#[global]Instance~iscategory_s...] 0.006 secs (0.005u,0.s)
Chars 12883 - 12889 [Proof.] 0. secs (0.u,0.s)
Chars 12894 - 12905 [(intros~s~d).] 0.396 secs (-7.133u,-1.019s)
PrimRec_PrimRecs_ind
     : forall (P : forall n : nat, PrimRec n -> Prop)
         (P0 : forall n n0 : nat, PrimRecs n n0 -> Prop),
       P 1 succFunc ->
       P 0 zeroFunc ->
       (forall (n m : nat) (l : m < n), P n (projFunc n m l)) ->
       (forall (n m : nat) (g : PrimRecs n m),
        P0 n m g -> forall h : PrimRec m, P m h -> P n (composeFunc n m g h)) ->
       (forall (n : nat) (g : PrimRec n),
        P n g ->
        forall h : PrimRec (S (S n)),
        P (S (S n)) h -> P (S n) (primRecFunc n g h)) ->
       (forall n : nat, P0 n 0 (PRnil n)) ->
       (forall (n m : nat) (p : PrimRec n),
        P n p ->
        forall p0 : PrimRecs n m, P0 n m p0 -> P0 n (S m) (PRcons n m p p0)) ->
       forall (n : nat) (p : PrimRec n), P n p
Chars 3130 - 3136 [split.] 40.212 secs (0.001u,0.031s)
Chars 3139 - 3140 [-] 0. secs (0.u,0.s)
Chars 3141 - 3149 [(apply~_).] 0.026 secs (0.022u,0.003s)
Chars 3152 - 3153 [-] 0. secs (0.u,0.s)
Chars 3154 - 3165 [(intros~x~E).] 0. secs (0.u,0.s)
Chars 3170 - 3212 [(destruct~(pseudo_order_antisy...] 0.002 secs (0.002u,0.s)
Chars 3215 - 3216 [-] 0. secs (0.u,0.s)
Chars 3217 - 3236 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 3241 - 3307 [(apply~(merely_destruct~(cotra...] 0.023 secs (0.02u,0.002s)
Chars 3312 - 3354 [(destruct~(pseudo_order_antisy...] 0.003 secs (0.003u,0.s)
Chars 3130 - 3136 [split.] 0. secs (0.u,0.s)
Chars 3141 - 3149 [(apply~_).] 0. secs (0.u,0.s)
Chars 3154 - 3165 [(intros~x~E).] 0. secs (0.u,0.s)
Chars 3170 - 3212 [(destruct~(pseudo_order_antisy...] 0. secs (0.u,0.s)
Chars 3217 - 3236 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 3241 - 3307 [(apply~(merely_destruct~(cotra...] 0.001 secs (0.001u,0.s)
Chars 3312 - 3354 [(destruct~(pseudo_order_antisy...] 0. secs (0.u,0.s)
Chars 3357 - 3361 [Qed.] 0.001 secs (0.001u,0.s)
Chars 3365 - 3421 [#[global]Instance~nlt_trans~:~...] 0. secs (0.u,0.s)
Chars 3424 - 3430 [Proof.] 0. secs (0.u,0.s)
[DEBUG] (nat -> (fun T : Type => T) Type)
Finished transaction in 0.104 secs (0.089u,0.014s) (successful)
produces_a_value
     : M nat
the_value_tactic = 1
     : nat
empty_string = ""
     : string
world_string = "world"
     : string
other_string = "other"
     : string
the_sequence_6 = 
6 :: 3 :: 10 :: 5 :: 16 :: 8 :: 4 :: 2 :: 1 :: nil
     : list nat
inlist
     : forall (A : Type) (x : A) (x0 : list A), M (In x x0)
y_in_zyx = 
fun x y z : nat => eval (inlist y (z :: y :: x :: nil))
     : forall x y z : nat, In y (z :: y :: x :: nil)

Arguments y_in_zyx (x y z)%nat_scope
inlist' = 
fun (A : Type) (x : A) =>
mfix1 f s : list A : M In x s :=
    (mmatch s in list A as s' return M (In x s')
     [m: ([?l r : list A] l ++ r =>
                          [H : s =m= l ++ r] mtry'
                                               ('il <- f l; 
                                                ret
                                                 ((fun 
                                                 (A0 : Type) 
                                                 (x0 : A0)
                                                 (_ : 
                                                 forall x1 : list A0,
                                                 M (In x0 x1))
                                                 (s0 l0 r0 : list A0)
                                                 (_ : s0 =m= l0 ++ r0)
                                                 (il0 : In x0 l0) =>
                                                 inlist'_obligation_1 x0 l0
                                                 r0 il0) A x f s l r H il) )
                                               (fun e : Exception =>
                                                mmatch'' NotCaught e
                                                 (raise e)
                                                 (with 
                                                 _ => 
                                                 'ir <- f r; 
                                                 ret
                                                 ((fun 
                                                 (A0 : Type) 
                                                 (x0 : A0)
                                                 (_ : 
                                                 forall x1 : list A0,
                                                 M (In x0 x1))
                                                 (s0 l0 r0 : list A0)
                                                 (_ : s0 =m= l0 ++ r0)
                                                 (_ : Exception)
                                                 (ir0 : In x0 r0) =>
                                                 inlist'_obligation_2 x0 l0
                                                 r0 ir0) A x f s l r H e ir) 
                                                 end)))%branch
       | ([?s' : list A] x :: s' => [_ : s =m= x :: s'] ret (in_eq x s'))%branch
       | ([?(y : A)
          (s' : list A)] y :: s' => [_ : s =m= y :: s'] 
                         'r <- f s'; ret (in_cons y x s' r) )%branch
       | (_ => raise NotFound)%branch])
     : forall (A : Type) (x : A) (x0 : list A), M (In x x0)

Arguments inlist' [A]%type_scope x x%list_scope
inlist'_obligation_1 = 
fun (A : Type) (x : A) (l r : list A) (il : In x l) =>
in_or_app l r x (or_introl il)
     : forall (A : Type) (x : A) (l r : list A), In x l -> In x (l ++ r)

Arguments inlist'_obligation_1 [A]%type_scope x (l r)%list_scope il
inlist'_obligation_2 = 
fun (A : Type) (x : A) (l r : list A) (ir : In x r) =>
in_or_app l r x (or_intror ir)
     : forall (A : Type) (x : A) (l r : list A), In x r -> In x (l ++ r)

Arguments inlist'_obligation_2 [A]%type_scope x (l r)%list_scope ir
ex_inlist = 
fun x y z : nat =>
in_cons y x
  ((fix app (l m : list nat) {struct l} : list nat :=
      match l with
      | nil => m
      | a :: l1 => a :: app l1 m
      end) (z :: nil) (x :: z :: nil))
  (in_cons z x
     ((fix app (l m : list nat) {struct l} : list nat :=
         match l with
         | nil => m
         | a :: l1 => a :: app l1 m
         end) nil (x :: z :: nil)) (in_eq x (z :: nil)))
     : forall x y z : nat, In x ((y :: z :: nil) ++ x :: z :: nil)

Arguments ex_inlist (x y z)%nat_scope
ex_inlist' = 
fun x y z : nat =>
(fun (A : Type) (x0 : A) (_ : forall x1 : list A, M (In x0 x1))
   (s l r : list A) (_ : s =m= l ++ r) (_ : Exception) 
   (ir : In x0 r) => inlist'_obligation_2 x0 l r ir) nat x
  (mfix1 f s : list nat : M In x s :=
       (mmatch s in list nat as s' return M (In x s')
        [m: ([?l r : list nat] l ++ r =>
                               [H : s =m= l ++ r] 
                               mtry'
                                 ('il <- f l; 
                                  ret
                                    ((fun (A : Type) 
                                        (x0 : A)
                                        (_ : forall x1 : list A, M (In x0 x1))
                                        (s0 l0 r0 : list A)
                                        (_ : s0 =m= l0 ++ r0)
                                        (il0 : In x0 l0) =>
                                      inlist'_obligation_1 x0 l0 r0 il0) nat
                                       x f s l r H il) )
                                 (fun e : Exception =>
                                  mmatch'' NotCaught e 
                                    (raise e)
                                    (with _ => 'ir <- f r; 
                                          ret
                                            ((fun 
                                                (A : Type) 
                                                (x0 : A)
                                                (_ : 
                                                 forall x1 : list A,
                                                 M (In x0 x1))
                                                (s0 l0 r0 : list A)
                                                (_ : s0 =m= l0 ++ r0)
                                                (_ : Exception)
                                                (ir0 : In x0 r0) =>
                                              inlist'_obligation_2 x0 l0 r0
                                                ir0) nat x f s l r H e ir) 
                                     end)))%branch
          | ([?s' : list nat] x :: s' => [_ : s =m= x :: s'] ret (in_eq x s'))%branch
          | ([?(y0 : nat)
             (s' : list nat)] y0 :: s' => [_ : s =m= y0 :: s'] 
                              'r <- f s'; ret (in_cons y0 x s' r) )%branch
          | (_ => raise NotFound)%branch]))
  ((y :: z :: nil) ++ x :: z :: nil) (y :: z :: nil) 
  (x :: z :: nil)
  (reduce (RedWhd [rl:RedBeta; RedDelta; RedMatch])
     match
       meq_refl in (_ =m= y0)
       return (y0 =m= (y :: z :: nil) ++ x :: z :: nil)
     with
     | meq_refl => meq_refl
     end) NotFound (in_eq x (z :: nil))
     : forall x y z : nat, In x ((y :: z :: nil) ++ x :: z :: nil)

Arguments ex_inlist' (x y z)%nat_scope
ex_inlist'' = 
fun x y z : nat =>
in_or_app (y :: z :: nil) (x :: z :: nil) x (or_intror (in_eq x (z :: nil)))
     : forall x y z : nat, In x ((y :: z :: nil) ++ x :: z :: nil)

Arguments ex_inlist'' (x y z)%nat_scope
ex1 = conj I (or_intror I)
     : True /\ (False \/ True)
nu@{u u0 u1} : forall {A B : Type}, name -> moption A -> (A -> M B) -> M B

nu is universe polymorphic
Arguments nu {A B}%type_scope _ _ _%function_scope
nu is opaque
Expands to: Constant Mtac2.intf.M.M.nu
ex_with_implication = 
fun (p q : Prop) (x : p) (x0 : q) => conj x x0
     : forall p q : Prop, p -> q -> p /\ q

Arguments ex_with_implication [p q]%type_scope _ _
Chars 12894 - 12905 [(intros~s~d).] 40.048 secs (0.001u,0.021s)
Chars 12910 - 13127 [(simple~notypeclasses~refine~~...] 0.163 secs (0.134u,0.028s)
Chars 13223 - 13224 [{] 0. secs (0.u,0.s)
Chars 13225 - 13248 [exact~(@idtoiso~A~_~_).] 0.003 secs (0.003u,0.s)
Chars 13249 - 13250 [}] 0. secs (0.u,0.s)
Chars 13255 - 13256 [{] 0. secs (0.u,0.s)
Chars 13257 - 13298 [(destruct~s~as~[s0~s1],~d~as~[...] 0.011 secs (0.011u,0.s)
Chars 13305 - 13330 [(intro~p;~destruct~p;~cbn).] 0.01 secs (0.01u,0.s)
Chars 13337 - 13381 [refine~((@Pmor_iso_adjust~s0~s...] 0.109 secs (0.101u,0.007s)
Chars 13388 - 13413 [refine~(@Pidtoiso~_~_~_).] 0.003 secs (0.002u,0.s)
Chars 13414 - 13415 [}] 0. secs (0.u,0.s)
Chars 13420 - 13421 [{] 0. secs (0.u,0.s)
Chars 13474 - 13498 [nrefine~isequiv_compose.] 0.066 secs (0.056u,0.009s)
Chars 13499 - 13523 [1:~(apply~isequiv_inverse).] 0.003 secs (0.002u,0.s)
Chars 13530 - 13554 [nrefine~isequiv_compose.] 0.052 secs (0.046u,0.004s)
Chars 13555 - 13579 [2:~(apply~isequiv_inverse).] 0.003 secs (0.003u,0.s)
Chars 13586 - 13616 [nrefine~isequiv_functor_sigma.] 0.037 secs (0.034u,0.002s)
Chars 13617 - 13631 [1:~(apply~A_cat).] 0.002 secs (0.002u,0.s)
Chars 13638 - 13652 [(destruct~s,~d).] 0.008 secs (0.008u,0.s)
Chars 13659 - 13678 [(simpl~Overture.pr1).] 0.003 secs (0.003u,0.s)
Chars 13685 - 13705 [(intro~p;~destruct~p).] 0.008 secs (0.008u,0.s)
Chars 13712 - 13736 [(eapply~@isequiv_compose).] 0.003 secs (0.003u,0.s)
Chars 13743 - 13744 [-] 0. secs (0.u,0.s)
Chars 13745 - 13753 [exact~_.] 0.002 secs (0.002u,0.s)
Chars 13760 - 13761 [-] 0. secs (0.u,0.s)
Chars 13762 - 13786 [(eapply~@isequiv_inverse).] 0.003 secs (0.003u,0.s)
Chars 13787 - 13788 [}] 0. secs (0.u,0.s)
Chars 13793 - 13794 [{] 0. secs (0.u,0.s)
Chars 13795 - 13838 [(intro~p;~apply~path_isomorphi...] 0.021 secs (0.021u,0.s)
Chars 13845 - 13857 [reflexivity.] 0.007 secs (0.007u,0.s)
Chars 13858 - 13859 [}] 0. secs (0.u,0.s)
Chars 12894 - 12905 [(intros~s~d).] 0.002 secs (0.002u,0.s)
Chars 12910 - 13127 [(simple~notypeclasses~refine~~...] 0.007 secs (0.007u,0.s)
Chars 13225 - 13248 [exact~(@idtoiso~A~_~_).] 0.002 secs (0.001u,0.s)
Chars 13257 - 13298 [(destruct~s~as~[s0~s1],~d~as~[...] 0.009 secs (0.008u,0.001s)
Chars 13305 - 13330 [(intro~p;~destruct~p;~cbn).] 0.006 secs (0.006u,0.s)
Chars 13337 - 13381 [refine~((@Pmor_iso_adjust~s0~s...] 0.001 secs (0.001u,0.s)
Chars 13388 - 13413 [refine~(@Pidtoiso~_~_~_).] 0.001 secs (0.001u,0.s)
Chars 13474 - 13498 [nrefine~isequiv_compose.] 0.004 secs (0.004u,0.s)
Chars 13499 - 13523 [1:~(apply~isequiv_inverse).] 0.002 secs (0.002u,0.s)
Chars 13530 - 13554 [nrefine~isequiv_compose.] 0.003 secs (0.003u,0.s)
Chars 13555 - 13579 [2:~(apply~isequiv_inverse).] 0.002 secs (0.002u,0.s)
Chars 13586 - 13616 [nrefine~isequiv_functor_sigma.] 0.002 secs (0.002u,0.s)
Chars 13617 - 13631 [1:~(apply~A_cat).] 0.002 secs (0.002u,0.s)
Chars 13638 - 13652 [(destruct~s,~d).] 0.002 secs (0.002u,0.s)
Chars 13659 - 13678 [(simpl~Overture.pr1).] 0.002 secs (0.002u,0.s)
Chars 13685 - 13705 [(intro~p;~destruct~p).] 0.005 secs (0.005u,0.s)
Chars 13712 - 13736 [(eapply~@isequiv_compose).] 0.002 secs (0.002u,0.s)
Chars 13745 - 13753 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 13762 - 13786 [(eapply~@isequiv_inverse).] 0.002 secs (0.002u,0.s)
Chars 13795 - 13838 [(intro~p;~apply~path_isomorphi...] 0.011 secs (0.011u,0.s)
Chars 13845 - 13857 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 13862 - 13870 [Defined.] 0.063 secs (0.063u,0.s)
Chars 13871 - 13883 [End~on_both.] 0.62 secs (0.616u,0.003s)
Chars 3433 - 3446 [(intros~x~y~z).] 40.18 secs (0.u,0.032s)
Chars 3449 - 3465 [(intros~E1~E2~E3).] 0. secs (0.u,0.s)
Chars 3468 - 3543 [(apply~(merely_destruct~(cotra...] 0.006 secs (0.004u,0.002s)
Chars 3433 - 3446 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 3449 - 3465 [(intros~E1~E2~E3).] 0. secs (0.u,0.s)
Chars 3468 - 3543 [(apply~(merely_destruct~(cotra...] 0.001 secs (0.u,0.s)
Chars 3546 - 3550 [Qed.] 0.001 secs (0.001u,0.s)
Chars 3554 - 3616 [#[global]Instance~nlt_antisymm...] 0. secs (0.u,0.s)
Chars 3619 - 3625 [Proof.] 0. secs (0.u,0.s)
Crunching:
((fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => C1
             | _ => 0
             end
  | 2%nat => match y with
             | 3%nat => C1
             | _ => 0
             end
  | 3%nat => match y with
             | 2%nat => C1
             | _ => 0
             end
  | S (S (S (S _))) => 0
  end) =
 (fun x y : nat =>
  if (x <? 2) && (y =? x)
  then C1
  else
   if (2 <=? x) && (2 <=? y)
   then
    match (x - 2)%nat with
    | 0%nat => match (y - 2)%nat with
               | 1%nat => C1
               | _ => 0
               end
    | 1%nat => match (y - 2)%nat with
               | 0%nat => C1
               | S _ => 0
               end
    | S (S _) => 0
    end
   else 0))
Chars 3628 - 3645 [(intros~x~y~H1~H2).] 40.172 secs (0.u,0.033s)
Chars 3648 - 3666 [(apply~tight_apart).] 0.002 secs (0.002u,0.s)
Chars 3667 - 3678 [(intros~nap).] 0. secs (0.u,0.s)
Chars 3679 - 3711 [(apply~apart_iff_total_lt~in~n...] 0.002 secs (0.002u,0.s)
Chars 3714 - 3732 [(destruct~nap;~auto).] 0.003 secs (0.002u,0.s)
Chars 3628 - 3645 [(intros~x~y~H1~H2).] 0. secs (0.u,0.s)
Chars 3648 - 3666 [(apply~tight_apart).] 0. secs (0.u,0.s)
Chars 3667 - 3678 [(intros~nap).] 0. secs (0.u,0.s)
Chars 3679 - 3711 [(apply~apart_iff_total_lt~in~n...] 0. secs (0.u,0.s)
Chars 3714 - 3732 [(destruct~nap;~auto).] 0. secs (0.u,0.s)
Chars 3735 - 3739 [Qed.] 0.001 secs (0.001u,0.s)
Chars 3743 - 3812 [Lemma~ne_total_lt~`{!TrivialAp...] 0.002 secs (0.001u,0.s)
Chars 3815 - 3821 [Proof.] 0. secs (0.u,0.s)
Chars 3824 - 3862 [(intros~neq;~apply~trivial_apa...] 0.149 secs (0.001u,0.035s)
Chars 3865 - 3886 [(apply~apart_total_lt).] 0. secs (0.u,0.s)
Chars 3887 - 3898 [assumption.] 0. secs (0.u,0.s)
Chars 3824 - 3862 [(intros~neq;~apply~trivial_apa...] 0. secs (0.u,0.s)
Chars 3865 - 3886 [(apply~apart_total_lt).] 0. secs (0.u,0.s)
Chars 3887 - 3898 [assumption.] 0. secs (0.u,0.s)
Chars 3901 - 3905 [Qed.] 0. secs (0.u,0.s)
Chars 3909 - 3999 [#[global]~Instance~lt_trichoto...] 0.001 secs (0.001u,0.s)
Chars 4002 - 4008 [Proof.] 0. secs (0.u,0.s)
'diag_seqmx_R' is now a registered translation.
Chars 4011 - 4022 [(intros~x~y).] 30.78 secs (20.19u,-0.557s)
Chars 4011 - 4022 [(intros~x~y).] 40.066 secs (0.u,0.034s)
Chars 4025 - 4067 [(destruct~(dec~(x~=~y))~as~[?|...] 0.027 secs (0.025u,0.s)
Chars 4070 - 4103 [(destruct~(ne_total_lt~x~y);~a...] 0.008 secs (0.008u,0.s)
Chars 4011 - 4022 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 4025 - 4067 [(destruct~(dec~(x~=~y))~as~[?|...] 0.001 secs (0.001u,0.s)
Chars 4070 - 4103 [(destruct~(ne_total_lt~x~y);~a...] 0.001 secs (0.001u,0.s)
Chars 4106 - 4110 [Qed.] 0.001 secs (0.u,0.s)
Chars 4111 - 4128 [End~pseudo_order.] 0.028 secs (0.021u,0.006s)
Chars 4130 - 4157 [Section~full_partial_order.] 0. secs (0.u,0.s)
Chars 4160 - 4190 [Context~`{FullPartialOrder~A}.] 0.001 secs (0.u,0.s)
Chars 4194 - 4234 [#[local]Existing~Instance~stri...] 0. secs (0.u,0.s)
Chars 4381 - 4457 [Instance~strict_po_apart_ne~~x...] 0.001 secs (0.001u,0.s)
Chars 4460 - 4466 [Proof.] 0. secs (0.u,0.s)
Chars 4469 - 4485 [(intros;~apply~_).] 0.254 secs (0.003u,0.035s)
Chars 4469 - 4485 [(intros;~apply~_).] 0. secs (0.u,0.s)
Chars 4488 - 4492 [Qed.] 0. secs (0.u,0.s)
Chars 4496 - 4559 [#[global]Instance~fullpartialo...] 0. secs (0.u,0.s)
Chars 4562 - 4568 [Proof.] 0. secs (0.u,0.s)
(* info auto: *)
simple apply lt_2 (in T2).
 simple apply lt_1 (in T2).
 simple apply lt_2 (in T2).
  simple apply lt_1 (in T2).
  simple apply lt_1 (in T2).
PeanoNat.Nat.lt_le_incl: forall n m : nat, n < m -> n <= m
PeanoNat.Nat.lt_ge_cases: forall n m : nat, n < m \/ m <= n
PeanoNat.Nat.le_gt_cases: forall n m : nat, n <= m \/ m < n
Compare_dec.le_lt_dec: forall n m : nat, {n <= m} + {m < n}
Lt.le_not_lt: forall n m : nat, n <= m -> ~ m < n
Lt.lt_not_le: forall n m : nat, n < m -> ~ m <= n
Lt.lt_n_Sm_le: forall n m : nat, n < S m -> n <= m
Lt.lt_le_S: forall n m : nat, n < m -> S n <= m
PeanoNat.Nat.lt_pred_le: forall n m : nat, PeanoNat.Nat.pred n < m -> n <= m
PeanoNat.Nat.lt_le_pred: forall n m : nat, n < m -> n <= PeanoNat.Nat.pred m
Lt.le_lt_n_Sm: forall n m : nat, n <= m -> n < S m
PeanoNat.Nat.le_lt_trans: forall n m p : nat, n <= m -> m < p -> n < p
PeanoNat.Nat.lt_le_trans: forall n m p : nat, n < m -> m <= p -> n < p
PeanoNat.Nat.nlt_ge: forall n m : nat, ~ n < m <-> m <= n
PeanoNat.Nat.le_ngt: forall n m : nat, n <= m <-> ~ m < n
PeanoNat.Nat.lt_nge: forall n m : nat, n < m <-> ~ m <= n
PeanoNat.Nat.nle_gt: forall n m : nat, ~ n <= m <-> m < n
PeanoNat.Nat.le_succ_l: forall n m : nat, S n <= m <-> n < m
PeanoNat.Nat.lt_succ_r: forall n m : nat, n < S m <-> n <= m
PeanoNat.Nat.ltb_spec:
  forall x y : nat, BoolSpec (x < y) (y <= x) (PeanoNat.Nat.ltb x y)
PeanoNat.Nat.leb_spec:
  forall x y : nat, BoolSpec (x <= y) (y < x) (PeanoNat.Nat.leb x y)
Between.in_int_intro:
  forall p q r : nat, p <= r -> r < q -> Between.in_int p q r
PeanoNat.Nat.divide_pos_le:
  forall n m : nat, 0 < m -> PeanoNat.Nat.divide n m -> n <= m
PeanoNat.Nat.lt_wf:
  forall z : nat, well_founded (fun n m : nat => z <= n < m)
PeanoNat.Nat.gt_wf:
  forall z : nat, well_founded (fun n m : nat => m < n <= z)
PeanoNat.Nat.rbase:
  forall (A : nat -> Prop) (z : nat),
  (fun n : nat => forall m : nat, z <= m -> m < n -> A m) z
Compare_dec.le_lt_eq_dec: forall n m : nat, n <= m -> {n < m} + {n = m}
Lt.le_lt_or_eq: forall n m : nat, n <= m -> n < m \/ n = m
PeanoNat.Nat.add_nonneg_pos: forall n m : nat, 0 <= n -> 0 < m -> 0 < n + m
PeanoNat.Nat.sub_lt: forall n m : nat, m <= n -> 0 < m -> n - m < n
PeanoNat.Nat.add_pos_nonneg: forall n m : nat, 0 < n -> 0 <= m -> 0 < n + m
PeanoNat.Nat.lt_eq_cases: forall n m : nat, n <= m <-> n < m \/ n = m
PeanoNat.Nat.square_lt_mono_nonneg:
  forall n m : nat, 0 <= n -> n < m -> n * n < m * m
PeanoNat.Nat.square_lt_simpl_nonneg:
  forall n m : nat, 0 <= m -> n * n < m * m -> n < m
PeanoNat.Nat.le_lteq: forall n m : nat, n <= m <-> n < m \/ n = m
PeanoNat.Nat.add_lt_le_mono:
  forall n m p q : nat, n < m -> p <= q -> n + p < m + q
PeanoNat.Nat.mul_nonneg_cancel_l:
  forall n m : nat, 0 < n -> 0 <= n * m <-> 0 <= m
PeanoNat.Nat.mul_nonneg_cancel_r:
  forall n m : nat, 0 < m -> 0 <= n * m <-> 0 <= n
PeanoNat.Nat.add_le_lt_mono:
  forall n m p q : nat, n <= m -> p < q -> n + p < m + q
PeanoNat.Nat.div_str_pos:
  forall a b : nat, 0 < b <= a -> 0 < PeanoNat.Nat.div a b
Plus.plus_lt_le_compat:
  forall n m p q : nat, n < m -> p <= q -> n + p < m + q
PeanoNat.Nat.le_lt_add_lt:
  forall n m p q : nat, n <= m -> p + m < q + n -> p < q
PeanoNat.Nat.lt_le_add_lt:
  forall n m p q : nat, n < m -> p + m <= q + n -> p < q
Plus.plus_le_lt_compat:
  forall n m p q : nat, n <= m -> p < q -> n + p < m + q
PeanoNat.Nat.le_neq: forall n m : nat, n < m <-> n <= m /\ n <> m
PeanoNat.Nat.div_le_compat_l:
  forall p q r : nat,
  0 < q <= r -> PeanoNat.Nat.div p r <= PeanoNat.Nat.div p q
PeanoNat.Nat.mul_le_mono_pos_r:
  forall n m p : nat, 0 < p -> n <= m <-> n * p <= m * p
PeanoNat.Nat.mul_le_mono_pos_l:
  forall n m p : nat, 0 < p -> n <= m <-> p * n <= p * m
PeanoNat.Nat.mul_le_mono_neg_r:
  forall n m p : nat, p < 0 -> n <= m <-> m * p <= n * p
PeanoNat.Nat.mul_le_mono_neg_l:
  forall n m p : nat, p < 0 -> n <= m <-> p * m <= p * n
PeanoNat.Nat.A'A_right:
  forall (A : nat -> Prop) (z : nat),
  (forall n : nat,
   (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n) ->
  forall n : nat, z <= n -> A n
PeanoNat.Nat.lt_exists_pred:
  forall z n : nat, z < n -> exists k : nat, n = S k /\ z <= k
PeanoNat.Nat.mod_bound_pos:
  forall x y : nat, 0 <= x -> 0 < y -> 0 <= PeanoNat.Nat.modulo x y < y
PeanoNat.Nat.add_le_mul: forall a b : nat, 1 < a -> 1 < b -> a + b <= a * b
PeanoNat.Nat.div_str_pos_iff:
  forall a b : nat, b <> 0 -> 0 < PeanoNat.Nat.div a b <-> b <= a
PeanoNat.Nat.pow_le_mono_r_iff:
  forall a b c : nat,
  1 < a -> b <= c <-> PeanoNat.Nat.pow a b <= PeanoNat.Nat.pow a c
PeanoNat.Nat.sqrt_up_lt_square:
  forall a b : nat,
  0 <= a -> 0 <= b -> b * b < a <-> b < PeanoNat.Nat.sqrt_up a
PeanoNat.Nat.log2_mul_below:
  forall a b : nat,
  0 < a ->
  0 < b ->
  PeanoNat.Nat.log2 a + PeanoNat.Nat.log2 b <= PeanoNat.Nat.log2 (a * b)
PeanoNat.Nat.sqrt_specif:
  forall n : nat,
  PeanoNat.Nat.sqrt n * PeanoNat.Nat.sqrt n <= n <
  S (PeanoNat.Nat.sqrt n) * S (PeanoNat.Nat.sqrt n)
PeanoNat.Nat.sqrt_spec':
  forall a : nat,
  PeanoNat.Nat.sqrt a * PeanoNat.Nat.sqrt a <= a <
  S (PeanoNat.Nat.sqrt a) * S (PeanoNat.Nat.sqrt a)
PeanoNat.Nat.log2_up_le_pow2:
  forall a b : nat,
  0 < a -> a <= PeanoNat.Nat.pow 2 b <-> PeanoNat.Nat.log2_up a <= b
PeanoNat.Nat.log2_le_pow2:
  forall a b : nat,
  0 < a -> PeanoNat.Nat.pow 2 b <= a <-> b <= PeanoNat.Nat.log2 a
List.in_seq:
  forall len start n : nat,
  List.In n (List.seq start len) <-> start <= n < start + len
PeanoNat.Nat.mul_lt_mono_nonneg:
  forall n m p q : nat, 0 <= n -> n < m -> 0 <= p -> p < q -> n * p < m * q
PeanoNat.Nat.double_below: forall n m : nat, n <= m -> 2 * n < 2 * m + 1
PeanoNat.Nat.min_spec:
  forall n m : nat,
  n < m /\ PeanoNat.Nat.min n m = n \/ m <= n /\ PeanoNat.Nat.min n m = m
PeanoNat.Nat.lt_exists_pred_strong:
  forall z n m : nat, z < m -> m <= n -> exists k : nat, m = S k /\ z <= k
max_spec:
  forall n m : nat,
  n < m /\ PeanoNat.Nat.max n m = m \/ m <= n /\ PeanoNat.Nat.max n m = n
PeanoNat.Nat.max_spec:
  forall n m : nat,
  n < m /\ PeanoNat.Nat.max n m = m \/ m <= n /\ PeanoNat.Nat.max n m = n
Min.min_spec:
  forall n m : nat,
  n < m /\ PeanoNat.Nat.min n m = n \/ m <= n /\ PeanoNat.Nat.min n m = m
PeanoNat.Nat.sqrt_unique:
  forall a b : nat, b * b <= a < S b * S b -> PeanoNat.Nat.sqrt a = b
PeanoNat.Nat.log2_up_mul_below:
  forall a b : nat,
  0 < a ->
  0 < b ->
  PeanoNat.Nat.log2_up a + PeanoNat.Nat.log2_up b <=
  S (PeanoNat.Nat.log2_up (a * b))
PeanoNat.Nat.sqrt_up_spec:
  forall a : nat,
  0 < a ->
  PeanoNat.Nat.pred (PeanoNat.Nat.sqrt_up a) *
  PeanoNat.Nat.pred (PeanoNat.Nat.sqrt_up a) < a <=
  PeanoNat.Nat.sqrt_up a * PeanoNat.Nat.sqrt_up a
PeanoNat.Nat.sqrt_spec:
  forall a : nat,
  0 <= a ->
  PeanoNat.Nat.sqrt a * PeanoNat.Nat.sqrt a <= a <
  S (PeanoNat.Nat.sqrt a) * S (PeanoNat.Nat.sqrt a)
PeanoNat.Nat.min_unicity:
  forall n m p : nat,
  n < m /\ p = n \/ m <= n /\ p = m -> p = PeanoNat.Nat.min n m
PeanoNat.Nat.max_unicity:
  forall n m p : nat,
  n < m /\ p = m \/ m <= n /\ p = n -> p = PeanoNat.Nat.max n m
PeanoNat.Nat.log2_spec:
  forall n : nat,
  0 < n ->
  PeanoNat.Nat.pow 2 (PeanoNat.Nat.log2 n) <= n <
  PeanoNat.Nat.pow 2 (S (PeanoNat.Nat.log2 n))
PeanoNat.Nat.log2_log2_up_spec:
  forall a : nat,
  0 < a ->
  PeanoNat.Nat.pow 2 (PeanoNat.Nat.log2 a) <= a <=
  PeanoNat.Nat.pow 2 (PeanoNat.Nat.log2_up a)
PeanoNat.Nat.Rgt_wd:
  forall z : nat,
  Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful eq iff))
    (fun n m : nat => m < n <= z)
PeanoNat.Nat.Rlt_wd:
  forall z : nat,
  Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful eq iff))
    (fun n m : nat => z <= n < m)
PeanoNat.Nat.sqrt_up_unique:
  forall a b : nat,
  0 < b ->
  PeanoNat.Nat.pred b * PeanoNat.Nat.pred b < a <= b * b ->
  PeanoNat.Nat.sqrt_up a = b
PeanoNat.Nat.log2_up_spec:
  forall a : nat,
  1 < a ->
  PeanoNat.Nat.pow 2 (PeanoNat.Nat.pred (PeanoNat.Nat.log2_up a)) < a <=
  PeanoNat.Nat.pow 2 (PeanoNat.Nat.log2_up a)
PeanoNat.Nat.log2_mul_pow2:
  forall a b : nat,
  0 < a ->
  0 <= b ->
  PeanoNat.Nat.log2 (a * PeanoNat.Nat.pow 2 b) = b + PeanoNat.Nat.log2 a
PeanoNat.Nat.log2_up_mul_pow2:
  forall a b : nat,
  0 < a ->
  0 <= b ->
  PeanoNat.Nat.log2_up (a * PeanoNat.Nat.pow 2 b) =
  b + PeanoNat.Nat.log2_up a
PeanoNat.Nat.log2_unique:
  forall a b : nat,
  0 <= b ->
  PeanoNat.Nat.pow 2 b <= a < PeanoNat.Nat.pow 2 (S b) ->
  PeanoNat.Nat.log2 a = b
PeanoNat.Nat.log2_up_unique:
  forall a b : nat,
  0 < b ->
  PeanoNat.Nat.pow 2 (PeanoNat.Nat.pred b) < a <= PeanoNat.Nat.pow 2 b ->
  PeanoNat.Nat.log2_up a = b
PeanoNat.Nat.left_induction:
  forall A : nat -> Prop,
  Morphisms.Proper (Morphisms.respectful eq iff) A ->
  forall z : nat,
  A z ->
  (forall n : nat, n < z -> A (S n) -> A n) -> forall n : nat, n <= z -> A n
PeanoNat.Nat.min_unicity_ext:
  forall f : nat -> nat -> nat,
  (forall n m : nat, n < m /\ f n m = n \/ m <= n /\ f n m = m) ->
  forall n m : nat, f n m = PeanoNat.Nat.min n m
PeanoNat.Nat.max_unicity_ext:
  forall f : nat -> nat -> nat,
  (forall n m : nat, n < m /\ f n m = m \/ m <= n /\ f n m = n) ->
  forall n m : nat, f n m = PeanoNat.Nat.max n m
PeanoNat.Nat.left_induction':
  forall A : nat -> Prop,
  Morphisms.Proper (Morphisms.respectful eq iff) A ->
  forall z : nat,
  (forall n : nat, z <= n -> A n) ->
  (forall n : nat, n < z -> A (S n) -> A n) -> forall n : nat, A n
String.index_correct2:
  forall (n m : nat) (s1 s2 : String.string),
  String.index n s1 s2 = Some m ->
  forall p : nat,
  n <= p -> p < m -> String.substring p (String.length s1) s2 <> s1
PeanoNat.Nat.log2_unique':
  forall a b c : nat,
  0 <= b ->
  0 <= c < PeanoNat.Nat.pow 2 b ->
  a = PeanoNat.Nat.pow 2 b + c -> PeanoNat.Nat.log2 a = b
PeanoNat.Nat.strong_right_induction:
  forall A : nat -> Prop,
  Morphisms.Proper (Morphisms.respectful eq iff) A ->
  forall z : nat,
  (forall n : nat,
   z <= n ->
   (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n -> A n) ->
  forall n : nat, z <= n -> A n
PeanoNat.Nat.log2_spec_alt:
  forall a : nat,
  0 < a ->
  exists r : nat,
    a = PeanoNat.Nat.pow 2 (PeanoNat.Nat.log2 a) + r /\
    0 <= r < PeanoNat.Nat.pow 2 (PeanoNat.Nat.log2 a)
PeanoNat.Nat.order_induction:
  forall A : nat -> Prop,
  Morphisms.Proper (Morphisms.respectful eq iff) A ->
  forall z : nat,
  A z ->
  (forall n : nat, z <= n -> A n -> A (S n)) ->
  (forall n : nat, n < z -> A (S n) -> A n) -> forall n : nat, A n
PeanoNat.Nat.strong_right_induction':
  forall A : nat -> Prop,
  Morphisms.Proper (Morphisms.respectful eq iff) A ->
  forall z : nat,
  (forall n : nat, n <= z -> A n) ->
  (forall n : nat,
   z <= n ->
   (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n -> A n) ->
  forall n : nat, A n
PeanoNat.Nat.order_induction_0:
  forall A : nat -> Prop,
  Morphisms.Proper (Morphisms.respectful eq iff) A ->
  A 0 ->
  (forall n : nat, 0 <= n -> A n -> A (S n)) ->
  (forall n : nat, n < 0 -> A (S n) -> A n) -> forall n : nat, A n
List.nth_nth_nth_map:
  forall [A : Type] (l : list A) [n : nat] (d : A) (ln : list nat) [dn : nat],
  n < length ln \/ length l <= dn ->
  List.nth (List.nth n ln dn) l d =
  List.nth n (List.map (fun x : nat => List.nth x l d) ln) d
PeanoNat.Nat.rs_rs':
  forall A : nat -> Prop,
  Morphisms.Proper (Morphisms.respectful eq iff) A ->
  forall z : nat,
  A z ->
  (forall n : nat, z <= n -> A n -> A (S n)) ->
  forall n : nat,
  z <= n ->
  (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n -> A n
PeanoNat.Nat.ls_ls':
  forall A : nat -> Prop,
  Morphisms.Proper (Morphisms.respectful eq iff) A ->
  forall z : nat,
  A z ->
  (forall n : nat, n < z -> A (S n) -> A n) ->
  forall n : nat,
  n <= z ->
  (fun n0 : nat => forall m : nat, m <= z -> n0 <= m -> A m) (S n) -> A n
PeanoNat.Nat.sqrt_iter_spec:
  forall k p q r : nat,
  q = p + p ->
  r <= q ->
  let s := PeanoNat.Nat.sqrt_iter k p q r in
  s * s <= k + p * p + (q - r) < S s * S s
PeanoNat.Nat.testbit_spec:
  forall a n : nat,
  exists l h : nat,
    0 <= l < PeanoNat.Nat.pow 2 n /\
    a =
    l +
    (PeanoNat.Nat.b2n (PeanoNat.Nat.testbit a n) + 2 * h) *
    PeanoNat.Nat.pow 2 n
PeanoNat.Nat.log2_iter_spec:
  forall k p q r : nat,
  PeanoNat.Nat.pow 2 (S p) = q + S r ->
  r < PeanoNat.Nat.pow 2 p ->
  let s := PeanoNat.Nat.log2_iter k p q r in
  PeanoNat.Nat.pow 2 s <= k + q < PeanoNat.Nat.pow 2 (S s)
PeanoNat.Nat.rs'_rs'':
  forall A : nat -> Prop,
  Morphisms.Proper (Morphisms.respectful eq iff) A ->
  forall z : nat,
  (forall n : nat,
   z <= n ->
   (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n -> A n) ->
  forall n : nat,
  (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) n <->
  (fun n0 : nat => forall m : nat, z <= m -> m < n0 -> A m) (S n)
(* info auto: *)
simple apply lt_2 (in T2).
 simple apply lt_6 (in T2).
  unfold Peano.lt (in core).
   simple apply le_n (in core).
 simple apply lt_1 (in T2).
(* info auto: *)
simple apply lt_4 (in T2).
 simple apply lt_1 (in T2).
 simple apply lt_2 (in T2).
  simple apply lt_6 (in T2).
   unfold Peano.lt (in core).
    simple apply le_n (in core).
  simple apply lt_1 (in T2).
(* info auto: *)
simple apply lt_4 (in T2).
 simple apply lt_1 (in T2).
 simple apply lt_2 (in T2).
  simple apply lt_6 (in T2).
   unfold Peano.lt (in core).
    simple apply le_n (in core).
  simple apply lt_1 (in T2).
Chars 4571 - 4590 [(split;~try~apply~_).] 40.289 secs (0.095u,0.057s)
Chars 4593 - 4594 [-] 0. secs (0.u,0.s)
Chars 4595 - 4619 [(apply~strict_po_mere_lt).] 0.001 secs (0.001u,0.s)
Chars 4622 - 4623 [-] 0. secs (0.u,0.s)
Chars 4624 - 4633 [(intros~x).] 0. secs (0.u,0.s)
Chars 4634 - 4638 [(red).] 0. secs (0.u,0.s)
Chars 4639 - 4675 [(intros~E;~apply~lt_iff_le_apa...] 0.002 secs (0.001u,0.s)
Chars 4680 - 4700 [(destruct~E~as~[_~?]).] 0.001 secs (0.001u,0.s)
Chars 4705 - 4735 [(apply~(irreflexivity~(≶)~x)).] 0.003 secs (0.003u,0.s)
Chars 4740 - 4751 [assumption.] 0. secs (0.u,0.s)
Chars 4571 - 4590 [(split;~try~apply~_).] 0. secs (0.u,0.s)
Chars 4595 - 4619 [(apply~strict_po_mere_lt).] 0. secs (0.u,0.s)
Chars 4624 - 4633 [(intros~x).] 0. secs (0.u,0.s)
Chars 4634 - 4638 [(red).] 0. secs (0.u,0.s)
Chars 4639 - 4675 [(intros~E;~apply~lt_iff_le_apa...] 0. secs (0.u,0.s)
Chars 4680 - 4700 [(destruct~E~as~[_~?]).] 0. secs (0.u,0.s)
Chars 4705 - 4735 [(apply~(irreflexivity~(≶)~x)).] 0. secs (0.u,0.s)
Chars 4740 - 4751 [assumption.] 0. secs (0.u,0.s)
Chars 4754 - 4758 [Qed.] 0.001 secs (0.u,0.s)
Chars 4762 - 4821 [Lemma~lt_le~x~y~:~PropHolds~(x...] 0.001 secs (0.001u,0.s)
Chars 4824 - 4830 [Proof.] 0. secs (0.u,0.s)
(* info auto: *)
idtac.
(* info auto: *)
idtac.
Chars 4833 - 4839 [intro.] 40.172 secs (0.u,0.032s)
Chars 4842 - 4864 [(apply~lt_iff_le_apart).] 0.003 secs (0.002u,0.s)
Chars 4867 - 4878 [assumption.] 0. secs (0.u,0.s)
Chars 4833 - 4839 [intro.] 0. secs (0.u,0.s)
Chars 4842 - 4864 [(apply~lt_iff_le_apart).] 0. secs (0.u,0.s)
Chars 4867 - 4878 [assumption.] 0. secs (0.u,0.s)
Chars 4881 - 4885 [Qed.] 0. secs (0.u,0.s)
Chars 4889 - 4938 [Lemma~not_le_not_lt~x~y~:~~~(x...] 0.001 secs (0.001u,0.s)
Chars 4941 - 4947 [Proof.] 0. secs (0.u,0.s)
Chars 4950 - 4963 [(intros~E1~E2).] 5.174 secs (0.u,0.034s)
Chars 4966 - 4975 [(apply~E1).] 0. secs (0.u,0.s)
Chars 4976 - 4988 [(apply~lt_le).] 0. secs (0.u,0.s)
Chars 4989 - 5000 [assumption.] 0. secs (0.u,0.s)
Chars 4950 - 4963 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 4966 - 4975 [(apply~E1).] 0. secs (0.u,0.s)
Chars 4976 - 4988 [(apply~lt_le).] 0. secs (0.u,0.s)
Chars 4989 - 5000 [assumption.] 0. secs (0.u,0.s)
Chars 5003 - 5007 [Qed.] 0. secs (0.u,0.s)
Chars 5011 - 5049 [Lemma~lt_apart~x~y~:~x~<~y~->~...] 0.001 secs (0.001u,0.s)
Chars 5052 - 5058 [Proof.] 0. secs (0.u,0.s)
Chars 5061 - 5067 [intro.] 0.115 secs (0.u,0.033s)
Chars 5070 - 5092 [(apply~lt_iff_le_apart).] 0.005 secs (0.004u,0.001s)
Chars 5095 - 5106 [assumption.] 0. secs (0.u,0.s)
Chars 5061 - 5067 [intro.] 0. secs (0.u,0.s)
Chars 5070 - 5092 [(apply~lt_iff_le_apart).] 0. secs (0.u,0.s)
Chars 5095 - 5106 [assumption.] 0. secs (0.u,0.s)
Chars 5109 - 5113 [Qed.] 0. secs (0.u,0.s)
Chars 5117 - 5160 [Lemma~lt_apart_flip~x~y~:~x~<~...] 0.001 secs (0.001u,0.s)
Chars 5163 - 5169 [Proof.] 0. secs (0.u,0.s)
     = 48
     : nat
Finished transaction in 40.638 secs (0.159u,0.115s) (successful)
Chars 5172 - 5178 [intro.] 40.167 secs (0.u,0.032s)
Chars 5181 - 5213 [(apply~symmetry,~lt_iff_le_apa...] 0.007 secs (0.007u,0.s)
Chars 5216 - 5227 [assumption.] 0. secs (0.u,0.s)
Chars 5172 - 5178 [intro.] 0. secs (0.u,0.s)
Chars 5181 - 5213 [(apply~symmetry,~lt_iff_le_apa...] 0. secs (0.u,0.s)
Chars 5216 - 5227 [assumption.] 0. secs (0.u,0.s)
Chars 5230 - 5234 [Qed.] 0. secs (0.u,0.s)
Chars 5238 - 5285 [Lemma~le_not_lt_flip~x~y~:~y~≤...] 0.001 secs (0.001u,0.s)
Chars 5288 - 5294 [Proof.] 0. secs (0.u,0.s)
'C[[::]]
     : nat
'C[[:: 8]]
     : nat
Finished transaction in 0. secs (0.u,0.s) (successful)
Chars 5297 - 5338 [(intros~E1~E2;~apply~lt_iff_le...] 40.166 secs (0.001u,0.035s)
Chars 5341 - 5366 [(destruct~E2~as~[E2a~E2b]).] 0.001 secs (0.001u,0.s)
Chars 5369 - 5380 [revert~E2b.] 0. secs (0.u,0.s)
Chars 5381 - 5399 [(apply~tight_apart).] 0.003 secs (0.003u,0.s)
Chars 5402 - 5440 [(apply~(antisymmetry~(≤));~ass...] 0.006 secs (0.004u,0.001s)
Chars 5297 - 5338 [(intros~E1~E2;~apply~lt_iff_le...] 0. secs (0.u,0.s)
Chars 5341 - 5366 [(destruct~E2~as~[E2a~E2b]).] 0. secs (0.u,0.s)
Chars 5369 - 5380 [revert~E2b.] 0. secs (0.u,0.s)
Chars 5381 - 5399 [(apply~tight_apart).] 0. secs (0.u,0.s)
Chars 5402 - 5440 [(apply~(antisymmetry~(≤));~ass...] 0. secs (0.u,0.s)
Chars 5443 - 5447 [Qed.] 0. secs (0.u,0.s)
Chars 5451 - 5498 [Lemma~lt_not_le_flip~x~y~:~y~<...] 0.001 secs (0.001u,0.s)
Chars 5501 - 5507 [Proof.] 0. secs (0.u,0.s)
     = fun (A : Type) (x : Fkont A) (x0 : A) =>
       x1 <--- x0 times x0;
       x2 <--- x1 times x0;
       x3 <--- x2 times x2;
       x4 <--- x3 times x2;
       x5 <--- x4 times x4;
       x6 <--- x5 times x5; x7 <--- x6 times x6; x8 <--- x7 times x7; x x8
     : Fchain
Constant Coq.NArith.BinNat.N.succ_lt_mono
  (shorter name to refer to it in current context is BinNat.N.succ_lt_mono)
Constant Coq.Arith.PeanoNat.Nat.succ_lt_mono
  (shorter name to refer to it in current context is PeanoNat.Nat.succ_lt_mono)
Constant Coq.PArith.BinPos.Pos.succ_lt_mono
  (shorter name to refer to it in current context is BinPos.Pos.succ_lt_mono)
Constant Coq.ZArith.BinInt.Z.succ_lt_mono
  (shorter name to refer to it in current context is BinInt.Z.succ_lt_mono)
Crunching: (forall θ : R, rotation θ (3 * PI / 2) (PI / 2) = x_rotation θ)
Crunching: (forall θ : R, rotation θ (3 * PI / 2) (PI / 2) = x_rotation θ)
Crunching: (forall θ : R, rotation θ (3 * PI / 2) (PI / 2) = x_rotation θ)
     = ("hello_world",
       (["y"], ["out"], bedrock_func_body:(
         $"x" = $1;
         $"putchars"($104, $101, $108, $108, $111, $44, $32, $119, $111,
                    $114, $108, $100, $33);
         $"out" = $1 + $"y")))
     : bedrock_func
     = "uintptr_t hello_world(uintptr_t y) {
  uintptr_t x, out;
  x = (uintptr_t)1ULL;
  putchars((uintptr_t)104ULL, (uintptr_t)101ULL, (uintptr_t)108ULL, (uintptr_t)108ULL, (uintptr_t)111ULL, (uintptr_t)44ULL, (uintptr_t)32ULL, (uintptr_t)119ULL, (uintptr_t)111ULL, (uintptr_t)114ULL, (uintptr_t)108ULL, (uintptr_t)100ULL, (uintptr_t)33ULL);
  out = ((uintptr_t)1ULL)+(y);
  return out;
}
"
     : string
Crunching: (forall θ : R, rotation θ (3 * PI / 2) (PI / 2) = x_rotation θ)
Crunching: (forall θ : R, rotation θ (3 * PI / 2) (PI / 2) = x_rotation θ)
     = ("fnv1a",
       (["data"; "len"], ["hash"], bedrock_func_body:(
         $"p" = $16777619;
         $"hash" = $2166136261;
         $"from" = $0;
         $"_gs_from0" = $0;
         $"_gs_to0" = $"len";
         while $"_gs_from0" < $"_gs_to0" {
           {$"b" = load1($"data" + $1 * $"_gs_from0");
            $"hash" = ($"hash" ^ $"b") * $16777619;
            $(cmd.unset "b")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
     = ("fnv1a",
       (["data"; "len"], ["hash"], bedrock_func_body:(
         $"p" = $1099511628211;
         $"hash" = $14695981039346656037;
         $"from" = $0;
         $"_gs_from0" = $0;
         $"_gs_to0" = $"len";
         while $"_gs_from0" < $"_gs_to0" {
           {$"b" = load1($"data" + $1 * $"_gs_from0");
            $"hash" = ($"hash" ^ $"b") * $1099511628211;
            $(cmd.unset "b")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
Crunching: (forall θ : R, rotation θ (3 * PI / 2) (PI / 2) = x_rotation θ)
Chars 5510 - 5523 [(intros~E1~E2).] 40.172 secs (0.u,0.033s)
Chars 5526 - 5564 [(apply~(le_not_lt_flip~y~x);~a...] 0.001 secs (0.001u,0.s)
Chars 5510 - 5523 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 5526 - 5564 [(apply~(le_not_lt_flip~y~x);~a...] 0. secs (0.u,0.s)
Chars 5567 - 5571 [Qed.] 0. secs (0.u,0.s)
Chars 5575 - 5627 [Lemma~lt_le_trans~x~y~z~:~x~<~...] 0.001 secs (0.001u,0.s)
Chars 5630 - 5636 [Proof.] 0. secs (0.u,0.s)
     = (ω ^ (ω ^ ω ^ 2 + 1) + 2)%pT1
     : ppT1
     = fun (A : Type) (x : Fkont A) (x0 : A) =>
       x1 <--- x0 times x0;
       x2 <--- x1 times x0;
       x3 <--- x0 times x0;
       x4 <--- x3 times x3;
       x5 <--- x4 times x4;
       x6 <--- x5 times x5;
       x7 <--- x0 times x0;
       x8 <--- x7 times x7; x9 <--- x8 times x6; x10 <--- x9 times x2; x x10
     : Fchain
EMonoid : forall [A : Type], Mult_op A -> A -> Equiv A -> Prop

EMonoid is not universe polymorphic
Arguments EMonoid [A]%type_scope E_op E_one E_eq
Expands to: Inductive additions.Monoid_def.EMonoid
Finished transaction in 0.025 secs (0.022u,0.002s) (successful)
Finished transaction in 0.001 secs (0.001u,0.s) (successful)
Chars 5639 - 5652 [(intros~E1~E2).] 40.165 secs (0.u,0.033s)
Chars 5655 - 5677 [(apply~lt_iff_le_apart).] 0.008 secs (0.007u,0.s)
Chars 5678 - 5706 [(apply~lt_iff_le_apart~in~E1).] 0.002 secs (0.002u,0.s)
Chars 5709 - 5734 [(destruct~E1~as~[E1a~E1b]).] 0.001 secs (0.001u,0.s)
Chars 5737 - 5743 [split.] 0. secs (0.u,0.s)
Chars 5746 - 5747 [-] 0. secs (0.u,0.s)
Chars 5748 - 5774 [(transitivity~y;~assumption).] 0.013 secs (0.011u,0.001s)
Chars 5777 - 5778 [-] 0. secs (0.u,0.s)
Chars 5779 - 5850 [(apply~(merely_destruct~(cotra...] 0.012 secs (0.01u,0.002s)
Chars 5855 - 5870 [(apply~lt_apart).] 0. secs (0.u,0.s)
Chars 5871 - 5892 [(apply~symmetry~in~E3).] 0.003 secs (0.003u,0.s)
Chars 5897 - 5940 [(transitivity~y;~apply~lt_iff_...] 0.023 secs (0.017u,0.005s)
Chars 5639 - 5652 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 5655 - 5677 [(apply~lt_iff_le_apart).] 0. secs (0.u,0.s)
Chars 5678 - 5706 [(apply~lt_iff_le_apart~in~E1).] 0. secs (0.u,0.s)
Chars 5709 - 5734 [(destruct~E1~as~[E1a~E1b]).] 0. secs (0.u,0.s)
Chars 5737 - 5743 [split.] 0. secs (0.u,0.s)
Chars 5748 - 5774 [(transitivity~y;~assumption).] 0. secs (0.u,0.s)
Chars 5779 - 5850 [(apply~(merely_destruct~(cotra...] 0.001 secs (0.001u,0.s)
Chars 5855 - 5870 [(apply~lt_apart).] 0. secs (0.u,0.s)
Chars 5871 - 5892 [(apply~symmetry~in~E3).] 0. secs (0.u,0.s)
Chars 5897 - 5940 [(transitivity~y;~apply~lt_iff_...] 0.001 secs (0.001u,0.s)
Chars 5943 - 5947 [Qed.] 0.002 secs (0.001u,0.s)
Chars 5951 - 6003 [Lemma~le_lt_trans~x~y~z~:~x~≤~...] 0.001 secs (0.u,0.001s)
Chars 6006 - 6012 [Proof.] 0. secs (0.u,0.s)
Chars 6015 - 6028 [(intros~E2~E1).] 40.174 secs (0.u,0.034s)
Chars 6031 - 6053 [(apply~lt_iff_le_apart).] 0.055 secs (0.045u,0.009s)
Chars 6054 - 6082 [(apply~lt_iff_le_apart~in~E1).] 0.002 secs (0.002u,0.s)
Chars 6085 - 6110 [(destruct~E1~as~[E1a~E1b]).] 0.001 secs (0.001u,0.s)
Chars 6113 - 6119 [split.] 0. secs (0.u,0.s)
Chars 6122 - 6123 [-] 0. secs (0.u,0.s)
Chars 6124 - 6144 [(transitivity~y;~auto).] 0.013 secs (0.01u,0.002s)
Chars 6147 - 6148 [-] 0. secs (0.u,0.s)
Chars 6149 - 6220 [(apply~(merely_destruct~(cotra...] 0.012 secs (0.009u,0.002s)
Chars 6225 - 6240 [(apply~lt_apart).] 0. secs (0.u,0.s)
Chars 6241 - 6262 [(apply~symmetry~in~E3).] 0.003 secs (0.002u,0.s)
Chars 6267 - 6311 [(transitivity~y;~apply~lt_iff_...] 0.021 secs (0.014u,0.006s)
Chars 6015 - 6028 [(intros~E2~E1).] 0. secs (0.u,0.s)
Chars 6031 - 6053 [(apply~lt_iff_le_apart).] 0. secs (0.u,0.s)
Chars 6054 - 6082 [(apply~lt_iff_le_apart~in~E1).] 0. secs (0.u,0.s)
Chars 6085 - 6110 [(destruct~E1~as~[E1a~E1b]).] 0. secs (0.u,0.s)
Chars 6113 - 6119 [split.] 0. secs (0.u,0.s)
Chars 6124 - 6144 [(transitivity~y;~auto).] 0. secs (0.u,0.s)
Chars 6149 - 6220 [(apply~(merely_destruct~(cotra...] 0.001 secs (0.001u,0.s)
Chars 6225 - 6240 [(apply~lt_apart).] 0. secs (0.u,0.s)
Chars 6241 - 6262 [(apply~symmetry~in~E3).] 0. secs (0.u,0.s)
Chars 6267 - 6311 [(transitivity~y;~apply~lt_iff_...] 0.001 secs (0.001u,0.s)
Chars 6314 - 6318 [Qed.] 0.002 secs (0.002u,0.s)
Chars 6322 - 6394 [Lemma~lt_iff_le_ne~`{!TrivialA...] 0.002 secs (0.002u,0.s)
Chars 6397 - 6403 [Proof.] 0. secs (0.u,0.s)
Debug:
In environment
c, u : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
u_ann : u.Ann u
u_Sn2 := u.Sn2_ u_ann : u.Sn2 u
u_SnSk := u.SnSk_ u_ann : u.SnSk u
u_Sk2 := u.Sk2_ u_ann : u.Sk2 u
v := fun n k : int => c n k * u n k : int -> int -> rat_Ring
AGREE, l : int
d : precond.Sn2 AGREE l
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: v (int.shift 2 AGREE) l; Sn2_cf0_0 AGREE l; 
        v AGREE l; Sn2_cf1_0 AGREE l; v (int.shift 1 AGREE) l;
         Sn2_cf0_1 AGREE l; v AGREE (int.shift 1 l)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
c, u : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
u_ann : u.Ann u
u_Sn2 := u.Sn2_ u_ann : u.Sn2 u
u_SnSk := u.SnSk_ u_ann : u.SnSk u
u_Sk2 := u.Sk2_ u_ann : u.Sk2 u
v := fun n k : int => c n k * u n k : int -> int -> rat_Ring
AGREE, l : int
d : precond.Sn2 AGREE l
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: v (int.shift 2 AGREE) l; Sn2_cf0_0 AGREE l; 
        v AGREE l; Sn2_cf1_0 AGREE l; v (int.shift 1 AGREE) l;
         Sn2_cf0_1 AGREE l; v AGREE (int.shift 1 l)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Chars 6407 - 6442 [transitivity~(x~<=~y~/\~apart~...] 40.161 secs (0.008u,0.034s)
Chars 6446 - 6447 [-] 0. secs (0.u,0.s)
Chars 6448 - 6470 [(apply~lt_iff_le_apart).] 0.001 secs (0.001u,0.s)
Chars 6474 - 6475 [-] 0. secs (0.u,0.s)
Chars 6476 - 6539 [(split;~intros~[E1~E2];~split;...] 0.011 secs (0.01u,0.s)
Chars 6407 - 6442 [transitivity~(x~<=~y~/\~apart~...] 0. secs (0.u,0.s)
Chars 6448 - 6470 [(apply~lt_iff_le_apart).] 0. secs (0.u,0.s)
Chars 6476 - 6539 [(split;~intros~[E1~E2];~split;...] 0.004 secs (0.004u,0.s)
Chars 6542 - 6546 [Qed.] 0.001 secs (0.001u,0.s)
Chars 6550 - 6661 [Lemma~le_equiv_lt~`{!TrivialAp...] 0.002 secs (0.002u,0.s)
Chars 6664 - 6670 [Proof.] 0. secs (0.u,0.s)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
c, u : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
u_ann : u.Ann u
u_Sn2 := u.Sn2_ u_ann : u.Sn2 u
u_SnSk := u.SnSk_ u_ann : u.SnSk u
u_Sk2 := u.Sk2_ u_ann : u.Sk2 u
v := fun n k : int => c n k * u n k : int -> int -> rat_Ring
n, k : int
_Hyp_ : precond.Sn2 n k
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v (int.shift 2 n) k; Sn2_cf0_0 n k; v n k; 
        Sn2_cf1_0 n k; v (int.shift 1 n) k; Sn2_cf0_1 n k;
         v n (int.shift 1 k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
c, u : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
u_ann : u.Ann u
u_Sn2 := u.Sn2_ u_ann : u.Sn2 u
u_SnSk := u.SnSk_ u_ann : u.SnSk u
u_Sk2 := u.Sk2_ u_ann : u.Sk2 u
v := fun n k : int => c n k * u n k : int -> int -> rat
n, k : int
_Hyp_ : precond.Sn2 n k
u3 := u (int.shift 2 n) k : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c (int.shift 2 n) k; u3; Sn2_cf0_0 n k; c n k; 
        u n k; Sn2_cf1_0 n k; c (int.shift 1 n) k; 
        u (int.shift 1 n) k; Sn2_cf0_1 n k; c n (int.shift 1 k);
         u n (int.shift 1 k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: 1%Q; a 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: a 0; 1%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
_n__, ltqp, lr : int
rlr : d.not_D4 _n__ ltqp lr
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d lr) _n__ ltqp;
         d.Q4_flat d _n__ ltqp (int.shift 1 lr); d.Q4_flat d _n__ ltqp lr]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
_n__, ltqp : int
n : nat
_Hyp_ : d.not_D4 _n__ ltqp n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d n) _n__ ltqp;
         d.Q4_flat d _n__ ltqp (int.shift 1 n); d.Q4_flat d _n__ ltqp n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Finished transaction in 0.082 secs (0.07u,0.012s) (successful)
Finished transaction in 0.002 secs (0.002u,0.s) (successful)
Chars 6673 - 6680 [(intros).] 40.163 secs (0.u,0.034s)
Chars 6683 - 6716 [(destruct~(dec~(x~=~y));~try~a...] 0.007 secs (0.004u,0.003s)
Chars 6719 - 6725 [right.] 0. secs (0.u,0.s)
Chars 6728 - 6753 [(apply~lt_iff_le_ne;~auto).] 0.004 secs (0.002u,0.s)
Chars 6673 - 6680 [(intros).] 0. secs (0.u,0.s)
Chars 6683 - 6716 [(destruct~(dec~(x~=~y));~try~a...] 0.001 secs (0.001u,0.s)
Chars 6719 - 6725 [right.] 0. secs (0.u,0.s)
Chars 6728 - 6753 [(apply~lt_iff_le_ne;~auto).] 0. secs (0.u,0.s)
Chars 6756 - 6760 [Qed.] 0.001 secs (0.001u,0.s)
Chars 6764 - 6866 [Instance~dec_from_lt_dec~~`{!T...] 0.001 secs (0.u,0.001s)
Chars 6869 - 6875 [Proof.] 0. secs (0.u,0.s)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × phase_shift (PI / 2))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 list2D_to_matrix
   [[C1 / √ 2; C1 / √ 2 * Cexp (PI / 2)];
   [C1 / √ 2; - (C1 / √ 2) * Cexp (PI / 2)]] × hadamard)
Crunching:
(sqrtx =
 list2D_to_matrix
   [[C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * Cexp (PI / 2) * (C1 / √ 2);
    C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * Cexp (PI / 2) * - (C1 / √ 2)];
   [C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * Cexp (PI / 2) * (C1 / √ 2);
   C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * Cexp (PI / 2) * - (C1 / √ 2)]])
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
_n__, _k__ : int
H : nat
_Hyp_ : d.not_D4 _n__ _k__ H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d H) _n__ _k__;
         d.Q4_flat d _n__ _k__ (int.shift 1 H); d.Q4_flat d _n__ _k__ H]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
_n__, _k__ : int
H : nat
_Hyp_ : d.not_D4 _n__ _k__ H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d 0) _n__ _k__;
         d.Q4_flat d _n__ _k__ (int.shift 1 0); d.Q4_flat d _n__ _k__ 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
_n__, _k__ : int
H : nat
_Hyp_ : d.not_D4 _n__ _k__ H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d H) _n__ _k__;
         d.Q4_flat d _n__ _k__ (int.shift 1 H); d.Q4_flat d _n__ _k__ H]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
_n__, ltqp, lr : int
rlr : d.not_D4 _n__ ltqp lr
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d lr) _n__ ltqp;
         d.Q4_flat d _n__ ltqp (int.shift 1 lr); d.Q4_flat d _n__ ltqp lr]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
_n__, ltqp : int
n : nat
_Hyp_ : d.not_D4 _n__ ltqp n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d n) _n__ ltqp;
         d.Q4_flat d _n__ ltqp (int.shift 1 n); d.Q4_flat d _n__ ltqp n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
_n__, ltqp : int
n : nat
H : d.not_D4 _n__ ltqp n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d n) _n__ ltqp;
         d.Q4_flat d _n__ ltqp (int.shift 1 n); d.Q4_flat d _n__ ltqp n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
_n__, ltqp : int
n : nat
x : d.not_D4 _n__ ltqp n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d n) _n__ ltqp;
         d.Q4_flat d _n__ ltqp (int.shift 1 n); d.Q4_flat d _n__ ltqp n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
_n__, ltqp, lr : int
rlr : d.not_D4 _n__ ltqp lr
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d lr) _n__ ltqp;
         d.Q4_flat d _n__ ltqp (int.shift 1 lr); d.Q4_flat d _n__ ltqp lr]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
_n__, ltqp : int
n : nat
_Hyp_ : d.not_D4 _n__ ltqp n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d n) _n__ ltqp;
         d.Q4_flat d _n__ ltqp (int.shift 1 n); d.Q4_flat d _n__ ltqp n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Chars 6878 - 6889 [(intros~x~y).] 40.183 secs (0.u,0.034s)
Chars 6892 - 6982 [(destruct~(decide_rel~(<=)~x~y...] 0.007 secs (0.006u,0.s)
Chars 6985 - 6986 [-] 0. secs (0.u,0.s)
Chars 6987 - 6992 [left.] 0. secs (0.u,0.s)
Chars 6993 - 7030 [(apply~(antisymmetry~(<=));~as...] 0.007 secs (0.006u,0.s)
Chars 7033 - 7034 [-] 0. secs (0.u,0.s)
Chars 7035 - 7041 [right.] 0. secs (0.u,0.s)
Chars 7042 - 7061 [(intros~E3;~apply~E2).] 0.001 secs (0.001u,0.s)
Chars 7066 - 7076 [(pattern~y).] 0. secs (0.u,0.s)
Chars 7077 - 7100 [(apply~(transport~_~E3)).] 0.001 secs (0.001u,0.s)
Chars 7105 - 7123 [(apply~reflexivity).] 0.007 secs (0.005u,0.001s)
Chars 7126 - 7127 [-] 0. secs (0.u,0.s)
Chars 7128 - 7134 [right.] 0. secs (0.u,0.s)
Chars 7135 - 7154 [(intros~E3;~apply~E1).] 0.001 secs (0.u,0.s)
Chars 7159 - 7193 [(pattern~y;~apply~(transport~_...] 0.001 secs (0.001u,0.s)
Chars 7198 - 7216 [(apply~reflexivity).] 0.007 secs (0.005u,0.001s)
Chars 6878 - 6889 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 6892 - 6982 [(destruct~(decide_rel~(<=)~x~y...] 0. secs (0.u,0.s)
Chars 6987 - 6992 [left.] 0. secs (0.u,0.s)
Chars 6993 - 7030 [(apply~(antisymmetry~(<=));~as...] 0. secs (0.u,0.s)
Chars 7035 - 7041 [right.] 0. secs (0.u,0.s)
Chars 7042 - 7061 [(intros~E3;~apply~E2).] 0. secs (0.u,0.s)
Chars 7066 - 7076 [(pattern~y).] 0. secs (0.u,0.s)
Chars 7077 - 7100 [(apply~(transport~_~E3)).] 0. secs (0.u,0.s)
Chars 7105 - 7123 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 7128 - 7134 [right.] 0. secs (0.u,0.s)
Chars 7135 - 7154 [(intros~E3;~apply~E1).] 0. secs (0.u,0.s)
Chars 7159 - 7193 [(pattern~y;~apply~(transport~_...] 0. secs (0.u,0.s)
Chars 7198 - 7216 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 7219 - 7227 [Defined.] 0.001 secs (0.001u,0.s)
Chars 7231 - 7344 [Definition~lt_dec_slow~`{!Triv...] 0.002 secs (0.002u,0.s)
Chars 7347 - 7353 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 0.106 secs (0.087u,0.018s) (successful)
Finished transaction in 0.004 secs (0.004u,0.s) (successful)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: ((fun n : nat => (⟨0∣ × ∣1⟩) n y = Zero x y) x)
Crunching: (fst ((⟨0∣ × ∣1⟩) x y) = fst (Zero x y))
Chars 7356 - 7367 [(intros~x~y).] 40.168 secs (0.u,0.033s)
Chars 7370 - 7424 [(destruct~(dec~(x~≤~y));~[~des...] 0.043 secs (0.038u,0.005s)
Chars 7427 - 7428 [-] 0. secs (0.u,0.s)
Chars 7429 - 7435 [right.] 0. secs (0.u,0.s)
Chars 7436 - 7452 [(apply~eq_not_lt).] 0.001 secs (0.001u,0.s)
Chars 7453 - 7464 [assumption.] 0. secs (0.u,0.s)
Chars 7467 - 7468 [-] 0. secs (0.u,0.s)
Chars 7469 - 7474 [left.] 0. secs (0.u,0.s)
Chars 7475 - 7494 [(apply~lt_iff_le_ne).] 0.022 secs (0.014u,0.007s)
Chars 7495 - 7500 [auto.] 0.001 secs (0.001u,0.s)
Chars 7503 - 7504 [-] 0. secs (0.u,0.s)
Chars 7505 - 7511 [right.] 0. secs (0.u,0.s)
Chars 7512 - 7532 [(apply~not_le_not_lt).] 0. secs (0.u,0.s)
Chars 7533 - 7544 [assumption.] 0. secs (0.u,0.s)
Chars 7356 - 7367 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 7370 - 7424 [(destruct~(dec~(x~≤~y));~[~des...] 0. secs (0.u,0.s)
Chars 7429 - 7435 [right.] 0. secs (0.u,0.s)
Chars 7436 - 7452 [(apply~eq_not_lt).] 0. secs (0.u,0.s)
Chars 7453 - 7464 [assumption.] 0. secs (0.u,0.s)
Chars 7469 - 7474 [left.] 0. secs (0.u,0.s)
Chars 7475 - 7494 [(apply~lt_iff_le_ne).] 0. secs (0.u,0.s)
Chars 7495 - 7500 [auto.] 0. secs (0.u,0.s)
Chars 7505 - 7511 [right.] 0. secs (0.u,0.s)
Chars 7512 - 7532 [(apply~not_le_not_lt).] 0. secs (0.u,0.s)
Chars 7533 - 7544 [assumption.] 0. secs (0.u,0.s)
Chars 7547 - 7555 [Defined.] 0.001 secs (0.001u,0.s)
Chars 7556 - 7579 [End~full_partial_order.] 0.053 secs (0.048u,0.005s)
Chars 7604 - 7704 [#[export]~Hint~Extern~5~(PropH...] 0. secs (0.u,0.s)
Chars 7705 - 7793 [#[export]~Hint~Extern~10~(Prop...] 0. secs (0.u,0.s)
Chars 7794 - 7886 [#[export]~Hint~Extern~20~(Deci...] 0. secs (0.u,0.s)
Chars 7888 - 7914 [Section~full_pseudo_order.] 0. secs (0.u,0.s)
Chars 7917 - 7946 [Context~`{FullPseudoOrder~A}.] 0.001 secs (0.001u,0.s)
Chars 7950 - 7993 [#[local]Existing~Instance~pseu...] 0. secs (0.u,0.s)
Chars 7997 - 8044 [Lemma~not_lt_le_flip~x~y~:~~~(...] 0.001 secs (0.001u,0.s)
Chars 8047 - 8053 [Proof.] 0. secs (0.u,0.s)
Crunching: (fst ((⟨0∣ × ∣1⟩) x 0%nat) = fst (Zero x 0%nat))
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[0]] = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[0]] = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[0]] = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = ∣0⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = ∣0⟩)
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (nat -> ⟨1∣ × σx = ⟨0∣)
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Finished transaction in 6.656 secs (6.588u,0.043s) (successful)
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Chars 8056 - 8063 [(intros).] 40.164 secs (0.001u,0.033s)
Chars 8066 - 8091 [(apply~le_iff_not_lt_flip).] 0.002 secs (0.002u,0.s)
Chars 8094 - 8105 [assumption.] 0. secs (0.u,0.s)
Chars 8056 - 8063 [(intros).] 0. secs (0.u,0.s)
Chars 8066 - 8091 [(apply~le_iff_not_lt_flip).] 0. secs (0.u,0.s)
Chars 8094 - 8105 [assumption.] 0. secs (0.u,0.s)
Chars 8108 - 8112 [Qed.] 0. secs (0.u,0.s)
Chars 8116 - 8170 [Instance~fullpseudo_partial~:~...] 0. secs (0.u,0.s)
Chars 8173 - 8179 [Proof.] 0. secs (0.u,0.s)
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (nat -> ⟨1∣ × σx = ⟨0∣)
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (list2D_to_matrix [[e; e0]] = ⟨1∣ × psi3)
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (list2D_to_matrix [[psi3 1%nat 0%nat; psi3 1%nat 1%nat]] = (H3) †)
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (0 = psi3 1%nat 2%nat)
Crunching: (0 = psi3 1%nat (S (S (S y))))
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (list2D_to_matrix [[e; e0]] = ⟨1∣ × σx)
Crunching: (list2D_to_matrix [[C1; 0]] = ⟨0∣)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣0⟩)
Crunching: (list2D_to_matrix [[0]; [C1]] = ∣1⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣0⟩)
Crunching: (list2D_to_matrix [[0]; [C1]] = ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[0; C1]] = ⟨1∣)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[0; C1]] = ⟨1∣)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σy × σy)
Crunching: (list2D_to_matrix [[- Ci * Ci; 0]; [0; Ci * - Ci]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σy × σy)
Crunching: (list2D_to_matrix [[- Ci * Ci; 0]; [0; Ci * - Ci]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σz × σz)
Crunching: (list2D_to_matrix [[C1; 0]; [0; - C1 * - C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σz × σz)
Crunching: (list2D_to_matrix [[C1; 0]; [0; - C1 * - C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × hadamard)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * (C1 / √ 2);
    C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * - (C1 / √ 2)];
   [C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * (C1 / √ 2);
   C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * - (C1 / √ 2)]] = 
 I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × hadamard)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * (C1 / √ 2);
    C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * - (C1 / √ 2)];
   [C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * (C1 / √ 2);
   C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * - (C1 / √ 2)]] = 
 I 2)
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P3_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Crunching:
(forall y : nat,
 (Hyp_F_NE >= 2)%nat \/ (y >= 2)%nat -> (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣) Hyp_F_NE y = 0)
Crunching: ((∣0⟩⟨0∣ .+ ∣1⟩⟨1∣) a H = (0 + 0 + (0 + 0))%R)
Chars 8182 - 8195 [(repeat~split).] 40.17 secs (0.001u,0.034s)
Chars 8198 - 8199 [-] 0. secs (0.u,0.s)
Chars 8200 - 8208 [(apply~_).] 0.026 secs (0.021u,0.004s)
Chars 8211 - 8212 [-] 0. secs (0.u,0.s)
Chars 8213 - 8221 [(apply~_).] 0.034 secs (0.027u,0.006s)
Chars 8224 - 8225 [-] 0. secs (0.u,0.s)
Chars 8226 - 8235 [(intros~x).] 0. secs (0.u,0.s)
Chars 8236 - 8278 [(apply~not_lt_le_flip,~(irrefl...] 0.003 secs (0.003u,0.s)
Chars 8281 - 8282 [-] 0. secs (0.u,0.s)
Chars 8283 - 8302 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 8307 - 8404 [(apply~le_iff_not_lt_flip;~app...] 0.006 secs (0.006u,0.s)
Chars 8409 - 8437 [(change~(complement~(<)~z~x)).] 0.001 secs (0.001u,0.s)
Chars 8442 - 8468 [(transitivity~y;~assumption).] 0.016 secs (0.014u,0.001s)
Chars 8471 - 8472 [-] 0. secs (0.u,0.s)
Chars 8473 - 8490 [(intros~x~y~E1~E2).] 0. secs (0.u,0.s)
Chars 8495 - 8562 [(apply~le_iff_not_lt_flip~in~E...] 0.003 secs (0.003u,0.s)
Chars 8567 - 8616 [(apply~(antisymmetry~(compleme...] 0.01 secs (0.008u,0.001s)
Chars 8182 - 8195 [(repeat~split).] 0. secs (0.u,0.s)
Chars 8200 - 8208 [(apply~_).] 0. secs (0.u,0.s)
Chars 8213 - 8221 [(apply~_).] 0. secs (0.u,0.s)
Chars 8226 - 8235 [(intros~x).] 0. secs (0.u,0.s)
Chars 8236 - 8278 [(apply~not_lt_le_flip,~(irrefl...] 0. secs (0.u,0.s)
Chars 8283 - 8302 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 8307 - 8404 [(apply~le_iff_not_lt_flip;~app...] 0.001 secs (0.u,0.s)
Chars 8409 - 8437 [(change~(complement~(<)~z~x)).] 0. secs (0.u,0.s)
Chars 8442 - 8468 [(transitivity~y;~assumption).] 0. secs (0.u,0.s)
Chars 8473 - 8490 [(intros~x~y~E1~E2).] 0. secs (0.u,0.s)
Chars 8495 - 8562 [(apply~le_iff_not_lt_flip~in~E...] 0. secs (0.u,0.s)
Chars 8567 - 8616 [(apply~(antisymmetry~(compleme...] 0. secs (0.u,0.s)
Chars 8619 - 8623 [Qed.] 0.002 secs (0.001u,0.s)
Chars 8627 - 8684 [Lemma~fullpseudo_fullpartial'~...] 0. secs (0.u,0.s)
Chars 8687 - 8693 [Proof.] 0. secs (0.u,0.s)
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Crunching:
(forall y : nat,
 (Hyp_F_NE >= 2)%nat \/ (y >= 2)%nat -> (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣) Hyp_F_NE y = 0)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
p : 0 <= k
Hnm : k + 1 < 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((0%Q +
            ((((match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q *
              (((- 0%Q)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z 1)%Q)%Q *
             s 0 (intZmod.addz (intZmod.addz k 1) 1))%Q)%Q +
           ((((((((((- rat_of_Z 2)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     (match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q +
                   ((- rat_of_Z 8)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((- rat_of_Z 11)%Q *
                   match k with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q + (- rat_of_Z 5)%Q)%Q +
                (match k with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end * 0%Q)%Q)%Q +
               (match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end * (0%Q * 0%Q)%Q)%Q)%Q + (rat_of_Z 2 * (0%Q * 0%Q)%Q)%Q)%Q +
             (rat_of_Z 2 * 0%Q)%Q)%Q * s 0 (intZmod.addz k 1))%Q)%Q +
          (((match k with
             | Posz n => iterop n addq 1 0
             | Negz n =>
                 (-
                  match n with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) n)%Q
                  end)%Q
             end + rat_of_Z 1)%Q *
            ((match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q *
             (match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q)%Q)%Q * s 0 k)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
p : 0 <= k
H : k + 1 < 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((0%Q +
            ((((match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q *
              (((- 0%Q)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z 1)%Q)%Q *
             s 0 (intZmod.addz (intZmod.addz k 1) 1))%Q)%Q +
           ((((((((((- rat_of_Z 2)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     (match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q +
                   ((- rat_of_Z 8)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((- rat_of_Z 11)%Q *
                   match k with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q + (- rat_of_Z 5)%Q)%Q +
                (match k with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end * 0%Q)%Q)%Q +
               (match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end * (0%Q * 0%Q)%Q)%Q)%Q + (rat_of_Z 2 * (0%Q * 0%Q)%Q)%Q)%Q +
             (rat_of_Z 2 * 0%Q)%Q)%Q * s 0 (intZmod.addz k 1))%Q)%Q +
          (((match k with
             | Posz n => iterop n addq 1 0
             | Negz n =>
                 (-
                  match n with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) n)%Q
                  end)%Q
             end + rat_of_Z 1)%Q *
            ((match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q *
             (match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q)%Q)%Q * s 0 k)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: ((∣0⟩⟨0∣ .+ ∣1⟩⟨1∣) a H = (0 + 0 + (0 + 0))%R)
Crunching: ((∣0⟩⟨0∣ .+ ∣1⟩⟨1∣) a H = (0 + 0 + (0 + 0))%R)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 (fun x z : nat => 0 + ∣0⟩ x 0%nat * ⟨0∣ 0%nat z)
 .+ (fun x z : nat => 0 + ∣1⟩ x 0%nat * ⟨1∣ 0%nat z))
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣0⟩⟨0∣)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 list2D_to_matrix [[C1; 0]; [0; 0]] .+ list2D_to_matrix [[0; 0]; [0; C1]])
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣0⟩⟨0∣)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 list2D_to_matrix [[0; 0]; [0; C1]] .+ list2D_to_matrix [[C1; 0]; [0; 0]])
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣0⟩⟨0∣)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 list2D_to_matrix [[0; 0]; [0; C1]] .+ list2D_to_matrix [[C1; 0]; [0; 0]])
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
a0 : 0 <= k
Hnm : k + 1 < 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((0%Q +
            ((((match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q *
              (((- 0%Q)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z 1)%Q)%Q *
             s 0 (intZmod.addz (intZmod.addz k 1) 1))%Q)%Q +
           ((((((((((- rat_of_Z 2)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     (match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q +
                   ((- rat_of_Z 8)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((- rat_of_Z 11)%Q *
                   match k with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q + (- rat_of_Z 5)%Q)%Q +
                (match k with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end * 0%Q)%Q)%Q +
               (match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end * (0%Q * 0%Q)%Q)%Q)%Q + (rat_of_Z 2 * (0%Q * 0%Q)%Q)%Q)%Q +
             (rat_of_Z 2 * 0%Q)%Q)%Q * s 0 (intZmod.addz k 1))%Q)%Q +
          (((match k with
             | Posz n => iterop n addq 1 0
             | Negz n =>
                 (-
                  match n with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) n)%Q
                  end)%Q
             end + rat_of_Z 1)%Q *
            ((match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q *
             (match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q)%Q)%Q * s 0 k)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
a0 : 0 <= k
H : k + 1 < 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((0%Q +
            ((((match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q *
              (((- 0%Q)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z 1)%Q)%Q *
             s 0 (intZmod.addz (intZmod.addz k 1) 1))%Q)%Q +
           ((((((((((- rat_of_Z 2)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     (match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q +
                   ((- rat_of_Z 8)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((- rat_of_Z 11)%Q *
                   match k with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q + (- rat_of_Z 5)%Q)%Q +
                (match k with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end * 0%Q)%Q)%Q +
               (match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end * (0%Q * 0%Q)%Q)%Q)%Q + (rat_of_Z 2 * (0%Q * 0%Q)%Q)%Q)%Q +
             (rat_of_Z 2 * 0%Q)%Q)%Q * s 0 (intZmod.addz k 1))%Q)%Q +
          (((match k with
             | Posz n => iterop n addq 1 0
             | Negz n =>
                 (-
                  match n with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) n)%Q
                  end)%Q
             end + rat_of_Z 1)%Q *
            ((match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q *
             (match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q)%Q)%Q * s 0 k)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(WF_Matrix
   (cnot
    × (fun x y : nat =>
       hadamard (x / 2)%nat (y / 2)%nat * I 2 (x mod 2) (y mod 2))))
Crunching: ((cnot × (hadamard ⊗ I 2)) x y = 0)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
p : 0 <= k
Hnm : k + 1 < 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((0%Q +
            ((((match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q *
              (((- 0%Q)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z 1)%Q)%Q *
             s 0 (intZmod.addz (intZmod.addz k 1) 1))%Q)%Q +
           ((((((((((- rat_of_Z 2)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     (match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q +
                   ((- rat_of_Z 8)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((- rat_of_Z 11)%Q *
                   match k with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q + (- rat_of_Z 5)%Q)%Q +
                (match k with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end * 0%Q)%Q)%Q +
               (match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end * (0%Q * 0%Q)%Q)%Q)%Q + (rat_of_Z 2 * (0%Q * 0%Q)%Q)%Q)%Q +
             (rat_of_Z 2 * 0%Q)%Q)%Q * s 0 (intZmod.addz k 1))%Q)%Q +
          (((match k with
             | Posz n => iterop n addq 1 0
             | Negz n =>
                 (-
                  match n with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) n)%Q
                  end)%Q
             end + rat_of_Z 1)%Q *
            ((match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q *
             (match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q)%Q)%Q * s 0 k)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
p : 0 <= k
H : k + 1 < 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((0%Q +
            ((((match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q *
              (((- 0%Q)%Q +
                match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z 1)%Q)%Q *
             s 0 (intZmod.addz (intZmod.addz k 1) 1))%Q)%Q +
           ((((((((((- rat_of_Z 2)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     (match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match k with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q +
                   ((- rat_of_Z 8)%Q *
                    (match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match k with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((- rat_of_Z 11)%Q *
                   match k with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q + (- rat_of_Z 5)%Q)%Q +
                (match k with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end * 0%Q)%Q)%Q +
               (match k with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end * (0%Q * 0%Q)%Q)%Q)%Q + (rat_of_Z 2 * (0%Q * 0%Q)%Q)%Q)%Q +
             (rat_of_Z 2 * 0%Q)%Q)%Q * s 0 (intZmod.addz k 1))%Q)%Q +
          (((match k with
             | Posz n => iterop n addq 1 0
             | Negz n =>
                 (-
                  match n with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) n)%Q
                  end)%Q
             end + rat_of_Z 1)%Q *
            ((match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q *
             (match k with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end + rat_of_Z 1)%Q)%Q)%Q * s 0 k)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Chars 8696 - 8715 [(split;~try~apply~_).] 40.181 secs (0.017u,0.037s)
Chars 8718 - 8729 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 8732 - 8738 [split.] 0.001 secs (0.001u,0.s)
Chars 8741 - 8742 [-] 0. secs (0.u,0.s)
Chars 8743 - 8752 [(intros~E).] 0. secs (0.u,0.s)
Chars 8753 - 8759 [split.] 0. secs (0.u,0.s)
Chars 8764 - 8765 [+] 0. secs (0.u,0.s)
Chars 8766 - 8787 [(apply~not_lt_le_flip).] 0. secs (0.u,0.s)
Chars 8788 - 8813 [(apply~lt_flip;~assumption).] 0.002 secs (0.002u,0.s)
Chars 8818 - 8819 [+] 0. secs (0.u,0.s)
Chars 8820 - 8848 [(apply~pseudo_order_lt_apart).] 0.002 secs (0.002u,0.s)
Chars 8849 - 8860 [assumption.] 0. secs (0.u,0.s)
Chars 8863 - 8864 [-] 0. secs (0.u,0.s)
Chars 8865 - 8878 [(intros~[?~E]).] 0.001 secs (0.001u,0.s)
Chars 8879 - 8926 [(apply~not_lt_apart_lt_flip;~[...] 0.005 secs (0.004u,0.s)
Chars 8931 - 8956 [(apply~le_iff_not_lt_flip).] 0.002 secs (0.002u,0.s)
Chars 8957 - 8965 [trivial.] 0. secs (0.u,0.s)
Chars 8696 - 8715 [(split;~try~apply~_).] 0.001 secs (0.001u,0.s)
Chars 8718 - 8729 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 8732 - 8738 [split.] 0. secs (0.u,0.s)
Chars 8743 - 8752 [(intros~E).] 0. secs (0.u,0.s)
Chars 8753 - 8759 [split.] 0. secs (0.u,0.s)
Chars 8766 - 8787 [(apply~not_lt_le_flip).] 0. secs (0.u,0.s)
Chars 8788 - 8813 [(apply~lt_flip;~assumption).] 0. secs (0.u,0.s)
Chars 8820 - 8848 [(apply~pseudo_order_lt_apart).] 0. secs (0.u,0.s)
Chars 8849 - 8860 [assumption.] 0. secs (0.u,0.s)
Chars 8865 - 8878 [(intros~[?~E]).] 0. secs (0.u,0.s)
Chars 8879 - 8926 [(apply~not_lt_apart_lt_flip;~[...] 0. secs (0.u,0.s)
Chars 8931 - 8956 [(apply~le_iff_not_lt_flip).] 0. secs (0.u,0.s)
Chars 8957 - 8965 [trivial.] 0. secs (0.u,0.s)
Chars 8968 - 8972 [Qed.] 0.001 secs (0.001u,0.s)
Chars 8976 - 9173 [#[global]~Instance~fullpseudo_...] 0.001 secs (0.001u,0.s)
Chars 9177 - 9234 [#[global]Instance~le_stable~:~...] 0. secs (0.u,0.s)
Chars 9237 - 9243 [Proof.] 0. secs (0.u,0.s)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
telQ := 0 : rat_Ring
remP := punk.biv_horner_seqop [:: d.P1_cf0_0; d.P1_cf1_0; d.P1_cf2_0] s n k
 : rat_Ring
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: P1_flat s n k; telQ;
         punk.biv_horner_seqop [:: d.P1_cf0_1; d.P1_cf1_1]
           (fun n_ k_ : int => s n_ (int.shift 1 k_)) n k; remP]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
telQ := 0 : rat_Ring
remP := punk.biv_horner_seqop [:: d.P1_cf0_0; d.P1_cf1_0; d.P1_cf2_0] s n k
 : rat_Ring
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: P1_flat s n k; telQ;
         punk.biv_horner_seqop [:: d.P1_cf0_1; d.P1_cf1_1]
           (fun n_ k_ : int => s n_ (int.shift 1 k_)) n k; remP]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(WF_Matrix
   (cnot
    × (fun x y : nat =>
       hadamard (x / 2)%nat (y / 2)%nat * I 2 (x mod 2) (y mod 2))))
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
telQ := 0 : rat_Ring
remP := punk.biv_horner_seqop [:: d.P1_cf0_0; d.P1_cf1_0; d.P1_cf2_0] s n k
 : rat_Ring
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: P1_flat s n k; telQ;
         punk.biv_horner_seqop [:: d.P1_cf0_1; d.P1_cf1_1]
           (fun n_ k_ : int => s n_ (int.shift 1 k_)) n k; remP]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = hadamard ⊗ I 2 × ∣ 0, 0 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]; [e1]; [e2]] =
 cnot × list2D_to_matrix [[C1 / √ 2]; [0]; [C1 / √ 2]; [0]])
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [0]; [0]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0, 0 ⟩ .+ ∣ 1, 1 ⟩))
Chars 9246 - 9257 [(intros~x~y).] 40.161 secs (0.u,0.034s)
Chars 9258 - 9272 [(unfold~Stable).] 0. secs (0.u,0.s)
Chars 9275 - 9285 [(intros~dn).] 0. secs (0.u,0.s)
Chars 9286 - 9311 [(apply~le_iff_not_lt_flip).] 0.002 secs (0.001u,0.s)
Chars 9314 - 9323 [(intros~E).] 0. secs (0.u,0.s)
Chars 9324 - 9333 [(apply~dn).] 0. secs (0.u,0.s)
Chars 9336 - 9382 [(intros~E';~apply~le_iff_not_l...] 0.004 secs (0.003u,0.s)
Chars 9246 - 9257 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 9258 - 9272 [(unfold~Stable).] 0. secs (0.u,0.s)
Chars 9275 - 9285 [(intros~dn).] 0. secs (0.u,0.s)
Chars 9286 - 9311 [(apply~le_iff_not_lt_flip).] 0. secs (0.u,0.s)
Chars 9314 - 9323 [(intros~E).] 0. secs (0.u,0.s)
Chars 9324 - 9333 [(apply~dn).] 0. secs (0.u,0.s)
Chars 9336 - 9382 [(intros~E';~apply~le_iff_not_l...] 0. secs (0.u,0.s)
Chars 9385 - 9389 [Qed.] 0.001 secs (0.001u,0.s)
Chars 9393 - 9471 [Lemma~le_or_lt~`{!TrivialApart...] 0.001 secs (0.001u,0.s)
Chars 9474 - 9480 [Proof.] 0. secs (0.u,0.s)
Chars 9483 - 9533 [(destruct~(trichotomy~(<)~x~y)...] 2.705 secs (-8.112u,-1.925s)
Finished transaction in 0.386 secs (0.385u,0.001s) (successful)
Finished transaction in 2.248 secs (2.232u,0.012s) (successful)
Finished transaction in 0.015 secs (0.015u,0.s) (successful)
Finished transaction in 0.016 secs (0.016u,0.s) (successful)
OrdersEx.Nat_as_OT.add_0_r: forall n : nat, n + 0 = n
OrdersEx.Nat_as_DT.add_0_r: forall n : nat, n + 0 = n
Nat.add_0_r: forall n : nat, n + 0 = n
NPeano.Nat.add_0_r: forall n : nat, n + 0 = n
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.377 secs (0.349u,0.024s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.244 secs (0.239u,0.004s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.016 secs (0.016u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.014 secs (0.014u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 0.808 secs (0.794u,0.011s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 1.498 secs (1.481u,0.016s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.024 secs (0.022u,0.001s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.027 secs (0.027u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Tactic call ran for 0.091 secs (0.09u,0.s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.149 secs (0.145u,0.002s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
KFK_proper
     : forall (kbr : Kchain) (fq : Fchain),
       Kchain_proper kbr -> Fchain_proper fq -> Kchain_proper (KFK kbr fq)
KFK_proper
     : forall (kbr : Kchain) (fq : Fchain),
       Kchain_proper kbr -> Fchain_proper fq -> Kchain_proper (KFK kbr fq)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
clear  H0  :  (False -> 0 = S n)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Chars 9483 - 9533 [(destruct~(trichotomy~(<)~x~y)...] 40.091 secs (0.02u,0.039s)
Chars 9536 - 9537 [-] 0. secs (0.u,0.s)
Chars 9538 - 9543 [left.] 0. secs (0.u,0.s)
Chars 9544 - 9564 [(apply~lt_le;~trivial).] 0.002 secs (0.002u,0.s)
Chars 9567 - 9568 [-] 0. secs (0.u,0.s)
Chars 9569 - 9574 [left.] 0. secs (0.u,0.s)
Chars 9575 - 9595 [(apply~eq_le;~trivial).] 0.006 secs (0.005u,0.001s)
Chars 9483 - 9533 [(destruct~(trichotomy~(<)~x~y)...] 0.001 secs (0.001u,0.s)
Chars 9538 - 9543 [left.] 0. secs (0.u,0.s)
Chars 9544 - 9564 [(apply~lt_le;~trivial).] 0. secs (0.u,0.s)
Chars 9569 - 9574 [left.] 0. secs (0.u,0.s)
Chars 9575 - 9595 [(apply~eq_le;~trivial).] 0. secs (0.u,0.s)
Chars 9598 - 9602 [Qed.] 0.001 secs (0.001u,0.s)
Chars 9606 - 9693 [#[global]~Instance~le_total~~`...] 0.001 secs (0.u,0.s)
Chars 9696 - 9702 [Proof.] 0. secs (0.u,0.s)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Finished transaction in 0.178 secs (0.175u,0.002s) (successful)
Finished transaction in 0.475 secs (0.473u,0.002s) (successful)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Finished transaction in 0.018 secs (0.018u,0.s) (successful)
Finished transaction in 0.018 secs (0.018u,0.s) (successful)
Finished transaction in 0.561 secs (0.551u,0.009s) (successful)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.604 secs (0.595u,0.008s) (success)
Proving invert_bind_args_raw_to_typed...
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Tactic call ran for 0.407 secs (0.401u,0.004s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.048 secs (0.048u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.024 secs (0.024u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 1.165 secs (1.158u,0.006s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.019 secs (0.017u,0.001s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Crunching: (forall b : R, n < 0 -> √ (n + b) <= √ n + √ b)
Tactic call ran for 2.688 secs (2.681u,0.003s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
check_guarded: true
check_positive: true
check_universes: true
cumulative sprop: false
definitional uip: false
"toto has been translated as totoᵗ"
totoᵗ : unit -> (forall A : Type, A -> A) -> Type -> Type
     : unit -> (forall A : Type, A -> A) -> Type -> Type
"FALSE has been translated as FALSEᵗ"
"toto"
Reducing rewrite_head...
Tactic call ran for 0.121 secs (0.12u,0.s) (success)
Tactic call ran for 0.042 secs (0.042u,0.s) (success)
Tactic call ran for 0.113 secs (0.113u,0.s) (success)
Assembling rewrite_head_no_dtree...
"a has been translated as aᵗ"
"T has been translated as Tᵗ"
"tm has been translated as tmᵗ"
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.047 secs (0.047u,0.s) (success)
"Ty has been translated as Tyᵗ"
Tyᵗ : El Tyᵗ
     : El Tyᵗ
Tactic call ran for 0.68 secs (0.67u,0.008s) (success)
Crunching: (~ 0 < 0 -> √ (p + H0) <= √ p + √ H0)
Crunching: (forall b : R, n < 0 -> √ (n + b) <= √ n + √ b)
Proving Rewriter_Interp...
Chars 9705 - 9724 [(split;~try~apply~_).] 40.168 secs (0.006u,0.034s)
Chars 9727 - 9738 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 9741 - 9771 [(destruct~(le_or_lt~x~y);~auto).] 0.027 secs (0.024u,0.002s)
Chars 9774 - 9780 [right.] 0. secs (0.u,0.s)
Chars 9781 - 9793 [(apply~lt_le).] 0.001 secs (0.001u,0.s)
Chars 9796 - 9804 [trivial.] 0. secs (0.u,0.s)
Chars 9705 - 9724 [(split;~try~apply~_).] 0. secs (0.u,0.s)
Chars 9727 - 9738 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 9741 - 9771 [(destruct~(le_or_lt~x~y);~auto).] 0.001 secs (0.001u,0.s)
Chars 9774 - 9780 [right.] 0. secs (0.u,0.s)
Chars 9781 - 9793 [(apply~lt_le).] 0. secs (0.u,0.s)
Chars 9796 - 9804 [trivial.] 0. secs (0.u,0.s)
Chars 9807 - 9811 [Qed.] 0.001 secs (0.001u,0.s)
Chars 9815 - 9905 [Lemma~not_le_lt_flip~`{!Trivia...] 0.001 secs (0.001u,0.s)
Chars 9908 - 9914 [Proof.] 0. secs (0.u,0.s)
Tactic call ran for 0.626 secs (0.622u,0.003s) (success)
Tactic call ran for 0.302 secs (0.299u,0.002s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 26.719 secs (26.372u,0.291s) (successful)
"sigT has been translated as sigTᵗ"
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
s4 := s n k : rat
s2 := s n (intZmod.addz k 1) : rat
s5 := s n (intZmod.addz (intZmod.addz k 1) 1) : rat
Unable to unify "true" with "false".
Finished transaction in 2.21 secs (2.194u,0.013s) (successful)
Finished transaction in 2.202 secs (2.172u,0.027s) (successful)
Finished transaction in 0.722 secs (0.711u,0.01s) (successful)
Finished transaction in 1.391 secs (1.368u,0.021s) (successful)
Crunching: (~ 0 < 0 -> √ (p + H0) <= √ p + √ H0)
Finished transaction in 0.052 secs (0.052u,0.s) (successful)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
s4 := s n k : rat
s2 := s n (intZmod.addz k 1) : rat
s5 := s n (intZmod.addz (intZmod.addz k 1) 1) : rat
Unable to unify "true" with "false".
Finished transaction in 0.063 secs (0.057u,0.005s) (successful)
Crunching: (forall b : R, n < 0 -> √ (n + b) <= √ n + √ b)
Finished transaction in 1.106 secs (1.094u,0.01s) (successful)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
s4 := s n k : rat
s2 := s n (intZmod.addz k 1) : rat
s5 := s n (intZmod.addz (intZmod.addz k 1) 1) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ((((match k with
             | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
             | Negz elpi_ctx_entry_5_ =>
                 (-
                  match elpi_ctx_entry_5_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) elpi_ctx_entry_5_)%Q
                  end)%Q
             end + rat_of_Z 1)%Q *
            ((match k with
              | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
              | Negz elpi_ctx_entry_5_ =>
                  (-
                   match elpi_ctx_entry_5_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) elpi_ctx_entry_5_)%Q
                   end)%Q
              end + rat_of_Z 1)%Q *
             (match k with
              | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
              | Negz elpi_ctx_entry_5_ =>
                  (-
                   match elpi_ctx_entry_5_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) elpi_ctx_entry_5_)%Q
                   end)%Q
              end + rat_of_Z 1)%Q)%Q)%Q * s4)%Q +
          ((((((((((- rat_of_Z 2)%Q *
                   (match k with
                    | Posz elpi_ctx_entry_5_ =>
                        iterop elpi_ctx_entry_5_ addq 1 0
                    | Negz elpi_ctx_entry_5_ =>
                        (-
                         match elpi_ctx_entry_5_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) elpi_ctx_entry_5_)%Q
                         end)%Q
                    end *
                    (match k with
                     | Posz elpi_ctx_entry_5_ =>
                         iterop elpi_ctx_entry_5_ addq 1 0
                     | Negz elpi_ctx_entry_5_ =>
                         (-
                          match elpi_ctx_entry_5_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) elpi_ctx_entry_5_)%Q
                          end)%Q
                     end *
                     match k with
                     | Posz elpi_ctx_entry_5_ =>
                         iterop elpi_ctx_entry_5_ addq 1 0
                     | Negz elpi_ctx_entry_5_ =>
                         (-
                          match elpi_ctx_entry_5_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) elpi_ctx_entry_5_)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((- rat_of_Z 8)%Q *
                   (match k with
                    | Posz elpi_ctx_entry_5_ =>
                        iterop elpi_ctx_entry_5_ addq 1 0
                    | Negz elpi_ctx_entry_5_ =>
                        (-
                         match elpi_ctx_entry_5_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) elpi_ctx_entry_5_)%Q
                         end)%Q
                    end *
                    match k with
                    | Posz elpi_ctx_entry_5_ =>
                        iterop elpi_ctx_entry_5_ addq 1 0
                    | Negz elpi_ctx_entry_5_ =>
                        (-
                         match elpi_ctx_entry_5_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) elpi_ctx_entry_5_)%Q
                         end)%Q
                    end)%Q)%Q)%Q +
                 ((- rat_of_Z 11)%Q *
                  match k with
                  | Posz elpi_ctx_entry_5_ =>
                      iterop elpi_ctx_entry_5_ addq 1 0
                  | Negz elpi_ctx_entry_5_ =>
                      (-
                       match elpi_ctx_entry_5_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) elpi_ctx_entry_5_)%Q
                       end)%Q
                  end)%Q)%Q + (- rat_of_Z 5)%Q)%Q +
               (match k with
                | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
                | Negz elpi_ctx_entry_5_ =>
                    (-
                     match elpi_ctx_entry_5_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_5_)%Q
                     end)%Q
                end *
                match n with
                | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
                | Negz elpi_ctx_entry_5_ =>
                    (-
                     match elpi_ctx_entry_5_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_5_)%Q
                     end)%Q
                end)%Q)%Q +
              (match k with
               | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
               | Negz elpi_ctx_entry_5_ =>
                   (-
                    match elpi_ctx_entry_5_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_5_)%Q
                    end)%Q
               end *
               (match n with
                | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
                | Negz elpi_ctx_entry_5_ =>
                    (-
                     match elpi_ctx_entry_5_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_5_)%Q
                     end)%Q
                end *
                match n with
                | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
                | Negz elpi_ctx_entry_5_ =>
                    (-
                     match elpi_ctx_entry_5_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_5_)%Q
                     end)%Q
                end)%Q)%Q)%Q +
             (rat_of_Z 2 *
              (match n with
               | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
               | Negz elpi_ctx_entry_5_ =>
                   (-
                    match elpi_ctx_entry_5_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_5_)%Q
                    end)%Q
               end *
               match n with
               | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
               | Negz elpi_ctx_entry_5_ =>
                   (-
                    match elpi_ctx_entry_5_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_5_)%Q
                    end)%Q
               end)%Q)%Q)%Q +
            (rat_of_Z 2 *
             match n with
             | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
             | Negz elpi_ctx_entry_5_ =>
                 (-
                  match elpi_ctx_entry_5_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) elpi_ctx_entry_5_)%Q
                  end)%Q
             end)%Q)%Q * s2)%Q)%Q;
         ((0%Q +
           ((((match k with
               | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
               | Negz elpi_ctx_entry_5_ =>
                   (-
                    match elpi_ctx_entry_5_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_5_)%Q
                    end)%Q
               end + rat_of_Z 2)%Q *
              ((match n with
                | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
                | Negz elpi_ctx_entry_5_ =>
                    (-
                     match elpi_ctx_entry_5_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_5_)%Q
                     end)%Q
                end + rat_of_Z 2)%Q +
               match k with
               | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
               | Negz elpi_ctx_entry_5_ =>
                   (-
                    match elpi_ctx_entry_5_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_5_)%Q
                    end)%Q
               end)%Q)%Q *
             (((-
                match n with
                | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
                | Negz elpi_ctx_entry_5_ =>
                    (-
                     match elpi_ctx_entry_5_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_5_)%Q
                     end)%Q
                end)%Q +
               match k with
               | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
               | Negz elpi_ctx_entry_5_ =>
                   (-
                    match elpi_ctx_entry_5_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_5_)%Q
                    end)%Q
               end)%Q + rat_of_Z 1)%Q)%Q * s5)%Q)%Q +
          ((((((((((- rat_of_Z 2)%Q *
                   (match k with
                    | Posz elpi_ctx_entry_5_ =>
                        iterop elpi_ctx_entry_5_ addq 1 0
                    | Negz elpi_ctx_entry_5_ =>
                        (-
                         match elpi_ctx_entry_5_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) elpi_ctx_entry_5_)%Q
                         end)%Q
                    end *
                    (match k with
                     | Posz elpi_ctx_entry_5_ =>
                         iterop elpi_ctx_entry_5_ addq 1 0
                     | Negz elpi_ctx_entry_5_ =>
                         (-
                          match elpi_ctx_entry_5_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) elpi_ctx_entry_5_)%Q
                          end)%Q
                     end *
                     match k with
                     | Posz elpi_ctx_entry_5_ =>
                         iterop elpi_ctx_entry_5_ addq 1 0
                     | Negz elpi_ctx_entry_5_ =>
                         (-
                          match elpi_ctx_entry_5_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) elpi_ctx_entry_5_)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((- rat_of_Z 8)%Q *
                   (match k with
                    | Posz elpi_ctx_entry_5_ =>
                        iterop elpi_ctx_entry_5_ addq 1 0
                    | Negz elpi_ctx_entry_5_ =>
                        (-
                         match elpi_ctx_entry_5_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) elpi_ctx_entry_5_)%Q
                         end)%Q
                    end *
                    match k with
                    | Posz elpi_ctx_entry_5_ =>
                        iterop elpi_ctx_entry_5_ addq 1 0
                    | Negz elpi_ctx_entry_5_ =>
                        (-
                         match elpi_ctx_entry_5_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) elpi_ctx_entry_5_)%Q
                         end)%Q
                    end)%Q)%Q)%Q +
                 ((- rat_of_Z 11)%Q *
                  match k with
                  | Posz elpi_ctx_entry_5_ =>
                      iterop elpi_ctx_entry_5_ addq 1 0
                  | Negz elpi_ctx_entry_5_ =>
                      (-
                       match elpi_ctx_entry_5_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) elpi_ctx_entry_5_)%Q
                       end)%Q
                  end)%Q)%Q + (- rat_of_Z 5)%Q)%Q +
               (match k with
                | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
                | Negz elpi_ctx_entry_5_ =>
                    (-
                     match elpi_ctx_entry_5_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_5_)%Q
                     end)%Q
                end *
                match n with
                | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
                | Negz elpi_ctx_entry_5_ =>
                    (-
                     match elpi_ctx_entry_5_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_5_)%Q
                     end)%Q
                end)%Q)%Q +
              (match k with
               | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
               | Negz elpi_ctx_entry_5_ =>
                   (-
                    match elpi_ctx_entry_5_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_5_)%Q
                    end)%Q
               end *
               (match n with
                | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
                | Negz elpi_ctx_entry_5_ =>
                    (-
                     match elpi_ctx_entry_5_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_5_)%Q
                     end)%Q
                end *
                match n with
                | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
                | Negz elpi_ctx_entry_5_ =>
                    (-
                     match elpi_ctx_entry_5_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_5_)%Q
                     end)%Q
                end)%Q)%Q)%Q +
             (rat_of_Z 2 *
              (match n with
               | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
               | Negz elpi_ctx_entry_5_ =>
                   (-
                    match elpi_ctx_entry_5_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_5_)%Q
                    end)%Q
               end *
               match n with
               | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
               | Negz elpi_ctx_entry_5_ =>
                   (-
                    match elpi_ctx_entry_5_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_5_)%Q
                    end)%Q
               end)%Q)%Q)%Q +
            (rat_of_Z 2 *
             match n with
             | Posz elpi_ctx_entry_5_ => iterop elpi_ctx_entry_5_ addq 1 0
             | Negz elpi_ctx_entry_5_ =>
                 (-
                  match elpi_ctx_entry_5_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) elpi_ctx_entry_5_)%Q
                  end)%Q
             end)%Q)%Q * s2)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall q : nat -> nat -> R * R,
 (fun x z : nat =>
  ((R0 +
    ((let (x0, _) := match x with
                     | 1%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
      x0) *
     (R0 +
      (R0 * (let (x0, _) := q 0%nat z in x0) +
       - (R0 * (let (_, y) := q 0%nat z in y)))) +
     -
     ((let (_, y) := match x with
                     | 1%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       y) *
      (R0 +
       (R0 * (let (_, y) := q 0%nat z in y) +
        R0 * (let (x0, _) := q 0%nat z in x0))))) +
    ((let (x0, _) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
      x0) *
     (R0 +
      (R1 * (let (x0, _) := q 0%nat z in x0) +
       - (R0 * (let (_, y) := q 0%nat z in y)))) +
     -
     ((let (_, y) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       y) *
      (R0 +
       (R1 * (let (_, y) := q 0%nat z in y) +
        R0 * (let (x0, _) := q 0%nat z in x0))))))%R,
  (R0 +
   ((let (x0, _) := match x with
                    | 1%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
     x0) *
    (R0 +
     (R0 * (let (_, y) := q 0%nat z in y) +
      R0 * (let (x0, _) := q 0%nat z in x0))) +
    (let (_, y) := match x with
                   | 1%nat => (R1, R0)
                   | _ => (R0, R0)
                   end in y) *
    (R0 +
     (R0 * (let (x0, _) := q 0%nat z in x0) +
      - (R0 * (let (_, y) := q 0%nat z in y))))) +
   ((let (x0, _) := match x with
                    | 0%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
     x0) *
    (R0 +
     (R1 * (let (_, y) := q 0%nat z in y) +
      R0 * (let (x0, _) := q 0%nat z in x0))) +
    (let (_, y) := match x with
                   | 0%nat => (R1, R0)
                   | _ => (R0, R0)
                   end in y) *
    (R0 +
     (R1 * (let (x0, _) := q 0%nat z in x0) +
      - (R0 * (let (_, y) := q 0%nat z in y))))))%R)) =
 (fun x z : nat =>
  ((R0 +
    ((let (x0, _) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
      x0) * (let (x0, _) := q 0%nat z in x0) +
     -
     ((let (_, y) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       y) * (let (_, y) := q 0%nat z in y))))%R,
  (R0 +
   ((let (x0, _) := match x with
                    | 0%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
     x0) * (let (_, y) := q 0%nat z in y) +
    (let (_, y) := match x with
                   | 0%nat => (R1, R0)
                   | _ => (R0, R0)
                   end in y) * (let (x0, _) := q 0%nat z in x0)))%R)))
Coq.Init.Datatypes.nat has been translated.
Coq.Init.Datatypes.list has been translated.
listᵗ : forall A : TYPE, list A.1 -> Type
     : forall A : TYPE, list A.1 -> Type
nilᵗ : forall A : TYPE, listᵗ A []
     : forall A : TYPE, listᵗ A []
consᵗ
:
forall (A : TYPE) (x : El A) (lH : ∃ l : list A.1, listᵗ A l),
listᵗ A (x.1 :: lH.1)
     : forall (A : TYPE) (x : El A) (lH : ∃ l : list A.1, listᵗ A l),
       listᵗ A (x.1 :: lH.1)
Crunching:
(forall q : nat -> nat -> R * R,
 (fun x z : nat =>
  ((R0 +
    ((let (x0, _) := match x with
                     | 1%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
      x0) *
     (R0 +
      (R0 * (let (x0, _) := q 0%nat z in x0) +
       - (R0 * (let (_, y) := q 0%nat z in y)))) +
     -
     ((let (_, y) := match x with
                     | 1%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       y) *
      (R0 +
       (R0 * (let (_, y) := q 0%nat z in y) +
        R0 * (let (x0, _) := q 0%nat z in x0))))) +
    ((let (x0, _) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
      x0) *
     (R0 +
      (R1 * (let (x0, _) := q 0%nat z in x0) +
       - (R0 * (let (_, y) := q 0%nat z in y)))) +
     -
     ((let (_, y) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       y) *
      (R0 +
       (R1 * (let (_, y) := q 0%nat z in y) +
        R0 * (let (x0, _) := q 0%nat z in x0))))))%R,
  (R0 +
   ((let (x0, _) := match x with
                    | 1%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
     x0) *
    (R0 +
     (R0 * (let (_, y) := q 0%nat z in y) +
      R0 * (let (x0, _) := q 0%nat z in x0))) +
    (let (_, y) := match x with
                   | 1%nat => (R1, R0)
                   | _ => (R0, R0)
                   end in y) *
    (R0 +
     (R0 * (let (x0, _) := q 0%nat z in x0) +
      - (R0 * (let (_, y) := q 0%nat z in y))))) +
   ((let (x0, _) := match x with
                    | 0%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
     x0) *
    (R0 +
     (R1 * (let (_, y) := q 0%nat z in y) +
      R0 * (let (x0, _) := q 0%nat z in x0))) +
    (let (_, y) := match x with
                   | 0%nat => (R1, R0)
                   | _ => (R0, R0)
                   end in y) *
    (R0 +
     (R1 * (let (x0, _) := q 0%nat z in x0) +
      - (R0 * (let (_, y) := q 0%nat z in y))))))%R)) =
 (fun x z : nat =>
  ((R0 +
    ((let (x0, _) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
      x0) * (let (x0, _) := q 0%nat z in x0) +
     -
     ((let (_, y) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       y) * (let (_, y) := q 0%nat z in y))))%R,
  (R0 +
   ((let (x0, _) := match x with
                    | 0%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
     x0) * (let (_, y) := q 0%nat z in y) +
    (let (_, y) := match x with
                   | 0%nat => (R1, R0)
                   | _ => (R0, R0)
                   end in y) * (let (x0, _) := q 0%nat z in x0)))%R)))
"paths has been translated as pathsᵗ"
"idpath has been translated as idpathᵗ"
Crunching:
(forall q : nat -> nat -> R * R,
 (fun x z : nat =>
  ((R0 +
    ((let (x0, _) := match x with
                     | 1%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
      x0) *
     (R0 +
      (R0 * (let (x0, _) := q 0%nat z in x0) +
       - (R0 * (let (_, y) := q 0%nat z in y)))) +
     -
     ((let (_, y) := match x with
                     | 1%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       y) *
      (R0 +
       (R0 * (let (_, y) := q 0%nat z in y) +
        R0 * (let (x0, _) := q 0%nat z in x0))))) +
    ((let (x0, _) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
      x0) *
     (R0 +
      (R1 * (let (x0, _) := q 0%nat z in x0) +
       - (R0 * (let (_, y) := q 0%nat z in y)))) +
     -
     ((let (_, y) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       y) *
      (R0 +
       (R1 * (let (_, y) := q 0%nat z in y) +
        R0 * (let (x0, _) := q 0%nat z in x0))))))%R,
  (R0 +
   ((let (x0, _) := match x with
                    | 1%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
     x0) *
    (R0 +
     (R0 * (let (_, y) := q 0%nat z in y) +
      R0 * (let (x0, _) := q 0%nat z in x0))) +
    (let (_, y) := match x with
                   | 1%nat => (R1, R0)
                   | _ => (R0, R0)
                   end in y) *
    (R0 +
     (R0 * (let (x0, _) := q 0%nat z in x0) +
      - (R0 * (let (_, y) := q 0%nat z in y))))) +
   ((let (x0, _) := match x with
                    | 0%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
     x0) *
    (R0 +
     (R1 * (let (_, y) := q 0%nat z in y) +
      R0 * (let (x0, _) := q 0%nat z in x0))) +
    (let (_, y) := match x with
                   | 0%nat => (R1, R0)
                   | _ => (R0, R0)
                   end in y) *
    (R0 +
     (R1 * (let (x0, _) := q 0%nat z in x0) +
      - (R0 * (let (_, y) := q 0%nat z in y))))))%R)) =
 (fun x z : nat =>
  ((R0 +
    ((let (x0, _) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
      x0) * (let (x0, _) := q 0%nat z in x0) +
     -
     ((let (_, y) := match x with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       y) * (let (_, y) := q 0%nat z in y))))%R,
  (R0 +
   ((let (x0, _) := match x with
                    | 0%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
     x0) * (let (_, y) := q 0%nat z in y) +
    (let (_, y) := match x with
                   | 0%nat => (R1, R0)
                   | _ => (R0, R0)
                   end in y) * (let (x0, _) := q 0%nat z in x0)))%R)))
"paths_ind has been translated as paths_indᵗ"
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
l1 : int
l2 : precond.Sn2 n l1
Unable to unify "true" with "false".
Chars 9917 - 9924 [(intros).] 40.307 secs (0.001u,0.032s)
Chars 9927 - 9957 [(destruct~(le_or_lt~y~x);~auto).] 0.005 secs (0.004u,0.s)
Chars 9960 - 9974 [contradiction.] 0. secs (0.u,0.s)
Chars 9917 - 9924 [(intros).] 0. secs (0.u,0.s)
Chars 9927 - 9957 [(destruct~(le_or_lt~y~x);~auto).] 0. secs (0.u,0.s)
Chars 9960 - 9974 [contradiction.] 0. secs (0.u,0.s)
Chars 9977 - 9981 [Qed.] 0. secs (0.u,0.s)
Chars 9985 - 10019 [Existing~Instance~dec_from_lt_...] 0. secs (0.u,0.s)
Chars 10023 - 10131 [Definition~lt_dec~`{!TrivialAp...] 0.002 secs (0.002u,0.s)
Chars 10134 - 10140 [Proof.] 0. secs (0.u,0.s)
"transport has been translated as transportᵗ"
"sigT has been translated as sigTᵗ"
"existT has been translated as existTᵗ"
Finished transaction in 0.545 secs (0.476u,0.066s) (successful)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = list2D_to_matrix [[C1]; [0]] × n)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣0⟩ × n)
Crunching:
(list2D_to_matrix [[n 0%nat 0%nat; n 0%nat 1%nat]; [0; 0]] =
 list2D_to_matrix [[n 0%nat 0%nat; n 0%nat 1%nat]; [0; 0]])
Crunching: (0 = n 0%nat 2%nat)
Crunching: (0 = n 0%nat (S (S (S y))))
Crunching: (0 = n 0%nat 2%nat)
Crunching: (0 = n 0%nat (S (S (S y))))
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
_n__, _k__ : int
s1 := s (int.shift 2 _n__) _k__ : rat
s2 := s _n__ _k__ : rat
s3 := s (int.shift 1 _n__) _k__ : rat
s4 := s _n__ (int.shift 1 _k__) : rat
p : precond.Sn2 _n__ _k__
Unable to unify "true" with "false".
"projT1 has been translated as projT1ᵗ"
Crunching:
((fun p : nat -> nat -> R * R =>
  (fun x0 z : nat =>
   ((R0 +
     ((let (x, _) := match x0 with
                     | 1%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       x) *
      (R0 +
       (R0 * (let (x, _) := p 0%nat z in x) +
        - (R0 * (let (_, y) := x 0%nat z in y)))) +
      -
      ((let (_, y) :=
          match x0 with
          | 1%nat => (R1, R0)
          | _ => (R0, R0)
          end in
        y) *
       (R0 +
        (R0 * (let (_, y) := x 0%nat z in y) +
         R0 * (let (x, _) := x 0%nat z in x))))) +
     ((let (x, _) := match x0 with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       x) *
      (R0 +
       (R1 * (let (x, _) := x 0%nat z in x) +
        - (R0 * (let (_, y) := x 0%nat z in y)))) +
      -
      ((let (_, y) :=
          match x0 with
          | 0%nat => (R1, R0)
          | _ => (R0, R0)
          end in
        y) *
       (R0 +
        (R1 * (let (_, y) := x 0%nat z in y) +
         R0 * (let (x, _) := x 0%nat z in x))))))%R,
   (R0 +
    ((let (x, _) := match x0 with
                    | 1%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
      x) *
     (R0 +
      (R0 * (let (_, y) := x 0%nat z in y) +
       R0 * (let (x, _) := x 0%nat z in x))) +
     (let (_, y) := match x0 with
                    | 1%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
      y) *
     (R0 +
      (R0 * (let (x, _) := x 0%nat z in x) +
       - (R0 * (let (_, y) := x 0%nat z in y))))) +
    ((let (x, _) := match x0 with
                    | 0%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
      x) *
     (R0 +
      (R1 * (let (_, y) := x 0%nat z in y) +
       R0 * (let (x, _) := x 0%nat z in x))) +
     (let (_, y) := match x0 with
                    | 0%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
      y) *
     (R0 +
      (R1 * (let (x, _) := x 0%nat z in x) +
       - (R0 * (let (_, y) := x 0%nat z in y))))))%R)) =
  (fun x0 z : nat =>
   ((R0 +
     ((let (x, _) := match x0 with
                     | 0%nat => (R1, R0)
                     | _ => (R0, R0)
                     end in
       x) * (let (x, _) := x 0%nat z in x) +
      -
      ((let (_, y) :=
          match x0 with
          | 0%nat => (R1, R0)
          | _ => (R0, R0)
          end in
        y) * (let (_, y) := x 0%nat z in y))))%R,
   (R0 +
    ((let (x, _) := match x0 with
                    | 0%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
      x) * (let (_, y) := x 0%nat z in y) +
     (let (_, y) := match x0 with
                    | 0%nat => (R1, R0)
                    | _ => (R0, R0)
                    end in
      y) * (let (x, _) := x 0%nat z in x)))%R))) x)
Chars 10143 - 10150 [(intros).] 6.307 secs (0.u,0.033s)
Chars 10153 - 10184 [(destruct~(decide_rel~(<=)~y~x)).] 0.004 secs (0.004u,0.s)
Chars 10187 - 10188 [-] 0. secs (0.u,0.s)
Chars 10189 - 10227 [(right;~apply~le_not_lt_flip;~...] 0.003 secs (0.003u,0.s)
Chars 10230 - 10231 [-] 0. secs (0.u,0.s)
Chars 10232 - 10270 [(left;~apply~not_le_lt_flip;~a...] 0.018 secs (0.018u,0.s)
Chars 10143 - 10150 [(intros).] 0. secs (0.u,0.s)
Chars 10153 - 10184 [(destruct~(decide_rel~(<=)~y~x)).] 0. secs (0.u,0.s)
Chars 10189 - 10227 [(right;~apply~le_not_lt_flip;~...] 0.001 secs (0.001u,0.s)
Chars 10232 - 10270 [(left;~apply~not_le_lt_flip;~a...] 0.001 secs (0.u,0.s)
Chars 10273 - 10281 [Defined.] 0.001 secs (0.001u,0.s)
Chars 10282 - 10304 [End~full_pseudo_order.] 0.032 secs (0.029u,0.002s)
Chars 10306 - 10390 [#[export]~Hint~Extern~8~(Decid...] 0. secs (0.u,0.s)
Chars 10714 - 10746 [Section~dec_strict_setoid_order.] 0. secs (0.u,0.s)
Chars 10749 - 10824 [Context~`{StrictOrder~A}~`{Apa...] 0.001 secs (0.001u,0.s)
Chars 10828 - 10869 [Instance:~(IsApart~A)~:=~dec_s...] 0.001 secs (0.u,0.001s)
Chars 10873 - 10900 [Context~`{!Trichotomy~(<)}.] 0. secs (0.u,0.s)
Chars 10904 - 10954 [Instance~dec_strict_pseudo_ord...] 0. secs (0.u,0.s)
Chars 10957 - 10963 [Proof.] 0. secs (0.u,0.s)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
_n__, _k__ : int
s1 := s (int.shift 2 _n__) _k__ : rat
s2 := s _n__ _k__ : rat
s3 := s (int.shift 1 _n__) _k__ : rat
H0 : precond.Sn2 _n__ _k__
H : 0 <= _k__
H1 : _k__ < _n__
H3 : (0 <= _k__) = true
Unable to unify "true" with "false".
"projT2 has been translated as projT2ᵗ"
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[C1]] × q2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 q1 × list2D_to_matrix [[q2 0%nat 0%nat; q2 0%nat 1%nat]])
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = q1 × q2)
Crunching:
(list2D_to_matrix
   [[q1 0%nat 0%nat * q2 0%nat 0%nat; q1 0%nat 0%nat * q2 0%nat 1%nat];
   [q1 1%nat 0%nat * q2 0%nat 0%nat; q1 1%nat 0%nat * q2 0%nat 1%nat]] =
 list2D_to_matrix
   [[q1 0%nat 0%nat * q2 0%nat 0%nat; q1 0%nat 0%nat * q2 0%nat 1%nat];
   [q1 1%nat 0%nat * q2 0%nat 0%nat; q1 1%nat 0%nat * q2 0%nat 1%nat]])
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat (S y))
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat (S y))
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat 1%nat)
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat 1%nat)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[C1]] × q2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 q1 × list2D_to_matrix [[q2 0%nat 0%nat; q2 0%nat 1%nat]])
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = q1 × q2)
Crunching:
(list2D_to_matrix
   [[q1 0%nat 0%nat * q2 0%nat 0%nat; q1 0%nat 0%nat * q2 0%nat 1%nat];
   [q1 1%nat 0%nat * q2 0%nat 0%nat; q1 1%nat 0%nat * q2 0%nat 1%nat]] =
 list2D_to_matrix
   [[q1 0%nat 0%nat * q2 0%nat 0%nat; q1 0%nat 0%nat * q2 0%nat 1%nat];
   [q1 1%nat 0%nat * q2 0%nat 0%nat; q1 1%nat 0%nat * q2 0%nat 1%nat]])
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat (S y))
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat (S y))
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat 1%nat)
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat 1%nat)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
_k__ : int
_Hyp_ : precond.Sn2 n _k__
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
l1 : int
l2 : precond.Sn2 n l1
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
pol : int
s4 := s (int.shift 2 n) pol : rat
rhs := Sn2_cf0_0 n pol * s n pol : rat_Ring
H : precond.Sn2 n pol
Unable to unify "true" with "false".
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[C1]] × q2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 q1 × list2D_to_matrix [[q2 0%nat 0%nat; q2 0%nat 1%nat]])
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = q1 × q2)
Crunching:
(list2D_to_matrix
   [[q1 0%nat 0%nat * q2 0%nat 0%nat; q1 0%nat 0%nat * q2 0%nat 1%nat];
   [q1 1%nat 0%nat * q2 0%nat 0%nat; q1 1%nat 0%nat * q2 0%nat 1%nat]] =
 list2D_to_matrix
   [[q1 0%nat 0%nat * q2 0%nat 0%nat; q1 0%nat 0%nat * q2 0%nat 1%nat];
   [q1 1%nat 0%nat * q2 0%nat 0%nat; q1 1%nat 0%nat * q2 0%nat 1%nat]])
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat (S y))
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat (S y))
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 2%nat 0%nat * q2 0%nat 1%nat)
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat 0%nat)
Crunching: (0 = q1 (S (S (S x))) 0%nat * q2 0%nat 1%nat)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
pol : int
s4 := s (int.shift 2 n) pol : rat
rhs := Sn2_cf0_0 n pol * s n pol : rat_Ring
x : precond.Sn2 n pol
lp := fun (t : porderType ring_display) (n : t) => [pred p | p < n]
 : forall t : porderType ring_display, t -> simpl_pred t
Unable to unify "true" with "false".
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
(fold_left Ha Hf Hn = fold_left f [] p)
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
"sigT_ind has been translated as sigT_indᵗ"
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Chars 10966 - 10985 [(split;~try~apply~_).] 40.162 secs (0.014u,0.038s)
Chars 10988 - 10989 [-] 0. secs (0.u,0.s)
Chars 10990 - 11006 [(intros~x~y~[?~?]).] 0.001 secs (0.001u,0.s)
Chars 11011 - 11043 [(destruct~(lt_antisym~x~y);~au...] 0.003 secs (0.002u,0.001s)
Chars 11046 - 11047 [-] 0. secs (0.u,0.s)
Chars 11048 - 11065 [(intros~x~y~Exy~z).] 0. secs (0.u,0.s)
Chars 11070 - 11140 [(destruct~(trichotomy~(<)~x~z)...] 0.014 secs (0.011u,0.002s)
Chars 11145 - 11151 [right.] 0. secs (0.u,0.s)
Chars 11152 - 11166 [(rewrite~<-~Exz).] 0. secs (0.u,0.s)
Chars 11167 - 11178 [assumption.] 0. secs (0.u,0.s)
Chars 11181 - 11182 [-] 0. secs (0.u,0.s)
Chars 11183 - 11194 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 11195 - 11246 [(transitivity~(x~<>~y);~[~spli...] 0.013 secs (0.012u,0.s)
Chars 11251 - 11257 [split.] 0.001 secs (0.u,0.001s)
Chars 11262 - 11263 [+] 0. secs (0.u,0.s)
Chars 11264 - 11313 [(destruct~(trichotomy~(<)~x~y)...] 0.037 secs (0.027u,0.009s)
Chars 11320 - 11345 [(intros~E;~contradiction~~E).] 0.001 secs (0.001u,0.s)
Chars 11350 - 11351 [+] 0. secs (0.u,0.s)
Chars 11352 - 11404 [(intros~[?|~?];~[~apply~lt_ne~...] 0.004 secs (0.003u,0.001s)
Building unify_unknown...
Chars 10966 - 10985 [(split;~try~apply~_).] 0. secs (0.u,0.s)
Chars 10990 - 11006 [(intros~x~y~[?~?]).] 0. secs (0.u,0.s)
Chars 11011 - 11043 [(destruct~(lt_antisym~x~y);~au...] 0. secs (0.u,0.s)
Chars 11048 - 11065 [(intros~x~y~Exy~z).] 0. secs (0.u,0.s)
Chars 11070 - 11140 [(destruct~(trichotomy~(<)~x~z)...] 0.002 secs (0.002u,0.s)
Chars 11145 - 11151 [right.] 0. secs (0.u,0.s)
Chars 11152 - 11166 [(rewrite~<-~Exz).] 0. secs (0.u,0.s)
Chars 11167 - 11178 [assumption.] 0. secs (0.u,0.s)
Chars 11183 - 11194 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 11195 - 11246 [(transitivity~(x~<>~y);~[~spli...] 0.001 secs (0.001u,0.s)
Chars 11251 - 11257 [split.] 0. secs (0.u,0.s)
Chars 11264 - 11313 [(destruct~(trichotomy~(<)~x~y)...] 0.001 secs (0.001u,0.s)
Chars 11320 - 11345 [(intros~E;~contradiction~~E).] 0. secs (0.u,0.s)
Chars 11352 - 11404 [(intros~[?|~?];~[~apply~lt_ne~...] 0.001 secs (0.001u,0.s)
Chars 11407 - 11411 [Qed.] 0.005 secs (0.005u,0.s)
Chars 11412 - 11440 [End~dec_strict_setoid_order.] 0.013 secs (0.012u,0.s)
Chars 11442 - 11468 [Section~dec_partial_order.] 0. secs (0.u,0.s)
Chars 11471 - 11517 [Context~`{PartialOrder~A}~`{De...] 0. secs (0.u,0.s)
Chars 11521 - 11577 [Definition~dec_lt~:~Lt~A~:=~fu...] 0. secs (0.u,0.s)
Chars 11581 - 11687 [Context~`{Alt~:~Lt~A}~`{is_mer...] 0.002 secs (0.001u,0.s)
Chars 11691 - 11727 [Instance~dec_order~:~(StrictOr...] 0. secs (0.u,0.s)
Chars 11730 - 11736 [Proof.] 0. secs (0.u,0.s)
Building final ident package...
Proving is_simple_correct0...
"existT has been translated as existTᵗ"
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨0∣ × (∣1⟩ × q2) = Zero)
Crunching: ((sin PI)² = 0 -> q1 × (⟨0∣ × ∣1⟩ × q2) = Zero)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨0∣ × (∣1⟩ × q2) = Zero)
Tactic call ran for 0.957 secs (0.948u,0.007s) (success)
Proving invert_bind_args_raw_to_typed...
Crunching: ((sin PI)² = 0 -> q1 × (⟨0∣ × ∣1⟩ × q2) = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × y)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = x × list2D_to_matrix [[0; 0]])
Tactic call ran for 0.561 secs (0.549u,0.006s) (success)
Proving fold_invert_bind_args...
Crunching: (list2D_to_matrix [[0; 0]; [0; 0]] = Zero)
Tactic call ran for 0.132 secs (0.13u,0.001s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.037 secs (0.036u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Tactic call ran for 1.62 secs (1.58u,0.019s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × y)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = x × list2D_to_matrix [[0; 0]])
Crunching: (list2D_to_matrix [[0; 0]; [0; 0]] = Zero)
Tactic call ran for 3.2 secs (3.163u,0.021s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Crunching:
((fun x z : nat =>
  Σ
    (fun y : nat =>
     Σ (fun y0 : nat => q1 x y0 * (∣1⟩ y y0) ^*) 1 *
     Σ (fun y0 : nat => ∣1⟩ y y0 * q2 y0 z) 1) 2) =
 (fun x z : nat => Σ (fun y : nat => q1 x y * q2 y z) 1))
Crunching: (swap × swap = I (2 * 2))
Crunching: (swap × swap = I (2 * 2))
Reifying...
Crunching:
(WF_Matrix l ->
 (fun x z : nat =>
  Σ
    (fun y : nat => Σ (fun y0 : nat => l x y0 * swap y0 y) (2 * 2) * swap y z)
    (2 * 2)) = l)
Crunching: (WF_Matrix H6 -> H6 × swap × swap = H6)
Crunching:
(WF_Matrix l ->
 (fun x z : nat =>
  Σ
    (fun y : nat => Σ (fun y0 : nat => l x y0 * swap y0 y) (2 * 2) * swap y z)
    (2 * 2)) = l)
Crunching:
(WF_Matrix l ->
 (fun x z : nat =>
  Σ
    (fun y : nat => Σ (fun y0 : nat => l x y0 * swap y0 y) (2 * 2) * swap y z)
    (2 * 2)) = l)
Crunching:
(WF_Matrix l ->
 (fun x z : nat =>
  Σ
    (fun y : nat => Σ (fun y0 : nat => l x y0 * swap y0 y) (2 * 2) * swap y z)
    (2 * 2)) = l)
Crunching:
((forall x y : nat, (x >= 2 * 2)%nat \/ (y >= 2 * 2)%nat -> l x y = 0) ->
 (fun x z : nat =>
  Σ
    (fun y : nat => Σ (fun y0 : nat => l x y0 * swap y0 y) (2 * 2) * swap y z)
    (2 * 2)) = l)
Compiling decision tree...
Splitting rewrite rules...
Crunching: (WF_Matrix H6 -> H6 × swap × swap = H6)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
   [e11; e12; e13; e14]] = H6 × swap)
Assembling rewrite_head...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Reducing rewrite_head...
Building ident_interp...
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
   [e11; e12; e13; e14]] =
 list2D_to_matrix
   [[H6 0%nat 0%nat; H6 0%nat 2%nat; H6 0%nat 1%nat; H6 0%nat 3%nat];
   [H6 1%nat 0%nat; H6 1%nat 2%nat; H6 1%nat 1%nat; H6 1%nat 3%nat];
   [H6 2%nat 0%nat; H6 2%nat 2%nat; H6 2%nat 1%nat; H6 2%nat 3%nat];
   [H6 3%nat 0%nat; H6 3%nat 2%nat; H6 3%nat 1%nat; H6 3%nat 3%nat]] × swap)
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Tactic call ran for 0.608 secs (0.601u,0.006s) (success)
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Tactic call ran for 6.029 secs (5.874u,0.145s) (success)
Building invert_bind_args_unknown...
Tactic call ran for 0.33 secs (0.324u,0.004s) (success)
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Proving Rewriter_Wf...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Tactic call ran for 0.623 secs (0.622u,0.s) (success)
"paths has been translated as pathsᵗ"
Crunching:
(EQ > 0 ->
 exists alp : R,
   alp > 0 /\
   (forall x : R,
    D_x no_cond H0 x /\ R_dist x H0 < alp -> R_dist (id x) (id H0) < EQ))
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.729 secs (0.716u,0.005s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.457 secs (0.446u,0.008s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.057 secs (0.057u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.029 secs (0.027u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 3.043 secs (2.983u,0.037s) (success)
Chars 11739 - 11745 [split.] 40.166 secs (0.001u,0.033s)
Chars 11748 - 11749 [-] 0. secs (0.u,0.s)
Chars 11750 - 11758 [(apply~_).] 0.001 secs (0.001u,0.s)
Chars 11761 - 11762 [-] 0. secs (0.u,0.s)
Chars 11763 - 11774 [(intros~x~E).] 0. secs (0.u,0.s)
Chars 11775 - 11797 [(apply~lt_correct~in~E).] 0.001 secs (0.001u,0.s)
Chars 11798 - 11827 [(destruct~E~as~[_~[]];~trivial).] 0.002 secs (0.002u,0.s)
Chars 11830 - 11831 [-] 0. secs (0.u,0.s)
Chars 11832 - 11851 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 11856 - 11929 [(apply~lt_correct;~apply~lt_co...] 0.005 secs (0.005u,0.s)
Chars 11934 - 11975 [(destruct~E1~as~[E1a~E1b],~E2~...] 0.003 secs (0.003u,0.s)
Chars 11980 - 11986 [split.] 0.001 secs (0.001u,0.s)
Chars 11991 - 11992 [+] 0. secs (0.u,0.s)
Chars 11993 - 12016 [(transitivity~y;~trivial).] 0.013 secs (0.009u,0.003s)
Chars 12021 - 12022 [+] 0. secs (0.u,0.s)
Chars 12023 - 12033 [(intros~E3).] 0. secs (0.u,0.s)
Chars 12034 - 12047 [(destruct~E2b).] 0.001 secs (0.001u,0.s)
Chars 12054 - 12090 [(apply~(antisymmetry~(≤));~tri...] 0.004 secs (0.003u,0.s)
Chars 12097 - 12110 [(rewrite~<-~E3).] 0.001 secs (0.001u,0.s)
Chars 12111 - 12122 [assumption.] 0. secs (0.u,0.s)
Chars 11739 - 11745 [split.] 0. secs (0.u,0.s)
Chars 11750 - 11758 [(apply~_).] 0. secs (0.u,0.s)
Chars 11763 - 11774 [(intros~x~E).] 0. secs (0.u,0.s)
Chars 11775 - 11797 [(apply~lt_correct~in~E).] 0. secs (0.u,0.s)
Chars 11798 - 11827 [(destruct~E~as~[_~[]];~trivial).] 0. secs (0.u,0.s)
Chars 11832 - 11851 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 11856 - 11929 [(apply~lt_correct;~apply~lt_co...] 0.001 secs (0.001u,0.s)
Chars 11934 - 11975 [(destruct~E1~as~[E1a~E1b],~E2~...] 0. secs (0.u,0.s)
Chars 11980 - 11986 [split.] 0. secs (0.u,0.s)
Chars 11993 - 12016 [(transitivity~y;~trivial).] 0.001 secs (0.001u,0.s)
Chars 12023 - 12033 [(intros~E3).] 0. secs (0.u,0.s)
Chars 12034 - 12047 [(destruct~E2b).] 0. secs (0.u,0.s)
Chars 12054 - 12090 [(apply~(antisymmetry~(≤));~tri...] 0.001 secs (0.001u,0.s)
Chars 12097 - 12110 [(rewrite~<-~E3).] 0. secs (0.u,0.s)
Chars 12111 - 12122 [assumption.] 0. secs (0.u,0.s)
Chars 12125 - 12129 [Qed.] 0.002 secs (0.001u,0.s)
Chars 12133 - 12171 [Context~`{Apart~A}~`{!TrivialA...] 0. secs (0.u,0.s)
Chars 12175 - 12216 [Instance:~(IsApart~A)~:=~dec_s...] 0.001 secs (0.001u,0.s)
Chars 12220 - 12280 [Instance~dec_full_partial_orde...] 0.001 secs (0.001u,0.s)
Chars 12283 - 12289 [Proof.] 0. secs (0.u,0.s)
Tactic call ran for 1.479 secs (1.444u,0.012s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Proving Rewriter_Interp...
Tactic call ran for 2.971 secs (2.93u,0.011s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Crunching:
(WF_Matrix l ->
 (fun x z : nat =>
  Σ
    (fun y : nat => Σ (fun y0 : nat => l x y0 * swap y0 y) (2 * 2) * swap y z)
    (2 * 2)) = l)
Tactic call ran for 4.213 secs (4.196u,0.005s) (success)
Crunching:
(WF_Matrix l ->
 (fun x z : nat =>
  Σ
    (fun y : nat => Σ (fun y0 : nat => l x y0 * swap y0 y) (2 * 2) * swap y z)
    (2 * 2)) = l)
Reifying...
Tactic call ran for 2.004 secs (1.986u,0.006s) (success)
Crunching:
(WF_Matrix l ->
 (fun x z : nat =>
  Σ
    (fun y : nat => Σ (fun y0 : nat => l x y0 * swap y0 y) (2 * 2) * swap y z)
    (2 * 2)) = l)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 74.722 secs (73.467u,0.863s) (successful)
"isequiv has been translated as isequivᵗ"
"equiv has been translated as equivᵗ"
"eq has been translated as eqᵗ"
"inverse has been translated as inverseᵗ"
"contr has been translated as contrᵗ"
"weakFunext has been translated as weakFunextᵗ"
Compiling decision tree...
Splitting rewrite rules...
Finished transaction in 3.519 secs (3.456u,0.053s) (successful)
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.432 secs (0.42u,0.01s) (success)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
ltk0 : 0 <= k
ltkn : k + 1 < n
Unable to unify "true" with "false".
Finished transaction in 3.665 secs (3.591u,0.062s) (successful)
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
ltk0 : 0 <= k
ltkn : k + 1 < n
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
ltk0 : 0 <= k
ltkn : k + 1 < n
Unable to unify "true" with "false".
Tactic call ran for 1.876 secs (1.836u,0.035s) (success)
Tactic call ran for 0.284 secs (0.274u,0.008s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.417 secs (0.405u,0.01s) (success)
Tactic call ran for 3.252 secs (3.076u,0.144s) (success)
Proving Rewriter_Interp...
Crunching: (Rmax a b = a)
Crunching: (Rmax a b = a)
Tactic call ran for 3.322 secs (3.281u,0.023s) (success)
Crunching:
(forall d2 : R,
 H2 > 0 -> d2 > 0 -> Rabs (N0 - E0) < Rmin H2 d2 -> E0 - H2 <= N0 <= E0 + d2)
Tactic call ran for 2.522 secs (2.474u,0.028s) (success)
"idpath has been translated as idpathᵗ"
Assembling verified rewriter...
Refining with verified rewriter...
Crunching: (E0 - l <= f)
Chars 12292 - 12310 [(split;~try~apply~_).] 40.173 secs (0.005u,0.035s)
Chars 12313 - 12320 [(intros).] 0. secs (0.u,0.s)
Chars 12321 - 12420 [(transitivity~(x~<=~y~/\~x~<>~...] 0.027 secs (0.023u,0.003s)
Chars 12423 - 12440 [(apply~lt_correct).] 0.001 secs (0.u,0.s)
Chars 12292 - 12310 [(split;~try~apply~_).] 0.002 secs (0.001u,0.s)
Chars 12313 - 12320 [(intros).] 0. secs (0.u,0.s)
Chars 12321 - 12420 [(transitivity~(x~<=~y~/\~x~<>~...] 0.008 secs (0.008u,0.s)
Chars 12423 - 12440 [(apply~lt_correct).] 0. secs (0.u,0.s)
Chars 12443 - 12447 [Qed.] 0.002 secs (0.001u,0.001s)
Chars 12451 - 12483 [Context~`{!TotalRelation~(≤)}.] 0. secs (0.u,0.s)
Chars 12487 - 12512 [Instance:~(Trichotomy~(<)).] 0. secs (0.u,0.s)
Chars 12515 - 12521 [Proof.] 0. secs (0.u,0.s)
Crunching: (forall y : nat, (H'2 >= 2)%nat \/ (y >= 1)%nat -> ∣0⟩ H'2 y = 0)
Crunching: (forall y : nat, (H'2 >= 2)%nat \/ (y >= 1)%nat -> ∣0⟩ H'2 y = 0)
Crunching: (forall y : nat, (H'2 >= 2)%nat \/ (y >= 1)%nat -> ∣0⟩ H'2 y = 0)
Crunching: (forall y : nat, (H'2 >= 2)%nat \/ (y >= 1)%nat -> ∣0⟩ H'2 y = 0)
Crunching: (forall y : nat, (H'2 >= 2)%nat \/ (y >= 1)%nat -> ∣0⟩ H'2 y = 0)
Crunching:
(Z.abs_N (Z.rem (Z.pos NF) (Z.pos x)) =
 Z.to_N (Z.of_N (Z.to_N (Z.of_N (Z.to_N (Z.of_N (N.pos NF mod N.pos x)))))))
Crunching:
(Z.abs_N (Z.rem (Z.pos NF) (Z.pos x)) =
 Z.to_N (Z.of_N (Z.to_N (Z.of_N (Z.to_N (Z.of_N (N.pos NF mod N.pos x)))))))
Crunching: (∣0⟩ H'2 y = 0)
Crunching: (∣0⟩ H'2 y = 0)
"paths_ind has been translated as paths_indᵗ"
Crunching: (forall y : nat, (H'2 >= 2)%nat \/ (y >= 1)%nat -> ∣0⟩ H'2 y = 0)
"Funext has been translated as Funextᵗ"
Chars 12524 - 12535 [(intros~x~y).] 40.151 secs (0.u,0.033s)
Chars 12538 - 12571 [(destruct~(dec~(x~=~y));~try~a...] 0.034 secs (0.031u,0.002s)
Chars 12574 - 12645 [(destruct~(total~(≤)~x~y);~[~l...] 0.016 secs (0.015u,0.s)
Chars 12648 - 12659 [(split;~auto).] 0.004 secs (0.004u,0.s)
Chars 12662 - 12695 [(intro~E;~apply~symmetry~in~E;...] 0.004 secs (0.004u,0.s)
Chars 12524 - 12535 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 12538 - 12571 [(destruct~(dec~(x~=~y));~try~a...] 0.002 secs (0.002u,0.s)
Chars 12574 - 12645 [(destruct~(total~(≤)~x~y);~[~l...] 0.005 secs (0.003u,0.001s)
Chars 12648 - 12659 [(split;~auto).] 0.001 secs (0.001u,0.s)
Chars 12662 - 12695 [(intro~E;~apply~symmetry~in~E;...] 0.001 secs (0.u,0.s)
Chars 12698 - 12702 [Qed.] 0.002 secs (0.002u,0.s)
Chars 12706 - 12776 [Instance~dec_pseudo_order~:~(P...] 0.002 secs (0.002u,0.s)
Chars 12780 - 12838 [Instance~dec_full_pseudo_order...] 0.001 secs (0.001u,0.s)
Chars 12841 - 12847 [Proof.] 0. secs (0.u,0.s)
Closed under the global context
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (∣0⟩⟨0∣ x y = 0)
Crunching: (∣0⟩⟨0∣ x y = 0)
Crunching: (∣0⟩⟨0∣ x y = 0)
Crunching: (∣0⟩⟨0∣ x y = 0)
Crunching: (∣0⟩⟨0∣ x y = 0)
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (∣0⟩⟨0∣ a Ha = 0)
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (∣0⟩⟨0∣ a Ha = 0)
Crunching: (WF_Matrix ∣0⟩⟨0∣)
"FALSE has been translated as FALSEᵗ"
Chars 12850 - 12869 [(split;~try~apply~_).] 40.201 secs (0.017u,0.039s)
Chars 12872 - 12883 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 12886 - 12892 [split.] 0.001 secs (0.001u,0.s)
Chars 12895 - 12896 [-] 0. secs (0.u,0.s)
Chars 12897 - 12908 [(intros~?~E).] 0. secs (0.u,0.s)
Chars 12909 - 12952 [(apply~lt_correct~in~E;~destru...] 0.003 secs (0.001u,0.001s)
Chars 12957 - 12995 [(apply~(antisymmetry~(≤));~ass...] 0.004 secs (0.004u,0.s)
Chars 12998 - 12999 [-] 0. secs (0.u,0.s)
Chars 13000 - 13010 [(intros~E1).] 0. secs (0.u,0.s)
Chars 13015 - 13051 [(destruct~(total~(≤)~x~y);~tri...] 0.007 secs (0.005u,0.002s)
Chars 13056 - 13090 [(destruct~(dec~(x~=~y))~as~[E2...] 0.029 secs (0.023u,0.005s)
Chars 13095 - 13096 [+] 0. secs (0.u,0.s)
Chars 13097 - 13108 [(rewrite~E2).] 0.001 secs (0.001u,0.s)
Chars 13109 - 13127 [(apply~reflexivity).] 0.003 secs (0.003u,0.s)
Chars 13132 - 13133 [+] 0. secs (0.u,0.s)
Chars 13134 - 13146 [(destruct~E1).] 0.002 secs (0.002u,0.s)
Chars 13147 - 13175 [(apply~lt_correct;~split;~auto).] 0.006 secs (0.006u,0.s)
Chars 13182 - 13213 [(apply~symmetric_neq;~assumpti...] 0.002 secs (0.002u,0.s)
Chars 12850 - 12869 [(split;~try~apply~_).] 0.001 secs (0.001u,0.s)
Chars 12872 - 12883 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 12886 - 12892 [split.] 0. secs (0.u,0.s)
Chars 12897 - 12908 [(intros~?~E).] 0. secs (0.u,0.s)
Chars 12909 - 12952 [(apply~lt_correct~in~E;~destru...] 0.001 secs (0.001u,0.s)
Chars 12957 - 12995 [(apply~(antisymmetry~(≤));~ass...] 0.001 secs (0.001u,0.s)
Chars 13000 - 13010 [(intros~E1).] 0. secs (0.u,0.s)
Chars 13015 - 13051 [(destruct~(total~(≤)~x~y);~tri...] 0.001 secs (0.001u,0.s)
Chars 13056 - 13090 [(destruct~(dec~(x~=~y))~as~[E2...] 0. secs (0.u,0.s)
Chars 13097 - 13108 [(rewrite~E2).] 0. secs (0.u,0.s)
Chars 13109 - 13127 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 13134 - 13146 [(destruct~E1).] 0. secs (0.u,0.s)
Chars 13147 - 13175 [(apply~lt_correct;~split;~auto).] 0.002 secs (0.002u,0.s)
Chars 13182 - 13213 [(apply~symmetric_neq;~assumpti...] 0.001 secs (0.001u,0.s)
Chars 13216 - 13220 [Qed.] 0.002 secs (0.001u,0.s)
Chars 13221 - 13243 [End~dec_partial_order.] 0.058 secs (0.056u,0.001s)
Chars 13245 - 13311 [Lemma~lt_eq_trans~`{Lt~A}~:~fo...] 0.001 secs (0.u,0.001s)
Chars 13312 - 13318 [Proof.] 0. secs (0.u,0.s)
Chars 13319 - 13342 [(intros~?~?~?~?~[];~trivial).] 1.494 secs (0.001u,0.034s)
Chars 13319 - 13342 [(intros~?~?~?~?~[];~trivial).] 0. secs (0.u,0.s)
Chars 13343 - 13347 [Qed.] 0. secs (0.u,0.s)
Chars 13349 - 13364 [Section~pseudo.] 0. secs (0.u,0.s)
Chars 13367 - 13386 [Context~{A~:~Type}.] 0. secs (0.u,0.s)
Chars 13389 - 13414 [Context~`{PseudoOrder~A}.] 0. secs (0.u,0.s)
Chars 13418 - 13479 [Lemma~nlt_lt_trans~{x~y~z~:~A}...] 0. secs (0.u,0.s)
Chars 13482 - 13488 [Proof.] 0. secs (0.u,0.s)
Crunching: (∣0⟩⟨0∣ a Ha = 0)
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (∣0⟩⟨0∣ a Ha = 0)
     = 87
     : positive
Crunching:
((if a
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => (R0, R0)
              end
   | 1%nat => match y with
              | 0%nat => (R1, R0)
              | S _ => (R0, R0)
              end
   | S (S _) => (R0, R0)
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => (R1, R0)
              | S _ => (R0, R0)
              end
   | 1%nat => match y with
              | 0%nat | _ => (R0, R0)
              end
   | S (S _) => (R0, R0)
   end) x
   (S
      ((fix sub (n m : nat) {struct n} : nat :=
          match n with
          | 0%nat => n
          | S k => match m with
                   | 0%nat => n
                   | S l => sub k l
                   end
          end) y 1%nat)) = (R0, R0))
"UIP has been translated as UIPᵗ"
Chars 13493 - 13511 [(intros~nltyx~ltyz).] 40.165 secs (0.u,0.033s)
Chars 13516 - 13553 [(pose~proof~(cotransitive~ltyz...] 0.002 secs (0.001u,0.s)
Chars 13558 - 13576 [strip_truncations.] 0.072 secs (0.063u,0.008s)
Chars 13581 - 13610 [(destruct~disj~as~[ltyx|~ltxz]).] 0.001 secs (0.001u,0.s)
Chars 13615 - 13616 [-] 0. secs (0.u,0.s)
Chars 13617 - 13639 [(destruct~(nltyx~ltyx)).] 0.001 secs (0.001u,0.s)
Chars 13644 - 13645 [-] 0. secs (0.u,0.s)
Chars 13646 - 13657 [exact~ltxz.] 0. secs (0.u,0.s)
Chars 13493 - 13511 [(intros~nltyx~ltyz).] 0. secs (0.u,0.s)
Chars 13516 - 13553 [(pose~proof~(cotransitive~ltyz...] 0. secs (0.u,0.s)
Chars 13558 - 13576 [strip_truncations.] 0. secs (0.u,0.s)
Chars 13581 - 13610 [(destruct~disj~as~[ltyx|~ltxz]).] 0. secs (0.u,0.s)
Chars 13617 - 13639 [(destruct~(nltyx~ltyx)).] 0. secs (0.u,0.s)
Chars 13646 - 13657 [exact~ltxz.] 0. secs (0.u,0.s)
Chars 13660 - 13664 [Qed.] 0.001 secs (0.001u,0.s)
Chars 13668 - 13729 [Lemma~lt_nlt_trans~{x~y~z~:~A}...] 0.001 secs (0.u,0.s)
Chars 13732 - 13738 [Proof.] 0. secs (0.u,0.s)
Crunching: (m + - H5 <= Hm)
Crunching: (m + - EQ <= Hm <= m + LT)
Crunching: (m + - EQ <= Hm <= m + LT)
Crunching: (m + - EQ <= Hm <= m + LT)
Crunching: (m + - EQ <= Hm <= m + LT)
clear  IHl  :  (False -> List.forallb p l = true)
C87' = 
fun (A : Type) (x : A) =>
x0 <--- x times x;
x1 <--- x0 times x;
x2 <--- x1 times x1;
x3 <--- x2 times x;
x4 <--- x3 times x1;
x5 <--- x4 times x4;
x6 <--- x5 times x5; x7 <--- x6 times x6; x8 <--- x7 times x3; Return x8
     : forall A : Type, A -> computation

Arguments C87' A%type_scope x
Crunching: (bool_to_matrix H H0 0%nat = 0)
Crunching: (bool_to_matrix H H0 0%nat = 0)
Crunching: (∣0⟩⟨0∣ a H = 0)
Crunching: (∣0⟩⟨0∣ a H = (sin PI * sin PI)%R)
Chars 13743 - 13761 [(intros~ltxy~nltzy).] 40.184 secs (0.018u,0.041s)
Chars 13766 - 13803 [(pose~proof~(cotransitive~ltxy...] 0.002 secs (0.u,0.002s)
Chars 13808 - 13826 [strip_truncations.] 0.074 secs (0.065u,0.008s)
Chars 13831 - 13860 [(destruct~disj~as~[ltxz|~ltzy]).] 0.001 secs (0.001u,0.s)
Chars 13865 - 13866 [-] 0. secs (0.u,0.s)
Chars 13867 - 13878 [exact~ltxz.] 0. secs (0.u,0.s)
Chars 13883 - 13884 [-] 0. secs (0.u,0.s)
Chars 13885 - 13907 [(destruct~(nltzy~ltzy)).] 0.001 secs (0.001u,0.s)
Chars 13743 - 13761 [(intros~ltxy~nltzy).] 0. secs (0.u,0.s)
Chars 13766 - 13803 [(pose~proof~(cotransitive~ltxy...] 0. secs (0.u,0.s)
Chars 13808 - 13826 [strip_truncations.] 0. secs (0.u,0.s)
Chars 13831 - 13860 [(destruct~disj~as~[ltxz|~ltzy]).] 0. secs (0.u,0.s)
Chars 13867 - 13878 [exact~ltxz.] 0. secs (0.u,0.s)
Chars 13885 - 13907 [(destruct~(nltzy~ltzy)).] 0. secs (0.u,0.s)
Chars 13910 - 13914 [Qed.] 0.001 secs (0.001u,0.s)
Chars 13918 - 13962 [Lemma~lt_transitive~:~Transiti...] 0. secs (0.u,0.s)
Chars 13965 - 13971 [Proof.] 0. secs (0.u,0.s)
"False has been translated as Falseᵗ"
Crunching: (bool_to_matrix H H0 0%nat = 0)
"equiv has been translated as equivᵗ"
Crunching: (bool_to_matrix H H0 0%nat = 0)
Crunching: (∣ 0 ⟩ H' y = 0)
Crunching: (∣ 0 ⟩ H' y = 0)
Crunching: (fst (∣ n ⟩ e' y) = fst 0)
Chars 13976 - 13999 [(intros~x~y~z~ltxy~ltyz).] 40.19 secs (0.u,0.033s)
Chars 14004 - 14042 [(pose~proof~(cotransitive~ltxy...] 0.002 secs (0.001u,0.s)
Chars 14047 - 14065 [strip_truncations.] 0.073 secs (0.06u,0.012s)
Chars 14070 - 14100 [(destruct~ltxyz~as~[ltxz|~ltzy]).] 0.001 secs (0.001u,0.s)
Chars 14105 - 14106 [-] 0. secs (0.u,0.s)
Chars 14107 - 14118 [assumption.] 0. secs (0.u,0.s)
Chars 14123 - 14124 [-] 0. secs (0.u,0.s)
Chars 14125 - 14175 [(destruct~(pseudo_order_antisy...] 0.003 secs (0.003u,0.s)
Chars 13976 - 13999 [(intros~x~y~z~ltxy~ltyz).] 0. secs (0.u,0.s)
Chars 14004 - 14042 [(pose~proof~(cotransitive~ltxy...] 0. secs (0.u,0.s)
Chars 14047 - 14065 [strip_truncations.] 0. secs (0.u,0.s)
Chars 14070 - 14100 [(destruct~ltxyz~as~[ltxz|~ltzy]).] 0. secs (0.u,0.s)
Chars 14107 - 14118 [assumption.] 0. secs (0.u,0.s)
Chars 14125 - 14175 [(destruct~(pseudo_order_antisy...] 0. secs (0.u,0.s)
Chars 14178 - 14182 [Qed.] 0.001 secs (0.001u,0.s)
Chars 14186 - 14225 [#[global]Existing~Instance~lt_...] 0. secs (0.u,0.s)
Chars 14227 - 14238 [End~pseudo.] 0.006 secs (0.006u,0.s)
Crunching: (0%nat <> 2%nat -> WF_Matrix (bools_to_matrix r))
Crunching: (bools_to_matrix M_nat H4 y = 0)
Crunching: (0%nat <> 2%nat -> WF_Matrix (bools_to_matrix r))
Crunching: nat
Crunching: (bools_to_matrix M_nat H4 y = 0)
Crunching: (bools_to_matrix l 0%nat y = 0)
Crunching: (bools_to_matrix l 0%nat y = 0)
(ret [[0.33333333333332099; 0.33333333333334692]])
(ret [[0.39052428152232477; 0.3905243021208048]])
(ret [[0.39051452913860984; 0.39053541828418686]])
(ret [[0.40546510799655183; 0.40546510821793463]])
(ret [[0.40546510810804604; 0.40546510810828312]])
Crunching: (forall H : nat, ∣Φ+⟩ H H1 = R0)
(ret [[0.33333333333332099; 0.33333333333334692]])
(ret [[0.39052428152232477; 0.3905243021208048]])
(ret [[0.39051452913860984; 0.39053541828418686]])
(ret [[0.40546510799655183; 0.40546510821793463]])
(ret [[0.40546510810804604; 0.40546510810828312]])
type_is_by_reference: type -> bool
is_numeric_type: type -> bool
type_is_by_value: type -> bool
is_long_type: type -> bool
is_pointer_type: type -> bool
is_anyfloat_type: type -> bool
is_ptrofs_type: type -> bool
bool_type: type -> bool
is_int32_type: type -> bool
is_int_type: type -> bool
is_scalar_type: type -> bool
is_float_type: type -> bool
is_single_type: type -> bool
type_is_volatile: type -> bool
same_base_type: type -> type -> bool
is_neutral_cast: type -> type -> bool
eqb_type: type -> type -> bool
composite_compute.complete_legal_cosu_type: composite_env -> type -> bool
complete_type: composite_env -> type -> bool
complete_or_function_type: composite_env -> type -> bool
align_mem.LegalAlignasStrong.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrict.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrongFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrictFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
Crunching: False
Crunching: (forall x y : nat, x < n -> y < n -> f x = f y -> x = y)
Crunching:
(forall f : nat -> nat,
 permutation Hq f -> forall x y : nat, x < Hq -> y < Hq -> f x = f y -> x = y)
Crunching:
(forall y : nat, (b >= 0)%nat \/ (y >= 0)%nat -> control U b y = 0)
Crunching:
((b >= 0 + (0 + 0))%nat \/ (zx0 >= 0 + (0 + 0))%nat -> control U b zx0 = 0)
Crunching:
((b >= 0 + (0 + 0))%nat \/ (Hb >= 0 + (0 + 0))%nat -> control U b Hb = 0)
Crunching: (0 <= Cmod2 n)
Crunching: (0 <= Cmod2 n)
Crunching:
(forall y : nat,
 (Hpq >= 2 ^ m)%nat \/ (y >= 2 ^ m)%nat -> pad n m H Hpq y = 0)
Crunching:
(forall y : nat, (f >= 2 ^ m)%nat \/ (y >= 2 ^ m)%nat -> pad n m H f y = 0)
Crunching:
(WF_Matrix Ha -> WF_Matrix H -> Ha .⊕ H = ∣0⟩⟨0∣ ⊗ Ha .+ ∣1⟩⟨1∣ ⊗ H)
Crunching: False
Crunching: False
Crunching: (nat -> False)
Crunching:
(forall (n : nat) (f g : nat -> nat),
 permutation n f -> permutation n g -> permutation n (f ∘ g)%prg)
Crunching: (0 < 1 -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
Crunching: (0 <= Cmod2 n)
Crunching: (0 < Cmod2 Hx)
Crunching: (0 < 1 -> ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B = A .⊕ B)
Crunching: (-1 <= / 3 <= 1)%R
Crunching: (0 < 1 -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (permutation 0 (y ∘ Hn)%prg)
Crunching: (0 < 1 -> ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B = A .⊕ B)
Crunching: (permutation E0 y -> permutation E0 (x ∘ y)%prg)
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hnm)),
 pad start Hpq A × pad start Hpq B = pad start Hpq (A × B))
Crunching: Z
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (hadamard) † × hadamard)
Crunching:
(list2D_to_matrix
   [[(C1 / √ 2) ^* * (C1 / √ 2) + (C1 / √ 2) ^* * (C1 / √ 2);
    (C1 / √ 2) ^* * (C1 / √ 2) + (C1 / √ 2) ^* * - (C1 / √ 2)];
   [(C1 / √ 2) ^* * (C1 / √ 2) + (- (C1 / √ 2)) ^* * (C1 / √ 2);
   (C1 / √ 2) ^* * (C1 / √ 2) + (- (C1 / √ 2)) ^* * - (C1 / √ 2)]] = 
 I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (σx) † × σx)
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
Crunching:
((fun x z : nat => Σ (fun y : nat => (σy) † x y * σy y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
((fun x z : nat => Σ (fun y : nat => (σz) † x y * σz y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (permutation HE (fswap f x HE))
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift ϕ) † × phase_shift ϕ)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp ϕ) ^* * Cexp ϕ]] = I 2)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching:
(WF_Matrix (phase_shift H') /\ (phase_shift H') † × phase_shift H' = I 2)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching:
(WF_Matrix (phase_shift (H' + 0)) /\
 (phase_shift H') † × phase_shift H' = I 2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift h) † × phase_shift h)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp h) ^* * Cexp h]] = I 2)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching: (I (2 ^ dim) = pad 0 dim (I 2))
Crunching: ((sin PI2)² <= 1²)
Crunching: (permutation HE (fswap f x HE))
Crunching: (1² <= (sin PI2)²)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching: ((sin PI2)² <= 1²)
Crunching: (forall x0 : nat, ((phase_shift x) † × phase_shift x) x0 = I 2 x0)
Crunching: (((phase_shift x) † × phase_shift x) H3 = I 2 H3)
Crunching: (1² <= (sin PI2)²)
Crunching: ((sin PI2)² <= 1²)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching: (forall x0 : nat, ((phase_shift x) † × phase_shift x) x0 = I 2 x0)
Crunching: (((phase_shift x) † × phase_shift x) H3 = I 2 H3)
Crunching: (b n = a -> permutation a (fswap b n a))
Crunching: (b n = a -> permutation a (fswap b n a))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (forall x0 : nat, ((phase_shift x) † × phase_shift x) x0 = I 2 x0)
Crunching: (((phase_shift x) † × phase_shift x) H3 = I 2 H3)
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching: (forall x0 : nat, ((phase_shift x) † × phase_shift x) x0 = I 2 x0)
Crunching: (((phase_shift x) † × phase_shift x) H3 = I 2 H3)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching: (forall x0 : nat, ((phase_shift x) † × phase_shift x) x0 = I 2 x0)
Crunching: (I (2 ^ dim) = pad 0 dim (I 2))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching: (forall x0 : nat, ((phase_shift x) † × phase_shift x) x0 = I 2 x0)
Crunching: (permutation (b c) (fswap b c (b c)))
Crunching: (permutation (b c) (fswap b c (b c)))
Crunching: False
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching: (forall x0 : nat, ((phase_shift x) † × phase_shift x) x0 = I 2 x0)
Crunching: (c < S a -> 0 = a -> permutation a (fswap b c a))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching:
((q >= 2 ^ abs)%nat \/ (Hqgt0 >= 2 ^ abs)%nat ->
 (if 0 + 1 <=? abs then I (2 ^ 0) ⊗ I 2 ⊗ I (2 ^ (abs - (0 + 1))) else Zero)
   q Hqgt0 = 0)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Finished transaction in 9.074 secs (8.91u,0.138s) (successful)
Crunching: (forall x0 : nat, ((phase_shift x) † × phase_shift x) x0 = I 2 x0)
Finished transaction in 0.022 secs (0.021u,0.s) (successful)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching:
((q >= 2 ^ abs)%nat \/ (Hqgt0 >= 2 ^ abs)%nat ->
 (if 0 + 1 <=? abs then I (2 ^ 0) ⊗ I 2 ⊗ I (2 ^ (abs - (0 + 1))) else Zero)
   q Hqgt0 = 0)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp x) ^* * Cexp x]] = I 2)
Crunching: (b n = a -> permutation a (fswap b n a))
Crunching: (b n = a -> permutation a (fswap b n a))
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Finished transaction in 6.513 secs (6.426u,0.068s) (successful)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift ϕ) † × phase_shift ϕ)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp ϕ) ^* * Cexp ϕ]] = I 2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (permutation (b c) (fswap b c (b c)))
Crunching: (permutation (b c) (fswap b c (b c)))
Crunching: (c < S a -> 0 = a -> permutation a (fswap b c a))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift ϕ) † × phase_shift ϕ)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (list2D_to_matrix [[C1; 0]; [0; (Cexp ϕ) ^* * Cexp ϕ]] = I 2)
Crunching:
(nN < S X_enc -> n nN = X_enc -> permutation X_enc (fswap n nN X_enc))
Crunching:
((fun x z : nat => Σ (fun y : nat => (Sgate y x) ^* * Sgate y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (Sgate) † × Sgate)
Crunching:
(list2D_to_matrix [[C1; 0]; [0; (Cexp (PI / 2)) ^* * Cexp (PI / 2)]] = I 2)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching:
((fun x z : nat => Σ (fun y : nat => (Sgate y x) ^* * Sgate y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (Sgate) † × Sgate)
Crunching:
(list2D_to_matrix [[C1; 0]; [0; (Cexp (PI / 2)) ^* * Cexp (PI / 2)]] = I 2)
Crunching: (sum_over_list (P :: l) = (P + sum_over_list l)%R)
Crunching: (forall x y z : R, - z < y - x -> x < y + z)
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
Crunching:
((fun x z : nat => Σ (fun y : nat => (Sgate y x) ^* * Sgate y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (Sgate) † × Sgate)
Crunching: Z
Crunching:
(list2D_to_matrix [[C1; 0]; [0; (Cexp (PI / 2)) ^* * Cexp (PI / 2)]] = I 2)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0) =
 (fun x z : nat => Σ (fun y : nat => (Sgate y x) ^* * Sgate y z) 2))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (Sgate) † × Sgate)
Crunching:
(I 2 = list2D_to_matrix [[C1; 0]; [0; (Cexp (PI / 2)) ^* * Cexp (PI / 2)]])
Crunching: (forall x0 : nat, x0 < S n' -> v x0 x y = v (f x0) x y)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(R -> R -> big_sum n eps0_pos = big_sum (fun i0 : nat => n (i i0)) eps0_pos)
Crunching:
((fun x z : nat => Σ (fun y : nat => (Sgate y x) ^* * Sgate y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (Sgate) † × Sgate)
Crunching:
(list2D_to_matrix [[C1; 0]; [0; (Cexp (PI / 2)) ^* * Cexp (PI / 2)]] = I 2)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0) =
 (fun x z : nat => Σ (fun y : nat => (Sgate y x) ^* * Sgate y z) 2))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (Sgate) † × Sgate)
Crunching:
(I 2 = list2D_to_matrix [[C1; 0]; [0; (Cexp (PI / 2)) ^* * Cexp (PI / 2)]])
Crunching: (l < eps0_pos -> H1 l = H1 (n l))
Crunching:
((Ha >= 2 ^ dim)%nat \/ (B >= 2 ^ dim)%nat -> pad_u dim 0 u Ha B = 0)
Crunching: (l < eps0_pos -> H1 l = H1 (n l))
Crunching:
(big_sum H1 eps0_pos x y = big_sum (fun i : nat => H1 (H4 i)) eps0_pos x y)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(big_sum (fun i : nat => nth i (a ++ b) 0) (length (a ++ b)) =
 (big_sum (fun i : nat => nth i a 0) (length a) +
  big_sum (fun i : nat => nth i b 0) (length b))%R)
Crunching: (sum_over_list (b ++ c) = (sum_over_list b + sum_over_list c)%R)
Crunching: (x = y)
specialized IHeP using (eq_refl e )
Crunching:
(((R1 + R1) *
  (/ (R1 + (R1 + R1)) *
   (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
      match x0 with
      | 0%nat => R1
      | S x1 => x * Ffix x x1
      end) (/ (R1 + (R1 + R1)))
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           (S
              ((fix Ffix (x x0 : nat) {struct x} : nat :=
                  match x with
                  | 0%nat => x0
                  | S x1 => S (Ffix x1 x0)
                  end) H3 0%nat))) 1%nat) *
   /
   match
     (fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          (S
             ((fix Ffix (x x0 : nat) {struct x} : nat :=
                 match x with
                 | 0%nat => x0
                 | S x1 => S (Ffix x1 x0)
                 end) H3 0%nat))) 1%nat
   with
   | 0%nat => R1
   | S _ =>
       (fix Ffix (x0 : nat) : R :=
          match x0 with
          | 0%nat => R0
          | 1%nat => R1
          | S (S _ as x1) => Ffix x1 + R1
          end)
         ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
             match x0 with
             | 0%nat => x1
             | S x2 => S (Ffix x2 x1)
             end)
            ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                match x0 with
                | 0%nat => x1
                | S x2 => S (Ffix x2 x1)
                end) H3
               (S
                  ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                      match x0 with
                      | 0%nat => x1
                      | S x2 => S (Ffix x2 x1)
                      end) H3 0%nat))) 1%nat) + R1
   end) +
  / (R1 + (R1 + R1) * (R1 + (R1 + R1))) *
  (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
     match x0 with
     | 0%nat => R1
     | S x1 => x * Ffix x x1
     end) (/ (R1 + (R1 + R1) * (R1 + (R1 + R1))))
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          (S
             ((fix Ffix (x x0 : nat) {struct x} : nat :=
                 match x with
                 | 0%nat => x0
                 | S x1 => S (Ffix x1 x0)
                 end) H3 0%nat))) 1%nat) *
  /
  match
    (fix Ffix (x x0 : nat) {struct x} : nat :=
       match x with
       | 0%nat => x0
       | S x1 => S (Ffix x1 x0)
       end)
      ((fix Ffix (x x0 : nat) {struct x} : nat :=
          match x with
          | 0%nat => x0
          | S x1 => S (Ffix x1 x0)
          end) H3
         (S
            ((fix Ffix (x x0 : nat) {struct x} : nat :=
                match x with
                | 0%nat => x0
                | S x1 => S (Ffix x1 x0)
                end) H3 0%nat))) 1%nat
  with
  | 0%nat => R1
  | S _ =>
      (fix Ffix (x0 : nat) : R :=
         match x0 with
         | 0%nat => R0
         | 1%nat => R1
         | S (S _ as x1) => Ffix x1 + R1
         end)
        ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
            match x0 with
            | 0%nat => x1
            | S x2 => S (Ffix x2 x1)
            end)
           ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
               match x0 with
               | 0%nat => x1
               | S x2 => S (Ffix x2 x1)
               end) H3
              (S
                 ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                     match x0 with
                     | 0%nat => x1
                     | S x2 => S (Ffix x2 x1)
                     end) H3 0%nat))) 1%nat) + R1
  end <
  (R1 + R1) *
  ((fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
      match x0 with
      | 0%nat => R1
      | S x1 => x * Ffix x x1
      end) (/ (R1 + (R1 + R1)))
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           ((fix Ffix (x x0 : nat) {struct x} : nat :=
               match x with
               | 0%nat => x0
               | S x1 => S (Ffix x1 x0)
               end) H3 0%nat)) 1%nat) *
   /
   (fix Ffix (x : nat) : R :=
      match x with
      | 0%nat => R0
      | 1%nat => R1
      | S (S _ as x0) => Ffix x0 + R1
      end)
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           ((fix Ffix (x x0 : nat) {struct x} : nat :=
               match x with
               | 0%nat => x0
               | S x1 => S (Ffix x1 x0)
               end) H3 0%nat)) 1%nat)) +
  (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
     match x0 with
     | 0%nat => R1
     | S x1 => x * Ffix x x1
     end) (/ (R1 + (R1 + R1) * (R1 + (R1 + R1))))
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          ((fix Ffix (x x0 : nat) {struct x} : nat :=
              match x with
              | 0%nat => x0
              | S x1 => S (Ffix x1 x0)
              end) H3 0%nat)) 1%nat) *
  /
  (fix Ffix (x : nat) : R :=
     match x with
     | 0%nat => R0
     | 1%nat => R1
     | S (S _ as x0) => Ffix x0 + R1
     end)
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          ((fix Ffix (x x0 : nat) {struct x} : nat :=
              match x with
              | 0%nat => x0
              | S x1 => S (Ffix x1 x0)
              end) H3 0%nat)) 1%nat))%R \/
 ((R1 + R1) *
  (/ (R1 + (R1 + R1)) *
   (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
      match x0 with
      | 0%nat => R1
      | S x1 => x * Ffix x x1
      end) (/ (R1 + (R1 + R1)))
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           (S
              ((fix Ffix (x x0 : nat) {struct x} : nat :=
                  match x with
                  | 0%nat => x0
                  | S x1 => S (Ffix x1 x0)
                  end) H3 0%nat))) 1%nat) *
   /
   match
     (fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          (S
             ((fix Ffix (x x0 : nat) {struct x} : nat :=
                 match x with
                 | 0%nat => x0
                 | S x1 => S (Ffix x1 x0)
                 end) H3 0%nat))) 1%nat
   with
   | 0%nat => R1
   | S _ =>
       (fix Ffix (x0 : nat) : R :=
          match x0 with
          | 0%nat => R0
          | 1%nat => R1
          | S (S _ as x1) => Ffix x1 + R1
          end)
         ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
             match x0 with
             | 0%nat => x1
             | S x2 => S (Ffix x2 x1)
             end)
            ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                match x0 with
                | 0%nat => x1
                | S x2 => S (Ffix x2 x1)
                end) H3
               (S
                  ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                      match x0 with
                      | 0%nat => x1
                      | S x2 => S (Ffix x2 x1)
                      end) H3 0%nat))) 1%nat) + R1
   end) +
  / (R1 + (R1 + R1) * (R1 + (R1 + R1))) *
  (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
     match x0 with
     | 0%nat => R1
     | S x1 => x * Ffix x x1
     end) (/ (R1 + (R1 + R1) * (R1 + (R1 + R1))))
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          (S
             ((fix Ffix (x x0 : nat) {struct x} : nat :=
                 match x with
                 | 0%nat => x0
                 | S x1 => S (Ffix x1 x0)
                 end) H3 0%nat))) 1%nat) *
  /
  match
    (fix Ffix (x x0 : nat) {struct x} : nat :=
       match x with
       | 0%nat => x0
       | S x1 => S (Ffix x1 x0)
       end)
      ((fix Ffix (x x0 : nat) {struct x} : nat :=
          match x with
          | 0%nat => x0
          | S x1 => S (Ffix x1 x0)
          end) H3
         (S
            ((fix Ffix (x x0 : nat) {struct x} : nat :=
                match x with
                | 0%nat => x0
                | S x1 => S (Ffix x1 x0)
                end) H3 0%nat))) 1%nat
  with
  | 0%nat => R1
  | S _ =>
      (fix Ffix (x0 : nat) : R :=
         match x0 with
         | 0%nat => R0
         | 1%nat => R1
         | S (S _ as x1) => Ffix x1 + R1
         end)
        ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
            match x0 with
            | 0%nat => x1
            | S x2 => S (Ffix x2 x1)
            end)
           ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
               match x0 with
               | 0%nat => x1
               | S x2 => S (Ffix x2 x1)
               end) H3
              (S
                 ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                     match x0 with
                     | 0%nat => x1
                     | S x2 => S (Ffix x2 x1)
                     end) H3 0%nat))) 1%nat) + R1
  end)%R =
 ((R1 + R1) *
  ((fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
      match x0 with
      | 0%nat => R1
      | S x1 => x * Ffix x x1
      end) (/ (R1 + (R1 + R1)))
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           ((fix Ffix (x x0 : nat) {struct x} : nat :=
               match x with
               | 0%nat => x0
               | S x1 => S (Ffix x1 x0)
               end) H3 0%nat)) 1%nat) *
   /
   (fix Ffix (x : nat) : R :=
      match x with
      | 0%nat => R0
      | 1%nat => R1
      | S (S _ as x0) => Ffix x0 + R1
      end)
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           ((fix Ffix (x x0 : nat) {struct x} : nat :=
               match x with
               | 0%nat => x0
               | S x1 => S (Ffix x1 x0)
               end) H3 0%nat)) 1%nat)) +
  (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
     match x0 with
     | 0%nat => R1
     | S x1 => x * Ffix x x1
     end) (/ (R1 + (R1 + R1) * (R1 + (R1 + R1))))
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          ((fix Ffix (x x0 : nat) {struct x} : nat :=
              match x with
              | 0%nat => x0
              | S x1 => S (Ffix x1 x0)
              end) H3 0%nat)) 1%nat) *
  /
  (fix Ffix (x : nat) : R :=
     match x with
     | 0%nat => R0
     | 1%nat => R1
     | S (S _ as x0) => Ffix x0 + R1
     end)
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          ((fix Ffix (x x0 : nat) {struct x} : nat :=
              match x with
              | 0%nat => x0
              | S x1 => S (Ffix x1 x0)
              end) H3 0%nat)) 1%nat))%R)
Crunching:
(((R1 + R1) *
  (/ (R1 + (R1 + R1)) *
   (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
      match x0 with
      | 0%nat => R1
      | S x1 => x * Ffix x x1
      end) (/ (R1 + (R1 + R1)))
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           (S
              ((fix Ffix (x x0 : nat) {struct x} : nat :=
                  match x with
                  | 0%nat => x0
                  | S x1 => S (Ffix x1 x0)
                  end) H3 0%nat))) 1%nat) *
   /
   match
     (fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          (S
             ((fix Ffix (x x0 : nat) {struct x} : nat :=
                 match x with
                 | 0%nat => x0
                 | S x1 => S (Ffix x1 x0)
                 end) H3 0%nat))) 1%nat
   with
   | 0%nat => R1
   | S _ =>
       (fix Ffix (x0 : nat) : R :=
          match x0 with
          | 0%nat => R0
          | 1%nat => R1
          | S (S _ as x1) => Ffix x1 + R1
          end)
         ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
             match x0 with
             | 0%nat => x1
             | S x2 => S (Ffix x2 x1)
             end)
            ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                match x0 with
                | 0%nat => x1
                | S x2 => S (Ffix x2 x1)
                end) H3
               (S
                  ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                      match x0 with
                      | 0%nat => x1
                      | S x2 => S (Ffix x2 x1)
                      end) H3 0%nat))) 1%nat) + R1
   end) +
  / (R1 + (R1 + R1) * (R1 + (R1 + R1))) *
  (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
     match x0 with
     | 0%nat => R1
     | S x1 => x * Ffix x x1
     end) (/ (R1 + (R1 + R1) * (R1 + (R1 + R1))))
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          (S
             ((fix Ffix (x x0 : nat) {struct x} : nat :=
                 match x with
                 | 0%nat => x0
                 | S x1 => S (Ffix x1 x0)
                 end) H3 0%nat))) 1%nat) *
  /
  match
    (fix Ffix (x x0 : nat) {struct x} : nat :=
       match x with
       | 0%nat => x0
       | S x1 => S (Ffix x1 x0)
       end)
      ((fix Ffix (x x0 : nat) {struct x} : nat :=
          match x with
          | 0%nat => x0
          | S x1 => S (Ffix x1 x0)
          end) H3
         (S
            ((fix Ffix (x x0 : nat) {struct x} : nat :=
                match x with
                | 0%nat => x0
                | S x1 => S (Ffix x1 x0)
                end) H3 0%nat))) 1%nat
  with
  | 0%nat => R1
  | S _ =>
      (fix Ffix (x0 : nat) : R :=
         match x0 with
         | 0%nat => R0
         | 1%nat => R1
         | S (S _ as x1) => Ffix x1 + R1
         end)
        ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
            match x0 with
            | 0%nat => x1
            | S x2 => S (Ffix x2 x1)
            end)
           ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
               match x0 with
               | 0%nat => x1
               | S x2 => S (Ffix x2 x1)
               end) H3
              (S
                 ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                     match x0 with
                     | 0%nat => x1
                     | S x2 => S (Ffix x2 x1)
                     end) H3 0%nat))) 1%nat) + R1
  end <
  (R1 + R1) *
  ((fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
      match x0 with
      | 0%nat => R1
      | S x1 => x * Ffix x x1
      end) (/ (R1 + (R1 + R1)))
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           ((fix Ffix (x x0 : nat) {struct x} : nat :=
               match x with
               | 0%nat => x0
               | S x1 => S (Ffix x1 x0)
               end) H3 0%nat)) 1%nat) *
   /
   (fix Ffix (x : nat) : R :=
      match x with
      | 0%nat => R0
      | 1%nat => R1
      | S (S _ as x0) => Ffix x0 + R1
      end)
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           ((fix Ffix (x x0 : nat) {struct x} : nat :=
               match x with
               | 0%nat => x0
               | S x1 => S (Ffix x1 x0)
               end) H3 0%nat)) 1%nat)) +
  (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
     match x0 with
     | 0%nat => R1
     | S x1 => x * Ffix x x1
     end) (/ (R1 + (R1 + R1) * (R1 + (R1 + R1))))
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          ((fix Ffix (x x0 : nat) {struct x} : nat :=
              match x with
              | 0%nat => x0
              | S x1 => S (Ffix x1 x0)
              end) H3 0%nat)) 1%nat) *
  /
  (fix Ffix (x : nat) : R :=
     match x with
     | 0%nat => R0
     | 1%nat => R1
     | S (S _ as x0) => Ffix x0 + R1
     end)
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          ((fix Ffix (x x0 : nat) {struct x} : nat :=
              match x with
              | 0%nat => x0
              | S x1 => S (Ffix x1 x0)
              end) H3 0%nat)) 1%nat))%R \/
 ((R1 + R1) *
  (/ (R1 + (R1 + R1)) *
   (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
      match x0 with
      | 0%nat => R1
      | S x1 => x * Ffix x x1
      end) (/ (R1 + (R1 + R1)))
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           (S
              ((fix Ffix (x x0 : nat) {struct x} : nat :=
                  match x with
                  | 0%nat => x0
                  | S x1 => S (Ffix x1 x0)
                  end) H3 0%nat))) 1%nat) *
   /
   match
     (fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          (S
             ((fix Ffix (x x0 : nat) {struct x} : nat :=
                 match x with
                 | 0%nat => x0
                 | S x1 => S (Ffix x1 x0)
                 end) H3 0%nat))) 1%nat
   with
   | 0%nat => R1
   | S _ =>
       (fix Ffix (x0 : nat) : R :=
          match x0 with
          | 0%nat => R0
          | 1%nat => R1
          | S (S _ as x1) => Ffix x1 + R1
          end)
         ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
             match x0 with
             | 0%nat => x1
             | S x2 => S (Ffix x2 x1)
             end)
            ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                match x0 with
                | 0%nat => x1
                | S x2 => S (Ffix x2 x1)
                end) H3
               (S
                  ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                      match x0 with
                      | 0%nat => x1
                      | S x2 => S (Ffix x2 x1)
                      end) H3 0%nat))) 1%nat) + R1
   end) +
  / (R1 + (R1 + R1) * (R1 + (R1 + R1))) *
  (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
     match x0 with
     | 0%nat => R1
     | S x1 => x * Ffix x x1
     end) (/ (R1 + (R1 + R1) * (R1 + (R1 + R1))))
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          (S
             ((fix Ffix (x x0 : nat) {struct x} : nat :=
                 match x with
                 | 0%nat => x0
                 | S x1 => S (Ffix x1 x0)
                 end) H3 0%nat))) 1%nat) *
  /
  match
    (fix Ffix (x x0 : nat) {struct x} : nat :=
       match x with
       | 0%nat => x0
       | S x1 => S (Ffix x1 x0)
       end)
      ((fix Ffix (x x0 : nat) {struct x} : nat :=
          match x with
          | 0%nat => x0
          | S x1 => S (Ffix x1 x0)
          end) H3
         (S
            ((fix Ffix (x x0 : nat) {struct x} : nat :=
                match x with
                | 0%nat => x0
                | S x1 => S (Ffix x1 x0)
                end) H3 0%nat))) 1%nat
  with
  | 0%nat => R1
  | S _ =>
      (fix Ffix (x0 : nat) : R :=
         match x0 with
         | 0%nat => R0
         | 1%nat => R1
         | S (S _ as x1) => Ffix x1 + R1
         end)
        ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
            match x0 with
            | 0%nat => x1
            | S x2 => S (Ffix x2 x1)
            end)
           ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
               match x0 with
               | 0%nat => x1
               | S x2 => S (Ffix x2 x1)
               end) H3
              (S
                 ((fix Ffix (x0 x1 : nat) {struct x0} : nat :=
                     match x0 with
                     | 0%nat => x1
                     | S x2 => S (Ffix x2 x1)
                     end) H3 0%nat))) 1%nat) + R1
  end)%R =
 ((R1 + R1) *
  ((fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
      match x0 with
      | 0%nat => R1
      | S x1 => x * Ffix x x1
      end) (/ (R1 + (R1 + R1)))
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           ((fix Ffix (x x0 : nat) {struct x} : nat :=
               match x with
               | 0%nat => x0
               | S x1 => S (Ffix x1 x0)
               end) H3 0%nat)) 1%nat) *
   /
   (fix Ffix (x : nat) : R :=
      match x with
      | 0%nat => R0
      | 1%nat => R1
      | S (S _ as x0) => Ffix x0 + R1
      end)
     ((fix Ffix (x x0 : nat) {struct x} : nat :=
         match x with
         | 0%nat => x0
         | S x1 => S (Ffix x1 x0)
         end)
        ((fix Ffix (x x0 : nat) {struct x} : nat :=
            match x with
            | 0%nat => x0
            | S x1 => S (Ffix x1 x0)
            end) H3
           ((fix Ffix (x x0 : nat) {struct x} : nat :=
               match x with
               | 0%nat => x0
               | S x1 => S (Ffix x1 x0)
               end) H3 0%nat)) 1%nat)) +
  (fix Ffix (x : R) (x0 : nat) {struct x0} : R :=
     match x0 with
     | 0%nat => R1
     | S x1 => x * Ffix x x1
     end) (/ (R1 + (R1 + R1) * (R1 + (R1 + R1))))
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          ((fix Ffix (x x0 : nat) {struct x} : nat :=
              match x with
              | 0%nat => x0
              | S x1 => S (Ffix x1 x0)
              end) H3 0%nat)) 1%nat) *
  /
  (fix Ffix (x : nat) : R :=
     match x with
     | 0%nat => R0
     | 1%nat => R1
     | S (S _ as x0) => Ffix x0 + R1
     end)
    ((fix Ffix (x x0 : nat) {struct x} : nat :=
        match x with
        | 0%nat => x0
        | S x1 => S (Ffix x1 x0)
        end)
       ((fix Ffix (x x0 : nat) {struct x} : nat :=
           match x with
           | 0%nat => x0
           | S x1 => S (Ffix x1 x0)
           end) H3
          ((fix Ffix (x x0 : nat) {struct x} : nat :=
              match x with
              | 0%nat => x0
              | S x1 => S (Ffix x1 x0)
              end) H3 0%nat)) 1%nat))%R)
specialized IHeP2 using (eq_refl e0 )
specialized IHeP1 using (eq_refl e )
out of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
Crunching: (derivable_pt tan P3)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (Tgate) † × Tgate)
Crunching:
(list2D_to_matrix [[C1; 0]; [0; (Cexp (PI / 4)) ^* * Cexp (PI / 4)]] = I 2)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation n m LE y x) ^* * rotation n m LE y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (rotation n m LE) † × rotation n m LE)
Crunching:
(list2D_to_matrix
   [[cos (n / 2) * cos (n / 2) +
     (Cexp m * sin (n / 2)) ^* * (Cexp m * sin (n / 2));
    cos (n / 2) * (- Cexp LE * sin (n / 2)) +
    (Cexp m * sin (n / 2)) ^* * (Cexp (m + LE) * cos (n / 2))];
   [(- Cexp LE * sin (n / 2)) ^* * cos (n / 2) +
    (Cexp (m + LE) * cos (n / 2)) ^* * (Cexp m * sin (n / 2));
   (- Cexp LE * sin (n / 2)) ^* * (- Cexp LE * sin (n / 2)) +
   (Cexp (m + LE) * cos (n / 2)) ^* * (Cexp (m + LE) * cos (n / 2))]] = 
 I 2)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
Crunching:
(forall λ : R,
 WF_Matrix (rotation H4 y0 λ) /\
 (rotation H4 y0 λ) † × rotation H4 y0 λ = I 2)
Crunching:
(forall λ : R,
 WF_Matrix (rotation H4 Hcase λ) /\
 (rotation H4 Hcase λ) † × rotation H4 Hcase λ = I 2)
Crunching: (WF_Unitary (rotation H4 Hb ϕ))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (0 <= m' \/ 0 <= cv -> perm_mat 0 p m' cv = 0%R)
Crunching: False
Crunching:
(forall (m n : nat) (u : Square 2),
 WF_Matrix u ->
 forall x y : nat,
 (x >= 2 ^ H3)%nat \/ (y >= 2 ^ H3)%nat -> pad_ctrl H3 m n u x y = 0)
out of reach
Tactic call ran for 0.005 secs (0.003u,0.001s) (failure)
Crunching: (pad_ctrl c H n u H4 y = 0)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation n m LE y x) ^* * rotation n m LE y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (C2 <> 0)
clear  H0  :  (False -> cB (map (rec a1)) a1 = Lt)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation n m LE) † x y * rotation n m LE y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
((fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0) =
 (fun x z : nat =>
  Σ (fun y : nat => (rotation n m LE) † x y * rotation n m LE y z) 2))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation n m LE) † x y * rotation n m LE y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0) =
 (fun x z : nat =>
  Σ (fun y : nat => (rotation n m LE) † x y * rotation n m LE y z) 2))
Crunching:
(forall y : nat,
 (Hfalse >= 2 ^ dim)%nat \/ (y >= 2 ^ dim)%nat ->
 pad_ctrl dim m n u Hfalse y = 0)
Crunching:
(forall y : nat,
 (Hfalse >= 2 ^ dim)%nat \/ (y >= 2 ^ dim)%nat ->
 pad_ctrl dim m n u Hfalse y = 0)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Crunching:
(forall y : nat,
 (Hfalse >= 2 ^ dim)%nat \/ (y >= 2 ^ dim)%nat ->
 pad_ctrl dim m n u Hfalse y = 0)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (rotation n m LE) † × rotation n m LE)
Crunching:
(list2D_to_matrix
   [[cos (n / 2) * cos (n / 2) +
     (Cexp m * sin (n / 2)) ^* * (Cexp m * sin (n / 2));
    cos (n / 2) * (- Cexp LE * sin (n / 2)) +
    (Cexp m * sin (n / 2)) ^* * (Cexp (m + LE) * cos (n / 2))];
   [(- Cexp LE * sin (n / 2)) ^* * cos (n / 2) +
    (Cexp (m + LE) * cos (n / 2)) ^* * (Cexp m * sin (n / 2));
   (- Cexp LE * sin (n / 2)) ^* * (- Cexp LE * sin (n / 2)) +
   (Cexp (m + LE) * cos (n / 2)) ^* * (Cexp (m + LE) * cos (n / 2))]] = 
 I 2)
Finished transaction in 70.742 secs (69.158u,1.413s) (successful)
Crunching:
(forall λ : R,
 WF_Matrix (rotation H4 q λ) /\ (rotation H4 q λ) † × rotation H4 q λ = I 2)
Crunching:
(forall λ : R,
 WF_Matrix (rotation H4 y0 λ) /\
 (rotation H4 y0 λ) † × rotation H4 y0 λ = I 2)
Crunching:
(forall λ : R,
 WF_Matrix (rotation H4 Hcase λ) /\
 (rotation H4 Hcase λ) † × rotation H4 Hcase λ = I 2)
Crunching:
(WF_Matrix (rotation H4 Hcase H) /\
 (rotation H4 Hcase H) † × rotation H4 Hcase H = I 2)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H4 LE ϕ y x) ^* * rotation H4 LE ϕ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(Σ
   (fun y0 : nat =>
    (if 0 =? 0
     then
      fun x y : nat =>
      match y with
      | 0%nat => match x with
                 | 0%nat => C1
                 | S _ => 0
                 end
      | 1%nat => match x with
                 | 0%nat | _ => 0
                 end
      | S (S _) => 0
      end ^*
     else
      fun x y : nat =>
      match y with
      | 0%nat => match x with
                 | 0%nat | _ => 0
                 end
      | 1%nat => match x with
                 | 0%nat => C1
                 | S _ => 0
                 end
      | S (S _) => 0
      end ^*) x y0 *
    (if 0 =? 0
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) y0 y) 2 = (if (x =? y) && (x <? 1) then C1 else 0))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H4 LE X1 y x) ^* * rotation H4 LE X1 y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (perm_mat 0 y H6 H' = 0%R)
Crunching: (perm_mat x y H6 H' = 0%R)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching: (WF_Unitary (perm_mat x y))
Crunching:
((forall n : nat, S (S n) = (n + 2)%nat) ->
 (fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
     = 87
     : positive
Finished transaction in 8.606 secs (8.402u,0.202s) (successful)
Crunching:
(forall n : nat,
 (forall m : nat, m < n -> WF_Unitary (perm_mat x y)) ->
 WF_Unitary (perm_mat x y))
     = 61917364224
     : positive
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
     = 7740489148688861129193206895632682221967747359359283689624583891190890622713918448413240721408
     : positive
make_chain :
forall gamma : positive -> positive, Strategy gamma -> positive -> chain

make_chain is not universe polymorphic
Arguments make_chain gamma%function_scope {Hgamma} n%positive_scope A _
make_chain is transparent
Expands to: Constant additions.Euclidean_Chains.make_chain
;; This extracted scheme code relies on some additional macros
;; available at http://www.pps.univ-paris-diderot.fr/~letouzey/scheme
(load "macros_extr.scm")

(define __ (lambda (_) __))


(define mult_op (lambda (mult_op0) mult_op0))

(define computation_execute (lambdas (op c)
  (match c
     ((Return x) x)
     ((Mult x y k) (@ computation_execute op (k (@ mult_op op x y)))))))
  
(define computation_eval (lambdas (e_op _ c) (@ computation_execute e_op c)))

(define chain_apply (lambdas (c e_op e_one a)
  (@ computation_eval e_op e_one (@ c __ a))))

(define cpower_pos (lambdas (g p e_op e_one a)
  (@ chain_apply (g p) e_op e_one a)))

(define cpower (lambdas (g n e_op e_one a)
  (match n
     ((N0) e_one)
     ((Npos p) (@ cpower_pos g p e_op e_one a)))))


;; This extracted scheme code relies on some additional macros
;; available at http://www.pps.univ-paris-diderot.fr/~letouzey/scheme
(load "macros_extr.scm")

(define __ (lambda (_) __))


(define add (lambdas (n m) (match n
                              ((O) m)
                              ((S p) `(S ,(@ add p m))))))
  
(define succ (lambda (x)
  (match x
     ((XI p) `(XO ,(succ p)))
     ((XO p) `(XI ,p))
     ((XH) `(XO ,`(XH))))))
  
(define add0 (lambdas (x y)
  (match x
     ((XI p)
       (match y
          ((XI q) `(XO ,(@ add_carry p q)))
          ((XO q) `(XI ,(@ add0 p q)))
          ((XH) `(XO ,(succ p)))))
     ((XO p)
       (match y
          ((XI q) `(XI ,(@ add0 p q)))
          ((XO q) `(XO ,(@ add0 p q)))
          ((XH) `(XI ,p))))
     ((XH)
       (match y
          ((XI q) `(XO ,(succ q)))
          ((XO q) `(XI ,q))
          ((XH) `(XO ,`(XH))))))))
  
(define add_carry (lambdas (x y)
  (match x
     ((XI p)
       (match y
          ((XI q) `(XI ,(@ add_carry p q)))
          ((XO q) `(XO ,(@ add_carry p q)))
          ((XH) `(XI ,(succ p)))))
     ((XO p)
       (match y
          ((XI q) `(XO ,(@ add_carry p q)))
          ((XO q) `(XI ,(@ add0 p q)))
          ((XH) `(XO ,(succ p)))))
     ((XH)
       (match y
          ((XI q) `(XI ,(succ q)))
          ((XO q) `(XO ,(succ q)))
          ((XH) `(XI ,`(XH))))))))
  
(define pred_double (lambda (x)
  (match x
     ((XI p) `(XI ,`(XO ,p)))
     ((XO p) `(XI ,(pred_double p)))
     ((XH) `(XH)))))
  
(define succ_double_mask (lambda (x)
  (match x
     ((IsNul) `(IsPos ,`(XH)))
     ((IsPos p) `(IsPos ,`(XI ,p)))
     ((IsNeg) `(IsNeg)))))

(define double_mask (lambda (x)
  (match x
     ((IsNul) `(IsNul))
     ((IsPos p) `(IsPos ,`(XO ,p)))
     ((IsNeg) `(IsNeg)))))

(define double_pred_mask (lambda (x)
  (match x
     ((XI p) `(IsPos ,`(XO ,`(XO ,p))))
     ((XO p) `(IsPos ,`(XO ,(pred_double p))))
     ((XH) `(IsNul)))))

(define sub_mask (lambdas (x y)
  (match x
     ((XI p)
       (match y
          ((XI q) (double_mask (@ sub_mask p q)))
          ((XO q) (succ_double_mask (@ sub_mask p q)))
          ((XH) `(IsPos ,`(XO ,p)))))
     ((XO p)
       (match y
          ((XI q) (succ_double_mask (@ sub_mask_carry p q)))
          ((XO q) (double_mask (@ sub_mask p q)))
          ((XH) `(IsPos ,(pred_double p)))))
     ((XH) (match y
              ((XI _) `(IsNeg))
              ((XO _) `(IsNeg))
              ((XH) `(IsNul)))))))
  
(define sub_mask_carry (lambdas (x y)
  (match x
     ((XI p)
       (match y
          ((XI q) (succ_double_mask (@ sub_mask_carry p q)))
          ((XO q) (double_mask (@ sub_mask p q)))
          ((XH) `(IsPos ,(pred_double p)))))
     ((XO p)
       (match y
          ((XI q) (double_mask (@ sub_mask_carry p q)))
          ((XO q) (succ_double_mask (@ sub_mask_carry p q)))
          ((XH) (double_pred_mask p))))
     ((XH) `(IsNeg)))))
  
(define sub (lambdas (x y)
  (match (@ sub_mask x y)
     ((IsNul) `(XH))
     ((IsPos z) z)
     ((IsNeg) `(XH)))))

(define compare_cont (lambdas (r x y)
  (match x
     ((XI p)
       (match y
          ((XI q) (@ compare_cont r p q))
          ((XO q) (@ compare_cont `(Gt) p q))
          ((XH) `(Gt))))
     ((XO p)
       (match y
          ((XI q) (@ compare_cont `(Lt) p q))
          ((XO q) (@ compare_cont r p q))
          ((XH) `(Gt))))
     ((XH) (match y
              ((XI _) `(Lt))
              ((XO _) `(Lt))
              ((XH) r))))))
  
(define compare (compare_cont `(Eq)))

(define iter_op (lambdas (op p a)
  (match p
     ((XI p0) (@ op a (@ iter_op op p0 (@ op a a))))
     ((XO p0) (@ iter_op op p0 (@ op a a)))
     ((XH) a))))
  
(define to_nat (lambda (x) (@ iter_op add x `(S ,`(O)))))

(define succ_double (lambda (x)
  (match x
     ((N0) `(Npos ,`(XH)))
     ((Npos p) `(Npos ,`(XI ,p))))))

(define double (lambda (n)
  (match n
     ((N0) `(N0))
     ((Npos p) `(Npos ,`(XO ,p))))))

(define sub0 (lambdas (n m)
  (match n
     ((N0) `(N0))
     ((Npos n~)
       (match m
          ((N0) n)
          ((Npos m~)
            (match (@ sub_mask n~ m~)
               ((IsNul) `(N0))
               ((IsPos p) `(Npos ,p))
               ((IsNeg) `(N0)))))))))

(define compare0 (lambdas (n m)
  (match n
     ((N0) (match m
              ((N0) `(Eq))
              ((Npos _) `(Lt))))
     ((Npos n~) (match m
                   ((N0) `(Gt))
                   ((Npos m~) (@ compare n~ m~)))))))

(define leb (lambdas (x y)
  (match (@ compare0 x y)
     ((Eq) `(True))
     ((Lt) `(True))
     ((Gt) `(False)))))

(define pos_div_eucl (lambdas (a b)
  (match a
     ((XI a~)
       (match (@ pos_div_eucl a~ b)
          ((Pair q r)
            (let ((r~ (succ_double r)))
              (match (@ leb b r~)
                 ((True) `(Pair ,(succ_double q) ,(@ sub0 r~ b)))
                 ((False) `(Pair ,(double q) ,r~)))))))
     ((XO a~)
       (match (@ pos_div_eucl a~ b)
          ((Pair q r)
            (let ((r~ (double r)))
              (match (@ leb b r~)
                 ((True) `(Pair ,(succ_double q) ,(@ sub0 r~ b)))
                 ((False) `(Pair ,(double q) ,r~)))))))
     ((XH)
       (match b
          ((N0) `(Pair ,`(N0) ,`(Npos ,`(XH))))
          ((Npos p)
            (match p
               ((XI _) `(Pair ,`(N0) ,`(Npos ,`(XH))))
               ((XO _) `(Pair ,`(N0) ,`(Npos ,`(XH))))
               ((XH) `(Pair ,`(Npos ,`(XH)) ,`(N0))))))))))
  
(define pos_eq_dec (lambdas (p x)
  (match p
     ((XI p0)
       (match x
          ((XI p1)
            (match (@ pos_eq_dec p0 p1)
               ((Left) `(Left))
               ((Right) `(Right))))
          ((XO _) `(Right))
          ((XH) `(Right))))
     ((XO p0)
       (match x
          ((XI _) `(Right))
          ((XO p1)
            (match (@ pos_eq_dec p0 p1)
               ((Left) `(Left))
               ((Right) `(Right))))
          ((XH) `(Right))))
     ((XH) (match x
              ((XI _) `(Right))
              ((XO _) `(Right))
              ((XH) `(Left)))))))
  
(define n2pos (lambda (n) (match n
                             ((N0) `(XH))
                             ((Npos p) p))))

(define exact_log2 (lambda (p)
  (match p
     ((XI _) `(None))
     ((XO q)
       (match q
          ((XI _)
            (match (exact_log2 q)
               ((Some l) `(Some ,(@ add0 l `(XH))))
               ((None) `(None))))
          ((XO _)
            (match (exact_log2 q)
               ((Some l) `(Some ,(@ add0 l `(XH))))
               ((None) `(None))))
          ((XH) `(Some ,`(XH)))))
     ((XH) `(None)))))
  
(define f3 (lambdas (k x) `(Mult ,x ,x ,(lambda (y) `(Mult ,y ,x ,k)))))

(define f1 (lambda (k) k))

(define f2 (lambdas (k x) `(Mult ,x ,x ,k)))

(define fcompose (lambdas (f4 f5 k x)
  (@ f4 __ (lambda (y) (@ f5 __ k y)) x)))

(define f2C (lambda (f) (@ f __ (lambda (x) `(Return ,x)))))

(define fexp2_of_nat (lambdas (n x x0)
  (match n
     ((O) (@ f1 x x0))
     ((S p) (@ fcompose (lambda (_) f2) (lambda (_) (fexp2_of_nat p)) x x0)))))
  
(define fexp2 (lambdas (p x x0) (@ fexp2_of_nat (to_nat p) x x0)))

(define k2F (lambdas (knp k) (@ knp __ (lambdas (y _) (k y)))))

(define kFK (lambdas (kbr fq k a)
  (@ kbr __ (lambdas (xb xr)
    (@ fq __ (lambda (y) `(Mult ,y ,xr ,(lambda (z) (@ k z xb)))) xb)) a)))

(define kFF (lambdas (kbr fq x x0) (@ k2F (lambda (_) (@ kFK kbr fq)) x x0)))

(define fFK (lambdas (fp fq k a)
  (@ fp __ (lambda (xb) (@ fq __ (lambda (y) (@ k y xb)) xb)) a)))

(define fK (lambdas (f k a) (@ f __ (lambda (y) (@ k y a)) a)))

(define chain_gen (lambdas (gamma x _)
  (match x
     ((Gen_F n)
       (match (@ pos_eq_dec n `(XH))
          ((Left) f1)
          ((Right)
            (match (@ pos_eq_dec n `(XI ,`(XH)))
               ((Left) f3)
               ((Right)
                 (match (exact_log2 n)
                    ((Some a) (fexp2 a))
                    ((None)
                      (match (@ pos_div_eucl n `(Npos ,(gamma n)))
                         ((Pair a b)
                           (match b
                              ((N0)
                                (@ fcompose (lambda (_)
                                  (@ chain_gen gamma `(Gen_F ,(gamma n)) _))
                                  (lambda (_)
                                  (@ chain_gen gamma `(Gen_F ,(n2pos a)) _))))
                              ((Npos p)
                                (@ kFF (lambda (_)
                                  (@ chain_gen gamma `(Gen_K
                                    ,(n2pos `(Npos ,p))
                                    ,(@ sub (gamma n) (n2pos `(Npos ,p)))) _))
                                  (lambda (_)
                                  (@ chain_gen gamma `(Gen_F ,(n2pos a)) _))))))))))))))
     ((Gen_K p d)
       (match (@ pos_eq_dec p `(XH))
          ((Left)
            (fK (lambda (_)
              (@ chain_gen gamma `(Gen_F ,(@ add0 `(XH) d)) _))))
          ((Right)
            (match (@ pos_div_eucl (@ add0 p d) `(Npos ,p))
               ((Pair a b)
                 (match b
                    ((N0)
                      (@ fFK (lambda (_) (@ chain_gen gamma `(Gen_F ,p) _))
                        (lambda (_)
                        (@ chain_gen gamma `(Gen_F ,(n2pos a)) _))))
                    ((Npos p0)
                      (@ kFK (lambda (_)
                        (@ chain_gen gamma `(Gen_K ,(n2pos `(Npos ,p0))
                          ,(@ sub p (n2pos `(Npos ,p0)))) _)) (lambda (_)
                        (@ chain_gen gamma `(Gen_F ,(n2pos a)) _)))))))))))))
  
(define make_chain (lambdas (gamma n x)
  (@ f2C (@ chain_gen gamma `(Gen_F ,n)) x)))


Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (x_rotation H0) † × x_rotation H0)
Crunching:
(list2D_to_matrix
   [[cos (H0 / 2) * cos (H0 / 2) +
     (- Ci * sin (H0 / 2)) ^* * (- Ci * sin (H0 / 2));
    cos (H0 / 2) * (- Ci * sin (H0 / 2)) +
    (- Ci * sin (H0 / 2)) ^* * cos (H0 / 2)];
   [(- Ci * sin (H0 / 2)) ^* * cos (H0 / 2) +
    cos (H0 / 2) * (- Ci * sin (H0 / 2));
   (- Ci * sin (H0 / 2)) ^* * (- Ci * sin (H0 / 2)) +
   cos (H0 / 2) * cos (H0 / 2)]] = I 2)
Crunching: (forall y0 : nat, q >= x \/ y0 >= x -> perm_mat x y q y0 = 0%R)
Crunching:
((forall n : nat, S (S n) = (n + 2)%nat) ->
 (fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (x - (x - z) - z = 0)
Crunching: (0%R = perm_mat 0 y H6 H')
Crunching: (perm_mat 0 y H6 H' = 0%R)
Crunching: (perm_mat x y H6 H' = 0%R)
Crunching: (perm_mat x y H6 H' = 0%R)
Crunching: (perm_mat x y H6 H' = 0%R)
Crunching: (x - (x - z) - z = 0)
Crunching: (0 <= NZ <= H4 -> H4 * NZ + NZ * H4 <= NZ * NZ + H4 * H4)
Crunching: (b * NZ + NZ * b <= NZ * NZ + b * b)
Crunching: (perm_mat 0 y H6 H' = 0%R)
Crunching: (forall y0 : nat, H4 >= x \/ y0 >= x -> perm_mat x y H4 y0 = 0%R)
Crunching: (x - (x - z) - z = 0)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Finished transaction in 13.994 secs (13.879u,0.113s) (successful)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Crunching: ((fun n : nat => ?eps > 0) n)
Crunching:
(forall r1 : R,
 ((if Rlt_le_dec r1 r then 0 else S (sample r0 (r1 - r))) <= S (length r0))%nat)
Crunching: (WF_Unitary (perm_mat x y))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Crunching: (WF_Unitary (perm_mat x y))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Crunching:
(forall n : nat,
 (forall m : nat, m < n -> WF_Unitary (perm_mat x y)) ->
 WF_Unitary (perm_mat x y))
Crunching: (WF_Unitary (perm_mat x y))
Crunching:
(forall n : nat,
 (forall m : nat, m < n -> WF_Unitary (perm_mat x y)) ->
 WF_Unitary (perm_mat x y))
Finished transaction in 5.206 secs (5.141u,0.064s) (successful)
Crunching:
((- - 0)%R +
 hadamard x 0%nat *
 (/ √ IZR (Z.succ (Z.succ 0)) .* ∣ 0 ⟩
  .+ - / √ IZR (Z.succ (Z.succ 0)) .* ∣ 1 ⟩) 0%nat y +
 hadamard x 1%nat *
 (/ √ IZR (Z.succ (Z.succ 0)) .* ∣ 0 ⟩
  .+ - / √ IZR (Z.succ (Z.succ 0)) .* ∣ 1 ⟩) 1%nat y = 
 ∣ 1 ⟩ x y)
Crunching:
((forall n : nat, S (S n) = (n + 2)%nat) ->
 (fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Crunching:
((forall n : nat, S (S n) = (n + 2)%nat) ->
 (fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (x_rotation θ) † × x_rotation θ)
Crunching:
(list2D_to_matrix
   [[cos (θ / 2) * cos (θ / 2) +
     (- Ci * sin (θ / 2)) ^* * (- Ci * sin (θ / 2));
    cos (θ / 2) * (- Ci * sin (θ / 2)) +
    (- Ci * sin (θ / 2)) ^* * cos (θ / 2)];
   [(- Ci * sin (θ / 2)) ^* * cos (θ / 2) +
    cos (θ / 2) * (- Ci * sin (θ / 2));
   (- Ci * sin (θ / 2)) ^* * (- Ci * sin (θ / 2)) + cos (θ / 2) * cos (θ / 2)]] =
 I 2)
Crunching: (forall y0 : nat, q >= x \/ y0 >= x -> perm_mat x y q y0 = 0%R)
Crunching:
((forall n : nat, S (S n) = (n + 2)%nat) ->
 (fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then exp 0 else 0))
Crunching:
((hadamard
  × (fun x y : nat =>
     / √ IZR (Z.succ (Z.succ 0)) * ∣ 0 ⟩ x y +
     - / √ IZR (Z.succ (Z.succ 0)) * ∣ 1 ⟩ x y)) 0%nat y = 
 ∣ 1 ⟩ 0%nat y)
Crunching: (WF_Unitary (perm_mat x y))
Crunching:
(forall n : nat,
 (forall m : nat, m < n -> WF_Unitary (perm_mat x y)) ->
 WF_Unitary (perm_mat x y))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (x_rotation H0) † × x_rotation H0)
Crunching:
(list2D_to_matrix
   [[cos (H0 / 2) * cos (H0 / 2) +
     (- Ci * sin (H0 / 2)) ^* * (- Ci * sin (H0 / 2));
    cos (H0 / 2) * (- Ci * sin (H0 / 2)) +
    (- Ci * sin (H0 / 2)) ^* * cos (H0 / 2)];
   [(- Ci * sin (H0 / 2)) ^* * cos (H0 / 2) +
    cos (H0 / 2) * (- Ci * sin (H0 / 2));
   (- Ci * sin (H0 / 2)) ^* * (- Ci * sin (H0 / 2)) +
   cos (H0 / 2) * cos (H0 / 2)]] = I 2)
Crunching:
((hadamard × (/ √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)) x y = ∣ 1 ⟩ x y)
Finished transaction in 13.131 secs (13.093u,0.036s) (successful)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(exists N : nat,
   forall n : nat, (n >= N)%nat -> R_dist (PI_2_3_7_tg n) 0 < Hn)
Crunching:
((forall n : nat, S (S n) = (n + 2)%nat) ->
 (fun x z : nat =>
  Σ (fun y : nat => (x_rotation θ y x) ^* * x_rotation θ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(forall r1 : R,
 ((if Rlt_le_dec r1 r then 0 else S (sample r0 (r1 - r))) <= S (length r0))%nat)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
'A_R' is now a registered translation.
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (y_rotation ϕ) † × y_rotation ϕ)
Crunching:
(list2D_to_matrix
   [[cos (ϕ / 2) * cos (ϕ / 2) + sin (ϕ / 2) * sin (ϕ / 2);
    cos (ϕ / 2) * - sin (ϕ / 2) + sin (ϕ / 2) * cos (ϕ / 2)];
   [(- sin (ϕ / 2)) ^* * cos (ϕ / 2) + cos (ϕ / 2) * sin (ϕ / 2);
   (- sin (ϕ / 2)) ^* * - sin (ϕ / 2) + cos (ϕ / 2) * cos (ϕ / 2)]] = 
 I 2)
Crunching:
(forall n0 : nat,
 (forall m : nat, (m < n0)%nat -> (sample x n <= m)%nat) ->
 (sample x n <= n0)%nat)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (y_rotation ϕ) † x y * y_rotation ϕ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (y_rotation ϕ) † × y_rotation ϕ)
Crunching:
(list2D_to_matrix
   [[cos (ϕ / 2) * cos (ϕ / 2) + sin (ϕ / 2) * sin (ϕ / 2);
    cos (ϕ / 2) * - sin (ϕ / 2) + sin (ϕ / 2) * cos (ϕ / 2)];
   [(- sin (ϕ / 2)) ^* * cos (ϕ / 2) + cos (ϕ / 2) * sin (ϕ / 2);
   (- sin (ϕ / 2)) ^* * - sin (ϕ / 2) + cos (ϕ / 2) * cos (ϕ / 2)]] = 
 I 2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(exists N : nat,
   forall n : nat, (n >= N)%nat -> R_dist (PI_2_3_7_tg n) 0 < Hn)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall y : nat,
 (p >= 2 ^ dim)%nat \/ (y >= 2 ^ dim)%nat ->
 (if start + Hxlex0 <=? dim
  then I (2 ^ start) ⊗ Hyley0 ⊗ I (2 ^ (dim - (start + Hxlex0)))
  else Zero) p y = 0)
Crunching: (probability_of_outcome c v = probability_of_outcome v c)
Crunching:
(forall r1 : R,
 ((if Rlt_le_dec r1 r then 0 else S (sample r0 (r1 - r))) <= S (length r0))%nat)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (y_rotation ϕ) † x y * y_rotation ϕ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: ((perm_mat m n × perm_mat m A) x y = perm_mat m (n ∘ A)%prg x y)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (y_rotation ϕ) † x y * y_rotation ϕ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (y_rotation ϕ) † × y_rotation ϕ)
Crunching:
(list2D_to_matrix
   [[cos (ϕ / 2) * cos (ϕ / 2) + sin (ϕ / 2) * sin (ϕ / 2);
    cos (ϕ / 2) * - sin (ϕ / 2) + sin (ϕ / 2) * cos (ϕ / 2)];
   [(- sin (ϕ / 2)) ^* * cos (ϕ / 2) + cos (ϕ / 2) * sin (ϕ / 2);
   (- sin (ϕ / 2)) ^* * - sin (ϕ / 2) + cos (ϕ / 2) * cos (ϕ / 2)]] = 
 I 2)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: ((perm_mat a Ha × perm_mat a g) i j = perm_mat a (Ha ∘ g)%prg i j)
Crunching: ((perm_mat a Ha × perm_mat a g) i j = perm_mat a (Ha ∘ g)%prg i j)
ordering_function_ex :
forall B : Ensemble Ord,
exists ! S : Ensemble Ord, exists f : Ord -> Ord, ordering_function f S B

ordering_function_ex is not universe polymorphic
Arguments ordering_function_ex B
ordering_function_ex is opaque
Expands to: Constant hydras.Schutte.Ordering_Functions.ordering_function_ex
ordering_function_unicity :
forall [B A1 A2 : Ensemble Ord] [f1 f2 : Ord -> Ord],
ordering_function f1 A1 B ->
ordering_function f2 A2 B -> fun_equiv f1 f2 A1 A2

ordering_function_unicity is not universe polymorphic
Arguments ordering_function_unicity [B A1 A2] [f1 f2]%function_scope O1 O2
ordering_function_unicity is opaque
Expands to: Constant
hydras.Schutte.Ordering_Functions.ordering_function_unicity
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(forall y : nat,
 (H2 >= 2 ^ H0)%nat \/ (y >= 2 ^ H0)%nat -> pad y0 H0 intx H2 y = 0)
Crunching: (WF_Unitary (pad q r p))
Crunching: (0%nat <> 1%nat -> (1 <= 0)%nat)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
uniform_sigma_lifting (M:=[the monad of idfun]) ?op ?t Identity.naturality
     : imonad_transformer.lifting_monadT (M:=[the monad of idfun]) 
         ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of idfun]) ?op ?t Identity.naturality)
where
?E : [ |- functor]
?op : [ |- ?E .-operation [the monad of idfun]]
?t : [ |- imonad_transformer.FMT.type]
'Z_R' is now a registered translation.
'A_R' is now a registered translation.
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[0]; [C1]] = ∣ 1 ⟩)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[0]; [C1]] = ∣ 1 ⟩)
Crunching: (0 <= r -> 0 < 0 -> (sample [] r < length [])%nat)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (q * Hocc + Hocc * q <= 0)
Crunching: (0%nat <> 1%nat -> (1 <= 0)%nat)
Crunching: (0%nat <> 1%nat -> (1 <= 0)%nat)
Crunching: (1 <= 0)%nat
Crunching: (1 <= 0)%nat
Crunching: (WF_Matrix u -> (u) † × u = I 2 -> WF_Unitary (pad_u dim n u))
Crunching: (WF_Matrix u -> (u) † × u = I 2 -> WF_Unitary (pad_u dim n u))
Crunching: (perm_mat 0 m x 0 = (if (x =? 0) && (x <? 0) then C1 else 0%R))
out of reach
Tactic call ran for 0.004 secs (0.001u,0.001s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(forall x y : nat,
 ((fix pow (n m : nat) {struct m} : nat :=
     match m with
     | 0 => 1
     | S m0 =>
         (fix mul (n0 m1 : nat) {struct n0} : nat :=
            match n0 with
            | 0 => 0
            | S p =>
                (fix add (n1 m2 : nat) {struct n1} : nat :=
                   match n1 with
                   | 0 => m2
                   | S p0 => S (add p0 m2)
                   end) m1 (mul p m1)
            end) n (pow n m0)
     end) 2 eps <= x)%nat \/
 ((fix pow (n m : nat) {struct m} : nat :=
     match m with
     | 0 => 1
     | S m0 =>
         (fix mul (n0 m1 : nat) {struct n0} : nat :=
            match n0 with
            | 0 => 0
            | S p =>
                (fix add (n1 m2 : nat) {struct n1} : nat :=
                   match n1 with
                   | 0 => m2
                   | S p0 => S (add p0 m2)
                   end) m1 (mul p m1)
            end) n (pow n m0)
     end) 2 eps <= y)%nat ->
 (if
   (fix leb (n m : nat) {struct n} : bool :=
      match n with
      | 0%nat => true
      | S n' => match m with
                | 0%nat => false
                | S m' => leb n' m'
                end
      end)
     ((fix add (n m : nat) {struct n} : nat :=
         match n with
         | 0%nat => m
         | S p => S (add p m)
         end) n 1%nat) eps
  then
   fun x0 y0 : nat =>
   ((((let (x1, _) :=
         if
          if
           (fix eqb (n m : nat) {struct n} : bool :=
              match n with
              | 0%nat => match m with
                         | 0%nat => true
                         | S _ => false
                         end
              | S n' => match m with
                        | 0%nat => false
                        | S m' => eqb n' m'
                        end
              end)
             (let (x1, _) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p =>
                                  (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                    (mul p m1)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add (n1 m2 : nat) {struct n1} :
                                         nat :=
                                       match ... with
                                       | ... => m2
                                       | ... => S ...
                                       end) m1 (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              x1)
             (let (x1, _) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p =>
                                  (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                    (mul p m1)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add (n1 m2 : nat) {struct n1} :
                                         nat :=
                                       match ... with
                                       | ... => m2
                                       | ... => S ...
                                       end) m1 (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              x1)
          then
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat n
           with
           | 0%nat => false
           | S m' =>
               (fix leb (n m : nat) {struct n} : bool :=
                  match n with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m'0 => leb n' m'0
                      end
                  end)
                 (let (x1, _) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end)
                      match
                        (fix pow (n m : nat) {struct m} : nat :=
                           match m with
                           | 0%nat => 1%nat
                           | S m0 =>
                               (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                  match n0 with
                                  | 0%nat => 0%nat
                                  | S p => (...) m1 (...)
                                  end) n (pow n m0)
                           end) 2%nat
                          ((fix sub (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => n
                              | S k =>
                                  match m with
                                  | 0%nat => n
                                  | S l => sub k l
                                  end
                              end) eps
                             ((fix add (n m : nat) {struct n} : nat :=
                                 match n with
                                 | 0%nat => m
                                 | S p => S (add p m)
                                 end) n 1%nat))
                      with
                      | 0%nat =>
                          (fix pow (n m : nat) {struct m} : nat :=
                             match m with
                             | 0%nat => 1%nat
                             | S m0 =>
                                 (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                    match n0 with
                                    | 0%nat => 0%nat
                                    | S p =>
                                        (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                          (mul p m1)
                                    end) n (pow n m0)
                             end) 2%nat
                            ((fix sub (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => n
                                | S k =>
                                    match m with
                                    | 0%nat => n
                                    | S l => sub k l
                                    end
                                end) eps
                               ((fix add (n m : nat) {struct n} : nat :=
                                   match n with
                                   | 0%nat => m
                                   | S p => S (add p m)
                                   end) n 1%nat))
                      | S y' =>
                          let (x1, _) :=
                            (fix divmod (x1 y1 q u : nat) {struct x1} :
                                 nat * nat :=
                               match x1 with
                               | 0%nat => (q, u)
                               | S x' =>
                                   match u with
                                   | 0%nat => divmod x' y1 (S q) y1
                                   | S u' => divmod x' y1 q u'
                                   end
                               end) x0 y' 0%nat y' in
                          x1
                      end 1%nat 0%nat 1%nat in
                  x1) m'
           end
          else false
         then (R1, R0)
         else (R0, R0) in
       x1) *
      (let (x1, _) :=
         EQ
           match
             (let (_, y1) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p =>
                                  (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                    (mul p m1)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add (n1 m2 : nat) {struct n1} :
                                         nat :=
                                       match ... with
                                       | ... => m2
                                       | ... => S ...
                                       end) m1 (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              y1)
           with
           | 0%nat => 1%nat
           | S _ => 0%nat
           end
           match
             (let (_, y1) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p =>
                                  (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                    (mul p m1)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add (n1 m2 : nat) {struct n1} :
                                         nat :=
                                       match ... with
                                       | ... => m2
                                       | ... => S ...
                                       end) m1 (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              y1)
           with
           | 0%nat => 1%nat
           | S _ => 0%nat
           end in
       x1) +
      -
      ((let (_, y1) :=
          if
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0%nat => match m with
                          | 0%nat => true
                          | S _ => false
                          end
               | S n' =>
                   match m with
                   | 0%nat => false
                   | S m' => eqb n' m'
                   end
               end)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
           then
            match
              (fix pow (n m : nat) {struct m} : nat :=
                 match m with
                 | 0%nat => 1%nat
                 | S m0 =>
                     (fix mul (n0 m1 : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => 0%nat
                        | S p =>
                            (fix add (n1 m2 : nat) {struct n1} : nat :=
                               match n1 with
                               | 0%nat => m2
                               | S p0 => S (...)
                               end) m1 (mul p m1)
                        end) n (pow n m0)
                 end) 2%nat n
            with
            | 0%nat => false
            | S m' =>
                (fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0%nat => true
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m'0 => leb n' m'0
                       end
                   end)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end)
                       match
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul ... {struct n0} : nat :=
                                   match ... with
                                   | ... 0%nat
                                   | ... ...
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match ... with
                                   | ... => n
                                   | ... => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match ... with
                                  | ... => m
                                  | ... => S ...
                                  end) n 1%nat))
                       with
                       | 0%nat =>
                           (fix pow (n m : nat) {struct m} : nat :=
                              match m with
                              | 0%nat => 1%nat
                              | S m0 =>
                                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                     match n0 with
                                     | 0%nat => 0%nat
                                     | S p => (...) m1 (...)
                                     end) n (pow n m0)
                              end) 2%nat
                             ((fix sub (n m : nat) {struct n} : nat :=
                                 match n with
                                 | 0%nat => n
                                 | S k =>
                                     match m with
                                     | 0%nat => n
                                     | S l => sub k l
                                     end
                                 end) eps
                                ((fix add (n m : nat) {struct n} : nat :=
                                    match n with
                                    | 0%nat => m
                                    | S p => S (add p m)
                                    end) n 1%nat))
                       | S y' =>
                           let (x1, _) :=
                             (fix divmod (x1 y1 q u : nat) {struct x1} :
                                  nat * nat :=
                                match x1 with
                                | 0%nat => (q, u)
                                | S x' =>
                                    match u with
                                    | 0%nat => divmod x' y1 (S q) y1
                                    | S u' => divmod x' y1 q u'
                                    end
                                end) x0 y' 0%nat y' in
                           x1
                       end 1%nat 0%nat 1%nat in
                   x1) m'
            end
           else false
          then (R1, R0)
          else (R0, R0) in
        y1) *
       (let (_, y1) :=
          EQ
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end in
        y1))) *
     (let (x1, _) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end)
            match
              (fix pow (n m : nat) {struct m} : nat :=
                 match m with
                 | 0%nat => 1%nat
                 | S m0 =>
                     (fix mul (n0 m1 : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => 0%nat
                        | S p =>
                            (fix add (n1 m2 : nat) {struct n1} : nat :=
                               match n1 with
                               | 0%nat => m2
                               | S p0 => S (add p0 m2)
                               end) m1 (mul p m1)
                        end) n (pow n m0)
                 end) 2%nat
                ((fix sub (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => n
                    | S k => match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                    end) eps
                   ((fix add (n m : nat) {struct n} : nat :=
                       match n with
                       | 0%nat => m
                       | S p => S (add p m)
                       end) n 1%nat))
            with
            | 0%nat => x0
            | S y' =>
                (fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) y'
                  (let (_, y1) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 y' 0%nat y' in
                   y1)
            end
            match
              (fix pow (n m : nat) {struct m} : nat :=
                 match m with
                 | 0%nat => 1%nat
                 | S m0 =>
                     (fix mul (n0 m1 : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => 0%nat
                        | S p =>
                            (fix add (n1 m2 : nat) {struct n1} : nat :=
                               match n1 with
                               | 0%nat => m2
                               | S p0 => S (add p0 m2)
                               end) m1 (mul p m1)
                        end) n (pow n m0)
                 end) 2%nat
                ((fix sub (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => n
                    | S k => match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                    end) eps
                   ((fix add (n m : nat) {struct n} : nat :=
                       match n with
                       | 0%nat => m
                       | S p => S (add p m)
                       end) n 1%nat))
            with
            | 0%nat => y0
            | S y' =>
                (fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) y'
                  (let (_, y1) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 y' 0%nat y' in
                   y1)
            end
         then
          match
            (fix pow (n m : nat) {struct m} : nat :=
               match m with
               | 0%nat => 1%nat
               | S m0 =>
                   (fix mul (n0 m1 : nat) {struct n0} : nat :=
                      match n0 with
                      | 0%nat => 0%nat
                      | S p =>
                          (fix add (n1 m2 : nat) {struct n1} : nat :=
                             match n1 with
                             | 0%nat => m2
                             | S p0 => S (add p0 m2)
                             end) m1 (mul p m1)
                      end) n (pow n m0)
               end) 2%nat
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0%nat => n
                  | S k => match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                  end) eps
                 ((fix add (n m : nat) {struct n} : nat :=
                     match n with
                     | 0%nat => m
                     | S p => S (add p m)
                     end) n 1%nat))
          with
          | 0%nat => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0%nat => true
                 | S n' =>
                     match m with
                     | 0%nat => false
                     | S m'0 => leb n' m'0
                     end
                 end)
                match
                  (fix pow (n m : nat) {struct m} : nat :=
                     match m with
                     | 0%nat => 1%nat
                     | S m0 =>
                         (fix mul (n0 m1 : nat) {struct n0} : nat :=
                            match n0 with
                            | 0%nat => 0%nat
                            | S p =>
                                (fix add (n1 m2 : nat) {struct n1} : nat :=
                                   match n1 with
                                   | 0%nat => m2
                                   | S p0 => S (add p0 m2)
                                   end) m1 (mul p m1)
                            end) n (pow n m0)
                     end) 2%nat
                    ((fix sub (n m : nat) {struct n} : nat :=
                        match n with
                        | 0%nat => n
                        | S k =>
                            match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                        end) eps
                       ((fix add (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => m
                           | S p => S (add p m)
                           end) n 1%nat))
                with
                | 0%nat => x0
                | S y' =>
                    (fix sub (n m : nat) {struct n} : nat :=
                       match n with
                       | 0%nat => n
                       | S k =>
                           match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                       end) y'
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       y1)
                end m'
          end
         else false
        then (R1, R0)
        else (R0, R0) in
      x1) +
     -
     (((let (x1, _) :=
          if
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0%nat => match m with
                          | 0%nat => true
                          | S _ => false
                          end
               | S n' =>
                   match m with
                   | 0%nat => false
                   | S m' => eqb n' m'
                   end
               end)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
           then
            match
              (fix pow (n m : nat) {struct m} : nat :=
                 match m with
                 | 0%nat => 1%nat
                 | S m0 =>
                     (fix mul (n0 m1 : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => 0%nat
                        | S p =>
                            (fix add (n1 m2 : nat) {struct n1} : nat :=
                               match n1 with
                               | 0%nat => m2
                               | S p0 => S (...)
                               end) m1 (mul p m1)
                        end) n (pow n m0)
                 end) 2%nat n
            with
            | 0%nat => false
            | S m' =>
                (fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0%nat => true
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m'0 => leb n' m'0
                       end
                   end)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end)
                       match
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul ... {struct n0} : nat :=
                                   match ... with
                                   | ... 0%nat
                                   | ... ...
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match ... with
                                   | ... => n
                                   | ... => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match ... with
                                  | ... => m
                                  | ... => S ...
                                  end) n 1%nat))
                       with
                       | 0%nat =>
                           (fix pow (n m : nat) {struct m} : nat :=
                              match m with
                              | 0%nat => 1%nat
                              | S m0 =>
                                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                     match n0 with
                                     | 0%nat => 0%nat
                                     | S p => (...) m1 (...)
                                     end) n (pow n m0)
                              end) 2%nat
                             ((fix sub (n m : nat) {struct n} : nat :=
                                 match n with
                                 | 0%nat => n
                                 | S k =>
                                     match m with
                                     | 0%nat => n
                                     | S l => sub k l
                                     end
                                 end) eps
                                ((fix add (n m : nat) {struct n} : nat :=
                                    match n with
                                    | 0%nat => m
                                    | S p => S (add p m)
                                    end) n 1%nat))
                       | S y' =>
                           let (x1, _) :=
                             (fix divmod (x1 y1 q u : nat) {struct x1} :
                                  nat * nat :=
                                match x1 with
                                | 0%nat => (q, u)
                                | S x' =>
                                    match u with
                                    | 0%nat => divmod x' y1 (S q) y1
                                    | S u' => divmod x' y1 q u'
                                    end
                                end) x0 y' 0%nat y' in
                           x1
                       end 1%nat 0%nat 1%nat in
                   x1) m'
            end
           else false
          then (R1, R0)
          else (R0, R0) in
        x1) *
       (let (_, y1) :=
          EQ
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end in
        y1) +
       (let (_, y1) :=
          if
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0%nat => match m with
                          | 0%nat => true
                          | S _ => false
                          end
               | S n' =>
                   match m with
                   | 0%nat => false
                   | S m' => eqb n' m'
                   end
               end)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
           then
            match
              (fix pow (n m : nat) {struct m} : nat :=
                 match m with
                 | 0%nat => 1%nat
                 | S m0 =>
                     (fix mul (n0 m1 : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => 0%nat
                        | S p =>
                            (fix add (n1 m2 : nat) {struct n1} : nat :=
                               match n1 with
                               | 0%nat => m2
                               | S p0 => S (...)
                               end) m1 (mul p m1)
                        end) n (pow n m0)
                 end) 2%nat n
            with
            | 0%nat => false
            | S m' =>
                (fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0%nat => true
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m'0 => leb n' m'0
                       end
                   end)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end)
                       match
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul ... {struct n0} : nat :=
                                   match ... with
                                   | ... 0%nat
                                   | ... ...
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match ... with
                                   | ... => n
                                   | ... => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match ... with
                                  | ... => m
                                  | ... => S ...
                                  end) n 1%nat))
                       with
                       | 0%nat =>
                           (fix pow (n m : nat) {struct m} : nat :=
                              match m with
                              | 0%nat => 1%nat
                              | S m0 =>
                                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                     match n0 with
                                     | 0%nat => 0%nat
                                     | S p => (...) m1 (...)
                                     end) n (pow n m0)
                              end) 2%nat
                             ((fix sub (n m : nat) {struct n} : nat :=
                                 match n with
                                 | 0%nat => n
                                 | S k =>
                                     match m with
                                     | 0%nat => n
                                     | S l => sub k l
                                     end
                                 end) eps
                                ((fix add (n m : nat) {struct n} : nat :=
                                    match n with
                                    | 0%nat => m
                                    | S p => S (add p m)
                                    end) n 1%nat))
                       | S y' =>
                           let (x1, _) :=
                             (fix divmod (x1 y1 q u : nat) {struct x1} :
                                  nat * nat :=
                                match x1 with
                                | 0%nat => (q, u)
                                | S x' =>
                                    match u with
                                    | 0%nat => divmod x' y1 (S q) y1
                                    | S u' => divmod x' y1 q u'
                                    end
                                end) x0 y' 0%nat y' in
                           x1
                       end 1%nat 0%nat 1%nat in
                   x1) m'
            end
           else false
          then (R1, R0)
          else (R0, R0) in
        y1) *
       (let (x1, _) :=
          EQ
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end in
        x1)) *
      (let (_, y1) :=
         if
          if
           (fix eqb (n m : nat) {struct n} : bool :=
              match n with
              | 0%nat => match m with
                         | 0%nat => true
                         | S _ => false
                         end
              | S n' => match m with
                        | 0%nat => false
                        | S m' => eqb n' m'
                        end
              end)
             match
               (fix pow (n m : nat) {struct m} : nat :=
                  match m with
                  | 0%nat => 1%nat
                  | S m0 =>
                      (fix mul (n0 m1 : nat) {struct n0} : nat :=
                         match n0 with
                         | 0%nat => 0%nat
                         | S p =>
                             (fix add (n1 m2 : nat) {struct n1} : nat :=
                                match n1 with
                                | 0%nat => m2
                                | S p0 => S (add p0 m2)
                                end) m1 (mul p m1)
                         end) n (pow n m0)
                  end) 2%nat
                 ((fix sub (n m : nat) {struct n} : nat :=
                     match n with
                     | 0%nat => n
                     | S k => match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                     end) eps
                    ((fix add (n m : nat) {struct n} : nat :=
                        match n with
                        | 0%nat => m
                        | S p => S (add p m)
                        end) n 1%nat))
             with
             | 0%nat => x0
             | S y' =>
                 (fix sub (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => n
                    | S k => match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                    end) y'
                   (let (_, y1) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 y' 0%nat y' in
                    y1)
             end
             match
               (fix pow (n m : nat) {struct m} : nat :=
                  match m with
                  | 0%nat => 1%nat
                  | S m0 =>
                      (fix mul (n0 m1 : nat) {struct n0} : nat :=
                         match n0 with
                         | 0%nat => 0%nat
                         | S p =>
                             (fix add (n1 m2 : nat) {struct n1} : nat :=
                                match n1 with
                                | 0%nat => m2
                                | S p0 => S (add p0 m2)
                                end) m1 (mul p m1)
                         end) n (pow n m0)
                  end) 2%nat
                 ((fix sub (n m : nat) {struct n} : nat :=
                     match n with
                     | 0%nat => n
                     | S k => match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                     end) eps
                    ((fix add (n m : nat) {struct n} : nat :=
                        match n with
                        | 0%nat => m
                        | S p => S (add p m)
                        end) n 1%nat))
             with
             | 0%nat => y0
             | S y' =>
                 (fix sub (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => n
                    | S k => match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                    end) y'
                   (let (_, y1) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 y' 0%nat y' in
                    y1)
             end
          then
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat
               ((fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) eps
                  ((fix add (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) n 1%nat))
           with
           | 0%nat => false
           | S m' =>
               (fix leb (n m : nat) {struct n} : bool :=
                  match n with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m'0 => leb n' m'0
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                                    match n1 with
                                    | 0%nat => m2
                                    | S p0 => S (...)
                                    end) m1 (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat => x0
                 | S y' =>
                     (fix sub (n m : nat) {struct n} : nat :=
                        match n with
                        | 0%nat => n
                        | S k =>
                            match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                        end) y'
                       (let (_, y1) :=
                          (fix divmod (x1 y1 q u : nat) {struct x1} :
                               nat * nat :=
                             match x1 with
                             | 0%nat => (q, u)
                             | S x' =>
                                 match u with
                                 | 0%nat => divmod x' y1 (S q) y1
                                 | S u' => divmod x' y1 q u'
                                 end
                             end) x0 y' 0%nat y' in
                        y1)
                 end m'
           end
          else false
         then (R1, R0)
         else (R0, R0) in
       y1)))%R,
   (((let (x1, _) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
         then
          match
            (fix pow (n m : nat) {struct m} : nat :=
               match m with
               | 0%nat => 1%nat
               | S m0 =>
                   (fix mul (n0 m1 : nat) {struct n0} : nat :=
                      match n0 with
                      | 0%nat => 0%nat
                      | S p =>
                          (fix add (n1 m2 : nat) {struct n1} : nat :=
                             match n1 with
                             | 0%nat => m2
                             | S p0 => S (add p0 m2)
                             end) m1 (mul p m1)
                      end) n (pow n m0)
               end) 2%nat n
          with
          | 0%nat => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0%nat => true
                 | S n' =>
                     match m with
                     | 0%nat => false
                     | S m'0 => leb n' m'0
                     end
                 end)
                (let (x1, _) :=
                   (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                      match x1 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y1 (S q) y1
                          | S u' => divmod x' y1 q u'
                          end
                      end)
                     match
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p => (...) m1 (...)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                     with
                     | 0%nat =>
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                   match n0 with
                                   | 0%nat => 0%nat
                                   | S p =>
                                       (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                         (mul p m1)
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match m with
                                   | 0%nat => n
                                   | S l => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match n with
                                  | 0%nat => m
                                  | S p => S (add p m)
                                  end) n 1%nat))
                     | S y' =>
                         let (x1, _) :=
                           (fix divmod (x1 y1 q u : nat) {struct x1} :
                                nat * nat :=
                              match x1 with
                              | 0%nat => (q, u)
                              | S x' =>
                                  match u with
                                  | 0%nat => divmod x' y1 (S q) y1
                                  | S u' => divmod x' y1 q u'
                                  end
                              end) x0 y' 0%nat y' in
                         x1
                     end 1%nat 0%nat 1%nat in
                 x1) m'
          end
         else false
        then (R1, R0)
        else (R0, R0) in
      x1) *
     (let (x1, _) :=
        EQ
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end in
      x1) +
     -
     ((let (_, y1) :=
         if
          if
           (fix eqb (n m : nat) {struct n} : bool :=
              match n with
              | 0%nat => match m with
                         | 0%nat => true
                         | S _ => false
                         end
              | S n' => match m with
                        | 0%nat => false
                        | S m' => eqb n' m'
                        end
              end)
             (let (x1, _) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p => (...) m1 (...)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                      (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              x1)
             (let (x1, _) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p => (...) m1 (...)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                      (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              x1)
          then
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (...)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat n
           with
           | 0%nat => false
           | S m' =>
               (fix leb (n m : nat) {struct n} : bool :=
                  match n with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m'0 => leb n' m'0
                      end
                  end)
                 (let (x1, _) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end)
                      match
                        (fix pow (n m : nat) {struct m} : nat :=
                           match m with
                           | 0%nat => 1%nat
                           | S m0 =>
                               (fix mul ... {struct n0} : nat :=
                                  match ... with
                                  | ... 0%nat
                                  | ... ...
                                  end) n (pow n m0)
                           end) 2%nat
                          ((fix sub (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => n
                              | S k =>
                                  match ... with
                                  | ... => n
                                  | ... => sub k l
                                  end
                              end) eps
                             ((fix add (n m : nat) {struct n} : nat :=
                                 match ... with
                                 | ... => m
                                 | ... => S ...
                                 end) n 1%nat))
                      with
                      | 0%nat =>
                          (fix pow (n m : nat) {struct m} : nat :=
                             match m with
                             | 0%nat => 1%nat
                             | S m0 =>
                                 (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                    match n0 with
                                    | 0%nat => 0%nat
                                    | S p => (...) m1 (...)
                                    end) n (pow n m0)
                             end) 2%nat
                            ((fix sub (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => n
                                | S k =>
                                    match m with
                                    | 0%nat => n
                                    | S l => sub k l
                                    end
                                end) eps
                               ((fix add (n m : nat) {struct n} : nat :=
                                   match n with
                                   | 0%nat => m
                                   | S p => S (add p m)
                                   end) n 1%nat))
                      | S y' =>
                          let (x1, _) :=
                            (fix divmod (x1 y1 q u : nat) {struct x1} :
                                 nat * nat :=
                               match x1 with
                               | 0%nat => (q, u)
                               | S x' =>
                                   match u with
                                   | 0%nat => divmod x' y1 (S q) y1
                                   | S u' => divmod x' y1 q u'
                                   end
                               end) x0 y' 0%nat y' in
                          x1
                      end 1%nat 0%nat 1%nat in
                  x1) m'
           end
          else false
         then (R1, R0)
         else (R0, R0) in
       y1) *
      (let (_, y1) :=
         EQ
           match
             (let (_, y1) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p => (...) m1 (...)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                      (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              y1)
           with
           | 0%nat => 1%nat
           | S _ => 0%nat
           end
           match
             (let (_, y1) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p => (...) m1 (...)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                      (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              y1)
           with
           | 0%nat => 1%nat
           | S _ => 0%nat
           end in
       y1))) *
    (let (_, y1) :=
       if
        if
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end)
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat
               ((fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) eps
                  ((fix add (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) n 1%nat))
           with
           | 0%nat => x0
           | S y' =>
               (fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0%nat => n
                  | S k => match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                  end) y'
                 (let (_, y1) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end) x0 y' 0%nat y' in
                  y1)
           end
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat
               ((fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) eps
                  ((fix add (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) n 1%nat))
           with
           | 0%nat => y0
           | S y' =>
               (fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0%nat => n
                  | S k => match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                  end) y'
                 (let (_, y1) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end) y0 y' 0%nat y' in
                  y1)
           end
        then
         match
           (fix pow (n m : nat) {struct m} : nat :=
              match m with
              | 0%nat => 1%nat
              | S m0 =>
                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                     match n0 with
                     | 0%nat => 0%nat
                     | S p =>
                         (fix add (n1 m2 : nat) {struct n1} : nat :=
                            match n1 with
                            | 0%nat => m2
                            | S p0 => S (add p0 m2)
                            end) m1 (mul p m1)
                     end) n (pow n m0)
              end) 2%nat
             ((fix sub (n m : nat) {struct n} : nat :=
                 match n with
                 | 0%nat => n
                 | S k => match m with
                          | 0%nat => n
                          | S l => sub k l
                          end
                 end) eps
                ((fix add (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => m
                    | S p => S (add p m)
                    end) n 1%nat))
         with
         | 0%nat => false
         | S m' =>
             (fix leb (n m : nat) {struct n} : bool :=
                match n with
                | 0%nat => true
                | S n' =>
                    match m with
                    | 0%nat => false
                    | S m'0 => leb n' m'0
                    end
                end)
               match
                 (fix pow (n m : nat) {struct m} : nat :=
                    match m with
                    | 0%nat => 1%nat
                    | S m0 =>
                        (fix mul (n0 m1 : nat) {struct n0} : nat :=
                           match n0 with
                           | 0%nat => 0%nat
                           | S p =>
                               (fix add (n1 m2 : nat) {struct n1} : nat :=
                                  match n1 with
                                  | 0%nat => m2
                                  | S p0 => S (add p0 m2)
                                  end) m1 (mul p m1)
                           end) n (pow n m0)
                    end) 2%nat
                   ((fix sub (n m : nat) {struct n} : nat :=
                       match n with
                       | 0%nat => n
                       | S k =>
                           match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                       end) eps
                      ((fix add (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => m
                          | S p => S (add p m)
                          end) n 1%nat))
               with
               | 0%nat => x0
               | S y' =>
                   (fix sub (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => n
                      | S k => match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                      end) y'
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      y1)
               end m'
         end
        else false
       then (R1, R0)
       else (R0, R0) in
     y1) +
    ((let (x1, _) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
         then
          match
            (fix pow (n m : nat) {struct m} : nat :=
               match m with
               | 0%nat => 1%nat
               | S m0 =>
                   (fix mul (n0 m1 : nat) {struct n0} : nat :=
                      match n0 with
                      | 0%nat => 0%nat
                      | S p =>
                          (fix add (n1 m2 : nat) {struct n1} : nat :=
                             match n1 with
                             | 0%nat => m2
                             | S p0 => S (add p0 m2)
                             end) m1 (mul p m1)
                      end) n (pow n m0)
               end) 2%nat n
          with
          | 0%nat => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0%nat => true
                 | S n' =>
                     match m with
                     | 0%nat => false
                     | S m'0 => leb n' m'0
                     end
                 end)
                (let (x1, _) :=
                   (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                      match x1 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y1 (S q) y1
                          | S u' => divmod x' y1 q u'
                          end
                      end)
                     match
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p => (...) m1 (...)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                     with
                     | 0%nat =>
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                   match n0 with
                                   | 0%nat => 0%nat
                                   | S p =>
                                       (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                         (mul p m1)
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match m with
                                   | 0%nat => n
                                   | S l => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match n with
                                  | 0%nat => m
                                  | S p => S (add p m)
                                  end) n 1%nat))
                     | S y' =>
                         let (x1, _) :=
                           (fix divmod (x1 y1 q u : nat) {struct x1} :
                                nat * nat :=
                              match x1 with
                              | 0%nat => (q, u)
                              | S x' =>
                                  match u with
                                  | 0%nat => divmod x' y1 (S q) y1
                                  | S u' => divmod x' y1 q u'
                                  end
                              end) x0 y' 0%nat y' in
                         x1
                     end 1%nat 0%nat 1%nat in
                 x1) m'
          end
         else false
        then (R1, R0)
        else (R0, R0) in
      x1) *
     (let (_, y1) :=
        EQ
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end in
      y1) +
     (let (_, y1) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
         then
          match
            (fix pow (n m : nat) {struct m} : nat :=
               match m with
               | 0%nat => 1%nat
               | S m0 =>
                   (fix mul (n0 m1 : nat) {struct n0} : nat :=
                      match n0 with
                      | 0%nat => 0%nat
                      | S p =>
                          (fix add (n1 m2 : nat) {struct n1} : nat :=
                             match n1 with
                             | 0%nat => m2
                             | S p0 => S (add p0 m2)
                             end) m1 (mul p m1)
                      end) n (pow n m0)
               end) 2%nat n
          with
          | 0%nat => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0%nat => true
                 | S n' =>
                     match m with
                     | 0%nat => false
                     | S m'0 => leb n' m'0
                     end
                 end)
                (let (x1, _) :=
                   (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                      match x1 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y1 (S q) y1
                          | S u' => divmod x' y1 q u'
                          end
                      end)
                     match
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p => (...) m1 (...)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                     with
                     | 0%nat =>
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                   match n0 with
                                   | 0%nat => 0%nat
                                   | S p =>
                                       (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                         (mul p m1)
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match m with
                                   | 0%nat => n
                                   | S l => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match n with
                                  | 0%nat => m
                                  | S p => S (add p m)
                                  end) n 1%nat))
                     | S y' =>
                         let (x1, _) :=
                           (fix divmod (x1 y1 q u : nat) {struct x1} :
                                nat * nat :=
                              match x1 with
                              | 0%nat => (q, u)
                              | S x' =>
                                  match u with
                                  | 0%nat => divmod x' y1 (S q) y1
                                  | S u' => divmod x' y1 q u'
                                  end
                              end) x0 y' 0%nat y' in
                         x1
                     end 1%nat 0%nat 1%nat in
                 x1) m'
          end
         else false
        then (R1, R0)
        else (R0, R0) in
      y1) *
     (let (x1, _) :=
        EQ
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end in
      x1)) *
    (let (x1, _) :=
       if
        if
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end)
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat
               ((fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) eps
                  ((fix add (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) n 1%nat))
           with
           | 0%nat => x0
           | S y' =>
               (fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0%nat => n
                  | S k => match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                  end) y'
                 (let (_, y1) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end) x0 y' 0%nat y' in
                  y1)
           end
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat
               ((fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) eps
                  ((fix add (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) n 1%nat))
           with
           | 0%nat => y0
           | S y' =>
               (fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0%nat => n
                  | S k => match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                  end) y'
                 (let (_, y1) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end) y0 y' 0%nat y' in
                  y1)
           end
        then
         match
           (fix pow (n m : nat) {struct m} : nat :=
              match m with
              | 0%nat => 1%nat
              | S m0 =>
                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                     match n0 with
                     | 0%nat => 0%nat
                     | S p =>
                         (fix add (n1 m2 : nat) {struct n1} : nat :=
                            match n1 with
                            | 0%nat => m2
                            | S p0 => S (add p0 m2)
                            end) m1 (mul p m1)
                     end) n (pow n m0)
              end) 2%nat
             ((fix sub (n m : nat) {struct n} : nat :=
                 match n with
                 | 0%nat => n
                 | S k => match m with
                          | 0%nat => n
                          | S l => sub k l
                          end
                 end) eps
                ((fix add (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => m
                    | S p => S (add p m)
                    end) n 1%nat))
         with
         | 0%nat => false
         | S m' =>
             (fix leb (n m : nat) {struct n} : bool :=
                match n with
                | 0%nat => true
                | S n' =>
                    match m with
                    | 0%nat => false
                    | S m'0 => leb n' m'0
                    end
                end)
               match
                 (fix pow (n m : nat) {struct m} : nat :=
                    match m with
                    | 0%nat => 1%nat
                    | S m0 =>
                        (fix mul (n0 m1 : nat) {struct n0} : nat :=
                           match n0 with
                           | 0%nat => 0%nat
                           | S p =>
                               (fix add (n1 m2 : nat) {struct n1} : nat :=
                                  match n1 with
                                  | 0%nat => m2
                                  | S p0 => S (add p0 m2)
                                  end) m1 (mul p m1)
                           end) n (pow n m0)
                    end) 2%nat
                   ((fix sub (n m : nat) {struct n} : nat :=
                       match n with
                       | 0%nat => n
                       | S k =>
                           match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                       end) eps
                      ((fix add (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => m
                          | S p => S (add p m)
                          end) n 1%nat))
               with
               | 0%nat => x0
               | S y' =>
                   (fix sub (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => n
                      | S k => match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                      end) y'
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      y1)
               end m'
         end
        else false
       then (R1, R0)
       else (R0, R0) in
     x1))%R)
  else fun _ _ : nat => (R0, R0)) x y = (R0, R0))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (sum_over_list RS' <= r -> sample RS' r = length RS')
out of reach
Tactic call ran for 0.005 secs (0.004u,0.001s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching:
(big_sum (fun i : nat => basis_vector H2 i × (basis_vector H2 i) †) N1 a b =
 0)
Crunching:
(I N1 = big_sum (fun i : nat => basis_vector H2 i × (basis_vector H2 i) †) N1)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (perm_mat 0 m x 0 = (if (x =? 0) && (x <? 0) then C1 else 0%R))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(big_sum (fun i : nat => basis_vector H2 i × (basis_vector H2 i) †) N1 a b =
 0)
Crunching:
(I N1 = big_sum (fun i : nat => basis_vector H2 i × (basis_vector H2 i) †) N1)
Crunching:
(forall u : Square 2, (m < n)%nat -> WF_Unitary u -> WF_Unitary (pad_u n m u))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: ((z >= 2 ^ n)%nat \/ (t >= 2 ^ n)%nat -> pad_u n m u z t = 0)
Crunching: (WF_Unitary (pad_u n m H1))
Crunching: (sum_over_list RS' <= r -> sample RS' r = length RS')
Crunching: (perm_mat 0 m x 0 = (if (x =? 0) && (x <? 0) then C1 else 0%R))
Crunching: (list2D_to_matrix [[e]; [e0]] = σy × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[0]; [Ci]] = Ci .* ∣ 1 ⟩)
Crunching: ((y < 2)%nat -> (h < 1)%nat -> (σz × ∣ 0 ⟩) y h = ∣ 0 ⟩ y h)
Crunching: ((x < H)%nat -> WF_Unitary l -> WF_Unitary (pad_u H x l))
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
Crunching:
(forall j : nat,
 (H1 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H1 j = ∣ 0 ⟩ H1 j)
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
fun Z : UU0 =>
uniform_sigma_lifting (M:=[the monad of ExceptMonad.acto Z]) 
  ?op ?t (Exception.naturality Z)
     : forall Z : UU0,
       imonad_transformer.lifting_monadT
         (M:=[the monad of ExceptMonad.acto Z]) ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of ExceptMonad.acto Z]) 
            ?op ?t (Exception.naturality Z))
where
?E : [Z : UU0 |- functor]
?op : [Z : UU0 |- ?E .-operation [the monad of ExceptMonad.acto Z]]
?t : [Z : UU0 |- imonad_transformer.FMT.type]
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching: (WF_Unitary (I n))
Crunching: (WF_Unitary (fun x y : nat => (A y x) ^*))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
((forall (x : R) (n : nat), cos_approx x n = cos_approx (- x) n) ->
 (N1 <= 0)%nat ->
 (forall m : nat,
  (m < 0)%nat ->
  I N1 = big_sum (fun i : nat => basis_vector 0 i × (basis_vector 0 i) †) N1) ->
 I N1 = big_sum (fun i : nat => basis_vector 0 i × (basis_vector 0 i) †) N1)
Crunching: (WF_Unitary (I n))
Crunching: (WF_Unitary (I n))
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching: (WF_Unitary (fun x y : nat => (A y x) ^*))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching:
(forall j : nat, (m < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) m j = ∣ 0 ⟩ m j)
Crunching: ((w2 < 2)%nat -> (H < 1)%nat -> (σz × ∣ 0 ⟩) w2 H = ∣ 0 ⟩ w2 H)
Crunching: ((y < 2)%nat -> (h < 1)%nat -> (σz × ∣ 0 ⟩) y h = ∣ 0 ⟩ y h)
Crunching:
(sum_over_list [a] < m -> (if Rlt_le_dec m a then 0%nat else 1%nat) = 1%nat)
Crunching:
(I (S m) =
 I m
 .+ (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0)
    × (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0) †)
Crunching: (WF_Unitary (I n))
Crunching: (WF_Unitary (I n))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(Set ->
 (if Rlt_le_dec m a then 0%nat else S (sample [] (m - a))) = S (length []))
Crunching: (∣1⟩ = basis_vector 2 1)
clear  H1  :  (False -> b1 = false)
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching: (sample (l1 ++ l2) r = sample l1 r)
Crunching: (sample (l1 ++ l2) r = sample l1 r)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (WF_Unitary (fun x y : nat => (A y x) ^*))
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
specialized IHl using (eq_refl (n, a0) )
Crunching: ((σz × ∣ 0 ⟩) H15 r = ∣ 0 ⟩ H15 r)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: False
rewrite if_dtt
if (pA a)
then (fun E : pA a = true => p (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
Crunching: False
Crunching: (WF_Unitary (fun x y : nat => (fst (z y x), (- snd (z y x))%R)))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching:
(list2D_to_matrix
   [[(if (i =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp n *
    (if (i =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (i * n) .* ∣ i ⟩)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = (fun x y : nat => Cexp (b * θ) * ∣ b ⟩ x y))
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
Crunching:
(list2D_to_matrix
   [[(if (i =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp n *
    (if (i =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (i * n) .* ∣ i ⟩)
uniform_sigma_lifting (M:=[the monad of option_monad]) 
  ?op ?t Option.naturality
     : imonad_transformer.lifting_monadT (M:=[the monad of option_monad]) 
         ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of option_monad]) ?op ?t Option.naturality)
where
?E : [ |- functor]
?op : [ |- ?E .-operation [the monad of option_monad]]
?t : [ |- imonad_transformer.FMT.type]
'A_R' is now a registered translation.
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (prob_partial_meas ψ ϕ = (norm ((ψ ⊗ I (2 ^ d)) † × ϕ) ^ 2)%R)
Crunching: (x = 0 -> 0 <= Rabs x)
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 (fun x z : nat =>
  Σ (fun y : nat => (perm_to_matrix n p x y * f_to_vec n f y z)%C) (2 ^ n)) =
 f_to_vec n (fun x : nat => f (p x)))
Crunching:
((fun x z : nat => Σ (fun y : nat => (cnot) † x y * cnot y z) 4) =
 (fun x y : nat => if (x =? y) && (x <? 4) then C1 else 0))
Crunching:
(prob_partial_meas n_lb ψ = (norm ((n_lb ⊗ I (2 ^ n)) † × ψ) ^ 2)%R)
Crunching:
(prob_partial_meas n_lb ψ = (norm ((n_lb ⊗ I (2 ^ n)) † × ψ) ^ 2 * 1)%R)
Crunching: (sample (l1 ++ l2) r = sample l1 r)
Crunching: (sample (l1 ++ l2) r = sample l1 r)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(prob_partial_meas n_lb ψ = (norm ((n_lb ⊗ I (2 ^ n)) † × ψ) ^ 2)%R)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = (fun x y : nat => Cexp (b * θ) * ∣ b ⟩ x y))
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (perm_to_matrix 0 p = I 1)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(Cexp (b * θ) .* ∣ b ⟩ =
 list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching:
((if Rlt_le_dec g a then 0%nat else S (sample (l1 ++ []) (g - a))) =
 (if Rlt_le_dec g a then 0%nat else S (sample l1 (g - a))))
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (sample ((a :: l1) ++ []) g = sample (a :: l1) g)
Crunching:
((if Rlt_le_dec g a then 0%nat else S (sample (l1 ++ []) (g - a))) =
 (if Rlt_le_dec g a then 0%nat else S (sample l1 (g - a))))
Crunching: (sample ((a :: l1) ++ []) g = sample (a :: l1) g)
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: ((phase_shift n × ∣ i ⟩) 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching:
(list2D_to_matrix
   [[(if (i =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp n *
    (if (i =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (i * n) .* ∣ i ⟩)
Crunching:
((fun x z : nat =>
  Σ
    (fun y0 : nat =>
     (perm_to_matrix 0 y x y0 * (if (y0 =? z) && (y0 <? 1) then C1 else 0%R))%C)
    1) = (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (list2D_to_matrix [[e]] = perm_to_matrix 0 y × f_to_vec 0 z)
Crunching: (list2D_to_matrix [[C1]] = f_to_vec 0 (fun x : nat => z (y x)))
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hq × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp Hq *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * Hq) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp Hq *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp Hq *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((phase_shift Hq × ∣ a ⟩) 0%nat 0%nat = (Cexp (a * Hq) .* ∣ a ⟩) 0%nat 0%nat)
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching: (WF_Unitary (I n))
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = (fun x y : nat => Cexp (b * θ) * ∣ b ⟩ x y))
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(Pure_State_Vector EQ ->
 prob_partial_meas H2 (H3 ⊗ EQ) = (Cmod ⟨ H2, H3 ⟩ * (Cmod ⟨ H2, H3 ⟩ * 1))%R)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(sample (l2 ++ Ha) H = (length l2 + sample Ha (H - sum_over_list l2))%nat)
Finished transaction in 138.777 secs (134.886u,3.657s) (successful)
Crunching:
((fun b : nat -> bool =>
  f_to_vec p (fun x0 : nat => x (q x0)) x0 y =
  Σ (fun y0 : nat => (perm_to_matrix p q x0 y0 * f_to_vec p b y0 y)%C)
    (2 ^ p)) x)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching: (WF_Unitary (I n))
Crunching:
((fun x y : nat => Cexp (b * θ) * ∣ b ⟩ x y) =
 list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (WF_Unitary (I n))
Crunching:
(Cexp (b * θ) .* ∣ b ⟩ =
 list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: ((phase_shift n × ∣ i ⟩) 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat)
Crunching:
(Pure_State_Vector EQ ->
 prob_partial_meas H2 (H3 ⊗ EQ) = (Cmod ⟨ H2, H3 ⟩ * (Cmod ⟨ H2, H3 ⟩ * 1))%R)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching:
(list2D_to_matrix
   [[(if (i =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp n *
    (if (i =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (i * n) .* ∣ i ⟩)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hq × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp Hq *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * Hq) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp Hq *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp Hq *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
((phase_shift Hq × ∣ a ⟩) 0%nat 0%nat = (Cexp (a * Hq) .* ∣ a ⟩) 0%nat 0%nat)
Crunching: (WF_Unitary (I n))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
Crunching:
(forall b : bool, hadamard × ∣ b ⟩ = / √ 2 .* (∣0⟩ .+ (-1) ^ b .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ H ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩))
Crunching:
((hadamard × ∣ H ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩)) 0%nat 0%nat)
Crunching:
((/ √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩)) 0%nat 0%nat =
 (hadamard × ∣ H ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩) =
 list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
simplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
Crunching: (WF_Unitary (I n))
simplified dependent [if false]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
Crunching:
(sample (l2 ++ Ha) H = (length l2 + sample Ha (H - sum_over_list l2))%nat)
Crunching:
(forall b : bool, hadamard × ∣ b ⟩ = / √ 2 .* (∣0⟩ .+ (-1) ^ b .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ H ⟩)
uniform_sigma_lifting (M:=[the monad of ListMonad.acto]) 
  ?op ?t List.naturality
     : imonad_transformer.lifting_monadT (M:=[the monad of ListMonad.acto])
         ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of ListMonad.acto]) ?op ?t List.naturality)
where
?E : [ |- functor]
?op : [ |- ?E .-operation [the monad of ListMonad.acto]]
?t : [ |- imonad_transformer.FMT.type]
'S_R' is now a registered translation.
'A_R' is now a registered translation.
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩))
Crunching:
((hadamard × ∣ H ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩)) 0%nat 0%nat)
Crunching:
((hadamard × ∣ false ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ false .* ∣1⟩)) 0%nat 0%nat)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ b ⟩)
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ b .* ∣1⟩))
Crunching: (WF_Unitary (I n))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Crunching:
((hadamard × ∣ a' ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩)) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩) =
 list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching:
((/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩)) 0%nat 0%nat =
 (hadamard × ∣ a' ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching:
((hadamard × ∣ a' ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩)) 0%nat 0%nat)
Crunching: (m ~= 0)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩) =
 list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩) =
 list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] =
 / √ IZR (Z.succ (Z.succ 0)) .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
((0%nat = m -> False) ->
 (0 < q)%nat ->
 (m < q)%nat ->
 WF_Matrix (pad_swap q 0 m) /\
 (pad_swap q 0 m) † × pad_swap q 0 m = I (2 ^ q))
Crunching:
(/ √ IZR (Z.succ (Z.succ 0)) .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩) =
 list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] =
 / √ IZR (Z.succ (Z.succ 0)) .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching: (r <= sample (repeat 0%R r ++ H) r0)%nat
Crunching: (r <= sample (repeat 0%R r ++ H) r0)%nat
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ H2 ⟩)
Crunching: (0 <= m -> (r <= sample (repeat 0%R r ++ H) m)%nat)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (H2 =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (H2 =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (H2 =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (H2 =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] =
 (fun x y : nat => / √ 2 * (∣ 0 ⟩ x y + (-1) ^ H2 * ∣ 1 ⟩ x y)))
Crunching:
(forall b : bool, hadamard × ∣ b ⟩ = / √ 2 .* (∣0⟩ .+ (-1) ^ b .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ H ⟩)
Crunching: (pad_u dim m A × pad_u dim 0 B = pad_u dim 0 B × pad_u dim m A)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩))
Crunching:
((hadamard × ∣ H ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩)) 0%nat 0%nat)
Crunching:
((hadamard × ∣ false ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ false .* ∣1⟩)) 0%nat 0%nat)
Crunching:
((hadamard × ∣ H ⟩) 1%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩)) 1%nat 0%nat)
Crunching:
((hadamard × ∣ true ⟩) 1%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ true .* ∣1⟩)) 1%nat 0%nat)
Crunching:
((hadamard × ∣ false ⟩) 1%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ false .* ∣1⟩)) 1%nat 0%nat)
Crunching: (pad_u dim m A × pad_u dim 0 B = pad_u dim 0 B × pad_u dim m A)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching: (pad_u dim m A × pad_u dim 0 B = pad_u dim 0 B × pad_u dim m A)
Crunching: (H <= sample (repeat 0%R H ++ m) H0)%nat
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod 2 ⟩)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod S H5 ⟩)
Crunching: (r <= sample (repeat 0%R r ++ H) r0)%nat
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod 2 ⟩)
Crunching: (perm_to_matrix 0 p n x = 0%R)
Crunching: (pad_u x m A' × pad_u x n B' = pad_u x n B' × pad_u x m A')
Crunching: (perm_to_matrix H q x Zx = R0)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod S H5 ⟩)
Crunching: (r <= sample (repeat 0%R r ++ H) r0)%nat
Crunching: (r <= sample (repeat 0%R r ++ H) m)%nat
Crunching: (- PI < - (PI / 2) -> False)
Crunching:
(cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat))
Crunching: (r <= sample (repeat 0%R r ++ H) m)%nat
Crunching: (0 <= m -> (r <= sample (repeat 0%R r ++ H) m)%nat)
Crunching: (0 <= m -> (r <= sample (repeat 0%R r ++ H) m)%nat)
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
fun S : UU0 =>
uniform_sigma_lifting (M:=[the monad of StateMonad.acto S]) 
  ?op ?t (State.naturality S)
     : forall S : UU0,
       imonad_transformer.lifting_monadT
         (M:=[the monad of StateMonad.acto S]) ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of StateMonad.acto S]) 
            ?op ?t (State.naturality S))
where
?E : [S : UU0 |- functor]
?op : [S : UU0 |- ?E .-operation [the monad of StateMonad.acto S]]
?t : [S : UU0 |- imonad_transformer.FMT.type]
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
Crunching:
((n < 2)%nat -> (bv < 2)%nat -> cnot × ∣ n, bv ⟩ = ∣ n, (n + bv) mod 2 ⟩)
simplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => F (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod 2 ⟩)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod 2 ⟩)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod 2 ⟩)
Crunching:
((qubit_perm_to_nat_perm q m ∘ qubit_perm_to_nat_perm q H1)%prg =
 qubit_perm_to_nat_perm q (H1 ∘ m)%prg)
Crunching: (WF_Matrix (H2 ⊗ B) /\ (H2 ⊗ B) † × (H2 ⊗ B) = I (s' * N0))
rewrite if_dtt
if (pA a1)
then (fun E : pA a1 = true => F (exist (fun a0 : A => pA a0 = true) a1 E))
else (fun _ : pA a1 = false => false)
Crunching:
(WF_Unitary Hxlex0 ->
 WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching: ((cnot × ∣ l, H5 ⟩) x y = ∣ l, (l + H5) mod S H5 ⟩ x y)
Crunching:
(WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
Crunching:
(R ->
 R ->
 WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching:
(WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching:
(WF_Unitary Hxlex0 ->
 WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching:
(WF_Unitary Hg ->
 WF_Unitary Hb -> WF_Matrix (Hg ⊗ Hb) /\ (Hg ⊗ Hb) † × (Hg ⊗ Hb) = I (a * b))
Crunching:
(WF_Unitary Hb -> WF_Matrix (Hg ⊗ Hb) /\ (Hg ⊗ Hb) † × (Hg ⊗ Hb) = I (a * b))
Crunching: ((cnot × ∣ l, H5 ⟩) x y = ∣ l, (l + H5) mod S H5 ⟩ x y)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
Crunching: ((cnot × ∣ l, H5 ⟩) x y = ∣ l, (l + H5) mod S H5 ⟩ x y)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
Crunching:
(Rabs 2 <> 0 ->
 (l >= m * 0)%nat \/ (x >= m * 0)%nat ->
 A (l / 0)%nat (x / 0)%nat * B (l mod 0) (x mod 0) = 0)
Crunching: ((cnot × ∣ l, H5 ⟩) x y = ∣ l, (l + H5) mod S H5 ⟩ x y)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
simplified dependent [if true] in H0
Ha' : (pA a')  = true
if (pA a')
then (fun E : pA a' = true => F (exist (fun a0 : A => pA a0 = true) a' E))
else (fun _ : pA a' = false => false)
Crunching: (H <= sample (repeat 0%R H ++ m) H0)%nat
Finished transaction in 17.134 secs (16.634u,0.47s) (successful)
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod S H5 ⟩)
Crunching:
((-1 + 0)%R = (-1)%R ->
 (0 + -1)%R = (-1)%R ->
 (qubit_perm_to_nat_perm q Hl ∘ qubit_perm_to_nat_perm q g)%prg =
 qubit_perm_to_nat_perm q (g ∘ Hl)%prg)
Crunching: (l <= cm + H)
Crunching:
(0 <= H2 <= Hfalse -> Hfalse * H2 + H2 * Hfalse <= H2 * H2 + Hfalse * Hfalse)
Crunching:
((forall r1 r2 : R, r1 < r2 -> ~ r2 < r1) ->
 (forall r1 r2 : R, r1 < r2 \/ r1 > r2 -> r1 <> r2) ->
 forall f : nat -> bool,
 pr_outcome_sum (env :: k) f =
 (if f 0%nat
  then (env + pr_outcome_sum k (fun y : nat => f (S y)))%R
  else pr_outcome_sum k (fun y : nat => f (S y))))
Crunching: nat
Crunching:
(pr_outcome_sum (m :: n) IH =
 (if IH 0%nat
  then (m + pr_outcome_sum n (fun y : nat => IH (S y)))%R
  else pr_outcome_sum n (fun y : nat => IH (S y))))
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching:
((qubit_perm_to_nat_perm q m ∘ qubit_perm_to_nat_perm q H1)%prg =
 qubit_perm_to_nat_perm q (H1 ∘ m)%prg)
Crunching:
((qubit_perm_to_nat_perm q m ∘ qubit_perm_to_nat_perm q H1)%prg =
 qubit_perm_to_nat_perm q (H1 ∘ m)%prg)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching:
((forall r1 r2 : R, r1 < r2 -> ~ r2 < r1) ->
 (forall r1 r2 : R, r1 < r2 \/ r1 > r2 -> r1 <> r2) ->
 forall f : nat -> bool,
 pr_outcome_sum (env :: k) f =
 (if f 0%nat
  then (env + pr_outcome_sum k (fun y : nat => f (S y)))%R
  else pr_outcome_sum k (fun y : nat => f (S y))))
Crunching: (WF_Matrix (H2 ⊗ B))
Crunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
Crunching: (WF_Matrix (H2 ⊗ B) /\ (H2 ⊗ B) † × (H2 ⊗ B) = I (s' * N0))
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
rewrite match_option_dtt
match (List.nth_error x (proj1_sig x0)) with
| None =>
(fun E : List.nth_error x (proj1_sig x0) = None =>
 match
   slist_nth_lemma1 (exist (fun l : list A => (length l =? n) = true) x e) x0
     E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error x (proj1_sig x0) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error x (proj1_sig x0)) with
| None =>
(fun E : List.nth_error x (proj1_sig x0) = None =>
 match
   slist_nth_lemma1 (exist (fun l : list A => (length l =? n) = true) x e) x0
     E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error x (proj1_sig x0) = Some a) => a)
Crunching:
((1 < 0)%R ->
 forall (A : Type) (f : nat -> A) (i : nat) (b : A), update f i b i = b)
Crunching:
(WF_Unitary Hxlex0 ->
 WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching:
(WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching:
(Σ (fun y0 : nat => (perm_to_matrix m n 0 y0 * perm_to_matrix m o y0 y)%C) x0 =
 perm_to_matrix m (fun x : nat => o (n x)) 0 y0)
Crunching:
(Morphisms.respectful ?R3 eq
   (Σ (fun y0 : nat => (perm_to_matrix m n x y0 * perm_to_matrix m o y0 y)%C))
   (perm_to_matrix m (fun x : nat => o (n x)) x))
Crunching:
(pad_u l m HP × pad_ctrl l q H' HQ = pad_ctrl l q H' HQ × pad_u l m HP)
Crunching:
(Σ (fun y0 : nat => (perm_to_matrix m n 0 y0 * perm_to_matrix m o y0 y)%C) x0 =
 perm_to_matrix m (fun x : nat => o (n x)) 0 y0)
Crunching: (forall b : p1, update n 0 b 0 = b)
Crunching:
(Morphisms.respectful ?R3 eq
   (Σ (fun y0 : nat => (perm_to_matrix m n x y0 * perm_to_matrix m o y0 y)%C))
   (perm_to_matrix m (fun x : nat => o (n x)) x))
Crunching:
(R ->
 R ->
 WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching:
(R ->
 WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching:
(WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching:
(WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching:
((1 < 0)%R ->
 forall (A : Type) (f : nat -> A) (i : nat) (b : A), update f i b i = b)
Crunching:
(WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching:
(R ->
 WF_Matrix (H2 ⊗ Hxlex0) /\ (H2 ⊗ Hxlex0) † × (H2 ⊗ Hxlex0) = I (s' * N0))
Crunching:
(pr_outcome_sum (m :: n) IH =
 (if IH 0%nat
  then (m + pr_outcome_sum n (fun y : nat => IH (S y)))%R
  else pr_outcome_sum n (fun y : nat => IH (S y))))
Crunching:
(perm_to_matrix p q × perm_to_matrix p n = perm_to_matrix p (n ∘ q)%prg)
Crunching:
(perm_to_matrix a b × perm_to_matrix a Hb = perm_to_matrix a (Hb ∘ b)%prg)
Crunching:
(forall y : nat,
 (t >= Hab ^ length ls)%nat \/ (y >= Hab ^ length ls)%nat -> (⨂ ls) t y = 0)
Crunching: (WF_Matrix (⨂ H2))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(pr_outcome_sum (a :: l1 ++ l2) f =
 (pr_outcome_sum (a :: l1) f +
  pr_outcome_sum l2 (fun x : nat => f (S (length l1 + x))))%R)
Crunching:
(pr_outcome_sum (a :: l1 ++ l2) f =
 (pr_outcome_sum (a :: l1) f +
  pr_outcome_sum l2 (fun x : nat => f (S (length l1 + x))))%R)
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.013 secs (0.011u,0.001s) (success)
Crunching:
(list2D_to_matrix [[e]] = perm_to_matrix 0 a × perm_to_matrix 0 s1')
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 s1' 0 0]] =
 perm_to_matrix 0 (s1' ∘ a)%prg)
Crunching: (H1 <= fst (Nat.divmod (HP + p) 1 0 1) <= ub)
Crunching:
(perm_to_matrix p q × perm_to_matrix p n = perm_to_matrix p (n ∘ q)%prg)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching:
(permutation a psi2 ->
 perm_to_matrix a a_encad × perm_to_matrix a psi2 =
 perm_to_matrix a (psi2 ∘ a_encad)%prg)
Crunching:
(permutation a x ->
 perm_to_matrix a a_encad × perm_to_matrix a x =
 perm_to_matrix a (x ∘ a_encad)%prg)
Crunching:
(permutation a y0 ->
 perm_to_matrix a Ha × perm_to_matrix a y0 = perm_to_matrix a (y0 ∘ Ha)%prg)
Crunching:
(perm_to_matrix a b × perm_to_matrix a Hb = perm_to_matrix a (Hb ∘ b)%prg)
Crunching: (H4 <= (HP + p) / 2 <= l)
Crunching:
(forall y : nat,
 (t >= Hab ^ length ls)%nat \/ (y >= Hab ^ length ls)%nat -> (⨂ ls) t y = 0)
Crunching: (H4 <= (HP + 0) / 2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: ((⨂ ls) l y = 0)
Crunching:
(pr_outcome_sum (r :: r0 ++ abs) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum abs (fun x : nat => f (S (length r0 + x))))%R)
Crunching:
(pr_outcome_sum (r :: r0 ++ abs) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum abs (fun x : nat => f (S (length r0 + x))))%R)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
rewrite if_dtt
if (n =? S r)
then
(fun E : (n =? S r) = true =>
 ltN_of_nat 0 n
   (ltN_S_mod_lemma1 (exist (fun k : nat => (k <? n) = true) r Hr) E))
else
(fun E : (n =? S r) = false =>
 ltN_of_nat (S r) n
   (ltN_S_mod_lemma2 (exist (fun k : nat => (k <? n) = true) r Hr) E))
Crunching:
(forall f : nat -> bool,
 pr_outcome_sum ((r :: r0) ++ LT) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum LT (fun x : nat => f (length (r :: r0) + x)%nat))%R)
Crunching: (update P F b le_mn2 = P le_mn2)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (n = o)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.006 secs (0.005u,0.001s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(forall H : nat,
 perm_to_matrix H a =
 (fun x y : nat => if (x =? y) && (x <? 2 ^ H) then C1 else 0%R))
Crunching: (perm_to_matrix H a = I (2 ^ H))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (?x < ?x)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: (update P F Ne x = P x)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching:
(forall y : nat,
 H1 >= 2 ^ H10 \/ y >= 2 ^ H10 -> perm_to_matrix H10 H H1 y = 0%R)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (perm_to_matrix n x f e2 = 0%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: (x = z z0 -> update z z0 x = z)
Finished transaction in 40.553 secs (40.025u,0.463s) (successful)
Crunching: (x = z z0 -> update z z0 x = z)
     = (exist (fun k : nat => (k <? 6) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 5) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 4) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 3) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 2) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 1) = true) 0 eq_refl, tt))))))
     : decr_list (fun n : nat => ltN (S n)) 6
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: ((H7 >= n)%nat -> (B) † × B = I n -> False)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching:
(pr_outcome_sum (Ha :: a) abs =
 ((if abs 0%nat then Ha else 0) + pr_outcome_sum a (fun i : nat => abs (S i)))%R)
Crunching: (forall b' : l1, update (update H n p) n b' = update H n b')
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching: (forall b' : l1, update (update H n p) n b' = update H n b')
Crunching: (update (update H x0 p) x0 LT = update H x0 LT)
clear  H2  :  (False -> False)
Crunching: Z
clear  H2  :  (False -> False)
Crunching:
(forall y : nat, (H15 >= n)%nat \/ (y >= n)%nat -> (c .* A) H15 y = 0)
Crunching: Z
clear  H2  :  (False -> False)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: Z
Crunching: ((nat -> x) -> False)
Crunching: (∣0⟩ = basis_vector 2 0)
rewrite if_dtt
if (n =? proj1_sig r)
then
(fun E : (n =? proj1_sig r) = true =>
 ltN_of_nat 0 (S n) (ltN_S_mod_lemma1 r E))
else
(fun E : (n =? proj1_sig r) = false =>
 ltN_of_nat (S (proj1_sig r)) (S n) (ltN_S_mod_lemma2 r E))
Crunching: (update k Hyp b' = update (update k Hyp H11) Hyp b')
Crunching: (pr_outcome_sum l a = pr_outcome_sum l Ha)
Crunching: (pr_outcome_sum l a = pr_outcome_sum l Ha)
Crunching: (forall b' : l1, update (update H n p) n b' = update H n b')
Crunching: (pr_outcome_sum l a = pr_outcome_sum l Ha)
Crunching: (pr_outcome_sum l a = pr_outcome_sum l Ha)
Crunching: (pr_outcome_sum l a = pr_outcome_sum l Ha)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (update (update H x0 p) x0 LT = update H x0 LT)
Crunching: (forall b : R, WF_Unitary (fun x y : nat => (l, b) * n1 x y))
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (H * H ^* = C1 -> WF_Unitary (H .* A))
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.008 secs (0.006u,0.001s) (success)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall y : nat, (H15 >= n)%nat \/ (y >= n)%nat -> (c .* A) H15 y = 0)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (p x)
Tactic call ran for 0.008 secs (0.007u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: ((/ √ 2)%R = 0)
Crunching: (forall x y z : R, y <= z - x -> x + y <= z)
Crunching: ((hadamard) ⊤ x y = hadamard x y)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Crunching: (p x)
Crunching: ((hadamard) ⊤ x y = hadamard x y)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching:
(forall f : nat -> bool,
 (forall i : nat, (i < length [])%nat -> f i = false) ->
 pr_outcome_sum [] f = 0)
Crunching:
(forall x : nat,
 update (update Distr A abs) B a x = update (update Distr B a) A abs x)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (update (update Distr A a) B LT = update (update Distr B LT) A a)
Crunching: ((hadamard) ⊤ x y = hadamard x y)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(f <> n' -> update (update env f r1) n' r2 = update (update env n' r2) f r1)
Crunching:
(forall f : nat -> bool,
 (forall i : nat, (i < length [])%nat -> f i = false) ->
 pr_outcome_sum [] f = 0)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: ((hadamard) ⊤ x y = hadamard x y)
Crunching: ((hadamard) ⊤ x y = hadamard x y)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: ((hadamard) ⊤ = hadamard)
Crunching: ((hadamard) † = hadamard)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (shift f 0 = f)
Crunching: ((σx) † = σx)
Crunching: ((σy) † = σy)
Crunching:
((let (x, _) :=
    match y with
    | 0%nat => match x with
               | 0%nat => (R1, R0)
               | S _ => (R0, R0)
               end
    | 1%nat => match x with
               | 1%nat => (R1, R0)
               | _ => (R0, R0)
               end
    | 2%nat => match x with
               | 3%nat => (R1, R0)
               | _ => (R0, R0)
               end
    | 3%nat => match x with
               | 2%nat => (R1, R0)
               | _ => (R0, R0)
               end
    | S (S (S (S _))) => (R0, R0)
    end in
  x,
 (-
  (let (_, y) :=
     match y with
     | 0%nat => match x with
                | 0%nat => (R1, R0)
                | S _ => (R0, R0)
                end
     | 1%nat => match x with
                | 1%nat => (R1, R0)
                | _ => (R0, R0)
                end
     | 2%nat => match x with
                | 3%nat => (R1, R0)
                | _ => (R0, R0)
                end
     | 3%nat => match x with
                | 2%nat => (R1, R0)
                | _ => (R0, R0)
                end
     | S (S (S (S _))) => (R0, R0)
     end in
   y))%R) =
 match x with
 | 0%nat => match y with
            | 0%nat => (R1, R0)
            | S _ => (R0, R0)
            end
 | 1%nat => match y with
            | 1%nat => (R1, R0)
            | _ => (R0, R0)
            end
 | 2%nat => match y with
            | 3%nat => (R1, R0)
            | _ => (R0, R0)
            end
 | 3%nat => match y with
            | 2%nat => (R1, R0)
            | _ => (R0, R0)
            end
 | S (S (S (S _))) => (R0, R0)
 end)
Crunching:
((let (x, _) :=
    match y with
    | 0%nat => match x with
               | 0%nat => (R1, R0)
               | S _ => (R0, R0)
               end
    | 1%nat => match x with
               | 1%nat => (R1, R0)
               | _ => (R0, R0)
               end
    | 2%nat => match x with
               | 3%nat => (R1, R0)
               | _ => (R0, R0)
               end
    | 3%nat => match x with
               | 2%nat => (R1, R0)
               | _ => (R0, R0)
               end
    | S (S (S (S _))) => (R0, R0)
    end in
  x,
 (-
  (let (_, y) :=
     match y with
     | 0%nat => match x with
                | 0%nat => (R1, R0)
                | S _ => (R0, R0)
                end
     | 1%nat => match x with
                | 1%nat => (R1, R0)
                | _ => (R0, R0)
                end
     | 2%nat => match x with
                | 3%nat => (R1, R0)
                | _ => (R0, R0)
                end
     | 3%nat => match x with
                | 2%nat => (R1, R0)
                | _ => (R0, R0)
                end
     | S (S (S (S _))) => (R0, R0)
     end in
   y))%R) =
 match x with
 | 0%nat => match y with
            | 0%nat => (R1, R0)
            | S _ => (R0, R0)
            end
 | 1%nat => match y with
            | 1%nat => (R1, R0)
            | _ => (R0, R0)
            end
 | 2%nat => match y with
            | 3%nat => (R1, R0)
            | _ => (R0, R0)
            end
 | 3%nat => match y with
            | 2%nat => (R1, R0)
            | _ => (R0, R0)
            end
 | S (S (S (S _))) => (R0, R0)
 end)
Crunching: (forall f : nat -> n, shift f 0 = f)
Crunching: (shift f 0 = f)
Crunching: (pr_outcome_sum (a :: l) x1 = sum_over_list (a :: l))
Crunching: (shift f 0 = f)
Tactic call ran for 0.006 secs (0.005u,0.s) (success)
Crunching: (Rabs (/ 2) < 1)
Crunching: (shift Hl 0 H = Hl H)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (forall f : nat -> n, shift f 0 = f)
rewrite if_dtt
if (n =? S (proj1_sig k))
then
(fun E : (n =? S (proj1_sig k)) = true =>
 ltN_of_nat 0 n (ltN_S_mod_lemma1 k E))
else
(fun E : (n =? S (proj1_sig k)) = false =>
 ltN_of_nat (S (proj1_sig k)) n (ltN_S_mod_lemma2 k E))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (pr_outcome_sum (a :: l) x1 = sum_over_list (a :: l))
Crunching:
((forall i : nat, (i < length (x0 :: p0))%nat -> HF i = true) ->
 pr_outcome_sum (x0 :: p0) HF = sum_over_list (x0 :: p0))
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (shift f 0 = f)
Crunching: (shift f 0 = f)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (positive -> shift f 0 = f -> shift f 0 = f)
Crunching: (Rabs (/ 2) < 1)
Crunching: (Rabs (/ 2) < 1)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (shift Hl 0 H = Hl H)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
Crunching: (m < n)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Finished transaction in 3.151 secs (3.129u,0.02s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Th_13_5_2 :
forall [A B : Ensemble Ord] [f : Ord -> Ord],
ordering_function f A B -> Closed B -> continuous f A B

Th_13_5_2 is not universe polymorphic
Arguments Th_13_5_2 [A B] [f]%function_scope f_ord B_closed
Th_13_5_2 is opaque
Expands to: Constant hydras.Schutte.Ordering_Functions.Th_13_5_2
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (pr_outcome_sum (a :: l) x1 = sum_over_list (a :: l))
Crunching: (pr_outcome_sum (a :: l) M = sum_over_list (a :: l))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: (σx ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ ∣0⟩⟨0∣ = notc)
Crunching:
((forall i : nat, (i < length (x0 :: p0))%nat -> HF i = true) ->
 pr_outcome_sum (x0 :: p0) HF = sum_over_list (x0 :: p0))
Crunching:
((fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => C1
             | _ => 0
             end
  | S (S _) => 0
  end) = (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
((fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => C1
             | _ => 0
             end
  | S (S _) => 0
  end) = (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = phase_shift θ × phase_shift θ')
Crunching:
(list2D_to_matrix [[C1; 0]; [0; Cexp θ * Cexp θ']] = phase_shift (θ + θ'))
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = (I 1) † × I 1)
Crunching:
(∣0⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R))
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = I 1 × (I 1) †)
Crunching: (I 1 = list2D_to_matrix [[C1]])
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (swap × (q ⊗ q') = q' ⊗ q)
     = @^~ 8
     : M nat
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ 8
     : M nat
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
     = st_get >>=
       ((fix denote (A : UU0) (p : program A) {struct p} : ?M A :=
           match p in (program T) return (?M T) with
           | @p_ret _ _ A0 v => Ret v
           | @p_bind _ _ A0 B m f => denote A0 m >>= (denote B \o f)
           | @p_cond _ _ A0 true p1 _ => denote A0 p1
           | @p_cond _ _ A0 false _ p2 => denote A0 p2
           | p_repeat n p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 => denote unit p0 >> loop m'
                  end) n
           | p_while fuel c p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 =>
                      st_get >>=
                      (fun s : nat =>
                       if c s then denote unit p0 >> loop m' else Ret tt)
                  end) fuel
           | p_get => st_get
           | p_put s' => st_put s'
           | p_mark t => st_mark t
           end) nat \o
          (fun n : nat =>
           p_do _ : unit <- p_put n.+1; p_do _ : unit <- p_mark n; p_ret n))
     : ?M nat
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = eT [:: 0] (eT 0 (e 1))
     : {l : seq nat &
       {a : nat &
       {s' : nat | step_star (0, p_nonce `; stop nat) l (s', stop nat a)}}}
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = eT [:: 0; 1] (eT false (e 2))
     : {l : seq nat &
       {a : bool_eqType &
       {s' : nat
       | step_star (0, p_nonce_twice `; stop bool_eqType) l
           (s', stop bool_eqType a)}}}
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = eT [:: false; false; false; false; false; true] (eT tt (e 0))
     : {l : seq bool &
       {a : unit &
       {s' : nat
       | step_star (5, p_countdown 100 `; stop unit) l (s', stop unit a)}}}
     = eT [::] (eT tt (e 21))
     : {l : seq unit &
       {a : unit &
       {s' : nat
       | step_star (0, p_multiply 3 7 `; stop unit) l (s', stop unit a)}}}
     = eT [::] (eT tt (e (1, 3)))
     : {l : seq unit &
       {a : unit &
       {s' : nat * nat
       | step_star (0, 0, p_division 22 7 `; stop unit) l (s', stop unit a)}}}
     = Some (eT [::] (eT stop unit tt (e (1, 3))))
     : option
         {l : seq unit &
         {f' : continuation &
         {s' : nat * nat
         | step_n 15 (0, 0, p_division 22 7 `; stop unit) l (s', f')}}}
rewrite if_dtt
if (proj1_sig k1 + proj1_sig k2 <? n)
then
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = true =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2) n E)
else
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = false =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2 - n) n (ltN_plus_mod_lemma1 k1 k2 E))
clear  H0a'  :  (False -> cmpA a a' <> Lt)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching:
(forall f : nat -> bool,
 pr_outcome_sum [] f =
 (sum_over_list [] - pr_outcome_sum [] (fun x : nat => ¬ f x))%R)
Crunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
Crunching: (shift (shift n b) a = shift n (a + b))
Crunching:
(pr_outcome_sum Pr eq =
 (sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching:
(0 < l / 2 -> forall j : nat, shift (shift p0 j) l = shift p0 (l + j))
Crunching:
((sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R =
 pr_outcome_sum Pr eq)
Crunching:
(pr_outcome_sum Pr eq =
 (sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R)
Crunching: (shift (shift n b) a = shift n (a + b))
Crunching:
((forall (A : Type) (x y z : A), x = y -> y = z -> x = z) ->
 (forall r1 r2 r3 : R, (r1 < r2)%R -> (r2 < r3)%R -> (r1 < r3)%R) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> (r2 < r4)%R -> r4 = r3 -> (r1 < r3)%R) ->
 forall j : nat, shift (shift H7 j) HE = shift H7 (HE + j))
Crunching: (shift (shift f j) i x = shift f (i + j) x)
rewrite if_dtt
if (n =? S r)
then
(fun E : (n =? S r) = true =>
 ltN_of_nat 0 n
   (ltN_S_mod_lemma1 (exist (fun k : nat => (k <? n) = true) r Hr) E))
else
(fun E : (n =? S r) = false =>
 ltN_of_nat (S r) n
   (ltN_S_mod_lemma2 (exist (fun k : nat => (k <? n) = true) r Hr) E))
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i hyp_sn = shift f (i + j) hyp_sn)
Crunching: positive
Crunching:
(pr_outcome_sum Pr eq =
 (sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R)
Crunching:
((sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R =
 pr_outcome_sum Pr eq)
Crunching: (shift (shift H w) LT = shift H (LT + w))
Crunching:
(pr_outcome_sum Pr eq =
 (sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R)
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching:
(0 < l / 2 -> forall j : nat, shift (shift p0 j) l = shift p0 (l + j))
Tactic call ran for 0.015 secs (0.013u,0.001s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Crunching: (nat -> False)
rewrite if_dtt
if (n =? proj1_sig r)
then
(fun E : (n =? proj1_sig r) = true =>
 ltN_of_nat 0 (S n) (ltN_S_mod_lemma1 r E))
else
(fun E : (n =? proj1_sig r) = false =>
 ltN_of_nat (S (proj1_sig r)) (S n) (ltN_S_mod_lemma2 r E))
rewrite if_dtt
if (n =? S (proj1_sig k))
then
(fun E : (n =? S (proj1_sig k)) = true =>
 ltN_of_nat 0 n (ltN_S_mod_lemma1 k E))
else
(fun E : (n =? S (proj1_sig k)) = false =>
 ltN_of_nat (S (proj1_sig k)) n (ltN_S_mod_lemma2 k E))
Crunching: (shift (shift n b) a = shift n (a + b))
Tactic call ran for 0.011 secs (0.011u,0.s) (success)
Crunching: positive
Crunching: positive
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    if f i
    then
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i HF R0
    else R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end) HF) =
 ((fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i HF R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end) HF) +
  -
  (fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     if if f i then false else true
     then
      (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
         match n with
         | 0%nat => match l with
                    | [] => default
                    | x :: _ => x
                    end
         | S m =>
             match l with
             | [] => default
             | _ :: t => nth m t default
             end
         end) i HF R0
     else R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end) HF))%R)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching: (fswap s2 x 0 x = s2 0)
Crunching: (fswap G Gfix H3 Gfix = G H3)
Crunching: (forall n : nat, 0 <= (if Nat.eq_dec n 0 then 1 else INR n))
Crunching: (fswap s2 x 0 x = s2 0)
Crunching:
(pr_outcome_sum [] m <= pr_outcome_sum [] (fun rnd : nat => m rnd || H rnd))
Crunching: (fswap n m p m = n p)
Crunching:
(cv_infty (fun n : nat => INR (S n)) ->
 Forall (fun x : R => 0 <= x) p ->
 pr_outcome_sum p q <= pr_outcome_sum p (fun rnd : nat => q rnd || He rnd))
Crunching:
(0 < 1 ->
 forall f2 : nat -> bool,
 Forall (fun x : R => 0 <= x) p ->
 pr_outcome_sum p q <= pr_outcome_sum p (fun rnd : nat => q rnd || f2 rnd))
Crunching: (fswap G Gfix H3 Gfix = G H3)
Crunching:
(forall q : positive,
 Z.abs_N (Z.rem (Z.pos H4) (Z.pos q)) = (N.pos H4 mod N.pos q)%N)
Crunching: (?R2 l a -> fswap f x 0 l = f a)
Crunching: (f l = fswap f x 0 a)
Crunching: (?R2 l a -> fswap f x 0 l = f a)
Crunching:
(pr_outcome_sum (a :: l) n <=
 pr_outcome_sum (a :: l) (fun rnd : nat => n rnd || H7 rnd))
Crunching:
(pr_outcome_sum (a :: l) n <=
 pr_outcome_sum (a :: l) (fun rnd : nat => n rnd || H7 rnd))
Crunching: (f l = fswap f x 0 a)
Crunching: (?R2 l a -> fswap f x 0 l = f a)
Crunching: (f l = fswap f x 0 a)
Crunching: (?R2 l a -> fswap f x 0 l = f a)
Crunching: (?R2 l a -> fswap f x 0 l = f a)
clear  H1  :  (False -> b1 = false)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (- - r = 0%R)
Tactic call ran for 0.006 secs (0.003u,0.002s) (success)
Crunching: (fswap f x y x = f y)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (fswap s2 0 x x = s2 0)
Crunching: (pr_outcome_sum N H6 <= pr_outcome_sum N f)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (pr_outcome_sum l H7 <= pr_outcome_sum l n)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pr_outcome_sum l H7 <= pr_outcome_sum l n)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (fswap H7 Hnd Hnd = H7)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (fswap H7 Hnd Hnd = H7)
Crunching: (fswap f x x x0 = f x0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (nat -> False)
Crunching: (nat -> False)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (nat -> False)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (nat -> False)
Crunching: (nat -> False)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (nat -> False)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (interval_sum (fun x : R => H7 (x - a)%R) (rl + a) (s + a) r)
Axioms:
ClassicalDedekindReals.sig_not_dec : forall P : Prop, {~ ~ P} + {~ P}
ClassicalDedekindReals.sig_forall_dec
  : forall P : nat -> Prop,
    (forall n : nat, {P n} + {~ P n}) ->
    {n : nat | ~ P n} + {forall n : nat, P n}
prop_ext : ClassicalFacts.prop_extensionality
lib.Axioms.proof_irr : ClassicalFacts.proof_irrelevance
Clight_core.inline_external_call_mem_events
  : forall (ef : external_function) (ge : Senv.t) 
      (vargs : list val) (m : mem) (t : Events.trace) 
      (vres : val) (m' : mem),
    ef_inline ef = true ->
    Events.external_call ef ge vargs m t vres m' ->
    {trace : list event_semantics.mem_event
    | event_semantics.ev_elim m trace m'}
Events.inline_assembly_sem : string -> signature -> Events.extcall_sem
functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Events.external_functions_sem : string -> signature -> Events.extcall_sem
Eqdep.Eq_rect_eq.eq_rect_eq
  : forall (U : Type) (p : U) (Q : U -> Type) (x : Q p) (h : p = p),
    x = eq_rect p Q x p h
Classical_Prop.classic : forall P : Prop, P \/ ~ P
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching: False
Crunching:
(interval_sum (fun x : R => q (x - eps)%R) (z + eps) (Hpos + eps) Hyp)
Crunching: (interval_sum (fun x : R => Maj2 (x - A)%R) (m + A) (n + A) o)
out of reach
Tactic call ran for 0.009 secs (0.009u,0.s) (failure)
Crunching: (forall x y : R, 0 < x -> y < 1 -> x * y < x)
Crunching: (interval_sum (fun x : R => H7 (x - a)%R) (a + rl) (s + a) r)
Crunching: (interval_sum (fun x : R => H7 (x - a)%R) (rl + a) (s + a) r)
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching:
(interval_sum X0 H Az LS ->
 (forall x0 : R, H <= x0 < Az -> X0 x0 <-> x x0) -> interval_sum x H Az LS)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.012 secs (0.008u,0.003s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.004u,0.001s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(interval_sum IHP' Base Step H11 ->
 (forall x : R, (Base < x \/ Base = x) /\ x < Step -> IHP' x <-> z x) ->
 interval_sum z Base Step H11)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(interval_sum X0 H Az LS ->
 (forall x0 : R, H <= x0 < Az -> X0 x0 <-> x x0) -> interval_sum x H Az LS)
out of reach
Tactic call ran for 0.008 secs (0.007u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
((forall i : nat, i < l -> H i = He i) -> f_to_vec l H = f_to_vec l He)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (forall a b c : nat, a < b -> b < c -> S a < c)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (interval_sum P1 rl rr r -> interval_sum P2 rl rr r)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(interval_sum (fun x : R => He (x + M)%R) (x + - M) (x_encad + - M) H ->
 interval_sum He x x_encad H)
Crunching: (interval_sum He x x_encad LT)
Crunching: (interval_sum He x x_encad (r2 - r1))
Crunching:
((forall i : nat, i < l -> H i = He i) -> f_to_vec l H = f_to_vec l He)
Crunching: (interval_sum He x x_encad LT)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (interval_sum He x x_encad LT)
out of reach
Tactic call ran for 0.008 secs (0.007u,0.s) (failure)
Crunching:
(interval_sum (fun x : R => He (x + Hxrange)%R) (a - Hxrange) (b - Hxrange) x ->
 interval_sum He a b x)
Crunching:
(interval_sum (fun x : R => He (x + M)%R) (x + - M) (x_encad + - M) H ->
 interval_sum He x x_encad H)
Crunching: (x ^ 5 <= x ^ 3)
Crunching: (interval_sum He x x_encad LT)
Crunching: (interval_sum He x x_encad LT)
Crunching: (interval_sum He x x_encad (r2 - r1))
Crunching: (interval_sum He x x_encad (r2 - r1))
Crunching: (x ^ 5 <= x ^ 3)
Crunching: (interval_sum He x x_encad LT)
Crunching: (interval_sum He x x_encad (r2 - r1))
Crunching: (interval_sum He x x_encad (r2 - r1))
Crunching: (interval_sum He x x_encad LT)
Crunching:
(forall y : nat, a >= r \/ y >= 1 -> basis_vector r Hrpos a y = 0%R)
Crunching:
(forall y : nat, a >= r \/ y >= 1 -> basis_vector r Hrpos a y = 0%R)
Crunching:
(forall y : nat, r <= H \/ 1 <= y -> basis_vector r Hrpos H y = 0%R)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Crunching:
(interval_sum (fun x : R => He (x + a)%R) (x + - a) (x_encad + - a) LT ->
 R1 = R1 -> (R0 + R1)%R = R1 -> interval_sum He x x_encad LT)
Crunching: (interval_sum He x x_encad LT)
Crunching: (x ^ 5 <= x ^ 3)
Crunching: (interval_sum He x x_encad LT)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: (interval_sum He a b (r2 + a - (r1 + a)))
Crunching: (r >= 0)
Crunching: (r >= 0)
Crunching: (positive -> basis_vector (S Hrpos) Hrpos x y = 0%R)
Crunching: (r >= 0)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 0) ^* * basis_vector d n y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 1) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 1) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d n y (S (S x))) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 (S (S x))) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(forall n : nat,
 n < start -> (basis_vector start n) † × basis_vector start n = I 1)
Crunching:
(0 < start -> (basis_vector start 0) † × basis_vector start 0 = I 1)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching: (0 < b)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 0) ^* * basis_vector d n y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 1) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 1) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d n y (S (S x))) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 (S (S x))) ^* * basis_vector d n y0 (S y))%C) d)
Crunching: (r < R0 -> R0 < r \/ r = R0)
Crunching:
(forall n : nat,
 n < start -> (basis_vector start n) † × basis_vector start n = I 1)
Crunching:
(0 < start -> (basis_vector start 0) † × basis_vector start 0 = I 1)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching: (0 < Hyp' -> (basis_vector Hyp' 0) † × basis_vector Hyp' 0 = I 1)
Crunching:
(forall n : nat,
 n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' a) † × basis_vector Hyp' a)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' a y 0) ^* * basis_vector Hyp' a y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' a y 0) ^* * basis_vector Hyp' a y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 0) ^* * basis_vector Hyp' a y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' a y 1) ^* * basis_vector Hyp' a y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 1) ^* * basis_vector Hyp' a y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' a y (S (S x))) ^* * basis_vector Hyp' a y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 (S (S x))) ^* * basis_vector Hyp' a y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R) =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(((if Rle_dec x0 y then y else x0) < z -> x0 < z /\ y < z) /\
 (x0 < z /\ y < z -> (if Rle_dec x0 y then y else x0) < z))
Crunching:
((x0 < z /\ y < z -> (if Rle_dec x0 y then y else x0) < z) /\
 ((if Rle_dec x0 y then y else x0) < z -> x0 < z /\ y < z))
Crunching: (0 < Hyp' -> (basis_vector Hyp' 0) † × basis_vector Hyp' 0 = I 1)
Crunching:
(((if Rle_dec x0 y then y else x0) < z -> x0 < z /\ y < z) /\
 (x0 < z /\ y < z -> (if Rle_dec x0 y then y else x0) < z))
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching: False
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching: False
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching: (0 < t \/ 0 = t)
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 0) ^* * basis_vector d n y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 1) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 1) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d n y (S (S x))) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 (S (S x))) ^* * basis_vector d n y0 (S y))%C) d)
Crunching: (forall r : R, interval_sum x H H5 r -> r >= 0)
Crunching: (r >= 0)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(forall n : nat,
 n < start -> (basis_vector start n) † × basis_vector start n = I 1)
Crunching:
(0 < start -> (basis_vector start 0) † × basis_vector start 0 = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector start 0) † × basis_vector start 0)
Crunching: Type
Crunching: Type
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector start 0 y 0) ^* * basis_vector start 0 y 0)%C) start]] =
 ?y)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector start 0 y 0) ^* * basis_vector start 0 y 1)%C) start)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector start 0 y0 0) ^* * basis_vector start 0 y0 (S (S y)))%C)
   start)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector start 0 y 1) ^* * basis_vector start 0 y 0)%C) start)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector start 0 y0 1) ^* * basis_vector start 0 y0 (S y))%C) start)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector start 0 y (S (S x))) ^* * basis_vector start 0 y 0)%C)
   start)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector start 0 y0 (S (S x))) ^* * basis_vector start 0 y0 (S y))%C)
   start)
Crunching:
(l2 < start -> (basis_vector start l2) † × basis_vector start l2 = I 1)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R) =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching: (0 < Hyp' -> (basis_vector Hyp' 0) † × basis_vector Hyp' 0 = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' 0) † × basis_vector Hyp' 0)
Crunching:
(I 1 =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 0) ^* * basis_vector Hyp' 0 y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 1) ^* * basis_vector Hyp' 0 y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 1) ^* * basis_vector Hyp' 0 y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' 0 y (S (S x))) ^* * basis_vector Hyp' 0 y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 (S (S x))) ^* * basis_vector Hyp' 0 y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' 0) † × basis_vector Hyp' 0)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 0) ^* * basis_vector Hyp' 0 y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 1) ^* * basis_vector Hyp' 0 y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 1) ^* * basis_vector Hyp' 0 y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' 0 y (S (S x))) ^* * basis_vector Hyp' 0 y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 (S (S x))) ^* * basis_vector Hyp' 0 y0 (S y))%C)
   Hyp')
Crunching:
(forall n : nat,
 n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' a) † × basis_vector Hyp' a)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' a y 0) ^* * basis_vector Hyp' a y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' a y 0) ^* * basis_vector Hyp' a y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 0) ^* * basis_vector Hyp' a y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' a y 1) ^* * basis_vector Hyp' a y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 1) ^* * basis_vector Hyp' a y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' a y (S (S x))) ^* * basis_vector Hyp' a y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 (S (S x))) ^* * basis_vector Hyp' a y0 (S y))%C)
   Hyp')
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R) =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching: (0 < Hyp' -> (basis_vector Hyp' 0) † × basis_vector Hyp' 0 = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' 0) † × basis_vector Hyp' 0)
Crunching:
(I 1 =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 0) ^* * basis_vector Hyp' 0 y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 1) ^* * basis_vector Hyp' 0 y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 1) ^* * basis_vector Hyp' 0 y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' 0 y (S (S x))) ^* * basis_vector Hyp' 0 y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 (S (S x))) ^* * basis_vector Hyp' 0 y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' 0) † × basis_vector Hyp' 0)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 0) ^* * basis_vector Hyp' 0 y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 1) ^* * basis_vector Hyp' 0 y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 1) ^* * basis_vector Hyp' 0 y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' 0 y (S (S x))) ^* * basis_vector Hyp' 0 y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 (S (S x))) ^* * basis_vector Hyp' 0 y0 (S y))%C)
   Hyp')
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R) =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' x) † × basis_vector Hyp' x)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' x y 0) ^* * basis_vector Hyp' x y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' x y 0) ^* * basis_vector Hyp' x y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' x y0 0) ^* * basis_vector Hyp' x y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' x y 1) ^* * basis_vector Hyp' x y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' x y0 1) ^* * basis_vector Hyp' x y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' x y (S (S x0))) ^* * basis_vector Hyp' x y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' x y0 (S (S x0))) ^* * basis_vector Hyp' x y0 (S y))%C)
   Hyp')
Crunching: (x < Hyp' -> (basis_vector Hyp' x) † × basis_vector Hyp' x = I 1)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S x) x) † × basis_vector (S x) x)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S x) x y 0) ^* * basis_vector (S x) x y 0) x +
      (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x 0)%C]] = 
 I 1)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S x) x y 0) ^* * basis_vector (S x) x y 1)
    x + (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 0) ^* * basis_vector (S x) x y0 (S (S y))) x +
  (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x (S (S y)))%C)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S x) x y 1) ^* * basis_vector (S x) x y 0)
    x + (basis_vector (S x) x x 1) ^* * basis_vector (S x) x x 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 1) ^* * basis_vector (S x) x y0 (S y)) x +
  (basis_vector (S x) x x 1) ^* * basis_vector (S x) x x (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S x) x y (S (S x0))) ^* * basis_vector (S x) x y 0) x +
  (basis_vector (S x) x x (S (S x0))) ^* * basis_vector (S x) x x 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 (S (S x0))) ^* * basis_vector (S x) x y0 (S y))
    x + (basis_vector (S x) x x (S (S x0))) ^* * basis_vector (S x) x x (S y))%C)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.288 secs (0.266u,0.019s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(WF_Matrix (basis_vector (S i) i) /\
 (basis_vector (S i) i) † × basis_vector (S i) i = I 1)
Crunching:
(WF_Matrix (basis_vector (S i) i) /\
 (basis_vector (S i) i) † × basis_vector (S i) i = I 1)
Crunching:
(Morphisms.respectful ?R2 and WF_Matrix
   (eq ((basis_vector (S i) i) † × basis_vector (S i) i)))
Crunching: (basis_vector (S i) i HB x = 0%R)
Crunching: (HB >= S i \/ Hm >= 1 -> basis_vector (S i) i HB Hm = 0%R)
Crunching:
(WF_Matrix (basis_vector (S i) i) /\
 (basis_vector (S i) i) † × basis_vector (S i) i = I 1)
Crunching:
(WF_Matrix (basis_vector (S i) i) /\
 (basis_vector (S i) i) † × basis_vector (S i) i = I 1)
Crunching: ((cos 1)² <= (1 - 1 / 2 + 1 / 24)²)
Crunching:
(Morphisms.respectful ?R2 and WF_Matrix
   (eq ((basis_vector (S i) i) † × basis_vector (S i) i)))
Crunching: (basis_vector (S i) i HB x = 0%R)
Crunching: (HB >= S i \/ Hm >= 1 -> basis_vector (S i) i HB Hm = 0%R)
Crunching:
(exists r2 : R,
   interval_sum p x H3 1 /\ interval_sum p H3 y r2 /\ (H4 - k)%R = (1 + r2)%R)
Crunching:
(exists r2 : R,
   interval_sum p x H3 1 /\
   interval_sum p H3 y r2 /\ (H4 + - k)%R = (1 + r2)%R)
Crunching:
(exists r2 : R,
   interval_sum p x H3 1 /\
   interval_sum p H3 y r2 /\ (H4 + - k)%R = (1 + r2)%R)
Crunching:
(exists r2 : R,
   interval_sum p x H3 1 /\
   interval_sum p H3 y r2 /\ (H4 + - k)%R = (1 + r2)%R)
Crunching: (Pure_State_Vector (basis_vector x y))
Finished transaction in 435.712 secs (432.338u,3.306s) (successful)
out of reach
Tactic call ran for 0.242 secs (0.234u,0.005s) (failure)
Crunching:
(forall rr r1 r2 : R,
 interval_sum x l rr r1 -> interval_sum x l rr r2 -> r1 = r2)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) m) † × basis_vector (S n) n)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S n) m y 0) ^* * basis_vector (S n) n y 0) n +
      (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n 0)%C]] = Zero)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) m y 0) ^* * basis_vector (S n) n y 1)
    n + (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 0) ^* * basis_vector (S n) n y0 (S (S y))) n +
  (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n (S (S y)))%C)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) m y 1) ^* * basis_vector (S n) n y 0)
    n + (basis_vector (S n) m n 1) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 1) ^* * basis_vector (S n) n y0 (S y)) n +
  (basis_vector (S n) m n 1) ^* * basis_vector (S n) n n (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S n) m y (S (S x))) ^* * basis_vector (S n) n y 0) n +
  (basis_vector (S n) m n (S (S x))) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 (S (S x))) ^* * basis_vector (S n) n y0 (S y))
    n + (basis_vector (S n) m n (S (S x))) ^* * basis_vector (S n) n n (S y))%C)
Crunching: (0 < 0 -> (basis_vector d 0) † × basis_vector d 0 = Zero)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d m) † × basis_vector d 1)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d m y 0) ^* * basis_vector d 1 y 0)%C)
       d]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d m y 0) ^* * basis_vector d 1 y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d m y0 0) ^* * basis_vector d 1 y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d m y 1) ^* * basis_vector d 1 y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d m y0 1) ^* * basis_vector d 1 y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d m y (S (S x))) ^* * basis_vector d 1 y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d m y0 (S (S x))) ^* * basis_vector d 1 y0 (S y))%C) d)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]] =
 (basis_vector (S (Init.Nat.pred n)) m) †
 × basis_vector (S (Init.Nat.pred n)) HIn)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S (Init.Nat.pred n)) m y 0) ^* *
         basis_vector (S (Init.Nat.pred n)) HIn y 0) 
        (Init.Nat.pred n) +
      (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) 0) ^* *
      basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) 0)%C]] = Zero)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y 0) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y 1) (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) 0) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y0 0) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y0 (S (S y))) 
    (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) 0) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) (S (S y)))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y 1) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y 0) (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) 1) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y0 1) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y0 (S y)) 
    (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) 1) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y (S (S x))) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y 0) (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) (S (S x))) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y0 (S (S x))) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y0 (S y)) 
    (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) (S (S x))) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) (S y))%C)
Finished transaction in 36.723 secs (36.25u,0.469s) (successful)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall x1 : RbaseSymbolsImpl.R, exp_in x x1 -> 0 < z -> Rabs (x - x0) < z)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (0%nat <> 1%nat -> PI = 0)
Crunching: (pr_P H1 m -> pr_P n m)
Crunching:
((forall rnd : R, 0 <= rnd < IZR (Z.succ 0) -> H1 rnd <-> e rnd) ->
 pr_P H1 H11 -> pr_P e H11)
Crunching: (WF_Matrix b -> (b × basis_vector a H) Hb 0 = b Hb H)
Crunching: (pr_P b r)
Crunching: positive
Crunching: (1 < 1)
Crunching: positive
Crunching:
(forall (A : Matrix H3 X) (i j : nat),
 WF_Matrix A -> Σ (fun y : nat => (A i y * basis_vector X j y 0)%C) X = A i j)
Crunching: (pr_P E0 p)
Crunching: (pr_P E0 p)
Finished transaction in 39.247 secs (38.812u,0.431s) (successful)
Crunching: ((A × basis_vector n j) i 0 = A i j)
Crunching: (1 = 1 -> 0 <= ?rnd < 1)
Crunching: (WF_Matrix b -> (b × basis_vector a H) Hb 0 = b Hb H)
Crunching: (0%nat <> 1%nat -> PI = 0)
Crunching:
(forall r : R,
 (forall rnd : R, 0 <= rnd < 1 -> N2 rnd <-> H7 rnd) ->
 pr_P N2 r -> pr_P H7 r)
out of reach
Tactic call ran for 0.016 secs (0.006u,0.009s) (failure)
     = st_get >>=
       ((fix denote (A : UU0) (p : program A) {struct p} : ?M A :=
           match p in (program T) return (?M T) with
           | @p_ret _ _ A0 v => Ret v
           | @p_bind _ _ A0 B m f => denote A0 m >>= (denote B \o f)
           | @p_cond _ _ A0 true p1 _ => denote A0 p1
           | @p_cond _ _ A0 false _ p2 => denote A0 p2
           | p_repeat n p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 => denote unit p0 >> loop m'
                  end) n
           | p_while fuel c p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 =>
                      st_get >>=
                      (fun s : nat =>
                       if c s then denote unit p0 >> loop m' else Ret tt)
                  end) fuel
           | p_get => st_get
           | p_put s' => st_put s'
           | p_mark t => st_mark t
           end) nat \o
          (fun n : nat =>
           p_do _ : unit <- p_put n.+1; p_do _ : unit <- p_mark n; p_ret n))
     : ?M nat
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = eT [:: 0] (eT 0 (e 1))
     : {l : seq nat &
       {a : nat &
       {s' : nat | step_star (0, p_nonce `; stop nat) l (s', stop nat a)}}}
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = eT [:: 0; 1] (eT false (e 2))
     : {l : seq nat &
       {a : bool_eqType &
       {s' : nat
       | step_star (0, p_nonce_twice `; stop bool_eqType) l
           (s', stop bool_eqType a)}}}
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = eT [:: false; false; false; false; false; true] (eT tt (e 0))
     : {l : seq bool &
       {a : unit &
       {s' : nat
       | step_star (5, p_countdown 100 `; stop unit) l (s', stop unit a)}}}
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(interval_sum (fun rnd : R => n (sample [] rnd) = true) 0 H
   (pr_outcome_sum [] n))
Crunching:
(interval_sum (fun rnd : R => n (sample [] rnd) = true) 0 H
   (pr_outcome_sum [] n))
Crunching: (x <= y)
Crunching:
(sum_over_list l = f2 ->
 interval_sum (fun rnd : R => f1 (sample l rnd) = true) 0 f2
   (pr_outcome_sum l f1))
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(sum_over_list l = f2 ->
 interval_sum (fun rnd : R => f1 (sample l rnd) = true) 0 f2
   (pr_outcome_sum l f1))
Crunching:
(interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 x0
   (big_sum (fun i : nat => if Hf i then nth i f 0 else 0) (length f)))
Crunching:
((forall h : R,
  (let (a, _) :=
     Alembert_C3
       (fun n : nat =>
        ((fix pow (r : R) (n0 : nat) {struct n0} : R :=
            match n0 with
            | 0%nat => R1
            | S n1 => r * pow r n1
            end) (- R1) n *
         /
         (fix INR (n0 : nat) : R :=
            match n0 with
            | 0%nat => R0
            | 1%nat => R1
            | S (S _ as n1) => INR n1 + R1
            end)
           ((fix fact (n0 : nat) : nat :=
               match n0 with
               | 0%nat => 1%nat
               | S n1 =>
                   (fix add (n2 m : nat) {struct n2} : nat :=
                      match n2 with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) (fact n1)
                     ((fix mul (n2 m : nat) {struct n2} : nat :=
                         match n2 with
                         | 0%nat => 0%nat
                         | S p =>
                             (fix add (n3 m0 : nat) {struct n3} : nat :=
                                match n3 with
                                | 0%nat => m0
                                | S p0 => S (add p0 m0)
                                end) m (mul p m)
                         end) n1 (fact n1))
               end)
              ((fix add (n0 m : nat) {struct n0} : nat :=
                  match n0 with
                  | 0%nat => m
                  | S p => S (add p m)
                  end)
                 ((fix add (n0 m : nat) {struct n0} : nat :=
                     match n0 with
                     | 0%nat => m
                     | S p => S (add p m)
                     end) n
                    ((fix add (n0 m : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => m
                        | S p => S (add p m)
                        end) n 0%nat)) 1%nat)))%R)
       ((h + (R1 + R1) * (let (a, _) := PI_2_aux in a) * / (R1 + R1)) *
        (h + (R1 + R1) * (let (a, _) := PI_2_aux in a) * / (R1 + R1)))
       sin_no_R0 Alembert_sin in
   ((h + (R1 + R1) * (let (a0, _) := PI_2_aux in a0) * / (R1 + R1)) * a)%R) =
  (let (a, _) := exist_cos (h * h) in a)) ->
 (fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i f R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end) f) = x0 ->
 interval_sum
   (fun rnd : R =>
    Hf
      ((fix sample (l : list R) (r : R) {struct l} : nat :=
          match l with
          | [] => 0%nat
          | x :: l' =>
              if Rlt_le_dec r x then 0%nat else S (sample l' (r + - x)%R)
          end) f rnd) = true) R0 x0 R0)
Crunching: ((Cmod c ^ 2)%R = fst (Cmod c ^ 2))
     = eT [::] (eT tt (e 21))
     : {l : seq unit &
       {a : unit &
       {s' : nat
       | step_star (0, p_multiply 3 7 `; stop unit) l (s', stop unit a)}}}
     = eT [::] (eT tt (e (1, 3)))
     : {l : seq unit &
       {a : unit &
       {s' : nat * nat
       | step_star (0, 0, p_division 22 7 `; stop unit) l (s', stop unit a)}}}
     = Some (eT [::] (eT stop unit tt (e (1, 3))))
     : option
         {l : seq unit &
         {f' : continuation &
         {s' : nat * nat
         | step_n 15 (0, 0, p_division 22 7 `; stop unit) l (s', f')}}}
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (forall x y z : R, Rmax x y < z <-> x < z /\ y < z)
Crunching:
(interval_sum (fun rnd : R => cm (sample l rnd) = true) 0 1
   (pr_outcome_sum l cm))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true)
   (big_sum (fun i : nat => if p i then nth i y0 0 else 0) (length y0)))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true)
   (big_sum (fun i : nat => if p i then nth i y0 0 else 0) (length y0)))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(pr_P (fun rnd : R => Hf (sample f rnd) = true) (pr_outcome_sum f Hf))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (forall x y z : R, Rmax x y < z <-> x < z /\ y < z)
Crunching:
((a = b * Ha + q -> a / Ha = b /\ a mod Ha = q) /\
 (a / Ha = b /\ a mod Ha = q -> a = b * Ha + q))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (a / S q = b /\ a mod S q = q <-> a = b * S q + q)
Crunching: (a = b * S q + q <-> a / S q = b /\ a mod S q = q)
Crunching: (p = H0 * x_pos + H2 -> p / x_pos = H0 /\ p mod x_pos = H2)
Crunching: (p = H0 * x_pos + H2 -> p / x_pos = H0 /\ p mod x_pos = H2)
Crunching:
(basis_vector (2 ^ (H3 + a)) (b * 2 ^ a + n) =
 basis_vector (2 ^ H3) b ⊗ basis_vector (2 ^ a) n)
Crunching:
(exists r0 : R,
   0 <= r0 <= x /\ pr_P (fun rnd : R => Hr (sample n rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= x /\ pr_P (fun rnd : R => Hr (sample n rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= x /\ pr_P (fun rnd : R => Hr (sample n rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= x /\ pr_P (fun rnd : R => Hr (sample n rnd) = true) r0)
Crunching:
(0 < 1 ->
 pr_outcome_sum y H13 <= H1 ->
 exists r0 : R,
   - 0 <= r0 <= H1 /\ pr_P (fun rnd : R => H13 (sample y rnd) = true) r0)
Crunching:
(z' < 2 ^ l' ->
 H6 < 2 ^ Hl' ->
 basis_vector (2 ^ (l' + Hl')) (z' * 2 ^ Hl' + H6) =
 basis_vector (2 ^ l') z' ⊗ basis_vector (2 ^ Hl') H6)
Crunching:
(pr_outcome_sum y H13 <= r ->
 exists r0 : R,
   - 0 <= r0 <= r /\ pr_P (fun rnd : R => H13 (sample y rnd) = true) r0)
Crunching:
(distribution y ->
 pr_outcome_sum y H13 <= l' ->
 exists r0 : R,
   0 <= r0 <= l' /\ pr_P (fun rnd : R => H13 (sample y rnd) = true) r0)
Crunching:
(distribution y ->
 pr_outcome_sum y H13 <= l' ->
 exists r0 : R,
   0 <= r0 <= l' /\ pr_P (fun rnd : R => H13 (sample y rnd) = true) r0)
Crunching:
(((0 < 1 \/ 0 = 1) /\ (1 < eps \/ 1 = eps)) /\
 pr_P (fun rnd : R => H13 (sample y rnd) = true) 1)
Crunching:
(forall (P : R -> Prop) (r1 r2 : R), pr_P P r1 -> pr_P P r2 -> r1 = r2)
Crunching: (z2 = H)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (z2 = H)
Crunching:
(forall (P : R -> Prop) (r1 r2 : R), pr_P P r1 -> pr_P P r2 -> r1 = r2)
Crunching:
(basis_vector (2 ^ (HE + n)) (v1 * 2 ^ n + y) =
 basis_vector (2 ^ HE) v1 ⊗ basis_vector (2 ^ n) y)
Crunching: (m = (- - (r0 - r1))%R)
Crunching:
(basis_vector (2 ^ (HE + H1)) (x * 2 ^ H1 + y) =
 basis_vector (2 ^ HE) x ⊗ basis_vector (2 ^ H1) y)
Tactic call ran for 0.004 secs (0.001u,0.002s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (m = (- - r2)%R)
Crunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
Crunching: (m = (- - r2)%R)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.003 secs (0.002u,0.001s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
(S
   ((fix Ffix (x : list bool) : nat :=
       match x with
       | [] => 0
       | x0 :: x1 =>
           (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (if x0 then 1 else 0)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1)
                ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                    match x2 with
                    | 0 => x3
                    | S x4 => S (Ffix0 x4 x3)
                    end) (Ffix x1) 0))
       end)
      ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
          match x with
          | 0 => []
          | S x1 => x0 x1 :: Ffix x1 x0
          end) a Ha)) <=
 (fix Ffix (x x0 : nat) {struct x0} : nat :=
    match x0 with
    | 0 => 1
    | S x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => 0
           | S x4 =>
               (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                  match x5 with
                  | 0 => x6
                  | S x7 => S (Ffix1 x7 x6)
                  end) x3 (Ffix0 x4 x3)
           end) x (Ffix x x1)
    end) 2 a)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
(S
   ((fix Ffix (x : list bool) : nat :=
       match x with
       | [] => 0
       | x0 :: x1 =>
           (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (if x0 then 1 else 0)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1)
                ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                    match x2 with
                    | 0 => x3
                    | S x4 => S (Ffix0 x4 x3)
                    end) (Ffix x1) 0))
       end)
      ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
          match x with
          | 0 => []
          | S x1 => x0 x1 :: Ffix x1 x0
          end) a Ha)) <=
 (fix Ffix (x x0 : nat) {struct x0} : nat :=
    match x0 with
    | 0 => 1
    | S x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => 0
           | S x4 =>
               (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                  match x5 with
                  | 0 => x6
                  | S x7 => S (Ffix1 x7 x6)
                  end) x3 (Ffix0 x4 x3)
           end) x (Ffix x x1)
    end) 2 a)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (z2 = H)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (z2 = H)
Crunching: (z2 = H)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
(forall (P : R -> Prop) (r1 r2 : R), pr_P P r1 -> pr_P P r2 -> r1 = r2)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (m = (- - (r0 - r1))%R)
Crunching:
(S
   ((fix Ffix (x : list bool) : nat :=
       match x with
       | [] => 0
       | x0 :: x1 =>
           (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (if x0 then 1 else 0)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1)
                ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                    match x2 with
                    | 0 => x3
                    | S x4 => S (Ffix0 x4 x3)
                    end) (Ffix x1) 0))
       end)
      ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
          match x with
          | 0 => []
          | S x1 => x0 x1 :: Ffix x1 x0
          end) a Ha)) <=
 (fix Ffix (x x0 : nat) {struct x0} : nat :=
    match x0 with
    | 0 => 1
    | S x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => 0
           | S x4 =>
               (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                  match x5 with
                  | 0 => x6
                  | S x7 => S (Ffix1 x7 x6)
                  end) x3 (Ffix0 x4 x3)
           end) x (Ffix x x1)
    end) 2 a)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
(forall x : nat -> bool,
 S
   ((fix Ffix (x0 : list bool) : nat :=
       match x0 with
       | [] => 0
       | x1 :: x2 =>
           (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
              match x3 with
              | 0 => x4
              | S x5 => S (Ffix0 x5 x4)
              end) (if x1 then 1 else 0)
             ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                 match x3 with
                 | 0 => x4
                 | S x5 => S (Ffix0 x5 x4)
                 end) (Ffix x2)
                ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                    match x3 with
                    | 0 => x4
                    | S x5 => S (Ffix0 x5 x4)
                    end) (Ffix x2) 0))
       end)
      ((fix Ffix (x0 : nat) (x1 : nat -> bool) {struct x0} : list bool :=
          match x0 with
          | 0 => []
          | S x2 => x1 x2 :: Ffix x2 x1
          end) H'1 x)) <=
 (fix Ffix (x0 x1 : nat) {struct x1} : nat :=
    match x1 with
    | 0 => 1
    | S x2 =>
        (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
           match x3 with
           | 0 => 0
           | S x5 =>
               (fix Ffix1 (x6 x7 : nat) {struct x6} : nat :=
                  match x6 with
                  | 0 => x7
                  | S x8 => S (Ffix1 x8 x7)
                  end) x4 (Ffix0 x5 x4)
           end) x0 (Ffix x0 x2)
    end) 2 H'1)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (m = (- - r2)%R)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (m = (- - r2)%R)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(S
   ((fix Ffix (x : list bool) : nat :=
       match x with
       | [] => 0
       | x0 :: x1 =>
           (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (if x0 then 1 else 0)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1)
                ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                    match x2 with
                    | 0 => x3
                    | S x4 => S (Ffix0 x4 x3)
                    end) (Ffix x1) 0))
       end)
      ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
          match x with
          | 0 => []
          | S x1 => x0 x1 :: Ffix x1 x0
          end) a Ha)) <=
 (fix Ffix (x x0 : nat) {struct x0} : nat :=
    match x0 with
    | 0 => 1
    | S x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => 0
           | S x4 =>
               (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                  match x5 with
                  | 0 => x6
                  | S x7 => S (Ffix1 x7 x6)
                  end) x3 (Ffix0 x4 x3)
           end) x (Ffix x x1)
    end) 2 a)
Crunching:
(forall x : nat -> bool,
 S
   ((fix Ffix (x0 : list bool) : nat :=
       match x0 with
       | [] => 0
       | x1 :: x2 =>
           (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
              match x3 with
              | 0 => x4
              | S x5 => S (Ffix0 x5 x4)
              end) (if x1 then 1 else 0)
             ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                 match x3 with
                 | 0 => x4
                 | S x5 => S (Ffix0 x5 x4)
                 end) (Ffix x2)
                ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                    match x3 with
                    | 0 => x4
                    | S x5 => S (Ffix0 x5 x4)
                    end) (Ffix x2) 0))
       end)
      ((fix Ffix (x0 : nat) (x1 : nat -> bool) {struct x0} : list bool :=
          match x0 with
          | 0 => []
          | S x2 => x1 x2 :: Ffix x2 x1
          end) H'1 x)) <=
 (fix Ffix (x0 x1 : nat) {struct x1} : nat :=
    match x1 with
    | 0 => 1
    | S x2 =>
        (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
           match x3 with
           | 0 => 0
           | S x5 =>
               (fix Ffix1 (x6 x7 : nat) {struct x6} : nat :=
                  match x6 with
                  | 0 => x7
                  | S x8 => S (Ffix1 x8 x7)
                  end) x4 (Ffix0 x5 x4)
           end) x0 (Ffix x0 x2)
    end) 2 H'1)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching: (S n <= m)
Crunching:
((forall (A : Type) (x y z : A), x = y -> y = z -> x = z) ->
 (forall r1 r2 r3 : R, r1 < r2 -> r2 < r3 -> r1 < r3) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 pr_outcome_sum A n = WF <-> pr_P (fun rnd : R => n (sample A rnd) = true) WF)
Crunching:
((forall (A : Type) (x y z : A), x = y -> y = z -> x = z) ->
 (forall r1 r2 r3 : R, r1 < r2 -> r2 < r3 -> r1 < r3) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 pr_outcome_sum A n = WF <-> pr_P (fun rnd : R => n (sample A rnd) = true) WF)
Crunching:
(forall x x0 : nat -> bool,
 (forall x1 : nat, S x1 <= HP -> x x1 = x0 x1) ->
 (fix Ffix (x2 : list bool) : nat :=
    match x2 with
    | [] => 0
    | x3 :: x4 =>
        (fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
           match x5 with
           | 0 => x6
           | S x7 => S (Ffix0 x7 x6)
           end) (if x3 then 1 else 0)
          ((fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
              match x5 with
              | 0 => x6
              | S x7 => S (Ffix0 x7 x6)
              end) (Ffix x4)
             ((fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
                 match x5 with
                 | 0 => x6
                 | S x7 => S (Ffix0 x7 x6)
                 end) (Ffix x4) 0))
    end)
   ((fix Ffix (x2 : nat) (x3 : nat -> bool) {struct x2} : list bool :=
       match x2 with
       | 0 => []
       | S x4 => x3 x4 :: Ffix x4 x3
       end) HP x) =
 (fix Ffix (x2 : list bool) : nat :=
    match x2 with
    | [] => 0
    | x3 :: x4 =>
        (fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
           match x5 with
           | 0 => x6
           | S x7 => S (Ffix0 x7 x6)
           end) (if x3 then 1 else 0)
          ((fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
              match x5 with
              | 0 => x6
              | S x7 => S (Ffix0 x7 x6)
              end) (Ffix x4)
             ((fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
                 match x5 with
                 | 0 => x6
                 | S x7 => S (Ffix0 x7 x6)
                 end) (Ffix x4) 0))
    end)
   ((fix Ffix (x2 : nat) (x3 : nat -> bool) {struct x2} : list bool :=
       match x2 with
       | 0 => []
       | S x4 => x3 x4 :: Ffix x4 x3
       end) HP x0))
Crunching:
((fix Ffix (x : list bool) : nat :=
    match x with
    | [] => 0
    | x0 :: x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => x3
           | S x4 => S (Ffix0 x4 x3)
           end) (if x0 then 1 else 0)
          ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (Ffix x1)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1) 0))
    end)
   ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
       match x with
       | 0 => []
       | S x1 => x0 x1 :: Ffix x1 x0
       end) n x) =
 (fix Ffix (x : list bool) : nat :=
    match x with
    | [] => 0
    | x0 :: x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => x3
           | S x4 => S (Ffix0 x4 x3)
           end) (if x0 then 1 else 0)
          ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (Ffix x1)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1) 0))
    end)
   ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
       match x with
       | 0 => []
       | S x1 => x0 x1 :: Ffix x1 x0
       end) n Hx))
Crunching:
((forall (A : Type) (x y z : A), x = y -> y = z -> x = z) ->
 (forall r1 r2 r3 : R, r1 < r2 -> r2 < r3 -> r1 < r3) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 pr_outcome_sum A n = WF <-> pr_P (fun rnd : R => n (sample A rnd) = true) WF)
Crunching:
(pr_outcome_sum l f = r <->
 interval_sum (fun rnd : R => f (sample l rnd) = true) 0 1 r)
Crunching:
(big_sum (fun i : nat => nth i [] 0) (length []) = 1 ->
 (pr_outcome_sum [] f = r ->
  interval_sum (fun rnd : R => f (sample [] rnd) = true) 0 1 r) /\
 (interval_sum (fun rnd : R => f (sample [] rnd) = true) 0 1 r ->
  pr_outcome_sum [] f = r))
Crunching: (0%nat <> 0%nat)
Crunching:
((forall x : nat, S x <= An -> X0 x = n x) ->
 (fix Ffix (x0 : list bool) : nat :=
    match x0 with
    | [] => 0
    | x1 :: x2 =>
        (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
           match x3 with
           | 0 => x4
           | S x5 => S (Ffix0 x5 x4)
           end) (if x1 then 1 else 0)
          ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
              match x3 with
              | 0 => x4
              | S x5 => S (Ffix0 x5 x4)
              end) (Ffix x2)
             ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                 match x3 with
                 | 0 => x4
                 | S x5 => S (Ffix0 x5 x4)
                 end) (Ffix x2) 0))
    end)
   ((fix Ffix (x0 : nat) (x1 : nat -> bool) {struct x0} : list bool :=
       match x0 with
       | 0 => []
       | S x2 => x1 x2 :: Ffix x2 x1
       end) An X0) =
 (fix Ffix (x0 : list bool) : nat :=
    match x0 with
    | [] => 0
    | x1 :: x2 =>
        (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
           match x3 with
           | 0 => x4
           | S x5 => S (Ffix0 x5 x4)
           end) (if x1 then 1 else 0)
          ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
              match x3 with
              | 0 => x4
              | S x5 => S (Ffix0 x5 x4)
              end) (Ffix x2)
             ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                 match x3 with
                 | 0 => x4
                 | S x5 => S (Ffix0 x5 x4)
                 end) (Ffix x2) 0))
    end)
   ((fix Ffix (x0 : nat) (x1 : nat -> bool) {struct x0} : list bool :=
       match x0 with
       | 0 => []
       | S x2 => x1 x2 :: Ffix x2 x1
       end) An n))
Crunching: (Forall (fun x : R => 0 - 0 <= x) (map Cmod2 (a :: l)))
Crunching:
(forall n : nat,
 (forall m : nat,
  m < n ->
  (fix Ffix (x : list bool) : nat :=
     match x with
     | [] => 0
     | x0 :: x1 =>
         (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
            match x2 with
            | 0 => x3
            | S x4 => S (Ffix0 x4 x3)
            end) (if x0 then 1 else 0)
           ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
               match x2 with
               | 0 => x3
               | S x4 => S (Ffix0 x4 x3)
               end) (Ffix x1)
              ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                  match x2 with
                  | 0 => x3
                  | S x4 => S (Ffix0 x4 x3)
                  end) (Ffix x1) 0))
     end)
    ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
        match x with
        | 0 => []
        | S x1 => x0 x1 :: Ffix x1 x0
        end) z H12) = m) ->
 (fix Ffix (x : list bool) : nat :=
    match x with
    | [] => 0
    | x0 :: x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => x3
           | S x4 => S (Ffix0 x4 x3)
           end) (if x0 then 1 else 0)
          ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (Ffix x1)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1) 0))
    end)
   ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
       match x with
       | 0 => []
       | S x1 => x0 x1 :: Ffix x1 x0
       end) z H12) = n)
Crunching:
(forall n : nat,
 (forall m : nat,
  m < n ->
  (fix Ffix (x : list bool) : nat :=
     match x with
     | [] => 0
     | x0 :: x1 =>
         (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
            match x2 with
            | 0 => x3
            | S x4 => S (Ffix0 x4 x3)
            end) (if x0 then 1 else 0)
           ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
               match x2 with
               | 0 => x3
               | S x4 => S (Ffix0 x4 x3)
               end) (Ffix x1)
              ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                  match x2 with
                  | 0 => x3
                  | S x4 => S (Ffix0 x4 x3)
                  end) (Ffix x1) 0))
     end)
    ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
        match x with
        | 0 => []
        | S x1 => x0 x1 :: Ffix x1 x0
        end) z H12) = m) ->
 (fix Ffix (x : list bool) : nat :=
    match x with
    | [] => 0
    | x0 :: x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => x3
           | S x4 => S (Ffix0 x4 x3)
           end) (if x0 then 1 else 0)
          ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (Ffix x1)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1) 0))
    end)
   ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
       match x with
       | 0 => []
       | S x1 => x0 x1 :: Ffix x1 x0
       end) z H12) = n)
Crunching: (Forall (fun x : R => 0 - 0 <= x) (map Cmod2 (a :: l)))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Tactic call ran for 0.019 secs (0.018u,0.s) (success)
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.008 secs (0.007u,0.s) (success)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Crunching: (f_to_vec H H10 = ?y)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Tactic call ran for 0.008 secs (0.007u,0.s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Crunching: False
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Crunching:
(f_to_vec a H x y = basis_vector (S (S x) ^ a) (funbool_to_nat a H) x y)
Crunching:
(f_to_vec a H x y = basis_vector (S (S x) ^ a) (funbool_to_nat a H) x y)
Crunching:
(exp_in 0 1 ->
 sum_over_list (map Cmod2 (vec_to_list ψ)) =
 big_sum (fun i : nat => (Cmod (ψ i 0%nat) ^ 2)%R) d)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Crunching:
(forall l1 l2 : list bool,
 binlist_to_nat (l1 ++ l2) =
 binlist_to_nat l1 + 2 ^ length l1 * binlist_to_nat l2)
Crunching:
(forall l1 l2 : list bool,
 binlist_to_nat (l1 ++ l2) =
 binlist_to_nat l1 + 2 ^ length l1 * binlist_to_nat l2)
Crunching:
(exp_in 0 1 ->
 sum_over_list (map Cmod2 (vec_to_list ψ)) =
 big_sum (fun i : nat => (Cmod (ψ i 0%nat) ^ 2)%R) d)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(sum_over_list (map Cmod2 (vec_to_list n)) =
 big_sum (fun i : nat => (Cmod (n i 0%nat) * (Cmod (n i 0%nat) * 1))%R) y)
Axioms:
ClassicalDedekindReals.sig_not_dec : forall P : Prop, {~ ~ P} + {~ P}
ClassicalDedekindReals.sig_forall_dec
  : forall P : nat -> Prop,
    (forall n : nat, {P n} + {~ P n}) ->
    {n : nat | ~ P n} + {forall n : nat, P n}
prop_ext : ClassicalFacts.prop_extensionality
lib.Axioms.proof_irr : ClassicalFacts.proof_irrelevance
Clight_core.inline_external_call_mem_events
  : forall (ef : external_function) (ge : Senv.t) 
      (vargs : list val) (m : mem) (t : Events.trace) 
      (vres : val) (m' : mem),
    ef_inline ef = true ->
    Events.external_call ef ge vargs m t vres m' ->
    {trace : list event_semantics.mem_event
    | event_semantics.ev_elim m trace m'}
Events.inline_assembly_sem : string -> signature -> Events.extcall_sem
functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Events.external_functions_sem : string -> signature -> Events.extcall_sem
Eqdep.Eq_rect_eq.eq_rect_eq
  : forall (U : Type) (p : U) (Q : U -> Type) (x : Q p) (h : p = p),
    x = eq_rect p Q x p h
Classical_Prop.classic : forall P : Prop, P \/ ~ P
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(WF_Unitary n ->
 Forall (fun x : R => 0 <= x) (apply_u n) /\ sum_over_list (apply_u n) = 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(WF_Unitary n ->
 Forall (fun x : R => 0 <= x) (apply_u n) /\ sum_over_list (apply_u n) = 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Tactic call ran for 0.016 secs (0.015u,0.s) (success)
Crunching: (length (apply_u u) = (2 ^ 0)%nat)
Crunching: (length (apply_u H) = (2 ^ Hbeq)%nat)
Crunching: (length (apply_u n) = (2 ^ l)%nat)
Crunching: (length (apply_u CDML) = (2 ^ S l)%nat)
Crunching: (length (apply_u H) = (2 ^ w2)%nat)
Tactic call ran for 0.015 secs (0.015u,0.s) (success)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching: (length (apply_u H) = (2 ^ Hbeq)%nat)
Crunching: (length (apply_u u) = (2 ^ Hneq)%nat)
Crunching: (length (apply_u u) = (2 ^ Hneq)%nat)
Crunching: (length (apply_u n) = (2 ^ l)%nat)
Crunching: (length (apply_u CDML) = (2 ^ S l)%nat)
Crunching: (length (apply_u H) = (2 ^ w2)%nat)
Crunching:
(nth x (apply_u dyz) 0 =
 (Cmod ⟨ basis_vector (2 ^ y) x, dyz × basis_vector (2 ^ y) 0 ⟩ *
  (Cmod ⟨ basis_vector (2 ^ y) x, dyz × basis_vector (2 ^ y) 0 ⟩ * 1))%R)
Crunching:
(forall x : nat,
 (x < 2 ^ 0)%nat ->
 WF_Matrix l ->
 nth x (apply_u l) (- 0)%R =
 probability_of_outcome (basis_vector (2 ^ 0) x) (l × basis_vector (2 ^ 0) 0))
Crunching:
((H < 2 ^ n)%nat ->
 WF_Matrix a ->
 nth H (apply_u a) (- 0)%R =
 probability_of_outcome (basis_vector (2 ^ n) H) (a × basis_vector (2 ^ n) 0))
Crunching:
(nth s1 (apply_u c_encad) 0 =
 probability_of_outcome (basis_vector (2 ^ c) s1)
   (c_encad × basis_vector (2 ^ c) 0))
Crunching:
(nth s1 (apply_u c_encad) 0 =
 probability_of_outcome (basis_vector (2 ^ c) s1)
   (c_encad × basis_vector (2 ^ c) 0))
Crunching:
(nth s1 (apply_u c_encad) 0 =
 probability_of_outcome (basis_vector (2 ^ c) s1)
   (c_encad × basis_vector (2 ^ c) 0))
Crunching:
(nth s1 (apply_u c_encad) 0 =
 probability_of_outcome (basis_vector (2 ^ c) s1)
   (c_encad × basis_vector (2 ^ c) 0))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(nth x (apply_u u) 0 =
 (norm ((basis_vector (S x) x) † × (u × basis_vector (S x) 0)) ^ 2)%R)
Crunching: (Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (Forall (fun x : R => 0 <= x) (repeat m 0))
Crunching: (Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (Forall (fun x : R => 0 <= x) (repeat m 0))
Crunching: (Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (Forall (fun x : R => 0 <= x) (repeat a H))
Crunching: (0 <= x -> Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (forall n : nat, (n >= ?N)%nat -> R_dist (PI_2_3_7_tg n) R0 < a)
Crunching:
(exists N : nat, forall n : nat, (n >= N)%nat -> R_dist (PI_2_3_7_tg n) 0 < a)
Crunching: (Forall (fun x : R => 0 <= x) (repeat r 0))
Crunching:
(forall (m : nat) (x : R), sum_over_list (repeat x m) = (INR m * x)%R)
Crunching:
(forall (m : nat) (x : R), sum_over_list (repeat x m) = (INR m * x)%R)
Crunching:
(forall (m : nat) (x : R), sum_over_list (repeat x m) = (INR m * x)%R)
Crunching: (sum_over_list (repeat x m) = (INR m * x)%R)
Crunching: (sum_over_list (repeat x 0) = (INR 0 * x)%R)
     = @^~ 8
     : M nat
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
Crunching: (sum_over_list (repeat x 0) = (INR 0 * x)%R)
Crunching: (sum_over_list (repeat x m) = (INR m * x)%R)
Crunching: (binlist_to_nat [] = b1)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (binlist_to_nat [] = b1)
Crunching: (hyp_r <= sample (uniform hyp_r n) m < n)%nat
Crunching: (binlist_to_nat [] = b1)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching: (0 = m)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching: (0 = m)
Crunching: (binlist_to_nat [] = b1)
Crunching: (hyp_r <= sample (uniform hyp_r n) m < n)%nat
Crunching: (hyp_r <= sample (uniform hyp_r n) m < n)%nat
Crunching: (hyp_r <= sample (uniform hyp_r n) m < n)%nat
Crunching: (0 = m)
Crunching: (0 = m)
Crunching: (hyp_r <= sample (uniform hyp_r n) m < n)%nat
Crunching: (hyp_r <= sample (uniform hyp_r n) m < n)%nat
Crunching: False
Crunching:
(Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
simplified dependent [if true]
e : (x <? n1)  = true
if (x <? n1)
then (fun E0 : (x <? n1) = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : (x <? n1) = false =>
 BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 (ltN_plus_lemma1 e) E0)))
Crunching:
(Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching: (distribution (uniform n r))
Crunching: (distribution (uniform n r))
Crunching: (distribution (uniform n r))
Crunching: (lb <= (x + y) * / 2)
Crunching: (lb <= (x + y) * / 2)
Crunching:
(Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(0 <= P1 <= H' ->
 0 < LT ->
 (P1 + H') * (P1 ^ LT + H' ^ LT) <= 2 * (P1 * P1 ^ LT + H' * H' ^ LT))
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching:
(0 <= alp <= H3 ->
 0 < x ->
 (alp + H3) * (alp ^ x + H3 ^ x) <= 2 * (alp * alp ^ x + H3 * H3 ^ x))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching:
(0 < x' ->
 (Hx + H10) * (Hx ^ x' + H10 ^ x') <= 2 * (Hx * Hx ^ x' + H10 * H10 ^ x'))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform 0 1))
Crunching: (distribution (uniform 0 Hn))
Crunching: (distribution (uniform 0 Hn))
Crunching: (distribution (uniform 0 r))
Crunching: (distribution (uniform 0 a))
Crunching: (distribution (uniform n r))
Crunching: (distribution (uniform n r))
Crunching: (distribution (uniform n r))
Crunching:
(Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
Crunching:
(length (incr_bin IH) = S (length IH) ->
 length (incr_bin (n :: IH)) = S (length (n :: IH)))
Crunching:
(length (incr_bin IH) = S (length IH) ->
 length (incr_bin (n :: IH)) = S (length (n :: IH)))
Crunching:
(length (incr_bin IH) = S (length IH) ->
 length (incr_bin (n :: IH)) = S (length (n :: IH)))
Crunching: (distribution (uniform n r))
Crunching: (distribution (uniform n r))
Crunching: (distribution (uniform n r))
Crunching: (length (incr_bin f) = length f)
Crunching:
(Exists (fun b : bool => b <> true) f -> length (incr_bin f) = length f)
Crunching: (lb <= (x + y) * / 2)
Crunching: (lb <= (x + y) * / 2)
Crunching: (forall r : nat, (0 < r)%nat -> distribution (uniform 0 r))
Crunching: (forall r : nat, (0 < r)%nat -> distribution (uniform 0 r))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (length (incr_bin f) = length f)
Crunching: (length (incr_bin f) = length f)
Crunching: (length (incr_bin f) = length f)
Crunching:
(Exists (fun b : bool => b <> true) f -> length (incr_bin f) = length f)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
rewrite if_dtt
if (n1 + x <? n1)
then (fun E0 : (n1 + x <? n1) = true => AA (ltN_of_nat (n1 + x) n1 E0))
else
(fun E0 : (n1 + x <? n1) = false =>
 BB (ltN_of_nat (n1 + x - n1) n2 (ltN_split_lemma1 (plus_ltN_lemma1 e) E0)))
Crunching: (forall l r : nat, (l <= r)%nat -> length (uniform l r) = r)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Crunching: (length (uniform a' Ha') = Ha')
Crunching: (forall l r : nat, (l <= r)%nat -> length (uniform l r) = r)
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Crunching: (∣0⟩ = basis_vector 2 0)
Building invert_bind_args_unknown...
Building all_pattern_idents...
Crunching: (∣0⟩ = basis_vector 2 0)
Building eta_pattern_ident_cps_gen...
Crunching: (∣0⟩ = basis_vector 2 0)
Building eta_pattern_ident_cps_gen_expand_literal...
Crunching: (∣0⟩ = basis_vector 2 0)
Building split_types...
Crunching: (∣0⟩ = basis_vector 2 0)
Building add_types_from_raw_sig...
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Building to_type_split_types_subst_default_eq...
Crunching: (∣0⟩ = basis_vector 2 0)
Building projT1_add_types_from_raw_sig_eq...
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Crunching: (length (incr_bin f) = length f)
Crunching: (∣0⟩ = basis_vector 2 0)
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (length (incr_bin f) = length f)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(Exists (fun b : bool => b <> true) f -> length (incr_bin f) = length f)
Crunching:
(Exists (fun b : bool => b <> true) f -> length (incr_bin f) = length f)
Crunching: (∣0⟩ = basis_vector 2 0)
Building unify...
Crunching: (length (incr_bin f) = length f)
Crunching: (∣0⟩ = basis_vector 2 0)
Building unify_unknown...
Building final ident package...
Crunching: (∣0⟩ = basis_vector 2 0)
Proving is_simple_correct0...
Crunching: (length (incr_bin f) = length f)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (length (incr_bin f) = length f)
Tactic call ran for 0.359 secs (0.353u,0.006s) (success)
Proving invert_bind_args_raw_to_typed...
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (length (incr_bin f) = length f)
Tactic call ran for 0.228 secs (0.221u,0.006s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.016 secs (0.016u,0.s) (success)
Proving split_ident_to_ident...
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.013 secs (0.013u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(Exists (fun b : bool => b <> true) f -> length (incr_bin f) = length f)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.805 secs (0.789u,0.015s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 1.46 secs (1.45u,0.009s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Crunching: (forall r : nat, (b <= r)%nat -> length (uniform b r) = r)
Reifying...
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Crunching: (Nat.testbit (length (incr_bin k)) m = Nat.testbit (length k) m)
Tactic call ran for 0.158 secs (0.155u,0.003s) (success)
Tactic call ran for 0.113 secs (0.11u,0.002s) (success)
Tactic call ran for 0.113 secs (0.113u,0.s) (success)
Assembling rewrite_head_no_dtree...
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Reducing rewrite_head_no_dtree...
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Proving Rewriter_Wf...
Tactic call ran for 0.068 secs (0.067u,0.s) (success)
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Tactic call ran for 0.967 secs (0.945u,0.021s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.839 secs (0.832u,0.007s) (success)
Tactic call ran for 0.612 secs (0.597u,0.015s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Crunching:
(exp_in 0 (exp 0) ->
 length (if x then false :: incr_bin [] else [true]) = S (length []))
Finished transaction in 21.944 secs (21.587u,0.34s) (successful)
Crunching: (length (uniform a' Ha') = Ha')
Crunching: (length (uniform a' Ha') = Ha')
Crunching: (length (uniform a' Ha') = Ha')
Crunching: (forall l r : nat, (l <= r)%nat -> length (uniform l r) = r)
Crunching: (forall l r : nat, (l <= r)%nat -> length (uniform l r) = r)
Crunching: (forall l r : nat, (l <= r)%nat -> length (uniform l r) = r)
Crunching: (false = true)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (false = true)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (false = true)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (false = true)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (false = true)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (false = true)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (false = true)
Crunching: (x - n <= Hxnonneg -> x - Hxnonneg <= n)
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
clear  H0a'  :  (False -> cmpA a a' <> Lt)
Crunching:
((H9 > 0)%R ->
 exists alp : R,
   (alp > 0)%R /\
   (forall x : Base R_met,
    D_x no_cond s x /\ (dist R_met x s < alp)%R ->
    (dist R_met (- cos x)%G (- cos s)%G < H9)%R))
rewrite if_dtt
if (proj1_sig k1 + proj1_sig k2 <? n)
then
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = true =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2) n E)
else
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = false =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2 - n) n (ltN_plus_mod_lemma1 k1 k2 E))
Crunching:
((forall r1 r2 r3 : R, r1 < r2 -> r2 < r3 -> r1 < r3) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 forall x : nat, fst pol (2 ^ pol + x) = S (fst pol x))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Finished transaction in 15.283 secs (15.215u,0.029s) (successful)
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Crunching: (f < 2 ^ E -> length (nat_to_binlist' f) <= E)
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Crunching: (fst pol (2 ^ pol + 0) = S (fst pol 0))
Crunching: (fst pol (2 ^ pol + i) = S (fst pol i))
Crunching: (forall x : nat, fst pol (2 ^ pol + x) = S (fst pol x))
Crunching: False
Crunching:
((forall r1 r2 r3 : R, r1 < r2 -> r2 < r3 -> r1 < r3) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 forall x : nat, fst pol (2 ^ pol + x) = S (fst pol x))
Crunching:
((0 < false)%R /\
 (forall x : Base R_met,
  D_x no_cond 1 x /\ (dist R_met x 1 < false)%R ->
  (dist R_met (atan x) (atan 1) < LE)%R))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Crunching:
((false > 0)%R /\
 (forall x : Base R_met,
  D_x no_cond 1 x /\ (dist R_met x 1 < false)%R ->
  (dist R_met (atan x) (atan 1) < LE)%R))
Crunching:
((eq > √ 0)%R ->
 exists alp : R,
   (alp > √ 0)%R /\
   (forall x : R,
    D_x no_cond 1 x /\ (R_dist x 1 < alp)%R ->
    (R_dist (atan x) (atan 1) < eq)%R))
Crunching:
((eq > √ 0)%R ->
 exists alp : R,
   (alp > √ 0)%R /\
   (forall x : R,
    D_x no_cond 1 x /\ (R_dist x 1 < alp)%R ->
    (R_dist (atan x) (atan 1) < eq)%R))
Crunching:
((0 < eq)%R ->
 exists alp : R,
   (0 < alp)%R /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\ (dist R_met x 1 < alp)%R ->
    (dist R_met (atan x) (atan 1) < eq)%R))
Crunching: (fst b Hb = 0%nat)
Crunching: (length (nat_to_binlist o eps) = o)
Crunching: (length (nat_to_binlist o eps) = o)
Crunching:
(match
   (fix Ffix (x x0 : nat) {struct x0} : nat :=
      match x0 with
      | 0%nat => 1%nat
      | S x1 =>
          (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
             match x2 with
             | 0%nat => 0%nat
             | S x4 =>
                 (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                    match x5 with
                    | 0%nat => x6
                    | S x7 => S (Ffix1 x7 x6)
                    end) x3 (Ffix0 x4 x3)
             end) x (Ffix x x1)
      end) 2%nat pol
 with
 | 0%nat =>
     (fix Ffix (x x0 : nat) {struct x0} : nat :=
        match x0 with
        | 0%nat => 1%nat
        | S x1 =>
            (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
               match x2 with
               | 0%nat => 0%nat
               | S x4 =>
                   (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                      match x5 with
                      | 0%nat => x6
                      | S x7 => S (Ffix1 x7 x6)
                      end) x3 (Ffix0 x4 x3)
               end) x (Ffix x x1)
        end) 2%nat pol
 | S x =>
     let (H, _) :=
       (fix Ffix (x0 x1 x2 x3 : nat) {struct x0} : nat * nat :=
          match x0 with
          | 0%nat => (x2, x3)
          | S x4 =>
              match x3 with
              | 0%nat => Ffix x4 x1 (S x2) x1
              | S x5 => Ffix x4 x1 x2 x5
              end
          end) P x 0%nat x in
     H
 end = 0%nat)
Crunching: (fst 0 Hb = 0%nat)
Crunching: (fst b Hb = 0%nat)
Crunching:
(forall eps : R,
 (eps > 0)%R ->
 exists alp : R,
   (alp > 0)%R /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\
    ((let (Base, dist, _, _, _, _) as m return (Base m -> Base m -> R) :=
        R_met in
      dist) x 1 < alp)%R ->
    ((let (Base, dist, _, _, _, _) as m return (Base m -> Base m -> R) :=
        R_met in
      dist) (atan x) (atan 1) < eps)%R))
Crunching:
((true > 0)%R /\
 (forall x : R,
  D_x no_cond 1 x /\ (R_dist x 1 < true)%R ->
  (R_dist (atan x) (atan 1) < a)%R))
rewrite if_dtt
if (x0 <? n)
then
(fun E0 : (x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) x0 E0))
else
(fun E0 : (x0 <? n) = false =>
 BB (exist (fun k : nat => (k <? 0) = true) (x0 - n) (ltN_split_lemma1 e E0)))
destruct  (Nat.add_0_r n)  in  x
Crunching: (fst a b = 0%nat)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
((0 < false)%R /\
 (forall x : Base R_met,
  D_x no_cond 1 x /\ (dist R_met x 1 < false)%R ->
  (dist R_met (atan x) (atan 1) < LE)%R))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
((false > 0)%R /\
 (forall x : Base R_met,
  D_x no_cond 1 x /\ (dist R_met x 1 < false)%R ->
  (dist R_met (atan x) (atan 1) < LE)%R))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
((eq > √ 0)%R ->
 exists alp : R,
   (alp > √ 0)%R /\
   (forall x : R,
    D_x no_cond 1 x /\ (R_dist x 1 < alp)%R ->
    (R_dist (atan x) (atan 1) < eq)%R))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
((eq > √ 0)%R ->
 exists alp : R,
   (alp > √ 0)%R /\
   (forall x : R,
    D_x no_cond 1 x /\ (R_dist x 1 < alp)%R ->
    (R_dist (atan x) (atan 1) < eq)%R))
Crunching:
(match
   (fix Ffix (x x0 : nat) {struct x0} : nat :=
      match x0 with
      | 0%nat => 1%nat
      | S x1 =>
          (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
             match x2 with
             | 0%nat => 0%nat
             | S x4 =>
                 (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                    match x5 with
                    | 0%nat => x6
                    | S x7 => S (Ffix1 x7 x6)
                    end) x3 (Ffix0 x4 x3)
             end) x (Ffix x x1)
      end) 2%nat pol
 with
 | 0%nat =>
     (fix Ffix (x x0 : nat) {struct x0} : nat :=
        match x0 with
        | 0%nat => 1%nat
        | S x1 =>
            (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
               match x2 with
               | 0%nat => 0%nat
               | S x4 =>
                   (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                      match x5 with
                      | 0%nat => x6
                      | S x7 => S (Ffix1 x7 x6)
                      end) x3 (Ffix0 x4 x3)
               end) x (Ffix x x1)
        end) 2%nat pol
 | S x =>
     let (H, _) :=
       (fix Ffix (x0 x1 x2 x3 : nat) {struct x0} : nat * nat :=
          match x0 with
          | 0%nat => (x2, x3)
          | S x4 =>
              match x3 with
              | 0%nat => Ffix x4 x1 (S x2) x1
              | S x5 => Ffix x4 x1 x2 x5
              end
          end) P x 0%nat x in
     H
 end = 0%nat)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (fst 0 Hb = 0%nat)
Crunching: (fst b Hb = 0%nat)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
((0 < eq)%R ->
 exists alp : R,
   (0 < alp)%R /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\ (dist R_met x 1 < alp)%R ->
    (dist R_met (atan x) (atan 1) < eq)%R))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching: (fst s x = 0%nat)
Crunching: (fst s x = 0%nat)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching: (fst m Hcase = 0%nat)
Crunching: (fst m Hcase = 0%nat)
Crunching: (fst m Hcase = 0%nat)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching: (funbool_to_list b a = funbool_to_list b (update a psi_un n))
Finished transaction in 89.823 secs (89.351u,0.279s) (successful)
Crunching: (funbool_to_list b (update a psi_un n) = funbool_to_list b a)
Crunching: (snd H 0 = 0%nat)
Crunching: (b <= m -> funbool_to_list b (update a m n) = funbool_to_list b a)
rewrite if_dtt
if match n1 with
   | 0 => false
   | S m' => x <=? m'
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = false => BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 e E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching: False
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching: (~ 1 < 1)
Crunching:
((0 + 1)%R = 1 ->
 (0 + 1)%R = 1 -> Rabs Hincl < Rabs HF -> HF > 0 -> Hincl < HF)
Crunching:
((1 + 0)%R = 1 ->
 (0 + 1)%R = 1 -> Rabs Hincl < Rabs HF -> HF > 0 -> Hincl < HF)
Crunching: (snd H 0 = 0%nat)
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
simplified dependent [if true]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if false]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
Crunching: (funbool_to_list b a = funbool_to_list b (update a psi_un n))
Crunching: (funbool_to_list b (update a psi_un n) = funbool_to_list b a)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Finished transaction in 20.562 secs (20.144u,0.375s) (successful)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (funbool_to_list b a = funbool_to_list b (update a psi_un n))
Crunching: (funbool_to_list b (update a psi_un n) = funbool_to_list b a)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (length Hb = n -> funbool_to_list n (list_to_funbool n Hb) = Hb)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (length Hb = n -> funbool_to_list n (list_to_funbool n Hb) = Hb)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length [] = n -> funbool_to_list n (list_to_funbool n []) = [])
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
Crunching: (funbool_to_list x (list_to_funbool x z1) = z1)
Debug:
In environment
n : int
r_ge0 : 2%:~R <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n; n%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end one) zero))" (cannot unify "false" and 
"true").
Debug:
In environment
n : int
r_ge0 : 2%:~R <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n; n%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end one) zero))" (cannot unify "false" and 
"true").
Crunching: (length Hb = n -> funbool_to_list n (list_to_funbool n Hb) = Hb)
Debug:
In environment
n : int
r_ge0 : 2%:~R <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n; n%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end one) zero))" (cannot unify "false" and 
"true").
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (snd pol X = X)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (funbool_to_nat len (nat_to_funbool len H0) = H0)
Finished transaction in 109.724 secs (108.991u,0.32s) (successful)
Crunching: (funbool_to_nat len (nat_to_funbool len n) = n)
Crunching: False
Crunching: (H8 = m)
Crunching: False
Crunching:
(exists alp : R,
   alp > 0 /\
   (forall x : R,
    D_x no_cond 1 x /\ R_dist x 1 < alp -> R_dist (atan x) (atan 1) < eps))
Crunching: False
Crunching: False
Crunching: (funbool_to_nat len (nat_to_funbool len H0) = H0)
Crunching:
(exists alp : R,
   alp > 0 /\
   (forall x : R,
    D_x no_cond 1 x /\ R_dist x 1 < alp -> R_dist (atan x) (atan 1) < eps))
Crunching: (funbool_to_nat len (nat_to_funbool len H0) = H0)
Crunching: False
Crunching: False
Crunching: (INR (S n - 1) = INR n)
Crunching:
(exists alp : R,
   alp > 0 /\
   (forall x : R,
    D_x no_cond 1 x /\ R_dist x 1 < alp -> R_dist (atan x) (atan 1) < eps))
Crunching: (INR (S n - 1) = INR n)
Crunching: (INR (S n - 1) = INR n)
Crunching: (INR (S n - 1) = INR n)
Crunching: (forall x y : nat, (y < 2 ^ n)%nat -> fst n (x * 2 ^ n + y) = x)
Crunching: (forall x y : nat, (y < 2 ^ n)%nat -> fst n (x * 2 ^ n + y) = x)
Crunching: ((E0 < 2 ^ Ha)%nat -> fst Ha (h * 2 ^ Ha + E0) = h)
Crunching: ((c < 2 ^ n)%nat -> fst n (a * 2 ^ n + c) = a)
