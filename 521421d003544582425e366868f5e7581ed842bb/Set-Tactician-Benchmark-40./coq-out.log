hammer main loaded
Module
E
 : Sig
     Definition t : Set.
     Definition eq : positive -> positive -> Prop.
     Definition eq_refl : forall x : t, x = x.
     Definition eq_sym : forall x y : t, x = y -> y = x.
     Definition eq_trans : forall x y z : t, x = y -> y = z -> x = z.
     Definition bits_lt : positive -> positive -> Prop.
     Definition lt : positive -> positive -> Prop.
     Definition bits_lt_trans :
       forall x y z : positive, bits_lt x y -> bits_lt y z -> bits_lt x z.
     Definition lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.
     Definition bits_lt_antirefl : forall x : positive, ~ bits_lt x x.
     Definition lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
     Definition compare : forall x y : t, Compare lt eq x y.
     Definition eq_dec : forall x y : positive, {x = y} + {x <> y}.
   End
:= PositiveOrderedTypeBits

E.t = positive
     : Set
Module
S
 : Sig
     Module E
     Definition elt : Type.
     Inductive tree : Set :=
         Leaf : tree | Node : tree -> bool -> tree -> tree.
     Definition tree_ind :
       forall P : tree -> Prop,
       P Leaf ->
       (forall t : tree,
        P t -> forall (b : bool) (t0 : tree), P t0 -> P (Node t b t0)) ->
       forall t : tree, P t.
     Definition t : Type.
     Definition empty : t.
     Definition is_empty : t -> bool.
     Definition mem : elt -> t -> bool.
     Definition add : elt -> t -> t.
     Definition singleton : elt -> t.
     Definition node : t -> bool -> t -> t.
     Definition remove : elt -> t -> t.
     Definition union : t -> t -> t.
     Definition inter : t -> t -> t.
     Definition diff : t -> t -> t.
     Definition equal : t -> t -> bool.
     Definition subset : t -> t -> bool.
     Definition rev_append : elt -> elt -> elt.
     Definition rev : elt -> elt.
     Definition xfold :
       forall B : Type, (elt -> B -> B) -> t -> B -> elt -> B.
     Definition fold : forall B : Type, (elt -> B -> B) -> t -> B -> B.
     Definition xforall : (elt -> bool) -> t -> elt -> bool.
     Definition for_all : (elt -> bool) -> t -> bool.
     Definition xexists : (elt -> bool) -> t -> elt -> bool.
     Definition exists_ : (elt -> bool) -> t -> bool.
     Definition xfilter : (elt -> bool) -> t -> elt -> t.
     Definition filter : (elt -> bool) -> t -> t.
     Definition xpartition : (elt -> bool) -> t -> elt -> t * t.
     Definition partition : (elt -> bool) -> t -> t * t.
     Definition xelements : t -> elt -> list elt -> list elt.
     Definition elements : t -> list elt.
     Definition cardinal : t -> nat.
     Definition omap : (elt -> elt) -> option elt -> option elt.
     Definition choose : t -> option elt.
     Definition min_elt : t -> option elt.
     Definition max_elt : t -> option elt.
     Definition compare_bool : bool -> bool -> comparison.
     Definition compare_fun : t -> t -> comparison.
     Definition In : elt -> t -> Prop.
     Definition Equal : t -> t -> Prop.
     Definition Subset : t -> t -> Prop.
     Definition Empty : t -> Prop.
     Definition For_all : (elt -> Prop) -> t -> Prop.
     Definition Exists : (elt -> Prop) -> t -> Prop.
     Definition eq : t -> t -> Prop.
     Definition lt : t -> t -> Prop.
     Definition In_1 :
       forall (s : t) (x y : positive), E.eq x y -> In x s -> In y s.
     Definition eq_refl : forall s : t, eq s s.
     Definition eq_sym : forall s s' : t, eq s s' -> eq s' s.
     Definition eq_trans :
       forall s s' s'' : t, eq s s' -> eq s' s'' -> eq s s''.
     Definition mem_1 : forall (s : t) (x : elt), In x s -> mem x s = true.
     Definition mem_2 : forall (s : t) (x : elt), mem x s = true -> In x s.
     Definition mem_Leaf : forall x : elt, mem x Leaf = false.
     Definition empty_1 : Empty empty.
     Definition mem_node :
       forall (x : elt) (l : t) (o : bool) (r : t),
       mem x (node l o r) = mem x (Node l o r).
     Definition is_empty_spec : forall s : t, Empty s <-> is_empty s = true.
     Definition is_empty_1 : forall s : t, Empty s -> is_empty s = true.
     Definition is_empty_2 : forall s : t, is_empty s = true -> Empty s.
     Definition subset_Leaf_s : forall s : t, Leaf [<=] s.
     Definition subset_spec :
       forall s s' : t, s [<=] s' <-> subset s s' = true.
     Definition subset_1 : forall s s' : t, s [<=] s' -> subset s s' = true.
     Definition subset_2 : forall s s' : t, subset s s' = true -> s [<=] s'.
     Definition equal_subset :
       forall s s' : t, equal s s' = subset s s' && subset s' s.
     Definition equal_spec : forall s s' : t, s [=] s' <-> equal s s' = true.
     Definition equal_1 : forall s s' : t, s [=] s' -> equal s s' = true.
     Definition equal_2 : forall s s' : t, equal s s' = true -> s [=] s'.
     Definition eq_dec_subproof :
       forall s s' : t, equal s s' = false -> ~ s [=] s'.
     Definition eq_dec : forall s s' : t, {eq s s'} + {~ eq s s'}.
     Definition lex_Opp :
       forall u v u' v' : comparison,
       u = CompOpp u' -> v = CompOpp v' -> lex u v = CompOpp (lex u' v').
     Definition compare_bool_inv :
       forall b b' : bool, compare_bool b b' = CompOpp (compare_bool b' b).
     Definition compare_inv :
       forall s s' : t, compare_fun s s' = CompOpp (compare_fun s' s).
     Definition lex_Eq :
       forall u v : comparison, lex u v = Eq <-> u = Eq /\ v = Eq.
     Definition compare_bool_Eq :
       forall b1 b2 : bool, compare_bool b1 b2 = Eq <-> eqb b1 b2 = true.
     Definition compare_equal :
       forall s s' : t, compare_fun s s' = Eq <-> equal s s' = true.
     Definition compare_gt :
       forall s s' : t, compare_fun s s' = Gt -> lt s' s.
     Definition compare_eq :
       forall s s' : t, compare_fun s s' = Eq -> eq s s'.
     Definition compare : forall s s' : t, Compare lt eq s s'.
     Inductive ct : comparison -> comparison -> comparison -> Prop :=
         ct_xxx : forall x : comparison, ct x x x
       | ct_xex : forall x : comparison, ct x Eq x
       | ct_exx : forall x : comparison, ct Eq x x
       | ct_glx : forall x : comparison, ct Gt Lt x
       | ct_lgx : forall x : comparison, ct Lt Gt x.
     Definition ct_cxe : forall x : comparison, ct (CompOpp x) x Eq.
     Definition ct_xce : forall x : comparison, ct x (CompOpp x) Eq.
     Definition ct_lxl : forall x : comparison, ct Lt x Lt.
     Definition ct_gxg : forall x : comparison, ct Gt x Gt.
     Definition ct_xll : forall x : comparison, ct x Lt Lt.
     Definition ct_xgg : forall x : comparison, ct x Gt Gt.
     Definition ct_lex :
       forall u v w u' v' w' : comparison,
       ct u v w -> ct u' v' w' -> ct (lex u u') (lex v v') (lex w w').
     Definition ct_compare_bool :
       forall a b c : bool,
       ct (compare_bool a b) (compare_bool b c) (compare_bool a c).
     Definition compare_x_Leaf :
       forall s : t, compare_fun s Leaf = (if is_empty s then Eq else Gt).
     Definition compare_empty_x :
       forall a : t,
       is_empty a = true ->
       forall b : t, compare_fun a b = (if is_empty b then Eq else Lt).
     Definition compare_x_empty :
       forall a : t,
       is_empty a = true ->
       forall b : t, compare_fun b a = (if is_empty b then Eq else Gt).
     Definition ct_compare_fun :
       forall a b c : t,
       ct (compare_fun a b) (compare_fun b c) (compare_fun a c).
     Definition lt_trans :
       forall s s' s'' : t, lt s s' -> lt s' s'' -> lt s s''.
     Definition lt_not_eq : forall s s' : t, lt s s' -> ~ eq s s'.
     Definition add_spec :
       forall (x y : elt) (s : t), In y (add x s) <-> x = y \/ In y s.
     Definition add_1 : forall (s : t) (x y : elt), x = y -> In y (add x s).
     Definition add_2 : forall (s : t) (x y : elt), In y s -> In y (add x s).
     Definition add_3 :
       forall (s : t) (x y : elt), x <> y -> In y (add x s) -> In y s.
     Definition remove_spec :
       forall (x y : elt) (s : t), In y (remove x s) <-> x <> y /\ In y s.
     Definition remove_1 :
       forall (s : t) (x y : elt), x = y -> ~ In y (remove x s).
     Definition remove_2 :
       forall (s : t) (x y : elt), x <> y -> In y s -> In y (remove x s).
     Definition remove_3 :
       forall (s : t) (x y : elt), In y (remove x s) -> In y s.
     Definition singleton_1 : forall x y : elt, In y (singleton x) -> x = y.
     Definition singleton_2 : forall x y : elt, x = y -> In y (singleton x).
     Definition union_spec :
       forall (x : elt) (s s' : t), In x (union s s') <-> In x s \/ In x s'.
     Definition union_1 :
       forall (s s' : t) (x : elt), In x (union s s') -> In x s \/ In x s'.
     Definition union_2 :
       forall (s s' : t) (x : elt), In x s -> In x (union s s').
     Definition union_3 :
       forall (s s' : t) (x : elt), In x s' -> In x (union s s').
     Definition inter_spec :
       forall (x : elt) (s s' : t), In x (inter s s') <-> In x s /\ In x s'.
     Definition inter_1 :
       forall (s s' : t) (x : elt), In x (inter s s') -> In x s.
     Definition inter_2 :
       forall (s s' : t) (x : elt), In x (inter s s') -> In x s'.
     Definition inter_3 :
       forall (s s' : t) (x : elt), In x s -> In x s' -> In x (inter s s').
     Definition diff_spec :
       forall (x : elt) (s s' : t), In x (diff s s') <-> In x s /\ ~ In x s'.
     Definition diff_1 :
       forall (s s' : t) (x : elt), In x (diff s s') -> In x s.
     Definition diff_2 :
       forall (s s' : t) (x : elt), In x (diff s s') -> ~ In x s'.
     Definition diff_3 :
       forall (s s' : t) (x : elt), In x s -> ~ In x s' -> In x (diff s s').
     Definition fold_1 :
       forall (s : t) (A : Type) (i : A) (f : elt -> A -> A),
       fold f s i = fold_left (fun (a : A) (e : elt) => f e a) (elements s) i.
     Definition cardinal_1 : forall s : t, cardinal s = length (elements s).
     Definition xfilter_spec :
       forall (f : elt -> bool) (s : t) (x i : elt),
       In x (xfilter f s i) <-> In x s /\ f (i @ x) = true.
     Definition filter_1 :
       forall (s : t) (x : elt) (f : elt -> bool),
       compat_bool E.eq f -> In x (filter f s) -> In x s.
     Definition filter_2 :
       forall (s : t) (x : elt) (f : elt -> bool),
       compat_bool E.eq f -> In x (filter f s) -> f x = true.
     Definition filter_3 :
       forall (s : t) (x : elt) (f : elt -> bool),
       compat_bool E.eq f -> In x s -> f x = true -> In x (filter f s).
     Definition xforall_spec :
       forall (f : elt -> bool) (s : t) (i : elt),
       xforall f s i = true <-> For_all (fun x : elt => f (i @ x) = true) s.
     Definition for_all_1 :
       forall (s : t) (f : elt -> bool),
       compat_bool E.eq f ->
       For_all (fun x : elt => f x = true) s -> for_all f s = true.
     Definition for_all_2 :
       forall (s : t) (f : elt -> bool),
       compat_bool E.eq f ->
       for_all f s = true -> For_all (fun x : elt => f x = true) s.
     Definition xexists_spec :
       forall (f : elt -> bool) (s : t) (i : elt),
       xexists f s i = true <-> Exists (fun x : elt => f (i @ x) = true) s.
     Definition exists_1 :
       forall (s : t) (f : elt -> bool),
       compat_bool E.eq f ->
       Exists (fun x : elt => f x = true) s -> exists_ f s = true.
     Definition exists_2 :
       forall (s : t) (f : elt -> bool),
       compat_bool E.eq f ->
       exists_ f s = true -> Exists (fun x : elt => f x = true) s.
     Definition partition_filter :
       forall (s : t) (f : elt -> bool),
       partition f s = (filter f s, filter (fun x : elt => negb (f x)) s).
     Definition partition_1 :
       forall (s : t) (f : elt -> bool),
       compat_bool E.eq f -> fst (partition f s) [=] filter f s.
     Definition partition_2 :
       forall (s : t) (f : elt -> bool),
       compat_bool E.eq f ->
       snd (partition f s) [=] filter (fun x : elt => negb (f x)) s.
     Definition xelements_spec :
       forall (s : t) (j : elt) (acc : list elt) (y : positive),
       InL y (xelements s j acc) <->
       InL y acc \/ (exists x : elt, y = j @ x /\ mem x s = true).
     Definition elements_1 :
       forall (s : t) (x : elt), In x s -> InL x (elements s).
     Definition elements_2 :
       forall (s : t) (x : positive), InL x (elements s) -> In x s.
     Definition lt_rev_append :
       forall (j : elt) (x y : positive), E.lt x y -> E.lt (j @ x) (j @ y).
     Definition elements_3 : forall s : t, Sorted E.lt (elements s).
     Definition elements_3w : forall s : t, NoDupA E.eq (elements s).
     Definition choose_1 :
       forall (s : t) (x : elt), choose s = Some x -> In x s.
     Definition choose_2 : forall s : t, choose s = None -> Empty s.
     Definition choose_empty :
       forall s : t, is_empty s = true -> choose s = None.
     Definition choose_3' :
       forall s s' : t, s [=] s' -> choose s = choose s'.
     Definition choose_3 :
       forall (s s' : t) (x y : elt),
       choose s = Some x -> choose s' = Some y -> s [=] s' -> E.eq x y.
     Definition min_elt_1 :
       forall (s : t) (x : elt), min_elt s = Some x -> In x s.
     Definition min_elt_3 : forall s : t, min_elt s = None -> Empty s.
     Definition min_elt_2 :
       forall (s : t) (x y : elt), min_elt s = Some x -> In y s -> ~ E.lt y x.
     Definition max_elt_1 :
       forall (s : t) (x : elt), max_elt s = Some x -> In x s.
     Definition max_elt_3 : forall s : t, max_elt s = None -> Empty s.
     Definition max_elt_2 :
       forall (s : t) (x y : elt), max_elt s = Some x -> In y s -> ~ E.lt x y.
   End
:= PositiveSet

S.elt = positive
     : Type
Module
WF
 : Sig
     Definition eqb : positive -> positive -> bool.
     Parameter eq_bool_alt :
       forall b b' : bool, b = b' <-> (b = true <-> b' = true).
     Parameter eq_option_alt :
       forall (elt : Type) (o o' : option elt),
       o = o' <-> (forall e : elt, o = Some e <-> o' = Some e).
     Parameter MapsTo_fun :
       forall (elt : Type) (m : M.t elt) (x : M.key) (e e' : elt),
       M.MapsTo x e m -> M.MapsTo x e' m -> e = e'.
     Parameter In_iff :
       forall (elt : Type) (m : M.t elt) (x y : M.key),
       x = y -> M.In x m <-> M.In y m.
     Parameter MapsTo_iff :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e : elt),
       x = y -> M.MapsTo x e m <-> M.MapsTo y e m.
     Parameter mem_in_iff :
       forall (elt : Type) (m : M.t elt) (x : M.key),
       M.In x m <-> M.mem x m = true.
     Parameter not_mem_in_iff :
       forall (elt : Type) (m : M.t elt) (x : M.key),
       ~ M.In x m <-> M.mem x m = false.
     Parameter In_dec :
       forall (elt : Type) (m : M.t elt) (x : M.key),
       {M.In x m} + {~ M.In x m}.
     Parameter find_mapsto_iff :
       forall (elt : Type) (m : M.t elt) (x : M.key) (e : elt),
       M.MapsTo x e m <-> M.find x m = Some e.
     Parameter not_find_in_iff :
       forall (elt : Type) (m : M.t elt) (x : M.key),
       ~ M.In x m <-> M.find x m = None.
     Parameter in_find_iff :
       forall (elt : Type) (m : M.t elt) (x : M.key),
       M.In x m <-> M.find x m <> None.
     Parameter equal_iff :
       forall (elt : Type) (m m' : M.t elt) (cmp : elt -> elt -> bool),
       M.Equivb cmp m m' <-> M.equal cmp m m' = true.
     Parameter empty_mapsto_iff :
       forall (elt : Type) (x : M.key) (e : elt),
       M.MapsTo x e (M.empty elt) <-> False.
     Parameter empty_in_iff :
       forall (elt : Type) (x : M.key), M.In x (M.empty elt) <-> False.
     Parameter is_empty_iff :
       forall (elt : Type) (m : M.t elt), M.Empty m <-> M.is_empty m = true.
     Parameter add_mapsto_iff :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e e' : elt),
       M.MapsTo y e' (M.add x e m) <->
       x = y /\ e = e' \/ x <> y /\ M.MapsTo y e' m.
     Parameter add_in_iff :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e : elt),
       M.In y (M.add x e m) <-> x = y \/ M.In y m.
     Parameter add_neq_mapsto_iff :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e e' : elt),
       x <> y -> M.MapsTo y e' (M.add x e m) <-> M.MapsTo y e' m.
     Parameter add_neq_in_iff :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e : elt),
       x <> y -> M.In y (M.add x e m) <-> M.In y m.
     Parameter remove_mapsto_iff :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e : elt),
       M.MapsTo y e (M.remove x m) <-> x <> y /\ M.MapsTo y e m.
     Parameter remove_in_iff :
       forall (elt : Type) (m : M.t elt) (x y : M.key),
       M.In y (M.remove x m) <-> x <> y /\ M.In y m.
     Parameter remove_neq_mapsto_iff :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e : elt),
       x <> y -> M.MapsTo y e (M.remove x m) <-> M.MapsTo y e m.
     Parameter remove_neq_in_iff :
       forall (elt : Type) (m : M.t elt) (x y : M.key),
       x <> y -> M.In y (M.remove x m) <-> M.In y m.
     Parameter elements_mapsto_iff :
       forall (elt : Type) (m : M.t elt) (x : M.key) (e : elt),
       M.MapsTo x e m <-> InA (M.eq_key_elt (A:=elt)) (x, e) (M.elements m).
     Parameter elements_in_iff :
       forall (elt : Type) (m : M.t elt) (x : M.key),
       M.In x m <->
       (exists e : elt, InA (M.eq_key_elt (A:=elt)) (x, e) (M.elements m)).
     Parameter map_mapsto_iff :
       forall (elt elt' : Type) (m : M.t elt) (x : M.key) 
         (b : elt') (f : elt -> elt'),
       M.MapsTo x b (M.map f m) <->
       (exists a : elt, b = f a /\ M.MapsTo x a m).
     Parameter map_in_iff :
       forall (elt elt' : Type) (m : M.t elt) (x : M.key) (f : elt -> elt'),
       M.In x (M.map f m) <-> M.In x m.
     Parameter mapi_in_iff :
       forall (elt elt' : Type) (m : M.t elt) (x : M.key)
         (f : M.key -> elt -> elt'), M.In x (M.mapi f m) <-> M.In x m.
     Parameter mapi_inv :
       forall (elt elt' : Type) (m : M.t elt) (x : M.key) 
         (b : elt') (f : M.key -> elt -> elt'),
       M.MapsTo x b (M.mapi f m) ->
       exists (a : elt) (y : M.key), y = x /\ b = f y a /\ M.MapsTo x a m.
     Parameter mapi_1bis :
       forall (elt elt' : Type) (m : M.t elt) (x : M.key) 
         (e : elt) (f : M.key -> elt -> elt'),
       (forall (x0 y : M.key) (e0 : elt), x0 = y -> f x0 e0 = f y e0) ->
       M.MapsTo x e m -> M.MapsTo x (f x e) (M.mapi f m).
     Parameter mapi_mapsto_iff :
       forall (elt elt' : Type) (m : M.t elt) (x : M.key) 
         (b : elt') (f : M.key -> elt -> elt'),
       (forall (x0 y : M.key) (e : elt), x0 = y -> f x0 e = f y e) ->
       M.MapsTo x b (M.mapi f m) <->
       (exists a : elt, b = f x a /\ M.MapsTo x a m).
     Parameter mem_find_b :
       forall (elt : Type) (m : M.t elt) (x : M.key),
       M.mem x m = (if M.find x m then true else false).
     Parameter mem_b :
       forall (elt : Type) (m : M.t elt) (x y : M.key),
       x = y -> M.mem x m = M.mem y m.
     Parameter find_o :
       forall (elt : Type) (m : M.t elt) (x y : M.key),
       x = y -> M.find x m = M.find y m.
     Parameter empty_o :
       forall (elt : Type) (x : M.key), M.find x (M.empty elt) = None.
     Parameter empty_a :
       forall (elt : Type) (x : M.key), M.mem x (M.empty elt) = false.
     Parameter add_eq_o :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e : elt),
       x = y -> M.find y (M.add x e m) = Some e.
     Parameter add_neq_o :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e : elt),
       x <> y -> M.find y (M.add x e m) = M.find y m.
     Parameter add_o :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e : elt),
       M.find y (M.add x e m) = (if eq_dec x y then Some e else M.find y m).
     Parameter add_eq_b :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e : elt),
       x = y -> M.mem y (M.add x e m) = true.
     Parameter add_neq_b :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e : elt),
       x <> y -> M.mem y (M.add x e m) = M.mem y m.
     Parameter add_b :
       forall (elt : Type) (m : M.t elt) (x y : M.key) (e : elt),
       M.mem y (M.add x e m) = eqb x y || M.mem y m.
     Parameter remove_eq_o :
       forall (elt : Type) (m : M.t elt) (x y : M.key),
       x = y -> M.find y (M.remove x m) = None.
     Parameter remove_neq_o :
       forall (elt : Type) (m : M.t elt) (x y : M.key),
       x <> y -> M.find y (M.remove x m) = M.find y m.
     Parameter remove_o :
       forall (elt : Type) (m : M.t elt) (x y : M.key),
       M.find y (M.remove x m) = (if eq_dec x y then None else M.find y m).
     Parameter remove_eq_b :
       forall (elt : Type) (m : M.t elt) (x y : M.key),
       x = y -> M.mem y (M.remove x m) = false.
     Parameter remove_neq_b :
       forall (elt : Type) (m : M.t elt) (x y : M.key),
       x <> y -> M.mem y (M.remove x m) = M.mem y m.
     Parameter remove_b :
       forall (elt : Type) (m : M.t elt) (x y : M.key),
       M.mem y (M.remove x m) = negb (eqb x y) && M.mem y m.
     Parameter map_o :
       forall (elt elt' : Type) (m : M.t elt) (x : M.key) (f : elt -> elt'),
       M.find x (M.map f m) = option_map f (M.find x m).
     Parameter map_b :
       forall (elt elt' : Type) (m : M.t elt) (x : M.key) (f : elt -> elt'),
       M.mem x (M.map f m) = M.mem x m.
     Parameter mapi_b :
       forall (elt elt' : Type) (m : M.t elt) (x : M.key)
         (f : M.key -> elt -> elt'), M.mem x (M.mapi f m) = M.mem x m.
     Parameter mapi_o :
       forall (elt elt' : Type) (m : M.t elt) (x : M.key)
         (f : M.key -> elt -> elt'),
       (forall (x0 y : M.key) (e : elt), x0 = y -> f x0 e = f y e) ->
       M.find x (M.mapi f m) = option_map (f x) (M.find x m).
     Parameter map2_1bis :
       forall (elt elt' elt'' : Type) (m : M.t elt) 
         (m' : M.t elt') (x : M.key)
         (f : option elt -> option elt' -> option elt''),
       f None None = None ->
       M.find x (M.map2 f m m') = f (M.find x m) (M.find x m').
     Parameter elements_o :
       forall (elt : Type) (m : M.t elt) (x : M.key),
       M.find x m = findA (eqb x) (M.elements m).
     Parameter elements_b :
       forall (elt : Type) (m : M.t elt) (x : M.key),
       M.mem x m =
       existsb (fun p : positive * elt => eqb x (fst p)) (M.elements m).
     Parameter Equal_mapsto_iff :
       forall (elt : Type) (m1 m2 : M.t elt),
       M.Equal m1 m2 <->
       (forall (k : M.key) (e : elt), M.MapsTo k e m1 <-> M.MapsTo k e m2).
     Parameter Equal_Equiv :
       forall (elt : Type) (m m' : M.t elt), M.Equal m m' <-> M.Equiv eq m m'.
     Definition compat_cmp :
       forall elt : Type,
       (elt -> elt -> Prop) -> (elt -> elt -> bool) -> Prop.
     Parameter Equiv_Equivb :
       forall (elt : Type) (eq_elt : elt -> elt -> Prop)
         (cmp : elt -> elt -> bool),
       compat_cmp eq_elt cmp ->
       forall m m' : M.t elt, M.Equiv eq_elt m m' <-> M.Equivb cmp m m'.
     Parameter Equal_Equivb :
       forall (elt : Type) (cmp : elt -> elt -> bool),
       (forall e e' : elt, cmp e e' = true <-> e = e') ->
       forall m m' : M.t elt, M.Equal m m' <-> M.Equivb cmp m m'.
     Parameter Equal_Equivb_eqdec :
       forall (elt : Type)
         (eq_elt_dec : forall e e' : elt, {e = e'} + {e <> e'}),
       let cmp := fun e e' : elt => if eq_elt_dec e e' then true else false
         in
       forall m m' : M.t elt, M.Equal m m' <-> M.Equivb cmp m m'.
     Parameter Equal_refl : forall (elt : Type) (m : M.t elt), M.Equal m m.
     Parameter Equal_sym :
       forall (elt : Type) (m m' : M.t elt), M.Equal m m' -> M.Equal m' m.
     Parameter Equal_trans :
       forall (elt : Type) (m m' m'' : M.t elt),
       M.Equal m m' -> M.Equal m' m'' -> M.Equal m m''.
     Parameter Equal_ST : forall elt : Type, Equivalence M.Equal.
     Definition KeySetoid_relation : RewriteRelation eq.
     Definition KeySetoid_Reflexive : Reflexive eq.
     Definition KeySetoid_Symmetric : Symmetric eq.
     Definition KeySetoid_Transitive : Transitive eq.
     Definition KeySetoid : Equivalence eq.
     Definition EqualSetoid_relation :
       forall elt : Type, RewriteRelation M.Equal.
     Definition EqualSetoid_Reflexive : forall elt : Type, Reflexive M.Equal.
     Definition EqualSetoid_Symmetric : forall elt : Type, Symmetric M.Equal.
     Definition EqualSetoid_Transitive :
       forall elt : Type, Transitive M.Equal.
     Definition EqualSetoid : forall elt : Type, Equivalence M.Equal.
     Parameter In_m_Proper :
       forall elt : Type, Proper (eq ==> M.Equal ==> iff) (M.In (A:=elt)).
     Definition In_m :
       forall (elt : Type) (x y : positive),
       x = y ->
       forall x0 y0 : M.t elt, M.Equal x0 y0 -> M.In x x0 <-> M.In y y0.
     Parameter MapsTo_m_Proper :
       forall elt : Type,
       Proper (eq ==> eq ==> M.Equal ==> iff) (M.MapsTo (A:=elt)).
     Definition MapsTo_m :
       forall (elt : Type) (x y : positive),
       x = y ->
       forall x0 y0 : elt,
       x0 = y0 ->
       forall x1 y1 : M.t elt,
       M.Equal x1 y1 -> M.MapsTo x x0 x1 <-> M.MapsTo y y0 y1.
     Parameter Empty_m_Proper :
       forall elt : Type, Proper (M.Equal ==> iff) (M.Empty (A:=elt)).
     Definition Empty_m :
       forall (elt : Type) (x y : M.t elt),
       M.Equal x y -> M.Empty x <-> M.Empty y.
     Parameter is_empty_m_Proper :
       forall elt : Type, Proper (M.Equal ==> eq) (M.is_empty (A:=elt)).
     Definition is_empty_m :
       forall (elt : Type) (x y : M.t elt),
       M.Equal x y -> M.is_empty x = M.is_empty y.
     Parameter mem_m_Proper :
       forall elt : Type, Proper (eq ==> M.Equal ==> eq) (M.mem (A:=elt)).
     Definition mem_m :
       forall (elt : Type) (x y : positive),
       x = y ->
       forall x0 y0 : M.t elt, M.Equal x0 y0 -> M.mem x x0 = M.mem y y0.
     Parameter find_m_Proper :
       forall elt : Type, Proper (eq ==> M.Equal ==> eq) (M.find (A:=elt)).
     Definition find_m :
       forall (elt : Type) (x y : positive),
       x = y ->
       forall x0 y0 : M.t elt, M.Equal x0 y0 -> M.find x x0 = M.find y y0.
     Parameter add_m_Proper :
       forall elt : Type,
       Proper (eq ==> eq ==> M.Equal ==> M.Equal) (M.add (A:=elt)).
     Definition add_m :
       forall (elt : Type) (x y : positive),
       x = y ->
       forall x0 y0 : elt,
       x0 = y0 ->
       forall x1 y1 : M.t elt,
       M.Equal x1 y1 -> M.Equal (M.add x x0 x1) (M.add y y0 y1).
     Parameter remove_m_Proper :
       forall elt : Type,
       Proper (eq ==> M.Equal ==> M.Equal) (M.remove (A:=elt)).
     Definition remove_m :
       forall (elt : Type) (x y : positive),
       x = y ->
       forall x0 y0 : M.t elt,
       M.Equal x0 y0 -> M.Equal (M.remove x x0) (M.remove y y0).
     Parameter map_m_Proper :
       forall elt elt' : Type,
       Proper (eq ==> M.Equal ==> M.Equal) (M.map (B:=elt')).
     Definition map_m :
       forall (elt elt' : Type) (x y : elt -> elt'),
       x = y ->
       forall x0 y0 : M.t elt,
       M.Equal x0 y0 -> M.Equal (M.map x x0) (M.map y y0).
   End
:= (WFacts_fun E M)

Module
WP
 : Sig
     Module F
     Definition Add :
       forall elt : Type, M.key -> elt -> M.t elt -> M.t elt -> Prop.
     Parameter eqk_equiv :
       forall elt : Type, Equivalence (M.eq_key (A:=elt)).
     Parameter eqke_equiv :
       forall elt : Type, Equivalence (M.eq_key_elt (A:=elt)).
     Parameter InA_eqke_eqk :
       forall (elt : Type) (k1 k2 : positive) (e1 e2 : elt)
         (l : list (M.key * elt)),
       k1 = k2 ->
       InA (M.eq_key_elt (A:=elt)) (k1, e1) l ->
       InA (M.eq_key (A:=elt)) (k2, e2) l.
     Parameter NoDupA_eqk_eqke :
       forall (elt : Type) (l : list (M.key * elt)),
       NoDupA (M.eq_key (A:=elt)) l -> NoDupA (M.eq_key_elt (A:=elt)) l.
     Parameter findA_rev :
       forall (elt : Type) (l : list (M.key * elt)) (k : positive),
       NoDupA (M.eq_key (A:=elt)) l ->
       findA (F.eqb k) l = findA (F.eqb k) (rev l).
     Parameter elements_Empty :
       forall (elt : Type) (m : M.t elt), M.Empty m <-> M.elements m = [].
     Parameter elements_empty :
       forall elt : Type, M.elements (M.empty elt) = [].
     Definition uncurry : forall U V W : Type, (U -> V -> W) -> U * V -> W.
     Definition of_list : forall elt : Type, list (M.key * elt) -> M.t elt.
     Definition to_list : forall elt : Type, M.t elt -> list (M.key * elt).
     Parameter of_list_1 :
       forall (elt : Type) (l : list (M.key * elt)) (k : M.key) (e : elt),
       NoDupA (M.eq_key (A:=elt)) l ->
       M.MapsTo k e (of_list l) <-> InA (M.eq_key_elt (A:=elt)) (k, e) l.
     Parameter of_list_1b :
       forall (elt : Type) (l : list (M.key * elt)) (k : M.key),
       NoDupA (M.eq_key (A:=elt)) l ->
       M.find k (of_list l) = findA (F.eqb k) l.
     Parameter of_list_2 :
       forall (elt : Type) (l : list (M.key * elt)),
       NoDupA (M.eq_key (A:=elt)) l ->
       equivlistA (M.eq_key_elt (A:=elt)) l (to_list (of_list l)).
     Parameter of_list_3 :
       forall (elt : Type) (s : M.t elt), M.Equal (of_list (to_list s)) s.
     Parameter fold_spec_right :
       forall (elt : Type) (m : M.t elt) (A : Type) 
         (i : A) (f : M.key -> elt -> A -> A),
       M.fold f m i = fold_right (uncurry f) i (rev (M.elements m)).
     Parameter fold_rec :
       forall (elt A : Type) (P : M.t elt -> A -> Type)
         (f : M.key -> elt -> A -> A) (i : A) (m : M.t elt),
       (forall m0 : M.t elt, M.Empty m0 -> P m0 i) ->
       (forall (k : M.key) (e : elt) (a : A) (m' m'' : M.t elt),
        M.MapsTo k e m ->
        ~ M.In k m' -> Add k e m' m'' -> P m' a -> P m'' (f k e a)) ->
       P m (M.fold f m i).
     Parameter fold_rec_bis :
       forall (elt A : Type) (P : M.t elt -> A -> Type)
         (f : M.key -> elt -> A -> A) (i : A) (m : M.t elt),
       (forall (m0 m' : M.t elt) (a : A), M.Equal m0 m' -> P m0 a -> P m' a) ->
       P (M.empty elt) i ->
       (forall (k : M.key) (e : elt) (a : A) (m' : M.t elt),
        M.MapsTo k e m -> ~ M.In k m' -> P m' a -> P (M.add k e m') (f k e a)) ->
       P m (M.fold f m i).
     Parameter fold_rec_nodep :
       forall (elt A : Type) (P : A -> Type) (f : M.key -> elt -> A -> A)
         (i : A) (m : M.t elt),
       P i ->
       (forall (k : M.key) (e : elt) (a : A),
        M.MapsTo k e m -> P a -> P (f k e a)) -> P (M.fold f m i).
     Parameter fold_rec_weak :
       forall (elt A : Type) (P : M.t elt -> A -> Type)
         (f : M.key -> elt -> A -> A) (i : A),
       (forall (m m' : M.t elt) (a : A), M.Equal m m' -> P m a -> P m' a) ->
       P (M.empty elt) i ->
       (forall (k : M.key) (e : elt) (a : A) (m : M.t elt),
        ~ M.In k m -> P m a -> P (M.add k e m) (f k e a)) ->
       forall m : M.t elt, P m (M.fold f m i).
     Parameter fold_rel :
       forall (elt A B : Type) (R : A -> B -> Type)
         (f : M.key -> elt -> A -> A) (g : M.key -> elt -> B -> B) 
         (i : A) (j : B) (m : M.t elt),
       R i j ->
       (forall (k : M.key) (e : elt) (a : A) (b : B),
        M.MapsTo k e m -> R a b -> R (f k e a) (g k e b)) ->
       R (M.fold f m i) (M.fold g m j).
     Parameter map_induction :
       forall (elt : Type) (P : M.t elt -> Type),
       (forall m : M.t elt, M.Empty m -> P m) ->
       (forall m m' : M.t elt,
        P m ->
        forall (x : M.key) (e : elt), ~ M.In x m -> Add x e m m' -> P m') ->
       forall m : M.t elt, P m.
     Parameter map_induction_bis :
       forall (elt : Type) (P : M.t elt -> Type),
       (forall m m' : M.t elt, M.Equal m m' -> P m -> P m') ->
       P (M.empty elt) ->
       (forall (x : M.key) (e : elt) (m : M.t elt),
        ~ M.In x m -> P m -> P (M.add x e m)) -> forall m : M.t elt, P m.
     Parameter fold_identity :
       forall (elt : Type) (m : M.t elt),
       M.Equal (M.fold (M.add (A:=elt)) m (M.empty elt)) m.
     Parameter fold_init :
       forall (elt A : Type) (eqA : A -> A -> Prop)
         (f : M.key -> elt -> A -> A),
       Proper (eq ==> eq ==> eqA ==> eqA) f ->
       forall (m : M.t elt) (i i' : A),
       eqA i i' -> eqA (M.fold f m i) (M.fold f m i').
     Parameter fold_Empty :
       forall (elt A : Type) (eqA : A -> A -> Prop),
       Equivalence eqA ->
       forall (f : M.key -> elt -> A -> A) (m : M.t elt) (i : A),
       M.Empty m -> eqA (M.fold f m i) i.
     Definition transpose_neqkey :
       forall elt A : Type,
       (A -> A -> Prop) -> (M.key -> elt -> A -> A) -> Prop.
     Parameter fold_commutes :
       forall (elt A : Type) (eqA : A -> A -> Prop),
       Equivalence eqA ->
       forall f : M.key -> elt -> A -> A,
       Proper (eq ==> eq ==> eqA ==> eqA) f ->
       transpose_neqkey eqA f ->
       forall (i : A) (m : M.t elt) (k : M.key) (e : elt),
       ~ M.In k m -> eqA (M.fold f m (f k e i)) (f k e (M.fold f m i)).
     Parameter fold_Equal :
       forall (elt A : Type) (eqA : A -> A -> Prop),
       Equivalence eqA ->
       forall f : M.key -> elt -> A -> A,
       Proper (eq ==> eq ==> eqA ==> eqA) f ->
       transpose_neqkey eqA f ->
       forall (m1 m2 : M.t elt) (i : A),
       M.Equal m1 m2 -> eqA (M.fold f m1 i) (M.fold f m2 i).
     Parameter fold_Equal2 :
       forall (elt A : Type) (eqA : A -> A -> Prop),
       Equivalence eqA ->
       forall f : M.key -> elt -> A -> A,
       Proper (eq ==> eq ==> eqA ==> eqA) f ->
       transpose_neqkey eqA f ->
       forall (m1 m2 : M.t elt) (i j : A),
       M.Equal m1 m2 -> eqA i j -> eqA (M.fold f m1 i) (M.fold f m2 j).
     Parameter fold_Add :
       forall (elt A : Type) (eqA : A -> A -> Prop),
       Equivalence eqA ->
       forall f : M.key -> elt -> A -> A,
       Proper (eq ==> eq ==> eqA ==> eqA) f ->
       transpose_neqkey eqA f ->
       forall (m1 m2 : M.t elt) (k : M.key) (e : elt) (i : A),
       ~ M.In k m1 ->
       Add k e m1 m2 -> eqA (M.fold f m2 i) (f k e (M.fold f m1 i)).
     Parameter fold_add :
       forall (elt A : Type) (eqA : A -> A -> Prop),
       Equivalence eqA ->
       forall f : M.key -> elt -> A -> A,
       Proper (eq ==> eq ==> eqA ==> eqA) f ->
       transpose_neqkey eqA f ->
       forall (m : M.t elt) (k : M.key) (e : elt) (i : A),
       ~ M.In k m -> eqA (M.fold f (M.add k e m) i) (f k e (M.fold f m i)).
     Parameter cardinal_fold :
       forall (elt : Type) (m : M.t elt),
       M.cardinal m = M.fold (fun (_ : M.key) (_ : elt) => S) m 0.
     Parameter cardinal_Empty :
       forall (elt : Type) (m : M.t elt), M.Empty m <-> M.cardinal m = 0.
     Parameter Equal_cardinal :
       forall (elt : Type) (m m' : M.t elt),
       M.Equal m m' -> M.cardinal m = M.cardinal m'.
     Parameter cardinal_1 :
       forall (elt : Type) (m : M.t elt), M.Empty m -> M.cardinal m = 0.
     Parameter cardinal_2 :
       forall (elt : Type) (m m' : M.t elt) (x : M.key) (e : elt),
       ~ M.In x m -> Add x e m m' -> M.cardinal m' = S (M.cardinal m).
     Parameter cardinal_inv_1 :
       forall (elt : Type) (m : M.t elt), M.cardinal m = 0 -> M.Empty m.
     Parameter cardinal_inv_2 :
       forall (elt : Type) (m : M.t elt) (n : nat),
       M.cardinal m = S n -> {p : M.key * elt | M.MapsTo (fst p) (snd p) m}.
     Parameter cardinal_inv_2b :
       forall (elt : Type) (m : M.t elt),
       M.cardinal m <> 0 -> {p : M.key * elt | M.MapsTo (fst p) (snd p) m}.
     Definition Disjoint : forall elt : Type, M.t elt -> M.t elt -> Prop.
     Definition Partition :
       forall elt : Type, M.t elt -> M.t elt -> M.t elt -> Prop.
     Definition filter :
       forall elt : Type, (M.key -> elt -> bool) -> M.t elt -> M.t elt.
     Definition for_all :
       forall elt : Type, (M.key -> elt -> bool) -> M.t elt -> bool.
     Definition exists_ :
       forall elt : Type, (M.key -> elt -> bool) -> M.t elt -> bool.
     Definition partition :
       forall elt : Type,
       (M.key -> elt -> bool) -> M.t elt -> M.t elt * M.t elt.
     Definition update : forall elt : Type, M.t elt -> M.t elt -> M.t elt.
     Definition restrict : forall elt : Type, M.t elt -> M.t elt -> M.t elt.
     Definition diff : forall elt : Type, M.t elt -> M.t elt -> M.t elt.
     Parameter filter_iff :
       forall (elt : Type) (f : M.key -> elt -> bool),
       Proper (eq ==> eq ==> eq) f ->
       forall (m : M.t elt) (k : M.key) (e : elt),
       M.MapsTo k e (filter f m) <-> M.MapsTo k e m /\ f k e = true.
     Parameter for_all_iff :
       forall (elt : Type) (f : M.key -> elt -> bool),
       Proper (eq ==> eq ==> eq) f ->
       forall m : M.t elt,
       for_all f m = true <->
       (forall (k : M.key) (e : elt), M.MapsTo k e m -> f k e = true).
     Parameter exists_iff :
       forall (elt : Type) (f : M.key -> elt -> bool),
       Proper (eq ==> eq ==> eq) f ->
       forall m : M.t elt,
       exists_ f m = true <->
       (exists p : M.key * elt,
          M.MapsTo (fst p) (snd p) m /\ f (fst p) (snd p) = true).
     Parameter Disjoint_alt :
       forall (elt : Type) (m m' : M.t elt),
       Disjoint m m' <->
       (forall (k : M.key) (e e' : elt),
        M.MapsTo k e m -> M.MapsTo k e' m' -> False).
     Parameter partition_iff_1 :
       forall (elt : Type) (f : M.key -> elt -> bool),
       Proper (eq ==> eq ==> eq) f ->
       forall (m m1 : M.t elt) (k : M.key) (e : elt),
       m1 = fst (partition f m) ->
       M.MapsTo k e m1 <-> M.MapsTo k e m /\ f k e = true.
     Parameter partition_iff_2 :
       forall (elt : Type) (f : M.key -> elt -> bool),
       Proper (eq ==> eq ==> eq) f ->
       forall (m m2 : M.t elt) (k : M.key) (e : elt),
       m2 = snd (partition f m) ->
       M.MapsTo k e m2 <-> M.MapsTo k e m /\ f k e = false.
     Parameter partition_Partition :
       forall (elt : Type) (f : M.key -> elt -> bool),
       Proper (eq ==> eq ==> eq) f ->
       forall m m1 m2 : M.t elt,
       partition f m = (m1, m2) -> Partition m m1 m2.
     Definition Partition_In :
       forall (elt : Type) (m m1 m2 : M.t elt) (k : M.key),
       Partition m m1 m2 -> M.In k m -> {M.In k m1} + {M.In k m2}.
     Parameter Disjoint_sym :
       forall (elt : Type) (m1 m2 : M.t elt),
       Disjoint m1 m2 -> Disjoint m2 m1.
     Parameter Partition_sym :
       forall (elt : Type) (m m1 m2 : M.t elt),
       Partition m m1 m2 -> Partition m m2 m1.
     Parameter Partition_Empty :
       forall (elt : Type) (m m1 m2 : M.t elt),
       Partition m m1 m2 -> M.Empty m <-> M.Empty m1 /\ M.Empty m2.
     Parameter Partition_Add :
       forall (elt : Type) (m m' : M.t elt) (x : M.key) (e : elt),
       ~ M.In x m ->
       Add x e m m' ->
       forall m1 m2 : M.t elt,
       Partition m' m1 m2 ->
       exists m3 : M.t elt,
         Add x e m3 m1 /\ Partition m m3 m2 \/
         Add x e m3 m2 /\ Partition m m1 m3.
     Parameter Partition_fold :
       forall (elt A : Type) (eqA : A -> A -> Prop),
       Equivalence eqA ->
       forall f : M.key -> elt -> A -> A,
       Proper (eq ==> eq ==> eqA ==> eqA) f ->
       transpose_neqkey eqA f ->
       forall (m m1 m2 : M.t elt) (i : A),
       Partition m m1 m2 -> eqA (M.fold f m i) (M.fold f m1 (M.fold f m2 i)).
     Parameter Partition_cardinal :
       forall (elt : Type) (m m1 m2 : M.t elt),
       Partition m m1 m2 -> M.cardinal m = M.cardinal m1 + M.cardinal m2.
     Parameter Partition_partition :
       forall (elt : Type) (m m1 m2 : M.t elt),
       Partition m m1 m2 ->
       let f := fun (k : M.key) (_ : elt) => M.mem k m1 in
       M.Equal m1 (fst (partition f m)) /\ M.Equal m2 (snd (partition f m)).
     Parameter update_mapsto_iff :
       forall (elt : Type) (m m' : M.t elt) (k : M.key) (e : elt),
       M.MapsTo k e (update m m') <->
       M.MapsTo k e m' \/ M.MapsTo k e m /\ ~ M.In k m'.
     Definition update_dec :
       forall (elt : Type) (m m' : M.t elt) (k : M.key) (e : elt),
       M.MapsTo k e (update m m') ->
       {M.MapsTo k e m'} + {M.MapsTo k e m /\ ~ M.In k m'}.
     Parameter update_in_iff :
       forall (elt : Type) (m m' : M.t elt) (k : M.key),
       M.In k (update m m') <-> M.In k m \/ M.In k m'.
     Parameter diff_mapsto_iff :
       forall (elt : Type) (m m' : M.t elt) (k : M.key) (e : elt),
       M.MapsTo k e (diff m m') <-> M.MapsTo k e m /\ ~ M.In k m'.
     Parameter diff_in_iff :
       forall (elt : Type) (m m' : M.t elt) (k : M.key),
       M.In k (diff m m') <-> M.In k m /\ ~ M.In k m'.
     Parameter restrict_mapsto_iff :
       forall (elt : Type) (m m' : M.t elt) (k : M.key) (e : elt),
       M.MapsTo k e (restrict m m') <-> M.MapsTo k e m /\ M.In k m'.
     Parameter restrict_in_iff :
       forall (elt : Type) (m m' : M.t elt) (k : M.key),
       M.In k (restrict m m') <-> M.In k m /\ M.In k m'.
     Definition filter_dom :
       forall elt : Type, (M.key -> bool) -> M.t elt -> M.t elt.
     Definition filter_range :
       forall elt : Type, (elt -> bool) -> M.t elt -> M.t elt.
     Definition for_all_dom :
       forall elt : Type, (M.key -> bool) -> M.t elt -> bool.
     Definition for_all_range :
       forall elt : Type, (elt -> bool) -> M.t elt -> bool.
     Definition exists_dom :
       forall elt : Type, (M.key -> bool) -> M.t elt -> bool.
     Definition exists_range :
       forall elt : Type, (elt -> bool) -> M.t elt -> bool.
     Definition partition_dom :
       forall elt : Type, (M.key -> bool) -> M.t elt -> M.t elt * M.t elt.
     Definition partition_range :
       forall elt : Type, (elt -> bool) -> M.t elt -> M.t elt * M.t elt.
     Parameter cardinal_m_Proper :
       forall elt : Type, Proper (M.Equal ==> eq) (M.cardinal (A:=elt)).
     Definition cardinal_m :
       forall (elt : Type) (x y : M.t elt),
       M.Equal x y -> M.cardinal x = M.cardinal y.
     Parameter Disjoint_m_Proper :
       forall elt : Type,
       Proper (M.Equal ==> M.Equal ==> iff) (Disjoint (elt:=elt)).
     Definition Disjoint_m :
       forall (elt : Type) (x y : M.t elt),
       M.Equal x y ->
       forall x0 y0 : M.t elt,
       M.Equal x0 y0 -> Disjoint x x0 <-> Disjoint y y0.
     Parameter Partition_m_Proper :
       forall elt : Type,
       Proper (M.Equal ==> M.Equal ==> M.Equal ==> iff)
         (Partition (elt:=elt)).
     Definition Partition_m :
       forall (elt : Type) (x y : M.t elt),
       M.Equal x y ->
       forall x0 y0 : M.t elt,
       M.Equal x0 y0 ->
       forall x1 y1 : M.t elt,
       M.Equal x1 y1 -> Partition x x0 x1 <-> Partition y y0 y1.
     Parameter update_m_Proper :
       forall elt : Type,
       Proper (M.Equal ==> M.Equal ==> M.Equal) (update (elt:=elt)).
     Definition update_m :
       forall (elt : Type) (x y : M.t elt),
       M.Equal x y ->
       forall x0 y0 : M.t elt,
       M.Equal x0 y0 -> M.Equal (update x x0) (update y y0).
     Parameter restrict_m_Proper :
       forall elt : Type,
       Proper (M.Equal ==> M.Equal ==> M.Equal) (restrict (elt:=elt)).
     Definition restrict_m :
       forall (elt : Type) (x y : M.t elt),
       M.Equal x y ->
       forall x0 y0 : M.t elt,
       M.Equal x0 y0 -> M.Equal (restrict x x0) (restrict y y0).
     Parameter diff_m_Proper :
       forall elt : Type,
       Proper (M.Equal ==> M.Equal ==> M.Equal) (diff (elt:=elt)).
     Definition diff_m :
       forall (elt : Type) (x y : M.t elt),
       M.Equal x y ->
       forall x0 y0 : M.t elt,
       M.Equal x0 y0 -> M.Equal (diff x x0) (diff y y0).
   End
:= (WProperties_fun E M)

E.lt
     : positive -> positive -> Prop
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
CVC4 (knn-64) succeeded
- dependencies: FSets.FMapPositive.PositiveMap.ME.MO.lt_strorder
- definitions: Structures.OrderedTypeEx.PositiveOrderedTypeBits.lt
Reconstructing the proof...
Tactic srun eauto succeeded.
Replace the hammer tactic with:
	srun eauto use: PositiveMap.ME.MO.lt_strorder unfold: PositiveOrderedTypeBits.lt.
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
Vampire (knn-1024) succeeded
- dependencies: FSets.FMapPositive.PositiveMap.ME.MO.IsTO.lt_compat, FSets.FMapPositive.PositiveMap.ME.MO.lt_compat, PArith.BinPos.Pos.Proper_instance_0
- definitions: Structures.OrderedTypeEx.PositiveOrderedTypeBits.lt
Reconstructing the proof...
Tactic srun eauto succeeded.
Replace the hammer tactic with:
	srun eauto use: PositiveMap.ME.MO.IsTO.lt_compat, PositiveMap.ME.MO.lt_compat, Pos.Proper_instance_0 unfold: PositiveOrderedTypeBits.lt.
Replace the hammer tactic with: sfirstorder 
equivlistA =
fun (A : Type) (eqA : A -> A -> Prop) (l l' : list A) =>
forall x : A, InA eqA x l <-> InA eqA x l'
     : forall A : Type, (A -> A -> Prop) -> list A -> list A -> Prop

Arguments equivlistA [A]%type_scope eqA%function_scope (l l')%list_scope
Replace the hammer tactic with: sauto lq: on 
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
SortA_equivlistA_eqlistA
     : forall (A : Type) (eqA : A -> A -> Prop),
       Equivalence eqA ->
       forall ltA : A -> A -> Prop,
       StrictOrder ltA ->
       Proper (eqA ==> eqA ==> iff) ltA ->
       forall l l' : list A,
       Sorted ltA l ->
       Sorted ltA l' -> equivlistA eqA l l' -> eqlistA eqA l l'
Replace the hammer tactic with: sfirstorder 
Replace the hammer tactic with: sfirstorder 
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
S.remove
     : S.elt -> S.t -> S.t
S.elements
     : S.t -> list S.elt
Replace the hammer tactic with: sfirstorder 
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
M.elements
     : forall A : Type, M.t A -> list (M.key * A)
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
Vampire (knn-1024) succeeded
Minimizing dependencies...
- dependencies: Wigderson.graph.SP.remove_cardinal_1, Init.Peano.le_n
- definitions: Init.Peano.lt
Reconstructing the proof...
Tactic sfirstorder succeeded.
Replace the hammer tactic with:
	sfirstorder use: SP.remove_cardinal_1, le_n unfold: lt.
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
specialize_SortA_equivlistA_eqlistA
     : forall (A : Type) (al bl : list (M.key * A)),
       Sorted (M.lt_key (A:=A)) al ->
       Sorted (M.lt_key (A:=A)) bl ->
       equivlistA (M.eq_key_elt (A:=A)) al bl ->
       eqlistA (M.eq_key_elt (A:=A)) al bl
M.elements_1
     : forall (A : Type) (m : M.t A) (x : M.key) (e : A),
       M.MapsTo x e m -> InA (M.eq_key_elt (A:=A)) (x, e) (M.elements m)
M.elements_2
     : forall (A : Type) (m : M.t A) (x : M.key) (e : A),
       InA (M.eq_key_elt (A:=A)) (x, e) (M.elements m) -> M.MapsTo x e m
M.elements_3
     : forall (A : Type) (m : M.t A), Sorted (M.lt_key (A:=A)) (M.elements m)
M.remove_1
     : forall (A : Type) (m : M.t A) (x y : M.key),
       M.E.eq x y -> ~ M.In y (M.remove x m)
M.eqke_equiv
     : forall A : Type, Equivalence (M.eq_key_elt (A:=A))
M.ltk_strorder
     : forall A : Type, StrictOrder (M.lt_key (A:=A))
Proper_eq_key_elt
     : forall A : Type,
       Proper (M.eq_key_elt (A:=A) ==> M.eq_key_elt (A:=A) ==> iff)
         (fun x y : E.t * A => E.lt (fst x) (fst y))
filter_InA
     : forall (A : Type) (eqA : A -> A -> Prop) (f : A -> bool),
       Proper (eqA ==> eq) f ->
       forall (l : list A) (x : A),
       InA eqA x (filter f l) <-> InA eqA x l /\ f x = true
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
Detecting provers...
sh: line 1: eprover: command not found
Eprover not found
Vampire found
Z3 found
CVC4 found
Extracting features...
Running provers (8 threads)...
