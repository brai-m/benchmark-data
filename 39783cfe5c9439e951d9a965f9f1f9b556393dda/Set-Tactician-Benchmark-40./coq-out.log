find_witness Control.TimeoutChars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 97 - 124 [Require~Import~HoTT.Basics.] 0.334 secs (0.245u,0.088s)
Chars 125 - 186 [Require~Import~Types.Arrow~Typ...] 0.388 secs (0.298u,0.088s)
Chars 187 - 215 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 218 - 256 [Generalizable~Variables~X~A~B~...] 0. secs (0.u,0.s)
Chars 1241 - 1347 [Definition~unpack_sigma~`{P~:~...] 0.001 secs (0.001u,0.s)
Chars 1349 - 1375 [Arguments~unpack_sigma~/.] 0. secs (0.u,0.s)
Chars 1403 - 1479 [Definition~eta_sigma~`{P~:~A~-...] 0.001 secs (0.001u,0.s)
Chars 1481 - 1504 [Arguments~eta_sigma~/.] 0. secs (0.u,0.s)
Chars 1506 - 1643 [Definition~eta2_sigma~`{P~:~fo...] 0.002 secs (0.002u,0.s)
Chars 1645 - 1669 [Arguments~eta2_sigma~/.] 0. secs (0.u,0.s)
Chars 1671 - 1848 [Definition~eta3_sigma~`{P~:~fo...] 0.004 secs (0.004u,0.s)
Chars 1850 - 1874 [Arguments~eta3_sigma~/.] 0. secs (0.u,0.s)
Chars 2203 - 2512 [Definition~path_sigma_uncurrie...] 0.004 secs (0.004u,0.s)
Chars 2699 - 2855 [Definition~path_sigma~{A~:~Typ...] 0.002 secs (0.002u,0.s)
Chars 2915 - 3103 [Definition~path_sigma_uncurrie...] 0.003 secs (0.003u,0.s)
Chars 3262 - 3610 [Definition~dpath_forall'~{A~:~...] 0.004 secs (0.004u,0.s)
Chars 3611 - 3617 [Proof.] 0. secs (0.u,0.s)
Chars 3620 - 3631 [(destruct~h).] 2.909 secs (0.003u,0.02s)
Chars 3634 - 3648 [(apply~1%equiv).] 0.002 secs (0.001u,0.s)
Chars 3620 - 3631 [(destruct~h).] 0.001 secs (0.001u,0.s)
Chars 3634 - 3648 [(apply~1%equiv).] 0.001 secs (0.001u,0.s)
Chars 3649 - 3657 [Defined.] 0.003 secs (0.003u,0.s)
Chars 3914 - 4092 [Definition~path_sigma'~{A~:~Ty...] 0.002 secs (0.002u,0.s)
Chars 4144 - 4237 [Definition~pr1_path~`{P~:~A~->...] 0.002 secs (0.002u,0.s)
Chars 4275 - 4326 [Notation~"p~..1"~:=~(pr1_path~...] 0. secs (0.u,0.s)
Chars 4328 - 4486 [Definition~pr2_path~`{P~:~A~->...] 0.005 secs (0.003u,0.001s)
Chars 4488 - 4539 [Notation~"p~..2"~:=~(pr2_path~...] 0. secs (0.u,0.s)
Chars 4587 - 4750 [Definition~pr1_path_sigma_uncu...] 0.002 secs (0.002u,0.s)
Chars 4751 - 4757 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 44 - 86 [Require~Import~Category.Core~F...] 0.026 secs (0.017u,0.008s)
Chars 87 - 129 [Require~Import~Category.Dual~F...] 1.82 secs (1.644u,0.172s)
Chars 130 - 187 [Require~Import~Functor.Composi...] 0. secs (0.u,0.s)
Chars 188 - 226 [Require~Import~Cat.Core~Functo...] 0.081 secs (0.077u,0.003s)
Chars 227 - 293 [Require~Import~Basics.Trunc~Ty...] 0.004 secs (0.003u,0.s)
Chars 295 - 321 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 322 - 345 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 346 - 374 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 375 - 399 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 401 - 433 [#[local]Open~Scope~category_sc...] 0. secs (0.u,0.s)
Chars 435 - 452 [Section~opposite.] 0. secs (0.u,0.s)
Chars 455 - 473 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 477 - 510 [Variable~(P~:~PreCategory~->~T...] 0. secs (0.u,0.s)
Chars 513 - 548 [Context~`{forall~C,~IsHProp~(P...] 0. secs (0.u,0.s)
Chars 551 - 614 [Context~`{HF~:~forall~C~D,~P~C...] 0. secs (0.u,0.s)
Chars 618 - 651 [Let~cat~:=~@sub_pre_cat~_~P~HF.] 0. secs (0.u,0.s)
Chars 655 - 700 [Hypothesis~(has_op~:~forall~C~...] 0. secs (0.u,0.s)
Chars 704 - 926 [Definition~opposite_functor~:~...] 0.008 secs (0.007u,0.s)
Chars 930 - 1248 [Let~opposite_functor_involutiv...] 0.01 secs (0.009u,0.001s)
Chars 1252 - 1283 [#[local]Open~Scope~functor_scope.] 0. secs (0.u,0.s)
Chars 1287 - 1338 [#[local]Arguments~path_sigma_u...] 0. secs (0.u,0.s)
Chars 1342 - 1425 [Definition~opposite_functor_in...] 0. secs (0.u,0.s)
Chars 1428 - 1434 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 51 - 120 [Require~Import~Category.Core~F...] 0.026 secs (0.015u,0.01s)
Chars 121 - 150 [Require~Import~Category.Dual.] 1.784 secs (1.612u,0.168s)
Chars 151 - 180 [Require~Import~Category.Prod.] 0.002 secs (0.002u,0.s)
Chars 1439 - 1452 [path_functor.] 2.721 secs (0.507u,0.107s)
Chars 181 - 227 [Require~Import~NaturalTransfor...] 0.025 secs (0.025u,0.s)
Chars 228 - 273 [Require~Import~FunctorCategory...] 0.099 secs (0.086u,0.012s)
Chars 274 - 351 [Require~Import~InitialTerminal...] 0.002 secs (0.u,0.001s)
Chars 352 - 371 [Require~Comma.Core.] 0.036 secs (0.035u,0.s)
Chars 372 - 421 [#[local]Set~Warnings~Append~"-...] 0.003 secs (0.u,0.003s)
Chars 574 - 592 [Import~Comma.Core.] 0.001 secs (0.u,0.001s)
Chars 593 - 641 [#[local]Set~Warnings~Append~"n...] 0. secs (0.u,0.s)
Chars 642 - 674 [Require~Import~Comma.Projection.] 0.003 secs (0.002u,0.s)
Chars 675 - 725 [Require~Import~Types.Prod~HoTT...] 0.002 secs (0.001u,0.001s)
Chars 726 - 756 [Require~Import~Basics.Tactics.] 0.001 secs (0.001u,0.s)
Chars 758 - 784 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 785 - 808 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 809 - 837 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 838 - 862 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 864 - 895 [#[local]Open~Scope~functor_scope.] 0. secs (0.u,0.s)
Chars 896 - 928 [#[local]Open~Scope~category_sc...] 0. secs (0.u,0.s)
Chars 1072 - 1111 [Section~comma_category_induced...] 0. secs (0.u,0.s)
Chars 1114 - 1132 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 1135 - 1165 [Variables~(A~B~C~:~PreCategory).] 0. secs (0.u,0.s)
Chars 1169 - 1541 [Definition~comma_category_indu...] 0.018 secs (0.014u,0.003s)
Chars 1545 - 1687 [Lemma~comma_category_induced_f...] 0.001 secs (0.001u,0.s)
Chars 1690 - 1696 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 31 - 100 [Require~Import~Category.Core~F...] 0.027 secs (0.018u,0.009s)
Chars 101 - 133 [Require~Import~Functor.Identity.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 0 - 22 [Require~Import~Basics.] 0.346 secs (0.277u,0.068s)
Chars 85 - 123 [Require~Import~HoTT.Basics~HoT...] 1.763 secs (1.579u,0.179s)
Chars 124 - 169 [Require~Import~HProp~Equiv.Pat...] 0.103 secs (0.101u,0.001s)
Chars 170 - 238 [Require~Import~Cubical.DPath~C...] 0.197 secs (0.192u,0.003s)
Chars 23 - 52 [Require~Import~Cubical.DPath.] 1.541 secs (1.439u,0.1s)
Chars 134 - 168 [Require~Import~Category.Morphi...] 1.884 secs (1.712u,0.171s)
Chars 169 - 248 [Require~Import~Functor.Composi...] 0.001 secs (0.001u,0.s)
Chars 249 - 324 [Require~Import~Adjoint.Core~Ad...] 0.032 secs (0.03u,0.001s)
Chars 53 - 87 [Require~Import~Cubical.PathSqu...] 0.09 secs (0.086u,0.003s)
Chars 88 - 123 [Require~Import~Cubical.DPathSq...] 0.039 secs (0.039u,0.s)
Chars 124 - 162 [Require~Import~Types.Paths~Typ...] 0.001 secs (0.001u,0.s)
Chars 164 - 189 [Declare~Scope~cube_scope.] 0. secs (0.u,0.s)
Chars 190 - 225 [Delimit~Scope~cube_scope~with~...] 0. secs (0.u,0.s)
Chars 226 - 258 [#[local]Unset~Elimination~Sche...] 0. secs (0.u,0.s)
Chars 259 - 287 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 289 - 319 [#[local]Open~Scope~square_scope.] 0. secs (0.u,0.s)
Chars 1330 - 1980 [#[universes(cumulative)]~Induc...] 0.007 secs (0.006u,0.s)
Chars 1982 - 2045 [Arguments~PathCube~{_~_~_~_~_~...] 0. secs (0.u,0.s)
Chars 2047 - 2103 [Scheme~PathCube_ind~:=~Inducti...] 0.002 secs (0.002u,0.s)
Chars 2104 - 2191 [Arguments~PathCube_ind~{A}~P~f...] 0. secs (0.u,0.s)
Chars 2193 - 2250 [Scheme~PathCube_rec~:=~Minimal...] 0.002 secs (0.002u,0.s)
Chars 2251 - 2338 [Arguments~PathCube_rec~{A}~P~f...] 0. secs (0.u,0.s)
Chars 2397 - 2432 [#[local]Notation~hr~:=~(sq_ref...] 0. secs (0.u,0.s)
Chars 2433 - 2468 [#[local]Notation~vr~:=~(sq_ref...] 0. secs (0.u,0.s)
Chars 2469 - 2496 [#[local]Notation~tr~:=~sq_tr.] 0. secs (0.u,0.s)
Chars 2497 - 2528 [#[local]Notation~fv~:=~sq_flip_v.] 0. secs (0.u,0.s)
Chars 325 - 363 [Require~Import~Functor.Pointwi...] 0.097 secs (0.095u,0.001s)
Chars 364 - 404 [Require~NaturalTransformation....] 0.002 secs (0.002u,0.s)
Chars 405 - 442 [Require~Functor.Pointwise.Prop...] 0.012 secs (0.011u,0.s)
Chars 443 - 503 [Require~Import~Category.Morphi...] 0.018 secs (0.018u,0.s)
Chars 504 - 540 [Require~Import~FunctorCategory...] 0. secs (0.u,0.s)
Chars 541 - 580 [Require~NaturalTransformation....] 0. secs (0.u,0.s)
Chars 581 - 628 [Require~NaturalTransformation....] 0. secs (0.u,0.s)
Chars 629 - 706 [Import~NaturalTransformation.I...] 0. secs (0.u,0.s)
Chars 707 - 764 [Require~Import~NaturalTransfor...] 0. secs (0.u,0.s)
Chars 765 - 845 [Require~Import~Basics.PathGrou...] 0.006 secs (0.003u,0.003s)
Chars 847 - 873 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 874 - 897 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 898 - 926 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 927 - 951 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 953 - 985 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 986 - 1017 [#[local]Open~Scope~functor_scope.] 0. secs (0.u,0.s)
Chars 1018 - 1064 [#[local]Open~Scope~natural_tra...] 0. secs (0.u,0.s)
Chars 1066 - 1091 [Section~AdjointPointwise.] 0. secs (0.u,0.s)
Chars 1094 - 1112 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 1116 - 1144 [Variables~(C~D~:~PreCategory).] 0. secs (0.u,0.s)
Chars 1188 - 1198 [Section~l.] 0. secs (0.u,0.s)
Chars 1203 - 1228 [Variable~(E~:~PreCategory).] 0. secs (0.u,0.s)
Chars 1234 - 1259 [Variable~(F~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 1264 - 1289 [Variable~(G~:~Functor~D~C).] 0. secs (0.u,0.s)
Chars 1295 - 1315 [Variable~(A~:~F~-|~G).] 0. secs (0.u,0.s)
Chars 1321 - 1473 [Definition~unit_l~:~~~NaturalT...] 0.002 secs (0.002u,0.s)
Chars 1478 - 1484 [Proof.] 0. secs (0.u,0.s)
Chars 2584 - 3381 [Definition~equiv_cu_path~{A}~{...] 0.057 secs (0.057u,0.s)
Chars 3382 - 3388 [Proof.] 0. secs (0.u,0.s)
Chars 239 - 293 [Require~Import~Colimits.Coeq~C...] 2.591 secs (2.465u,0.121s)
Chars 295 - 322 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 323 - 351 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 1159 - 1178 [Section~Extensions.] 0. secs (0.u,0.s)
Chars 1823 - 2101 [Definition~ExtensionAlong@{a~b...] 0.001 secs (0.001u,0.s)
Chars 2476 - 2738 [Definition~lift_extensionalong...] 0. secs (0.u,0.s)
Chars 2741 - 2747 [Proof.] 0. secs (0.u,0.s)
Chars 2752 - 2763 [(intros~ext).] 5.279 secs (0.u,0.029s)
Chars 3058 - 3104 [(pose~proof~ext.2~as~e2;~set~(...] 0.002 secs (0.002u,0.s)
Chars 3109 - 3119 [(cbn~in~e2).] 0. secs (0.u,0.s)
Chars 3210 - 3224 [exact~(e1;~e2).] 0.001 secs (0.001u,0.s)
Chars 2752 - 2763 [(intros~ext).] 0. secs (0.u,0.s)
Chars 3058 - 3104 [(pose~proof~ext.2~as~e2;~set~(...] 0. secs (0.u,0.s)
Chars 3109 - 3119 [(cbn~in~e2).] 0. secs (0.u,0.s)
Chars 3210 - 3224 [exact~(e1;~e2).] 0. secs (0.u,0.s)
Chars 3227 - 3235 [Defined.] 0. secs (0.u,0.s)
Chars 3412 - 3735 [Definition~equiv_path_extensio...] 0.003 secs (0.003u,0.s)
Chars 3738 - 3744 [Proof.] 0. secs (0.u,0.s)
Chars 3749 - 3761 [revert~ext'.] 0.182 secs (-4.302u,-0.366s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 44 - 101 [Require~Import~HoTT.Basics~HoT...] 1.913 secs (1.715u,0.196s)
Chars 4760 - 4817 [(destruct~u~as~[u1~u2];~destru...] 40.102 secs (0.005u,0.019s)
Chars 4820 - 4841 [(destruct~pq~as~[p~q]).] 0.002 secs (0.002u,0.s)
Chars 4844 - 4892 [(destruct~p;~simpl~in~q;~destr...] 0.007 secs (0.006u,0.s)
Chars 4760 - 4817 [(destruct~u~as~[u1~u2];~destru...] 0.002 secs (0.002u,0.s)
Chars 4820 - 4841 [(destruct~pq~as~[p~q]).] 0. secs (0.u,0.s)
Chars 4844 - 4892 [(destruct~p;~simpl~in~q;~destr...] 0.003 secs (0.003u,0.s)
Chars 4893 - 4901 [Defined.] 0.003 secs (0.003u,0.s)
Chars 4903 - 5132 [Definition~pr2_path_sigma_uncu...] 0.005 secs (0.005u,0.s)
Chars 5133 - 5139 [Proof.] 0. secs (0.u,0.s)
Chars 102 - 165 [Require~Import~HFiber~Extensio...] 4.198 secs (4.005u,0.188s)
Chars 5142 - 5199 [(destruct~u~as~[u1~u2];~destru...] 1.158 secs (0.011u,0.019s)
Chars 5202 - 5223 [(destruct~pq~as~[p~q]).] 0.004 secs (0.003u,0.s)
Chars 5226 - 5274 [(destruct~p;~simpl~in~q;~destr...] 0.019 secs (0.017u,0.002s)
Chars 5142 - 5199 [(destruct~u~as~[u1~u2];~destru...] 0.004 secs (0.004u,0.s)
Chars 5202 - 5223 [(destruct~pq~as~[p~q]).] 0.001 secs (0.001u,0.s)
Chars 5226 - 5274 [(destruct~p;~simpl~in~q;~destr...] 0.006 secs (0.006u,0.s)
Chars 5275 - 5283 [Defined.] 0.011 secs (0.008u,0.002s)
Chars 5285 - 5421 [Definition~eta_path_sigma_uncu...] 0.002 secs (0.002u,0.s)
Chars 5422 - 5428 [Proof.] 0. secs (0.u,0.s)
Chars 5431 - 5442 [(destruct~p).] 0.139 secs (0.003u,0.018s)
Chars 5443 - 5455 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 5431 - 5442 [(destruct~p).] 0. secs (0.u,0.s)
Chars 5443 - 5455 [reflexivity.] 0. secs (0.u,0.s)
Chars 5456 - 5464 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5466 - 5694 [Lemma~transport_pr1_path_sigma...] 0.003 secs (0.003u,0.s)
Chars 5695 - 5701 [Proof.] 0. secs (0.u,0.s)
Chars 5704 - 5743 [(destruct~pq~as~[p~q],~u,~v;~s...] 0.159 secs (0.008u,0.018s)
Chars 5746 - 5772 [(destruct~p,~q;~simpl~in~*).] 0.005 secs (0.005u,0.s)
Chars 5775 - 5787 [reflexivity.] 0. secs (0.u,0.s)
Chars 5704 - 5743 [(destruct~pq~as~[p~q],~u,~v;~s...] 0.002 secs (0.002u,0.s)
Chars 5746 - 5772 [(destruct~p,~q;~simpl~in~*).] 0.001 secs (0.001u,0.s)
Chars 5775 - 5787 [reflexivity.] 0. secs (0.u,0.s)
Chars 5788 - 5796 [Defined.] 0.004 secs (0.004u,0.s)
Chars 5798 - 5971 [Definition~pr1_path_sigma~`{P~...] 0.004 secs (0.003u,0.s)
Chars 6024 - 6201 [Definition~ap_pr1_path_sigma~{...] 0.003 secs (0.002u,0.s)
Chars 6203 - 6433 [Definition~pr2_path_sigma~`{P~...] 0.008 secs (0.006u,0.001s)
Chars 6435 - 6573 [Definition~eta_path_sigma~`{P~...] 0.002 secs (0.001u,0.001s)
Chars 6575 - 6835 [Definition~transport_pr1_path_...] 0.021 secs (0.009u,0.011s)
Chars 6918 - 7027 [#[global]~Instance~isequiv_pat...] 0.001 secs (0.u,0.001s)
Chars 7028 - 7034 [Proof.] 0. secs (0.u,0.s)
Chars 166 - 244 [Require~Import~ReflectiveSubun...] 2.964 secs (2.873u,0.088s)
Chars 245 - 277 [Require~Import~Truncations.Core.] 0.024 secs (0.024u,0.s)
Chars 278 - 313 [Require~Import~Homotopy.Suspen...] 0.226 secs (0.225u,0.s)
Chars 315 - 343 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 344 - 379 [#[local]Open~Scope~subuniverse...] 0. secs (0.u,0.s)
Chars 832 - 849 [Section~Diagonal.] 0. secs (0.u,0.s)
Chars 852 - 904 [Context~(O~:~Subuniverse)~{X~Y...] 0. secs (0.u,0.s)
Chars 908 - 981 [Definition~mapinO_diagonal~`{M...] 0. secs (0.u,0.s)
Chars 984 - 990 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 7037 - 7164 [simple~refine~~(Build_IsEquiv~...] 5.506 secs (4.158u,0.116s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 1439 - 1452 [path_functor.] 40.07 secs (0.015u,0.027s)
Chars 1457 - 1520 [refine~(path_forall~_~_~opposi...] 0.005 secs (0.005u,0.s)
Chars 1525 - 1559 [(repeat~(apply~path_forall;~in...] 0.008 secs (0.006u,0.002s)
Chars 1564 - 1599 [(rewrite~!transport_forall_con...] 0.02 secs (0.017u,0.002s)
Chars 1604 - 1633 [transport_path_forall_hammer.] 0.036 secs (0.033u,0.003s)
Chars 1638 - 1680 [(unfold~opposite_functor_invol...] 0.003 secs (0.003u,0.s)
Chars 1685 - 1729 [(rewrite~!transport_pr1_path_s...] 0.048 secs (0.037u,0.01s)
Chars 1734 - 1745 [(simpl~in~*).] 0.005 secs (0.005u,0.s)
Chars 1750 - 1801 [(repeat~progress~change~(fun~x...] 0.005 secs (0.004u,0.s)
Chars 1806 - 2108 [(match~goal~with~~|~|-~~~~cont...] 0.008 secs (0.006u,0.001s)
Chars 2113 - 2124 [(simpl~in~*).] 0.002 secs (0.002u,0.s)
Chars 2129 - 2138 [(hnf~in~*).] 0.002 secs (0.002u,0.s)
Chars 2143 - 2154 [subst_body.] 0.003 secs (0.002u,0.s)
Chars 2159 - 2178 [(destruct_head~@sig).] 0.005 secs (0.005u,0.s)
Chars 2183 - 2206 [(destruct_head~@Functor).] 0.004 secs (0.003u,0.s)
Chars 2211 - 2238 [(destruct_head~@PreCategory).] 0.015 secs (0.014u,0.s)
Chars 2243 - 2255 [reflexivity.] 0.004 secs (0.003u,0.s)
Chars 1439 - 1452 [path_functor.] 0.001 secs (0.001u,0.s)
Chars 1457 - 1520 [refine~(path_forall~_~_~opposi...] 0.002 secs (0.002u,0.s)
Chars 1525 - 1559 [(repeat~(apply~path_forall;~in...] 0.002 secs (0.002u,0.s)
Chars 1564 - 1599 [(rewrite~!transport_forall_con...] 0.002 secs (0.002u,0.s)
Chars 1604 - 1633 [transport_path_forall_hammer.] 0.002 secs (0.002u,0.s)
Chars 1638 - 1680 [(unfold~opposite_functor_invol...] 0.002 secs (0.002u,0.s)
Chars 1685 - 1729 [(rewrite~!transport_pr1_path_s...] 0.003 secs (0.003u,0.s)
Chars 1734 - 1745 [(simpl~in~*).] 0.003 secs (0.003u,0.s)
Chars 1750 - 1801 [(repeat~progress~change~(fun~x...] 0.002 secs (0.002u,0.s)
Chars 1806 - 2108 [(match~goal~with~~|~|-~~~~cont...] 0.002 secs (0.002u,0.s)
Chars 2113 - 2124 [(simpl~in~*).] 0.002 secs (0.002u,0.s)
Chars 2129 - 2138 [(hnf~in~*).] 0.001 secs (0.001u,0.s)
Chars 2143 - 2154 [subst_body.] 0.002 secs (0.002u,0.s)
Chars 2159 - 2178 [(destruct_head~@sig).] 0. secs (0.u,0.s)
Chars 2183 - 2206 [(destruct_head~@Functor).] 0. secs (0.u,0.s)
Chars 2211 - 2238 [(destruct_head~@PreCategory).] 0.001 secs (0.001u,0.s)
Chars 2243 - 2255 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 2258 - 2262 [Qed.] 0.114 secs (0.101u,0.012s)
Chars 2263 - 2276 [End~opposite.] 0.078 secs (0.063u,0.014s)
find_witness Control.TimeoutChars 0 - 36 [Require~Import~Basics~Types~Wi...] 3.315 secs (3.01u,0.283s)
Chars 37 - 65 [Require~Import~Pointed.Core.] 0.244 secs (0.236u,0.007s)
Chars 66 - 94 [Require~Import~Pointed.pMap.] 0.089 secs (0.087u,0.s)
Chars 95 - 125 [Require~Import~Pointed.pEquiv.] 0.017 secs (0.017u,0.s)
Chars 1701 - 1886 [(let~x1~:=~match~goal~with~~~~...] 40.117 secs (0.004u,0.018s)
Chars 1891 - 1897 [(simpl).] 0.002 secs (0.002u,0.s)
Chars 1902 - 1966 [(abstract~(rewrite~?left_ident...] 0.013 secs (0.012u,0.001s)
Chars 1701 - 1886 [(let~x1~:=~match~goal~with~~~~...] 0. secs (0.u,0.s)
Chars 1891 - 1897 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 1902 - 1966 [(abstract~(rewrite~?left_ident...] 0. secs (0.u,0.s)
Chars 1969 - 1977 [Defined.] 0.005 secs (0.004u,0.s)
Chars 1981 - 2348 [Definition~comma_category_indu...] 0.006 secs (0.005u,0.s)
Chars 2351 - 2357 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 110 [Require~Import~HoTT.Basics~HoT...] 9.601 secs (9.027u,0.552s)
Chars 112 - 139 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 141 - 197 [Definition~FinNat~(n~:~nat)~:~...] 0. secs (0.u,0.s)
Chars 199 - 265 [Definition~zero_finnat~(n~:~na...] 0. secs (0.u,0.s)
Chars 267 - 340 [Lemma~path_zero_finnat~(n~:~na...] 0. secs (0.u,0.s)
Chars 341 - 347 [Proof.] 0. secs (0.u,0.s)
Chars 350 - 376 [by~apply~path_sigma_hprop.] 0.685 secs (0.007u,0.036s)
Chars 2362 - 2547 [(let~x1~:=~match~goal~with~~~~...] 3.794 secs (1.428u,0.137s)
Chars 350 - 376 [by~apply~path_sigma_hprop.] 0. secs (0.u,0.s)
Chars 377 - 385 [Defined.] 0.001 secs (0.001u,0.s)
Chars 387 - 486 [Definition~succ_finnat~{n~:~na...] 0.001 secs (0.001u,0.s)
Chars 488 - 588 [Lemma~path_succ_finnat~{n~:~na...] 0.001 secs (0.001u,0.s)
Chars 589 - 595 [Proof.] 0. secs (0.u,0.s)
Chars 598 - 624 [by~apply~path_sigma_hprop.] 0.107 secs (0.005u,0.036s)
Chars 598 - 624 [by~apply~path_sigma_hprop.] 0. secs (0.u,0.s)
Chars 625 - 633 [Defined.] 0.001 secs (0.001u,0.s)
Chars 635 - 731 [Definition~last_finnat~(n~:~na...] 0. secs (0.u,0.s)
Chars 733 - 808 [Lemma~path_last_finnat~(n~:~na...] 0. secs (0.u,0.s)
Chars 809 - 815 [Proof.] 0. secs (0.u,0.s)
Chars 818 - 844 [by~apply~path_sigma_hprop.] 0.517 secs (0.045u,0.051s)
Chars 818 - 844 [by~apply~path_sigma_hprop.] 0. secs (0.u,0.s)
Chars 845 - 853 [Defined.] 0.001 secs (0.001u,0.s)
Chars 855 - 965 [Definition~incl_finnat~{n~:~na...] 0.001 secs (0.001u,0.s)
Chars 967 - 1061 [Lemma~path_incl_finnat~(n~:~na...] 0.001 secs (0.001u,0.s)
Chars 1062 - 1068 [Proof.] 0. secs (0.u,0.s)
Chars 1071 - 1097 [by~apply~path_sigma_hprop.] 0.103 secs (0.004u,0.037s)
Chars 1071 - 1097 [by~apply~path_sigma_hprop.] 0. secs (0.u,0.s)
Chars 1098 - 1106 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1108 - 1326 [Definition~finnat_ind~(P~:~for...] 0.001 secs (0.001u,0.s)
Chars 1327 - 1333 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 43 - 65 [Require~Import~Basics.] 0.335 secs (0.252u,0.081s)
Chars 126 - 155 [Require~Import~Pointed.Loops.] 6.073 secs (5.808u,0.254s)
Chars 156 - 183 [Require~Import~Truncations.] 0.003 secs (0.003u,0.s)
Chars 185 - 216 [#[local]Open~Scope~pointed_scope.] 0. secs (0.u,0.s)
Chars 241 - 353 [#[global]~Instance~ispointed_t...] 0.001 secs (0.001u,0.s)
Chars 355 - 436 [Definition~pTr~(n~:~trunc_inde...] 0.002 secs (0.002u,0.s)
Chars 438 - 499 [Definition~ptr~{n~:~trunc_inde...] 0. secs (0.u,0.s)
Chars 500 - 506 [Proof.] 0. secs (0.u,0.s)
Chars 66 - 87 [Require~Import~Types.] 1.399 secs (1.27u,0.126s)
Chars 88 - 108 [Require~Import~HSet.] 0.047 secs (0.046u,0.s)
Chars 109 - 130 [Require~Import~HProp.] 0. secs (0.u,0.s)
Chars 1491 - 1534 [(pose~proof~(A~:~AdjunctionUni...] 40.107 secs (0.003u,0.019s)
Chars 1541 - 1660 [refine~~(_~~~o~(((idtoiso~(C:=...] 0.007 secs (0.004u,0.003s)
Chars 1667 - 1766 [refine~~(_~~~o~NaturalTransfor...] 0.003 secs (0.003u,0.s)
Chars 3391 - 3416 [srapply~equiv_adjointify.] 40.121 secs (0.006u,0.021s)
Chars 3419 - 3420 [{] 0. secs (0.u,0.s)
Chars 1773 - 2035 [refine~~((idtoiso~(C:=_~->~_)~...] 0.007 secs (0.005u,0.001s)
Chars 2042 - 2099 [refine~(NaturalTransformation....] 0.002 secs (0.002u,0.s)
Chars 2106 - 2194 [exact~~(NaturalTransformation....] 0.001 secs (0.001u,0.s)
Chars 1491 - 1534 [(pose~proof~(A~:~AdjunctionUni...] 0. secs (0.u,0.s)
Chars 1541 - 1660 [refine~~(_~~~o~(((idtoiso~(C:=...] 0. secs (0.u,0.s)
Chars 1667 - 1766 [refine~~(_~~~o~NaturalTransfor...] 0. secs (0.u,0.s)
Chars 1773 - 2035 [refine~~((idtoiso~(C:=_~->~_)~...] 0. secs (0.u,0.s)
Chars 2042 - 2099 [refine~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 2106 - 2194 [exact~~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 2199 - 2207 [Defined.] 0.003 secs (0.002u,0.s)
Chars 2213 - 2363 [Definition~counit_l~:~~~Natura...] 0.002 secs (0.002u,0.s)
Chars 2368 - 2374 [Proof.] 0. secs (0.u,0.s)
Chars 3421 - 3446 [(destruct~sii0,~sii1;~cbn).] 0.03 secs (0.021u,0.008s)
tt
     : unit
Chars 3451 - 3539 [(rewrite~(eisretr~sq_G1~si0i)^...] 0.046 secs (0.043u,0.003s)
Chars 3544 - 3552 [intro~X.] 0.004 secs (0.004u,0.s)
Chars 3557 - 3634 [by~destruct~(sq_G1^-1~si0i),~(...] 0.156 secs (0.137u,0.018s)
Chars 3635 - 3636 [}] 0. secs (0.u,0.s)
Chars 3639 - 3657 [1,~2:~by~intros~[].] 0.434 secs (0.355u,0.078s)
Chars 3660 - 3680 [(destruct~sii0,~sii1).] 0.349 secs (0.336u,0.011s)
Chars 3683 - 3687 [(cbn).] 0.486 secs (0.48u,0.005s)
Chars 3690 - 3722 [(rewrite~<-~(eisretr~sq_G1~si0...] 0.514 secs (0.503u,0.009s)
Chars 131 - 152 [Require~Import~DProp.] 7.621 secs (7.243u,0.36s)
Chars 153 - 179 [Require~Import~Spaces.Nat.] 0.075 secs (0.07u,0.004s)
Chars 180 - 202 [Require~Import~HFiber.] 0. secs (0.u,0.s)
Chars 203 - 232 [Require~Import~Factorization.] 0. secs (0.u,0.s)
Chars 233 - 264 [Require~Import~Equiv.PathSplit.] 0. secs (0.u,0.s)
Chars 265 - 292 [Require~Import~Truncations.] 0.004 secs (0.004u,0.s)
Chars 3725 - 3757 [(rewrite~<-~(eisretr~sq_1G~s0i...] 0.486 secs (0.482u,0.002s)
Chars 293 - 326 [Require~Import~Colimits.Quotient.] 0.619 secs (0.601u,0.016s)
Chars 327 - 353 [Require~Import~Projective.] 0.045 secs (0.044u,0.001s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 3760 - 3792 [(rewrite~<-~(eisretr~sq_1G~s1i...] 0.569 secs (0.517u,0.051s)
Chars 354 - 373 [Require~Import~Fin.] 0.186 secs (0.184u,0.001s)
Chars 375 - 403 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 404 - 431 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 478 - 573 [Class~Finite~(X~:~Type)~:={~~~...] 0.003 secs (0.003u,0.s)
Chars 575 - 597 [Arguments~fcard~X~{_}.] 0. secs (0.u,0.s)
Chars 598 - 631 [Arguments~merely_equiv_fin~X~{_}.] 0. secs (0.u,0.s)
Chars 633 - 709 [Definition~issig_finite~X~:~{n...] 0. secs (0.u,0.s)
Chars 710 - 716 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 37 [Require~Import~HoTT.Basics.Dec...] 0.32 secs (0.241u,0.078s)
Chars 3795 - 3834 [(destruct~(@equiv_inv~_~_~sq_G...] 1.533 secs (1.523u,0.007s)
Chars 3837 - 3876 [(destruct~(@equiv_inv~_~_~sq_1...] 1.347 secs (1.336u,0.008s)
Chars 509 - 528 [srapply~Build_pMap.] 13.556 secs (0.001u,0.034s)
Chars 531 - 532 [+] 0. secs (0.u,0.s)
Chars 533 - 542 [(apply~tr).] 0.001 secs (0.u,0.s)
Chars 545 - 546 [+] 0. secs (0.u,0.s)
Chars 547 - 559 [reflexivity.] 0. secs (0.u,0.s)
Chars 509 - 528 [srapply~Build_pMap.] 0. secs (0.u,0.s)
Chars 533 - 542 [(apply~tr).] 0. secs (0.u,0.s)
Chars 547 - 559 [reflexivity.] 0. secs (0.u,0.s)
Chars 560 - 568 [Defined.] 0. secs (0.u,0.s)
Chars 570 - 655 [#[global]~Instance~isequiv_ptr...] 0.05 secs (0.032u,0.016s)
Chars 657 - 769 [Definition~pequiv_ptr~{n~:~tru...] 0.009 secs (0.009u,0.s)
Chars 771 - 908 [Definition~pTr_rec~n~{X~Y~:~pT...] 0.003 secs (0.002u,0.001s)
Chars 910 - 1012 [Definition~equiv_ptr_rec~`{Fun...] 0.001 secs (0.001u,0.s)
Chars 1013 - 1019 [Proof.] 0. secs (0.u,0.s)
Chars 3749 - 3761 [revert~ext'.] 40.059 secs (0.u,0.028s)
Chars 3766 - 3796 [srapply~equiv_path_from_contr.] 0.022 secs (0.017u,0.004s)
Chars 3801 - 3802 [{] 0. secs (0.u,0.s)
Chars 3803 - 3830 [(unfold~ExtensionAlong;~cbn).] 0.001 secs (0.001u,0.s)
Chars 3837 - 3862 [exists~(fun~y~=>~1%path).] 0.002 secs (0.001u,0.s)
Chars 3869 - 3905 [(intros~x;~symmetry;~apply~con...] 0.004 secs (0.003u,0.001s)
Chars 3906 - 3907 [}] 0. secs (0.u,0.s)
Chars 3912 - 3963 [(destruct~ext~as~[g~gd];~unfol...] 0.005 secs (0.005u,0.s)
Chars 3968 - 4203 [refine~~(contr_sigma_sigma~(fo...] 0.136 secs (0.107u,0.028s)
Chars 4208 - 4257 [refine~(contr_equiv'~{p~:~g~o~...] 0.006 secs (0.005u,0.s)
Chars 4258 - 4262 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 4267 - 4311 [(refine~(equiv_functor_sigma_i...] 0.003 secs (0.003u,0.s)
Chars 4316 - 4366 [(refine~(equiv_functor_forall_...] 0.003 secs (0.002u,0.001s)
Chars 4371 - 4408 [refine~(_~oE~equiv_path_invers...] 0.002 secs (0.002u,0.s)
Chars 4413 - 4444 [(symmetry;~apply~equiv_moveR_1M).] 0.003 secs (0.003u,0.s)
Chars 3749 - 3761 [revert~ext'.] 0. secs (0.u,0.s)
Chars 3766 - 3796 [srapply~equiv_path_from_contr.] 0. secs (0.u,0.s)
Chars 3803 - 3830 [(unfold~ExtensionAlong;~cbn).] 0.001 secs (0.001u,0.s)
Chars 3837 - 3862 [exists~(fun~y~=>~1%path).] 0. secs (0.u,0.s)
Chars 3869 - 3905 [(intros~x;~symmetry;~apply~con...] 0.001 secs (0.001u,0.s)
Chars 3912 - 3963 [(destruct~ext~as~[g~gd];~unfol...] 0.003 secs (0.003u,0.s)
Chars 3968 - 4203 [refine~~(contr_sigma_sigma~(fo...] 0. secs (0.u,0.s)
Chars 4208 - 4257 [refine~(contr_equiv'~{p~:~g~o~...] 0. secs (0.u,0.s)
Chars 4258 - 4262 [(cbn).] 0. secs (0.u,0.s)
Chars 4267 - 4311 [(refine~(equiv_functor_sigma_i...] 0.001 secs (0.001u,0.s)
Chars 4316 - 4366 [(refine~(equiv_functor_forall_...] 0.001 secs (0.001u,0.s)
Chars 4371 - 4408 [refine~(_~oE~equiv_path_invers...] 0. secs (0.u,0.s)
Chars 4413 - 4444 [(symmetry;~apply~equiv_moveR_1M).] 0.001 secs (0.001u,0.s)
Chars 4447 - 4455 [Defined.] 0.007 secs (0.006u,0.s)
Chars 2381 - 2426 [(pose~proof~(A~:~AdjunctionCou...] 7.337 secs (4.831u,0.194s)
Chars 4459 - 4810 [Definition~path_extension~`{Fu...] 0.004 secs (0.004u,0.s)
Chars 4814 - 5050 [#[global]~Instance~isequiv_pat...] 0.004 secs (0.004u,0.s)
Chars 5094 - 5502 [Fixpoint~ExtendableAlong@{i~j~...] 0.002 secs (0.002u,0.s)
Chars 5650 - 5733 [#[global]~Arguments~Extendable...] 0. secs (0.u,0.s)
Chars 5801 - 6061 [Definition~lift_extendablealon...] 0. secs (0.u,0.s)
Chars 6064 - 6070 [Proof.] 0. secs (0.u,0.s)
Chars 3879 - 3918 [(destruct~(@equiv_inv~_~_~sq_1...] 1.393 secs (1.332u,0.059s)
Chars 3921 - 3935 [(destruct~p00i).] 0.368 secs (0.362u,0.005s)
Chars 3938 - 3946 [intro~X.] 0.082 secs (0.082u,0.s)
Chars 3949 - 3963 [by~destruct~X.] 0.43 secs (0.417u,0.013s)
Chars 6075 - 6119 [(revert~P;~simple_induction~n~...] 0.949 secs (0.002u,0.027s)
Chars 6124 - 6125 [-] 0. secs (0.u,0.s)
Chars 6126 - 6145 [(intros~_;~exact~tt).] 0. secs (0.u,0.s)
Chars 6150 - 6151 [-] 0. secs (0.u,0.s)
Chars 6152 - 6170 [(intros~ext;~split).] 0.001 secs (0.001u,0.s)
Chars 6177 - 6178 [+] 0. secs (0.u,0.s)
Chars 6179 - 6276 [(intros~g;~exact~~~(lift_exten...] 0.002 secs (0.002u,0.s)
Chars 6283 - 6284 [+] 0. secs (0.u,0.s)
Chars 6285 - 6296 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 6396 - 6449 [(pose~(P'~:=~(fun~b~=>~h~b~=~k...] 0.001 secs (0.001u,0.s)
Chars 6458 - 6486 [exact~(IH~P'~(snd~ext~h~k)).] 0.001 secs (0.u,0.s)
Chars 6075 - 6119 [(revert~P;~simple_induction~n~...] 0. secs (0.u,0.s)
Chars 6126 - 6145 [(intros~_;~exact~tt).] 0. secs (0.u,0.s)
Chars 6152 - 6170 [(intros~ext;~split).] 0. secs (0.u,0.s)
Chars 6179 - 6276 [(intros~g;~exact~~~(lift_exten...] 0. secs (0.u,0.s)
Chars 6285 - 6296 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 6396 - 6449 [(pose~(P'~:=~(fun~b~=>~h~b~=~k...] 0. secs (0.u,0.s)
Chars 6458 - 6486 [exact~(IH~P'~(snd~ext~h~k)).] 0. secs (0.u,0.s)
Chars 6489 - 6497 [Defined.] 0.001 secs (0.001u,0.s)
Chars 6501 - 6696 [Definition~equiv_extendable_pa...] 0.001 secs (0.001u,0.s)
Chars 6699 - 6705 [Proof.] 0. secs (0.u,0.s)
Chars 3391 - 3416 [srapply~equiv_adjointify.] 0.001 secs (0.001u,0.s)
Chars 3421 - 3446 [(destruct~sii0,~sii1;~cbn).] 0.002 secs (0.002u,0.s)
Chars 3451 - 3539 [(rewrite~(eisretr~sq_G1~si0i)^...] 0.001 secs (0.001u,0.s)
Chars 3544 - 3552 [intro~X.] 0.001 secs (0.001u,0.s)
Chars 3557 - 3634 [by~destruct~(sq_G1^-1~si0i),~(...] 0.001 secs (0.001u,0.s)
Chars 3639 - 3657 [1,~2:~by~intros~[].] 0.018 secs (0.018u,0.s)
Chars 3660 - 3680 [(destruct~sii0,~sii1).] 0.019 secs (0.019u,0.s)
Chars 3683 - 3687 [(cbn).] 0.017 secs (0.017u,0.s)
Chars 3690 - 3722 [(rewrite~<-~(eisretr~sq_G1~si0...] 0.061 secs (0.061u,0.s)
Chars 3725 - 3757 [(rewrite~<-~(eisretr~sq_1G~s0i...] 0.089 secs (0.083u,0.005s)
Chars 3760 - 3792 [(rewrite~<-~(eisretr~sq_1G~s1i...] 0.116 secs (0.116u,0.s)
Chars 3795 - 3834 [(destruct~(@equiv_inv~_~_~sq_G...] 0.071 secs (0.069u,0.001s)
Chars 3837 - 3876 [(destruct~(@equiv_inv~_~_~sq_1...] 0.065 secs (0.065u,0.s)
Chars 3879 - 3918 [(destruct~(@equiv_inv~_~_~sq_1...] 0.069 secs (0.069u,0.s)
Chars 3921 - 3935 [(destruct~p00i).] 0.068 secs (0.067u,0.s)
Chars 3938 - 3946 [intro~X.] 0.07 secs (0.07u,0.s)
Chars 3949 - 3963 [by~destruct~X.] 0.066 secs (0.065u,0.s)
Chars 3964 - 3972 [Defined.] 1.465 secs (1.434u,0.03s)
Chars 3974 - 4008 [Notation~cu_path~:=~equiv_cu_p...] 0. secs (0.u,0.s)
Chars 4010 - 4030 [Section~Reflexivity.] 0. secs (0.u,0.s)
Chars 4064 - 4178 [Context~{A}~{a00~a10~a01~a11~:...] 0. secs (0.u,0.s)
Chars 4213 - 4295 [Definition~cu_refl_lr~(s~:~Pat...] 0. secs (0.u,0.s)
Chars 4298 - 4304 [Proof.] 0. secs (0.u,0.s)
Chars 4309 - 4323 [by~destruct~s.] 0.065 secs (0.005u,0.024s)
Chars 4309 - 4323 [by~destruct~s.] 0. secs (0.u,0.s)
Chars 4326 - 4334 [Defined.] 0.001 secs (0.u,0.s)
Chars 4369 - 4451 [Definition~cu_refl_tb~(s~:~Pat...] 0.002 secs (0.002u,0.s)
Chars 4454 - 4460 [Proof.] 0. secs (0.u,0.s)
Chars 4465 - 4479 [by~destruct~s.] 0.061 secs (0.007u,0.022s)
Chars 4465 - 4479 [by~destruct~s.] 0. secs (0.u,0.s)
Chars 4482 - 4490 [Defined.] 0.001 secs (0.u,0.001s)
Chars 4525 - 4607 [Definition~cu_refl_fb~(s~:~Pat...] 0.002 secs (0.002u,0.s)
Chars 4610 - 4616 [Proof.] 0. secs (0.u,0.s)
Chars 4621 - 4635 [by~destruct~s.] 0.063 secs (0.002u,0.028s)
Chars 4621 - 4635 [by~destruct~s.] 0. secs (0.u,0.s)
Chars 4638 - 4646 [Defined.] 0.001 secs (0.u,0.s)
Chars 4648 - 4664 [End~Reflexivity.] 0.002 secs (0.002u,0.s)
Chars 4708 - 4734 [Section~PathCubeRewriting.] 0. secs (0.u,0.s)
Chars 4738 - 5316 [Context~{A}~{x000~x010~x100~x1...] 0.003 secs (0.002u,0.001s)
Chars 5397 - 5700 [Definition~equiv_cu_GGGGGG~{s0...] 0.004 secs (0.004u,0.s)
Chars 5703 - 5709 [Proof.] 0. secs (0.u,0.s)
Chars 38 - 186 [Require~Import~HoTT.Classes.in...] 9.79 secs (9.244u,0.523s)
Chars 187 - 230 [Require~Export~HoTT.Classes.or...] 0.844 secs (0.815u,0.027s)
Chars 232 - 270 [Generalizable~Variables~F~f~R~...] 0. secs (0.u,0.s)
Chars 272 - 289 [Section~contents.] 0. secs (0.u,0.s)
Chars 290 - 316 [Context~`{OrderedField~F}.] 0.001 secs (0.001u,0.s)
Chars 318 - 399 [Lemma~pos_recip_compat~(x~:~F)...] 0.004 secs (0.004u,0.s)
Chars 400 - 406 [Proof.] 0. secs (0.u,0.s)
Chars 7037 - 7164 [simple~refine~~(Build_IsEquiv~...] 40.049 secs (0.002u,0.021s)
Chars 7167 - 7200 [all:~(destruct~u,~v;~intros~[p...] 0.052 secs (0.042u,0.009s)
Chars 7203 - 7219 [all:~(simpl~in~*).] 0.008 secs (0.007u,0.s)
Chars 7222 - 7253 [all:~(destruct~q,~p;~simpl~in~*).] 0.048 secs (0.04u,0.007s)
Chars 7256 - 7273 [all:~reflexivity.] 0.003 secs (0.002u,0.s)
Chars 7037 - 7164 [simple~refine~~(Build_IsEquiv~...] 0. secs (0.u,0.s)
Chars 7167 - 7200 [all:~(destruct~u,~v;~intros~[p...] 0.007 secs (0.007u,0.s)
Chars 7203 - 7219 [all:~(simpl~in~*).] 0.005 secs (0.005u,0.s)
Chars 7222 - 7253 [all:~(destruct~q,~p;~simpl~in~*).] 0.007 secs (0.005u,0.001s)
Chars 7256 - 7273 [all:~reflexivity.] 0.001 secs (0.001u,0.s)
Chars 7274 - 7282 [Defined.] 0.058 secs (0.048u,0.01s)
Chars 7284 - 7442 [Definition~equiv_path_sigma~`(...] 0.004 secs (0.003u,0.001s)
Chars 7499 - 7624 [#[global]~Instance~isequiv_pat...] 0.001 secs (0.001u,0.s)
Chars 7627 - 7743 [(apply~~~(isequiv_adjointify~(...] 1.996 secs (0.629u,-0.096s)
Chars 995 - 1004 [(intros~p).] 40.149 secs (0.001u,0.032s)
Chars 1009 - 1060 [refine~(inO_equiv_inO'~_~(hfib...] 0.006 secs (0.006u,0.s)
Chars 995 - 1004 [(intros~p).] 0. secs (0.u,0.s)
Chars 1009 - 1060 [refine~(inO_equiv_inO'~_~(hfib...] 0. secs (0.u,0.s)
Chars 1063 - 1071 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1075 - 1153 [Definition~mapinO_from_diagona...] 0.001 secs (0.u,0.s)
Chars 1156 - 1162 [Proof.] 0. secs (0.u,0.s)
Chars 719 - 725 [issig.] 22.833 secs (0.013u,0.041s)
Chars 719 - 725 [issig.] 0. secs (0.u,0.s)
Chars 726 - 734 [Defined.] 0.002 secs (0.002u,0.s)
Chars 1053 - 1107 [#[global]Instance~ishprop_fini...] 0. secs (0.u,0.s)
Chars 1108 - 1114 [Proof.] 0. secs (0.u,0.s)
Chars 2362 - 2547 [(let~x1~:=~match~goal~with~~~~...] 40.033 secs (0.004u,0.018s)
Chars 2552 - 2672 [(abstract~(destruct~m',~m,~x;~...] 0.122 secs (0.107u,0.013s)
Chars 2362 - 2547 [(let~x1~:=~match~goal~with~~~~...] 0. secs (0.u,0.s)
Chars 2552 - 2672 [(abstract~(destruct~m',~m,~x;~...] 0.001 secs (0.001u,0.s)
Chars 2675 - 2683 [Defined.] 0.009 secs (0.009u,0.s)
Chars 2687 - 2965 [Definition~comma_category_indu...] 0.007 secs (0.007u,0.s)
Chars 2968 - 2974 [Proof.] 0. secs (0.u,0.s)
Chars 1336 - 1361 [(induction~n~as~[|~n~IHn]).] 40.132 secs (0.u,0.036s)
Chars 1364 - 1365 [-] 0. secs (0.u,0.s)
Chars 1366 - 1392 [(elim~(not_lt_n_0~u.1~u.2)).] 0.001 secs (0.001u,0.s)
Chars 1395 - 1396 [-] 0. secs (0.u,0.s)
Chars 1397 - 1417 [(destruct~u~as~[x~h]).] 0.001 secs (0.001u,0.s)
Chars 1422 - 1442 [(destruct~x~as~[|~x]).] 0.002 secs (0.001u,0.s)
Chars 1447 - 1448 [+] 0. secs (0.u,0.s)
Chars 1449 - 1505 [exact~(transport~(P~n.+1)~(pat...] 0.002 secs (0.001u,0.s)
Chars 1510 - 1511 [+] 0. secs (0.u,0.s)
Chars 1512 - 1582 [refine~(transport~(P~n.+1)~(pa...] 0.003 secs (0.003u,0.s)
Chars 1589 - 1597 [(apply~s).] 0.001 secs (0.u,0.s)
Chars 1598 - 1608 [(apply~IHn).] 0. secs (0.u,0.s)
Chars 1336 - 1361 [(induction~n~as~[|~n~IHn]).] 0. secs (0.u,0.s)
Chars 1366 - 1392 [(elim~(not_lt_n_0~u.1~u.2)).] 0. secs (0.u,0.s)
Chars 1397 - 1417 [(destruct~u~as~[x~h]).] 0. secs (0.u,0.s)
Chars 1422 - 1442 [(destruct~x~as~[|~x]).] 0. secs (0.u,0.s)
Chars 1449 - 1505 [exact~(transport~(P~n.+1)~(pat...] 0. secs (0.u,0.s)
Chars 1512 - 1582 [refine~(transport~(P~n.+1)~(pa...] 0. secs (0.u,0.s)
Chars 1589 - 1597 [(apply~s).] 0. secs (0.u,0.s)
Chars 1598 - 1608 [(apply~IHn).] 0. secs (0.u,0.s)
Chars 1609 - 1617 [Defined.] 0.002 secs (0.002u,0.s)
Chars 1619 - 1863 [Lemma~compute_finnat_ind_zero~...] 0.003 secs (0.002u,0.s)
Chars 1864 - 1870 [Proof.] 0. secs (0.u,0.s)
Chars 2381 - 2426 [(pose~proof~(A~:~AdjunctionCou...] 40.05 secs (0.002u,0.021s)
Chars 2433 - 2549 [refine~~(((idtoiso~(C:=_~->~_)...] 0.005 secs (0.005u,0.s)
Chars 2556 - 2655 [refine~~(NaturalTransformation...] 0.003 secs (0.003u,0.s)
Chars 2662 - 2950 [refine~~(_~~~o~(((idtoiso~(C:=...] 0.009 secs (0.007u,0.001s)
Chars 2957 - 3014 [refine~(NaturalTransformation....] 0.002 secs (0.002u,0.s)
Chars 3021 - 3109 [exact~~(NaturalTransformation....] 0.001 secs (0.u,0.001s)
Chars 2381 - 2426 [(pose~proof~(A~:~AdjunctionCou...] 0. secs (0.u,0.s)
Chars 2433 - 2549 [refine~~(((idtoiso~(C:=_~->~_)...] 0. secs (0.u,0.s)
Chars 2556 - 2655 [refine~~(NaturalTransformation...] 0. secs (0.u,0.s)
Chars 2662 - 2950 [refine~~(_~~~o~(((idtoiso~(C:=...] 0. secs (0.u,0.s)
Chars 2957 - 3014 [refine~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 3021 - 3109 [exact~~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 3114 - 3122 [Defined.] 0.004 secs (0.003u,0.001s)
Chars 3128 - 3174 [Create~HintDb~adjoint_pointwis...] 0. secs (0.u,0.s)
Chars 3179 - 3395 [Hint~Rewrite~~identity_of~left...] 0.002 secs (0.002u,0.s)
Chars 3401 - 3479 [Definition~pointwise_l~:~point...] 0.002 secs (0.002u,0.s)
Chars 3484 - 3490 [Proof.] 0. secs (0.u,0.s)
Chars 2979 - 2985 [(simpl).] 12.331 secs (9.588u,0.301s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 35 [Require~Import~HoTT.Types.Univ...] 0.973 secs (0.781u,0.189s)
Chars 1022 - 1047 [srapply~equiv_adjointify.] 40.175 secs (0.001u,0.034s)
Chars 1050 - 1051 [{] 0. secs (0.u,0.s)
Chars 1052 - 1060 [intro~f.] 0. secs (0.u,0.s)
Chars 1065 - 1083 [refine~(f~o*~ptr).] 0.001 secs (0.001u,0.s)
Chars 1084 - 1085 [}] 0. secs (0.u,0.s)
Chars 1088 - 1107 [1:~srapply~pTr_rec.] 0.002 secs (0.002u,0.s)
Chars 1110 - 1111 [{] 0. secs (0.u,0.s)
Chars 1112 - 1120 [intro~f.] 0.001 secs (0.001u,0.s)
Chars 1125 - 1145 [(destruct~f~as~[f~p]).] 0.002 secs (0.002u,0.s)
Chars 1150 - 1180 [(apply~(ap~(Build_pMap~_~_~f))).] 0.003 secs (0.002u,0.s)
Chars 1185 - 1201 [(apply~concat_1p).] 0.002 secs (0.002u,0.s)
Chars 1202 - 1203 [}] 0. secs (0.u,0.s)
Chars 1206 - 1214 [intro~f.] 0.001 secs (0.001u,0.s)
Chars 1217 - 1236 [(apply~path_pforall).] 0.001 secs (0.u,0.s)
Chars 1239 - 1263 [srapply~Build_pHomotopy.] 0.002 secs (0.u,0.002s)
Chars 1266 - 1297 [1:~(intro;~by~strip_truncations).] 0.075 secs (0.063u,0.011s)
Chars 1300 - 1304 [(cbn).] 0.003 secs (0.002u,0.s)
Chars 1307 - 1335 [(symmetry;~apply~concat_pp_V).] 0.005 secs (0.003u,0.001s)
Chars 1022 - 1047 [srapply~equiv_adjointify.] 0. secs (0.u,0.s)
Chars 1052 - 1060 [intro~f.] 0. secs (0.u,0.s)
Chars 1065 - 1083 [refine~(f~o*~ptr).] 0. secs (0.u,0.s)
Chars 1088 - 1107 [1:~srapply~pTr_rec.] 0. secs (0.u,0.s)
Chars 1112 - 1120 [intro~f.] 0. secs (0.u,0.s)
Chars 1125 - 1145 [(destruct~f~as~[f~p]).] 0. secs (0.u,0.s)
Chars 1150 - 1180 [(apply~(ap~(Build_pMap~_~_~f))).] 0. secs (0.u,0.s)
Chars 1185 - 1201 [(apply~concat_1p).] 0.001 secs (0.u,0.s)
Chars 1206 - 1214 [intro~f.] 0. secs (0.u,0.s)
Chars 1217 - 1236 [(apply~path_pforall).] 0. secs (0.u,0.s)
Chars 1239 - 1263 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 1266 - 1297 [1:~(intro;~by~strip_truncations).] 0.001 secs (0.001u,0.s)
Chars 1300 - 1304 [(cbn).] 0.002 secs (0.002u,0.s)
Chars 1307 - 1335 [(symmetry;~apply~concat_pp_V).] 0.002 secs (0.002u,0.s)
Chars 1336 - 1344 [Defined.] 0.012 secs (0.011u,0.s)
Chars 1346 - 1400 [#[global]Instance~is0functor_p...] 0. secs (0.u,0.s)
Chars 1401 - 1407 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 6710 - 6769 [(generalize~dependent~C;~simpl...] 40.15 secs (0.004u,0.028s)
Chars 6774 - 6794 [1:~(apply~equiv_idmap).] 0. secs (0.u,0.s)
Chars 6799 - 6822 [(refine~(_~*E~_);~simpl).] 0.004 secs (0.004u,0.s)
Chars 6827 - 6828 [-] 0. secs (0.u,0.s)
Chars 6829 - 6881 [(refine~(equiv_functor_forall'...] 0.004 secs (0.004u,0.s)
Chars 6888 - 6934 [(refine~(equiv_functor_sigma'~...] 0.002 secs (0.u,0.001s)
Chars 6941 - 6965 [(apply~equiv_path_forall).] 0.001 secs (0.001u,0.s)
Chars 6970 - 6971 [-] 0. secs (0.u,0.s)
Chars 6972 - 7017 [(refine~(equiv_functor_forall'...] 0.004 secs (0.004u,0.s)
Chars 7024 - 7076 [(refine~(equiv_functor_forall'...] 0.006 secs (0.006u,0.s)
Chars 7083 - 7122 [refine~(_~oE~IHn~(fun~b~=>~h~b...] 0.003 secs (0.003u,0.s)
Chars 7129 - 7149 [(apply~equiv_inverse).] 0.002 secs (0.002u,0.s)
Chars 7156 - 7252 [refine~~(equiv_functor_pathspl...] 0.004 secs (0.004u,0.s)
Chars 7259 - 7282 [(intros~[];~reflexivity).] 0.004 secs (0.003u,0.s)
Chars 6710 - 6769 [(generalize~dependent~C;~simpl...] 0.001 secs (0.001u,0.s)
Chars 6774 - 6794 [1:~(apply~equiv_idmap).] 0. secs (0.u,0.s)
Chars 6799 - 6822 [(refine~(_~*E~_);~simpl).] 0.002 secs (0.001u,0.s)
Chars 6829 - 6881 [(refine~(equiv_functor_forall'...] 0.002 secs (0.002u,0.s)
Chars 6888 - 6934 [(refine~(equiv_functor_sigma'~...] 0.001 secs (0.001u,0.s)
Chars 6941 - 6965 [(apply~equiv_path_forall).] 0. secs (0.u,0.s)
Chars 6972 - 7017 [(refine~(equiv_functor_forall'...] 0.002 secs (0.u,0.002s)
Chars 7024 - 7076 [(refine~(equiv_functor_forall'...] 0.004 secs (0.004u,0.s)
Chars 7083 - 7122 [refine~(_~oE~IHn~(fun~b~=>~h~b...] 0.001 secs (0.001u,0.s)
Chars 7129 - 7149 [(apply~equiv_inverse).] 0.001 secs (0.u,0.s)
Chars 7156 - 7252 [refine~~(equiv_functor_pathspl...] 0.001 secs (0.001u,0.s)
Chars 7259 - 7282 [(intros~[];~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 7285 - 7293 [Defined.] 0.01 secs (0.009u,0.001s)
Chars 7297 - 7531 [Definition~isequiv_extendable~...] 0.005 secs (0.004u,0.001s)
Chars 7535 - 7680 [#[global]~Instance~ishprop_ext...] 0. secs (0.u,0.s)
Chars 7683 - 7689 [Proof.] 0. secs (0.u,0.s)
Chars 5714 - 5761 [by~destruct~t0ii,~t1ii,~tii0,~...] 40.128 secs (0.014u,0.024s)
Chars 5714 - 5761 [by~destruct~t0ii,~t1ii,~tii0,~...] 0.001 secs (0.001u,0.s)
Chars 5764 - 5772 [Defined.] 0.003 secs (0.002u,0.s)
Chars 5776 - 5962 [Context~{s0ii'}~{s1ii'}~{sii0'...] 0.003 secs (0.003u,0.s)
Chars 5966 - 6027 [Definition~equiv_cu_Gccccc~:=~...] 0.001 secs (0.u,0.001s)
Chars 6030 - 6091 [Definition~equiv_cu_cGcccc~:=~...] 0.002 secs (0.002u,0.s)
Chars 6094 - 6155 [Definition~equiv_cu_ccGccc~:=~...] 0.001 secs (0.001u,0.s)
Chars 6158 - 6219 [Definition~equiv_cu_cccGcc~:=~...] 0.001 secs (0.001u,0.s)
Chars 6222 - 6283 [Definition~equiv_cu_ccccGc~:=~...] 0.009 secs (0.007u,0.002s)
Chars 6286 - 6347 [Definition~equiv_cu_cccccG~:=~...] 0.001 secs (0.u,0.s)
Chars 6350 - 6420 [Definition~equiv_cu_ccGGGG~:=~...] 0.001 secs (0.001u,0.s)
Chars 6423 - 6493 [Definition~equiv_cu_GGGGcc~:=~...] 0.001 secs (0.001u,0.s)
Chars 6496 - 6560 [Definition~equiv_cu_GGcccc~:=~...] 0.001 secs (0.001u,0.s)
Chars 6563 - 6627 [Definition~equiv_cu_ccGGcc~:=~...] 0.001 secs (0.001u,0.s)
Chars 6630 - 6694 [Definition~equiv_cu_ccccGG~:=~...] 0.001 secs (0.001u,0.s)
Chars 6696 - 6718 [End~PathCubeRewriting.] 0.01 secs (0.007u,0.002s)
Chars 6720 - 6758 [Notation~cu_GGGGGG~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 6759 - 6797 [Notation~cu_Gccccc~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 6798 - 6836 [Notation~cu_cGcccc~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 6837 - 6875 [Notation~cu_ccGccc~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 6876 - 6914 [Notation~cu_cccGcc~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 6915 - 6953 [Notation~cu_ccccGc~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 6954 - 6992 [Notation~cu_cccccG~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 6993 - 7031 [Notation~cu_ccGGGG~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 7032 - 7070 [Notation~cu_GGGGcc~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 7071 - 7109 [Notation~cu_GGcccc~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 7110 - 7148 [Notation~cu_ccGGcc~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 7149 - 7187 [Notation~cu_ccccGG~:=~equiv_cu...] 0. secs (0.u,0.s)
Chars 7237 - 7945 [Definition~equiv_cu_rot_tb_fb~...] 0.031 secs (0.029u,0.001s)
Chars 7946 - 7952 [Proof.] 0. secs (0.u,0.s)
     = false
     : bool
     = false
     : bool
Chars 36 - 308 [Require~Import~HoTT.Classes.in...] 12.278 secs (11.721u,0.53s)
Chars 310 - 350 [Generalizable~Variables~N~Z~Zl...] 0. secs (0.u,0.s)
Chars 352 - 369 [Section~contents.] 0. secs (0.u,0.s)
Chars 370 - 402 [Context~`{Funext}~`{Univalence}.] 0. secs (0.u,0.s)
Chars 407 - 448 [(apply~(strictly_order_reflect...] 40.176 secs (0.016u,0.036s)
Chars 403 - 507 [Context~`{Integers~Z}~`{Apart~...] 0.006 secs (0.006u,0.s)
Chars 449 - 466 [(rewrite~mult_0_r).] 0.011 secs (0.007u,0.003s)
Chars 467 - 494 [(rewrite~(recip_inverse'~x)).] 0.005 secs (0.004u,0.001s)
Chars 495 - 508 [(apply~lt_0_1).] 0.011 secs (0.008u,0.002s)
Chars 407 - 448 [(apply~(strictly_order_reflect...] 0. secs (0.u,0.s)
Chars 449 - 466 [(rewrite~mult_0_r).] 0.001 secs (0.001u,0.s)
Chars 467 - 494 [(rewrite~(recip_inverse'~x)).] 0.001 secs (0.001u,0.s)
Chars 495 - 508 [(apply~lt_0_1).] 0. secs (0.u,0.s)
Chars 509 - 513 [Qed.] 0.002 secs (0.002u,0.s)
Chars 515 - 596 [Lemma~neg_recip_compat~(x~:~F)...] 0.005 secs (0.003u,0.002s)
Chars 597 - 603 [Proof.] 0. secs (0.u,0.s)
Chars 559 - 657 [Lemma~int_abs_unique~(a~b~:~In...] 0.069 secs (0.065u,0.003s)
Chars 658 - 664 [Proof.] 0. secs (0.u,0.s)
     = true
     : bool
Chars 7627 - 7743 [(apply~~~(isequiv_adjointify~(...] 40.046 secs (0.004u,0.021s)
Chars 7744 - 7745 [-] 0. secs (0.u,0.s)
Chars 7746 - 7806 [by~intro~r;~induction~r;~destr...] 0.004 secs (0.004u,0.s)
Chars 7807 - 7808 [-] 0. secs (0.u,0.s)
Chars 7809 - 7837 [(destruct~u,~v;~intros~[p~q]).] 0.015 secs (0.014u,0.s)
Chars 7840 - 7851 [(simpl~in~*).] 0.003 secs (0.003u,0.s)
Chars 7854 - 7877 [(destruct~p;~simpl~in~q).] 0.006 secs (0.006u,0.s)
Chars 7880 - 7904 [(destruct~q;~reflexivity).] 0.007 secs (0.005u,0.001s)
Chars 7627 - 7743 [(apply~~~(isequiv_adjointify~(...] 0. secs (0.u,0.s)
Chars 7746 - 7806 [by~intro~r;~induction~r;~destr...] 0.001 secs (0.u,0.001s)
Chars 7809 - 7837 [(destruct~u,~v;~intros~[p~q]).] 0.003 secs (0.003u,0.s)
Chars 7840 - 7851 [(simpl~in~*).] 0.002 secs (0.002u,0.s)
Chars 7854 - 7877 [(destruct~p;~simpl~in~q).] 0.002 secs (0.002u,0.s)
Chars 7880 - 7904 [(destruct~q;~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 7905 - 7913 [Defined.] 0.015 secs (0.014u,0.s)
Chars 7967 - 8152 [Definition~equiv_path_sigma_co...] 0.005 secs (0.005u,0.s)
Chars 8211 - 8533 [Definition~path_sigma_pp_pp~{A...] 0.007 secs (0.006u,0.s)
Chars 8534 - 8540 [Proof.] 0. secs (0.u,0.s)
Chars 1167 - 1181 [(intros~x1~u~v).] 40.164 secs (0.u,0.033s)
Chars 1186 - 1207 [(destruct~v~as~[x2~p]).] 0.001 secs (0.001u,0.s)
Chars 1212 - 1223 [(destruct~p).] 0.001 secs (0.001u,0.s)
Chars 1228 - 1289 [refine~(inO_equiv_inO'~_~(hfib...] 0.006 secs (0.005u,0.001s)
Chars 1167 - 1181 [(intros~x1~u~v).] 0. secs (0.u,0.s)
Chars 1186 - 1207 [(destruct~v~as~[x2~p]).] 0. secs (0.u,0.s)
Chars 1212 - 1223 [(destruct~p).] 0. secs (0.u,0.s)
Chars 1228 - 1289 [refine~(inO_equiv_inO'~_~(hfib...] 0. secs (0.u,0.s)
Chars 1292 - 1300 [Defined.] 0.002 secs (0.001u,0.s)
Chars 1302 - 1315 [End~Diagonal.] 0.005 secs (0.005u,0.s)
Chars 1457 - 1530 [Definition~susp_localgen~(f~:~...] 0. secs (0.u,0.s)
Chars 1531 - 1537 [Proof.] 0. secs (0.u,0.s)
Chars 1540 - 1563 [(econstructor;~intros~i).] 0.083 secs (0.u,0.034s)
Chars 1566 - 1593 [exact~(functor_susp~(f~i)).] 0.001 secs (0.001u,0.s)
Chars 1540 - 1563 [(econstructor;~intros~i).] 0. secs (0.u,0.s)
Chars 1566 - 1593 [exact~(functor_susp~(f~i)).] 0. secs (0.u,0.s)
Chars 1594 - 1602 [Defined.] 0. secs (0.u,0.s)
Chars 1604 - 1686 [#[global]~Instance~isaccrsu_se...] 0. secs (0.u,0.s)
Chars 1687 - 1693 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 658 [Require~Import~HoTT.Types.Univ...] 14.265 secs (13.522u,0.7s)
Chars 660 - 685 [Import~Quoting.Instances.] 0. secs (0.u,0.s)
Chars 686 - 711 [Import~NatPair.Instances.] 0. secs (0.u,0.s)
Chars 712 - 750 [#[local]Set~Universe~Minimizat...] 0. secs (0.u,0.s)
Chars 752 - 769 [Section~contents.] 0. secs (0.u,0.s)
Chars 770 - 802 [Context~`{Funext}~`{Univalence}.] 0. secs (0.u,0.s)
Chars 803 - 815 [Universe~UQ.] 0. secs (0.u,0.s)
Chars 816 - 1301 [Context~{Q~:~Type@{UQ}}~{Qap~:...] 0.006 secs (0.006u,0.s)
Chars 1303 - 1365 [#[global]Instance~rational_1_n...] 0.001 secs (0.001u,0.s)
Chars 1366 - 1372 [Proof.] 0. secs (0.u,0.s)
Chars 1117 - 1167 [refine~(istrunc_equiv_istrunc~...] 40.213 secs (0.025u,0.038s)
Chars 1170 - 1217 [(apply~ishprop_sigma_disjoint;...] 0.006 secs (0.006u,0.s)
Chars 1220 - 1238 [strip_truncations.] 0.073 secs (0.06u,0.012s)
Chars 1241 - 1285 [refine~(nat_eq_fin_equiv~n~m~(...] 0.001 secs (0.001u,0.s)
Chars 1117 - 1167 [refine~(istrunc_equiv_istrunc~...] 0. secs (0.u,0.s)
Chars 1170 - 1217 [(apply~ishprop_sigma_disjoint;...] 0. secs (0.u,0.s)
Chars 1220 - 1238 [strip_truncations.] 0. secs (0.u,0.s)
Chars 1241 - 1285 [refine~(nat_eq_fin_equiv~n~m~(...] 0. secs (0.u,0.s)
Chars 1286 - 1294 [Defined.] 0.002 secs (0.001u,0.s)
Chars 1350 - 1433 [Definition~finite_equiv~X~{Y}~...] 0. secs (0.u,0.s)
Chars 1434 - 1440 [Proof.] 0. secs (0.u,0.s)
Chars 2979 - 2985 [(simpl).] 40.042 secs (0.u,0.018s)
Chars 2990 - 3265 [(let~s~:=~match~goal~with~~~~~...] 0.006 secs (0.005u,0.s)
Chars 3270 - 3613 [(abstract~(destruct_head~prod;...] 0.158 secs (0.126u,0.031s)
Chars 2979 - 2985 [(simpl).] 0. secs (0.u,0.s)
Chars 2990 - 3265 [(let~s~:=~match~goal~with~~~~~...] 0. secs (0.u,0.s)
Chars 3270 - 3613 [(abstract~(destruct_head~prod;...] 0.001 secs (0.001u,0.s)
Chars 3630 - 3638 [Defined.] 0.019 secs (0.016u,0.001s)
Chars 3642 - 3789 [Definition~comma_category_indu...] 0.006 secs (0.003u,0.003s)
Chars 3792 - 3798 [Proof.] 0. secs (0.u,0.s)
Chars 1873 - 1877 [(cbn).] 40.155 secs (0.003u,0.035s)
Chars 1878 - 1936 [by~induction~(hset_path2~1~(pa...] 0.029 secs (0.026u,0.002s)
Chars 1873 - 1877 [(cbn).] 0. secs (0.u,0.s)
Chars 1878 - 1936 [by~induction~(hset_path2~1~(pa...] 0. secs (0.u,0.s)
Chars 1937 - 1945 [Defined.] 0.004 secs (0.002u,0.001s)
Chars 1947 - 2236 [Lemma~compute_finnat_ind_succ~...] 0.007 secs (0.005u,0.001s)
Chars 2237 - 2243 [Proof.] 0. secs (0.u,0.s)
Chars 3803 - 4167 [(refine~~~(Build_Functor~(fst~...] 8.255 secs (5.465u,0.133s)
Finished transaction in 45.747 secs (5.389u,0.25s) (successful)
Chars 3497 - 4711 [Time~(exists~unit_l~counit_l;~...] 45.747 secs (5.389u,0.25s)
Finished transaction in 0.001 secs (0.001u,0.s) (successful)
Chars 3497 - 4711 [Time~(exists~unit_l~counit_l;~...] 0.001 secs (0.001u,0.s)
Chars 4731 - 4739 [Defined.] 0.286 secs (0.281u,0.004s)
Chars 4742 - 4748 [End~l.] 0.012 secs (0.012u,0.s)
Chars 4794 - 4804 [Section~r.] 0. secs (0.u,0.s)
Chars 4809 - 4834 [Variable~(F~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 4839 - 4864 [Variable~(G~:~Functor~D~C).] 0. secs (0.u,0.s)
Chars 4870 - 4890 [Variable~(A~:~F~-|~G).] 0. secs (0.u,0.s)
Chars 4896 - 4921 [Variable~(E~:~PreCategory).] 0. secs (0.u,0.s)
Chars 4927 - 5079 [Definition~unit_r~:~~~NaturalT...] 0.002 secs (0.002u,0.s)
Chars 5084 - 5090 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 1410 - 1433 [(apply~Build_Is0Functor).] 40.173 secs (0.001u,0.034s)
Chars 1436 - 1449 [(intros~X~Y~f).] 0. secs (0.u,0.s)
Chars 1452 - 1543 [exact~~(Build_pMap~(pTr~n~X)~(...] 0.003 secs (0.003u,0.s)
Chars 1410 - 1433 [(apply~Build_Is0Functor).] 0. secs (0.u,0.s)
Chars 1436 - 1449 [(intros~X~Y~f).] 0. secs (0.u,0.s)
Chars 1452 - 1543 [exact~~(Build_pMap~(pTr~n~X)~(...] 0. secs (0.u,0.s)
Chars 1544 - 1552 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1554 - 1608 [#[global]Instance~is1functor_p...] 0.003 secs (0.002u,0.s)
Chars 1609 - 1615 [Proof.] 0. secs (0.u,0.s)
Chars 44 - 72 [Require~Import~Basics~Types.] 1.752 secs (1.527u,0.193s)
Chars 7694 - 7767 [exact~(istrunc_equiv_istrunc~_...] 40.123 secs (0.001u,0.031s)
Chars 7694 - 7767 [exact~(istrunc_equiv_istrunc~_...] 0. secs (0.u,0.s)
Chars 7770 - 7778 [Defined.] 0. secs (0.u,0.s)
Chars 7782 - 7974 [Definition~equiv_extendable_is...] 0. secs (0.u,0.s)
Chars 7977 - 7983 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 7955 - 7980 [srapply~equiv_adjointify.] 40.152 secs (0.004u,0.029s)
Chars 7983 - 7984 [{] 0. secs (0.u,0.s)
Chars 7985 - 7996 [intro~cube.] 0.001 secs (0.001u,0.s)
Chars 8001 - 8030 [refine~(cu_GGGGcc~_~_~_~_~_).] 0.005 secs (0.005u,0.s)
Chars 8035 - 8065 [1,~2,~3,~4:~exact~(eissect~tr~_).] 0.028 secs (0.026u,0.001s)
Chars 8070 - 8082 [revert~cube.] 0.001 secs (0.001u,0.s)
Chars 8087 - 8106 [(set~(a~:=~tr~s0ii)).] 0.006 secs (0.005u,0.001s)
Chars 8111 - 8130 [(set~(b~:=~tr~s1ii)).] 0.005 secs (0.004u,0.001s)
Chars 8135 - 8154 [(set~(c~:=~tr~sii0)).] 0.005 secs (0.004u,0.s)
Chars 8159 - 8178 [(set~(d~:=~tr~sii1)).] 0.005 secs (0.003u,0.001s)
Chars 8183 - 8228 [(clearbody~a~b~c~d;~clear~s0ii...] 0.004 secs (0.003u,0.s)
Chars 8233 - 8244 [intro~cube.] 0.001 secs (0.001u,0.s)
Chars 8249 - 8266 [by~destruct~cube.] 0.02 secs (0.016u,0.003s)
Chars 8267 - 8268 [}] 0. secs (0.u,0.s)
Chars 8271 - 8290 [1,~2:~by~intros~[].] 0.077 secs (0.061u,0.015s)
Chars 8293 - 8322 [(rewrite~<-~(eissect~tr~s0ii)).] 0.026 secs (0.022u,0.003s)
Chars 8325 - 8354 [(rewrite~<-~(eissect~tr~s1ii)).] 0.024 secs (0.022u,0.002s)
Chars 8357 - 8386 [(rewrite~<-~(eissect~tr~sii0)).] 0.027 secs (0.025u,0.001s)
Chars 8389 - 8418 [(rewrite~<-~(eissect~tr~sii1)).] 0.028 secs (0.021u,0.007s)
Chars 8421 - 8440 [(set~(a~:=~tr~s0ii)).] 0.027 secs (0.025u,0.001s)
Chars 8443 - 8462 [(set~(b~:=~tr~s1ii)).] 0.026 secs (0.023u,0.002s)
Chars 8465 - 8484 [(set~(c~:=~tr~sii0)).] 0.026 secs (0.024u,0.002s)
Chars 8487 - 8506 [(set~(d~:=~tr~sii1)).] 0.021 secs (0.019u,0.001s)
Chars 8509 - 8554 [(clearbody~a~b~c~d;~clear~s0ii...] 0.019 secs (0.018u,0.001s)
Chars 8557 - 8565 [intro~X.] 0.005 secs (0.005u,0.s)
Chars 8568 - 8667 [(rewrite~~~<-~(eissect~~~~~~~~...] 0.068 secs (0.068u,0.s)
Chars 8670 - 8757 [(set~~~(e~:=~~~~cu_ccGGGG~(eis...] 0.04 secs (0.04u,0.s)
Chars 8760 - 8781 [(clearbody~e;~clear~X).] 0.018 secs (0.018u,0.s)
Chars 8784 - 8798 [by~destruct~e.] 0.042 secs (0.042u,0.s)
Chars 7955 - 7980 [srapply~equiv_adjointify.] 0.001 secs (0.001u,0.s)
Chars 7985 - 7996 [intro~cube.] 0.001 secs (0.001u,0.s)
Chars 8001 - 8030 [refine~(cu_GGGGcc~_~_~_~_~_).] 0. secs (0.u,0.s)
Chars 8035 - 8065 [1,~2,~3,~4:~exact~(eissect~tr~_).] 0.002 secs (0.002u,0.s)
Chars 8070 - 8082 [revert~cube.] 0.001 secs (0.001u,0.s)
Chars 8087 - 8106 [(set~(a~:=~tr~s0ii)).] 0.001 secs (0.001u,0.s)
Chars 8111 - 8130 [(set~(b~:=~tr~s1ii)).] 0.001 secs (0.001u,0.s)
Chars 8135 - 8154 [(set~(c~:=~tr~sii0)).] 0.001 secs (0.001u,0.s)
Chars 8159 - 8178 [(set~(d~:=~tr~sii1)).] 0.001 secs (0.001u,0.s)
Chars 8183 - 8228 [(clearbody~a~b~c~d;~clear~s0ii...] 0.002 secs (0.002u,0.s)
Chars 8233 - 8244 [intro~cube.] 0.001 secs (0.001u,0.s)
Chars 8249 - 8266 [by~destruct~cube.] 0.001 secs (0.001u,0.s)
Chars 8271 - 8290 [1,~2:~by~intros~[].] 0.005 secs (0.005u,0.s)
Chars 8293 - 8322 [(rewrite~<-~(eissect~tr~s0ii)).] 0.005 secs (0.005u,0.s)
Chars 8325 - 8354 [(rewrite~<-~(eissect~tr~s1ii)).] 0.004 secs (0.004u,0.s)
Chars 8357 - 8386 [(rewrite~<-~(eissect~tr~sii0)).] 0.005 secs (0.005u,0.s)
Chars 8389 - 8418 [(rewrite~<-~(eissect~tr~sii1)).] 0.005 secs (0.005u,0.s)
Chars 8421 - 8440 [(set~(a~:=~tr~s0ii)).] 0.006 secs (0.006u,0.s)
Chars 8443 - 8462 [(set~(b~:=~tr~s1ii)).] 0.005 secs (0.005u,0.s)
Chars 8465 - 8484 [(set~(c~:=~tr~sii0)).] 0.005 secs (0.005u,0.s)
Chars 8487 - 8506 [(set~(d~:=~tr~sii1)).] 0.005 secs (0.005u,0.s)
Chars 8509 - 8554 [(clearbody~a~b~c~d;~clear~s0ii...] 0.009 secs (0.009u,0.s)
Chars 8557 - 8565 [intro~X.] 0.004 secs (0.004u,0.s)
Chars 8568 - 8667 [(rewrite~~~<-~(eissect~~~~~~~~...] 0.004 secs (0.004u,0.s)
Chars 8670 - 8757 [(set~~~(e~:=~~~~cu_ccGGGG~(eis...] 0.01 secs (0.009u,0.s)
Chars 8760 - 8781 [(clearbody~e;~clear~X).] 0.012 secs (0.012u,0.s)
Chars 8784 - 8798 [by~destruct~e.] 0.005 secs (0.005u,0.s)
Chars 8799 - 8807 [Defined.] 0.065 secs (0.064u,0.s)
Chars 8809 - 8853 [Notation~cu_rot_tb_fb~:=~equiv...] 0. secs (0.u,0.s)
Chars 8988 - 9193 [Definition~equiv_cu_G11~{A}~{a...] 0.002 secs (0.002u,0.s)
Chars 9194 - 9200 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 606 - 650 [(set~(negxpos~:=~fst~(flip_neg...] 40.186 secs (0.007u,0.035s)
Chars 665 - 680 [(unfold~int_abs).] 40.147 secs (0.u,0.034s)
Chars 653 - 697 [(apply~(strictly_order_reflect...] 0.023 secs (0.021u,0.001s)
Chars 681 - 806 [(destruct~(int_abs_sig~Z~N~(In...] 0.032 secs (0.026u,0.005s)
Chars 807 - 808 [-] 0. secs (0.u,0.s)
Chars 700 - 717 [(rewrite~mult_0_r).] 0.014 secs (0.013u,0.001s)
Chars 720 - 751 [(rewrite~<-~negate_mult_distr_l).] 0.008 secs (0.007u,0.s)
Chars 754 - 781 [(rewrite~(recip_inverse'~x)).] 0.006 secs (0.005u,0.001s)
Chars 809 - 854 [(apply~(injective~(naturals_to...] 0.038 secs (0.032u,0.005s)
Chars 855 - 866 [(path_via~z).] 0.004 secs (0.004u,0.s)
Chars 867 - 868 [-] 0. secs (0.u,0.s)
Chars 784 - 814 [(apply~flip_pos_negate,~lt_0_1).] 0.023 secs (0.018u,0.004s)
Chars 606 - 650 [(set~(negxpos~:=~fst~(flip_neg...] 0. secs (0.u,0.s)
Chars 653 - 697 [(apply~(strictly_order_reflect...] 0.001 secs (0.001u,0.s)
Chars 700 - 717 [(rewrite~mult_0_r).] 0.001 secs (0.001u,0.s)
Chars 720 - 751 [(rewrite~<-~negate_mult_distr_l).] 0.001 secs (0.001u,0.s)
Chars 754 - 781 [(rewrite~(recip_inverse'~x)).] 0.001 secs (0.001u,0.s)
Chars 784 - 814 [(apply~flip_pos_negate,~lt_0_1).] 0.001 secs (0.001u,0.s)
Chars 815 - 819 [Qed.] 0.003 secs (0.002u,0.s)
Chars 869 - 955 [(assert~(E~:~n1~+~n2~=~0);~~~[...] 0.028 secs (0.026u,0.001s)
Chars 821 - 1005 [Lemma~flip_lt_recip~x~y~(Py~:~...] 0.018 secs (0.016u,0.001s)
Chars 1006 - 1012 [Proof.] 0. secs (0.u,0.s)
Chars 958 - 1003 [(apply~(injective~(naturals_to...] 0.039 secs (0.029u,0.01s)
Chars 1006 - 1041 [(rewrite~preserves_0,~preserve...] 0.023 secs (0.019u,0.003s)
Chars 1044 - 1058 [(rewrite~E1,~E2).] 0.003 secs (0.003u,0.s)
Chars 1061 - 1081 [(apply~plus_negate_r).] 0.033 secs (0.029u,0.003s)
Chars 1082 - 1083 [-] 0. secs (0.u,0.s)
Chars 1084 - 1170 [(assert~(E~:~n1~+~n2~=~0);~~~[...] 0.027 secs (0.024u,0.002s)
Chars 1173 - 1218 [(apply~(injective~(naturals_to...] 0.038 secs (0.028u,0.009s)
Chars 1221 - 1256 [(rewrite~preserves_0,~preserve...] 0.023 secs (0.016u,0.006s)
Chars 1259 - 1273 [(rewrite~E1,~E2).] 0.003 secs (0.003u,0.s)
Chars 1276 - 1296 [(apply~plus_negate_l).] 0.013 secs (0.013u,0.s)
Chars 1297 - 1298 [-] 0. secs (0.u,0.s)
Chars 1299 - 1344 [(apply~(injective~(naturals_to...] 0.04 secs (0.03u,0.008s)
Chars 1345 - 1360 [(path_via~(-~z)).] 0.005 secs (0.004u,0.s)
Chars 665 - 680 [(unfold~int_abs).] 0.001 secs (0.001u,0.s)
Chars 681 - 806 [(destruct~(int_abs_sig~Z~N~(In...] 0.005 secs (0.005u,0.s)
Chars 809 - 854 [(apply~(injective~(naturals_to...] 0.001 secs (0.001u,0.s)
Chars 855 - 866 [(path_via~z).] 0.001 secs (0.001u,0.s)
Chars 869 - 955 [(assert~(E~:~n1~+~n2~=~0);~~~[...] 0.006 secs (0.006u,0.s)
Chars 958 - 1003 [(apply~(injective~(naturals_to...] 0.001 secs (0.u,0.s)
Chars 1006 - 1041 [(rewrite~preserves_0,~preserve...] 0.001 secs (0.001u,0.s)
Chars 1044 - 1058 [(rewrite~E1,~E2).] 0.001 secs (0.001u,0.s)
Chars 1061 - 1081 [(apply~plus_negate_r).] 0.001 secs (0.001u,0.s)
Chars 1084 - 1170 [(assert~(E~:~n1~+~n2~=~0);~~~[...] 0.006 secs (0.006u,0.s)
Chars 1173 - 1218 [(apply~(injective~(naturals_to...] 0.001 secs (0.001u,0.s)
Chars 1221 - 1256 [(rewrite~preserves_0,~preserve...] 0.001 secs (0.001u,0.s)
Chars 1259 - 1273 [(rewrite~E1,~E2).] 0.001 secs (0.001u,0.s)
Chars 1276 - 1296 [(apply~plus_negate_l).] 0.001 secs (0.001u,0.s)
Chars 1299 - 1344 [(apply~(injective~(naturals_to...] 0.001 secs (0.001u,0.s)
Chars 1345 - 1360 [(path_via~(-~z)).] 0.001 secs (0.u,0.s)
Chars 1361 - 1365 [Qed.] 0.03 secs (0.023u,0.007s)
Chars 1367 - 1390 [Context~`{!IntAbs~Z~N}.] 0.027 secs (0.023u,0.003s)
Chars 1392 - 1438 [Context~`{!IsSemiRingPreservin...] 0.002 secs (0.002u,0.s)
Chars 1440 - 1540 [Lemma~int_abs_spec~x~:~~~0~≤~x...] 0.06 secs (0.06u,0.s)
Chars 1541 - 1547 [Proof.] 0. secs (0.u,0.s)
Chars 73 - 96 [Require~Import~Pointed.] 9.572 secs (9.096u,0.466s)
Chars 97 - 124 [Require~Import~Truncations.] 0.004 secs (0.004u,0.s)
Chars 8543 - 8560 [(destruct~u,~v,~w).] 40.115 secs (0.006u,0.028s)
Chars 8561 - 8572 [(simpl~in~*).] 0.003 secs (0.001u,0.001s)
Chars 8575 - 8599 [(destruct~p1,~p2,~q1,~q2).] 0.013 secs (0.009u,0.003s)
Chars 8602 - 8614 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 8543 - 8560 [(destruct~u,~v,~w).] 0.001 secs (0.001u,0.s)
Chars 8561 - 8572 [(simpl~in~*).] 0.002 secs (0.002u,0.s)
Chars 8575 - 8599 [(destruct~p1,~p2,~q1,~q2).] 0.001 secs (0.u,0.001s)
Chars 8602 - 8614 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 8615 - 8623 [Defined.] 0.012 secs (0.01u,0.001s)
Chars 8625 - 9040 [Definition~path_sigma_pp_pp'~{...] 0.009 secs (0.006u,0.003s)
Chars 9042 - 9250 [Definition~path_sigma_p1_1p'~{...] 0.003 secs (0.003u,0.s)
Chars 9251 - 9257 [Proof.] 0. secs (0.u,0.s)
Chars 9260 - 9274 [(destruct~p,~q).] 0.119 secs (0.003u,0.021s)
Chars 9277 - 9289 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 9260 - 9274 [(destruct~p,~q).] 0. secs (0.u,0.s)
Chars 9277 - 9289 [reflexivity.] 0. secs (0.u,0.s)
Chars 9290 - 9298 [Defined.] 0.003 secs (0.003u,0.s)
Chars 9362 - 9463 [Definition~pr1_path_1~{A~:~Typ...] 0.001 secs (0.001u,0.s)
Chars 9465 - 9617 [Definition~pr1_path_pp~{A~:~Ty...] 0.004 secs (0.001u,0.002s)
Chars 9619 - 9728 [Definition~pr1_path_V~{A~:~Typ...] 0.003 secs (0.002u,0.s)
Chars 9836 - 9969 [Definition~ap_exist~{A~:~Type}...] 0.002 secs (0.001u,0.001s)
Chars 9970 - 9976 [Proof.] 0. secs (0.u,0.s)
Chars 9979 - 10003 [(destruct~q;~reflexivity).] 0.065 secs (0.002u,0.021s)
Chars 9979 - 10003 [(destruct~q;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 10004 - 10012 [Defined.] 0.001 secs (0.001u,0.s)
Chars 10089 - 10307 [Definition~transportD_is_trans...] 0.003 secs (0.003u,0.s)
Chars 10308 - 10314 [Proof.] 0. secs (0.u,0.s)
Chars 125 - 158 [Require~Import~Colimits.Quotient.] 0.587 secs (0.583u,0.004s)
Chars 10317 - 10328 [(destruct~p).] 0.069 secs (0.002u,0.021s)
Chars 10329 - 10341 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 10317 - 10328 [(destruct~p).] 0. secs (0.u,0.s)
Chars 10329 - 10341 [reflexivity.] 0. secs (0.u,0.s)
Chars 10342 - 10350 [Defined.] 0.002 secs (0.002u,0.s)
Chars 10413 - 10716 [Definition~ap_path_sigma~{A}~{...] 0.009 secs (0.005u,0.003s)
Chars 10717 - 10723 [Proof.] 0. secs (0.u,0.s)
Chars 10726 - 10753 [(destruct~p,~q;~reflexivity).] 0.194 secs (0.019u,0.032s)
Chars 10726 - 10753 [(destruct~p,~q;~reflexivity).] 0.003 secs (0.003u,0.s)
Chars 10754 - 10762 [Defined.] 0.006 secs (0.005u,0.s)
Chars 11000 - 11187 [Lemma~ap_path_sigma_1p~{A~B~:~...] 0.002 secs (0.001u,0.s)
Chars 11188 - 11194 [Proof.] 0. secs (0.u,0.s)
Chars 11197 - 11221 [(destruct~p;~reflexivity).] 0.08 secs (0.003u,0.02s)
Chars 11197 - 11221 [(destruct~p;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 11222 - 11230 [Defined.] 0.001 secs (0.001u,0.s)
Chars 11451 - 11856 [Definition~ap_sig_rec_path_sig...] 0.013 secs (0.011u,0.001s)
Chars 11857 - 11863 [Proof.] 0. secs (0.u,0.s)
Chars 11866 - 11877 [(destruct~p).] 0.112 secs (0.008u,0.02s)
Chars 11878 - 11889 [(destruct~q).] 0.008 secs (0.004u,0.003s)
Chars 11890 - 11902 [reflexivity.] 0.004 secs (0.004u,0.s)
Chars 11866 - 11877 [(destruct~p).] 0.002 secs (0.001u,0.s)
Chars 11878 - 11889 [(destruct~q).] 0.002 secs (0.002u,0.s)
Chars 11890 - 11902 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 11903 - 11911 [Defined.] 0.01 secs (0.01u,0.s)
Chars 12118 - 12326 [Definition~path_path_sigma_unc...] 0.004 secs (0.003u,0.001s)
Chars 12327 - 12333 [Proof.] 0. secs (0.u,0.s)
Chars 1696 - 1732 [exists~(susp_localgen~(acc_lge...] 40.174 secs (0.001u,0.033s)
Chars 1735 - 1765 [(intros~A;~split;~intros~A_inO).] 0.001 secs (0.001u,0.s)
Chars 1768 - 1769 [{] 0. secs (0.u,0.s)
Chars 1770 - 1779 [(intros~i).] 0. secs (0.u,0.s)
Chars 1784 - 1837 [(apply~(ooextendable_iff_funct...] 0.007 secs (0.006u,0.s)
Chars 1844 - 1857 [(intros~[x~y]).] 0.002 secs (0.002u,0.s)
Chars 1858 - 1867 [(cbn~in~*).] 0.001 secs (0.001u,0.s)
Chars 1872 - 1917 [refine~(ooextendable_postcompo...] 0.002 secs (0.002u,0.s)
Chars 1922 - 1965 [2:~(apply~inO_iff_islocal;~exa...] 0.002 secs (0.002u,0.s)
Chars 1970 - 1979 [(intros~b).] 0. secs (0.u,0.s)
Chars 1984 - 1999 [(apply~dp_const).] 0.001 secs (0.001u,0.s)
Chars 2000 - 2001 [}] 0. secs (0.u,0.s)
Chars 2004 - 2005 [{] 0. secs (0.u,0.s)
Chars 2006 - 2017 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 2022 - 2058 [(apply~(inO_iff_islocal~O);~in...] 0.003 secs (0.003u,0.s)
Chars 2063 - 2084 [specialize~(A_inO~i).] 0. secs (0.u,0.s)
Chars 2089 - 2134 [refine~(ooextendable_postcompo...] 0.001 secs (0.001u,0.s)
Chars 2139 - 2214 [2:~exact~(fst~(ooextendable_if...] 0.043 secs (0.024u,0.018s)
Chars 2219 - 2228 [(intros~b).] 0.001 secs (0.001u,0.s)
Chars 2233 - 2258 [(symmetry;~apply~dp_const).] 0.004 secs (0.004u,0.s)
Chars 2259 - 2260 [}] 0. secs (0.u,0.s)
Chars 1696 - 1732 [exists~(susp_localgen~(acc_lge...] 0. secs (0.u,0.s)
Chars 1735 - 1765 [(intros~A;~split;~intros~A_inO).] 0. secs (0.u,0.s)
Chars 1770 - 1779 [(intros~i).] 0. secs (0.u,0.s)
Chars 1784 - 1837 [(apply~(ooextendable_iff_funct...] 0. secs (0.u,0.s)
Chars 1844 - 1857 [(intros~[x~y]).] 0. secs (0.u,0.s)
Chars 1858 - 1867 [(cbn~in~*).] 0. secs (0.u,0.s)
Chars 1872 - 1917 [refine~(ooextendable_postcompo...] 0. secs (0.u,0.s)
Chars 1922 - 1965 [2:~(apply~inO_iff_islocal;~exa...] 0. secs (0.u,0.s)
Chars 1970 - 1979 [(intros~b).] 0. secs (0.u,0.s)
Chars 1984 - 1999 [(apply~dp_const).] 0. secs (0.u,0.s)
Chars 2006 - 2017 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 2022 - 2058 [(apply~(inO_iff_islocal~O);~in...] 0. secs (0.u,0.s)
Chars 2063 - 2084 [specialize~(A_inO~i).] 0. secs (0.u,0.s)
Chars 2089 - 2134 [refine~(ooextendable_postcompo...] 0. secs (0.u,0.s)
Chars 2139 - 2214 [2:~exact~(fst~(ooextendable_if...] 0. secs (0.u,0.s)
Chars 2219 - 2228 [(intros~b).] 0. secs (0.u,0.s)
Chars 2233 - 2258 [(symmetry;~apply~dp_const).] 0.001 secs (0.001u,0.s)
Chars 2261 - 2269 [Defined.] 0.01 secs (0.009u,0.s)
Chars 2271 - 2341 [Definition~susp_nullgen~(S~:~N...] 0. secs (0.u,0.s)
Chars 2342 - 2348 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 44 [Require~Import~Basics~Types~Po...] 11.398 secs (10.731u,0.633s)
Chars 1373 - 1377 [(red).] 40.186 secs (0.001u,0.041s)
Chars 1378 - 1398 [(apply~trivial_apart).] 0.003 secs (0.003u,0.s)
Chars 1399 - 1415 [solve_propholds.] 0.054 secs (0.05u,0.003s)
Chars 1373 - 1377 [(red).] 0. secs (0.u,0.s)
Chars 1378 - 1398 [(apply~trivial_apart).] 0. secs (0.u,0.s)
Chars 1399 - 1415 [solve_propholds.] 0. secs (0.u,0.s)
Chars 1416 - 1420 [Qed.] 0.001 secs (0.001u,0.s)
Chars 1422 - 1489 [Record~Qpos@{}~:~Type@{UQ}~:=~...] 0.002 secs (0.002u,0.s)
Chars 1490 - 1512 [Notation~"Q+"~:=~Qpos.] 0. secs (0.u,0.s)
Chars 1514 - 1561 [#[global]Instance~Qpos_Q@{}~:~...] 0. secs (0.u,0.s)
Chars 1562 - 1581 [Arguments~Qpos_Q~/.] 0. secs (0.u,0.s)
Chars 1583 - 1638 [Lemma~Qpos_plus_pr@{}~:~forall...] 0.002 secs (0.002u,0.s)
Chars 1639 - 1645 [Proof.] 0. secs (0.u,0.s)
Chars 2351 - 2374 [(econstructor;~intros~i).] 2.272 secs (0.001u,0.033s)
Chars 2377 - 2396 [exact~(Susp~(S~i)).] 0. secs (0.u,0.s)
Chars 2351 - 2374 [(econstructor;~intros~i).] 0. secs (0.u,0.s)
Chars 2377 - 2396 [exact~(Susp~(S~i)).] 0. secs (0.u,0.s)
Chars 2397 - 2405 [Defined.] 0. secs (0.u,0.s)
Chars 2407 - 2504 [#[global]~Instance~isaccmodali...] 0. secs (0.u,0.s)
Chars 2505 - 2511 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 36 [Require~Import~Basics~Types~Po...] 11.423 secs (10.745u,0.644s)
Chars 37 - 66 [Require~Import~Cubical.DPath.] 0. secs (0.u,0.s)
Chars 159 - 200 [Require~Import~Homotopy.Classi...] 7.564 secs (7.294u,0.263s)
Chars 201 - 231 [Require~Import~Algebra.Groups.] 0.038 secs (0.037u,0.s)
Chars 232 - 255 [Require~Import~WildCat.] 0.011 secs (0.01u,0.s)
Chars 257 - 286 [#[local]Open~Scope~trunc_scope.] 0. secs (0.u,0.s)
Chars 287 - 315 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 316 - 347 [#[local]Open~Scope~pointed_scope.] 0. secs (0.u,0.s)
Chars 509 - 539 [#[local]Unset~Keyed~Unification.] 0. secs (0.u,0.s)
Chars 1326 - 1443 [Record~ooGroup~:={~~~~~~~~~~~~...] 0.003 secs (0.003u,0.s)
Chars 1445 - 1495 [#[global]Existing~Instance~isc...] 0. secs (0.u,0.s)
Chars 1497 - 1535 [#[local]Notation~B~:=~classify...] 0. secs (0.u,0.s)
Chars 1537 - 1611 [Definition~group_type~(G~:~ooG...] 0.002 secs (0.002u,0.s)
Chars 2390 - 2434 [Coercion~group_type~:~ooGroup~...] 0. secs (0.u,0.s)
Chars 2500 - 2547 [Definition~group_loops~(X~:~pT...] 0. secs (0.u,0.s)
Chars 2548 - 2554 [Proof.] 0. secs (0.u,0.s)
Chars 1443 - 1452 [(intros~?).] 40.182 secs (0.001u,0.033s)
Chars 1455 - 1491 [refine~(Build_Finite~Y~(fcard~...] 0.001 secs (0.001u,0.s)
Chars 1494 - 1546 [(pose~proof~(merely_equiv_fin~...] 0.094 secs (0.067u,0.026s)
Chars 1549 - 1558 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 1561 - 1590 [exact~(equiv_compose~f~e^-1).] 0.006 secs (0.005u,0.s)
Chars 1443 - 1452 [(intros~?).] 0. secs (0.u,0.s)
Chars 1455 - 1491 [refine~(Build_Finite~Y~(fcard~...] 0. secs (0.u,0.s)
Chars 1494 - 1546 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 1549 - 1558 [(apply~tr).] 0. secs (0.u,0.s)
Chars 1561 - 1590 [exact~(equiv_compose~f~e^-1).] 0. secs (0.u,0.s)
Chars 1591 - 1599 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1601 - 1691 [Definition~finite_equiv'~X~{Y}...] 0.002 secs (0.002u,0.s)
Chars 1693 - 1765 [Corollary~finite_equiv_equiv~X...] 0. secs (0.u,0.s)
Chars 1766 - 1772 [Proof.] 0. secs (0.u,0.s)
Chars 45 - 75 [Require~Import~Algebra.Groups.] 5.15 secs (4.978u,0.142s)
Chars 76 - 103 [Require~Import~Truncations.] 0.004 secs (0.004u,0.s)
Chars 104 - 139 [Require~Import~Homotopy.Suspen...] 0. secs (0.u,0.s)
Chars 1646 - 1653 [(intros).] 5.622 secs (0.001u,0.041s)
Chars 1654 - 1699 [(apply~semirings.pos_plus_comp...] 0.018 secs (0.018u,0.s)
Chars 1646 - 1653 [(intros).] 0. secs (0.u,0.s)
Chars 1654 - 1699 [(apply~semirings.pos_plus_comp...] 0.002 secs (0.002u,0.s)
Chars 1700 - 1704 [Qed.] 0.001 secs (0.001u,0.s)
Chars 1706 - 1789 [#[global]~Instance~Qpos_plus@{...] 0. secs (0.u,0.s)
Chars 1791 - 1870 [#[global]~Instance~pos_is_pos@...] 0.002 secs (0.001u,0.s)
Chars 1872 - 1937 [Lemma~pos_eq@{}~:~forall~a~b~:...] 0.001 secs (0.001u,0.s)
Chars 1938 - 1944 [Proof.] 0. secs (0.u,0.s)
Chars 3803 - 4167 [(refine~~~(Build_Functor~(fst~...] 40.077 secs (0.028u,0.024s)
Chars 3803 - 4167 [(refine~~~(Build_Functor~(fst~...] 0.002 secs (0.002u,0.s)
Chars 4170 - 4178 [Defined.] 0.005 secs (0.004u,0.s)
Chars 4179 - 4214 [End~comma_category_induced_fun...] 0.039 secs (0.036u,0.002s)
Chars 4299 - 4338 [Section~slice_category_induced...] 0. secs (0.u,0.s)
Chars 4341 - 4359 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 4362 - 4387 [Variable~(C~:~PreCategory).] 0. secs (0.u,0.s)
Chars 4391 - 4413 [Section~slice_coslice.] 0. secs (0.u,0.s)
Chars 4418 - 4443 [Variable~(D~:~PreCategory).] 0. secs (0.u,0.s)
Chars 4593 - 4697 [Definition~slice_category_indu...] 0.011 secs (0.006u,0.004s)
Chars 4702 - 4708 [Proof.] 0. secs (0.u,0.s)
Chars 140 - 181 [Require~Import~Homotopy.Classi...] 3.199 secs (3.068u,0.124s)
Chars 182 - 220 [Require~Import~Homotopy.Homoto...] 0. secs (0.u,0.s)
Chars 222 - 251 [#[local]Open~Scope~trunc_scope.] 0. secs (0.u,0.s)
Chars 252 - 283 [#[local]Open~Scope~pointed_scope.] 0. secs (0.u,0.s)
Chars 284 - 316 [Import~ClassifyingSpaceNotation.] 0. secs (0.u,0.s)
Chars 547 - 572 [Section~AssumeUnivalence.] 0. secs (0.u,0.s)
Chars 576 - 598 [Context~`{Univalence}.] 0. secs (0.u,0.s)
Chars 719 - 779 [Definition~Bouquet~(S~:~Type)~...] 0. secs (0.u,0.s)
Chars 783 - 862 [#[global]~Instance~isconnected...] 0. secs (0.u,0.s)
Chars 865 - 871 [Proof.] 0. secs (0.u,0.s)
Chars 4715 - 4827 [(exists~(fun~_~:~Unit~=>~m);~s...] 2.379 secs (-0.332u,-0.024s)
Chars 67 - 99 [Require~Import~Algebra.AbGroups.] 7.511 secs (7.27u,0.221s)
Chars 100 - 127 [Require~Import~Truncations.] 0.005 secs (0.005u,0.s)
Chars 128 - 163 [Require~Import~Homotopy.Suspen...] 0. secs (0.u,0.s)
Chars 2246 - 2414 [refine~~(_~@~~~transport~(fun~...] 40.208 secs (0.024u,0.041s)
Chars 2417 - 2439 [(destruct~u~as~[u1~u2]).] 0.003 secs (0.003u,0.s)
Chars 2442 - 2499 [(assert~(p~:~u2~=~leq_S_n~u1.+...] 0.002 secs (0.002u,0.s)
Chars 2502 - 2503 [-] 0. secs (0.u,0.s)
Chars 2504 - 2523 [(apply~path_ishprop).] 0.002 secs (0.002u,0.s)
Chars 2526 - 2527 [-] 0. secs (0.u,0.s)
Chars 2528 - 2534 [(simpl).] 0.018 secs (0.017u,0.s)
Chars 2535 - 2550 [by~induction~p.] 0.007 secs (0.007u,0.s)
Chars 2246 - 2414 [refine~~(_~@~~~transport~(fun~...] 0. secs (0.u,0.s)
Chars 2417 - 2439 [(destruct~u~as~[u1~u2]).] 0. secs (0.u,0.s)
Chars 2442 - 2499 [(assert~(p~:~u2~=~leq_S_n~u1.+...] 0.001 secs (0.u,0.s)
Chars 2504 - 2523 [(apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 2528 - 2534 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 164 - 205 [Require~Import~Homotopy.Classi...] 0.901 secs (0.841u,0.057s)
Chars 2535 - 2550 [by~induction~p.] 0.001 secs (0.001u,0.s)
Chars 2551 - 2559 [Defined.] 0.009 secs (0.007u,0.001s)
Chars 2561 - 2643 [#[universes(polymorphic=no)]~D...] 0. secs (0.u,0.s)
Chars 2644 - 2650 [Proof.] 0. secs (0.u,0.s)
Chars 206 - 237 [Require~Import~Homotopy.HSpace.] 0.026 secs (0.026u,0.s)
Chars 238 - 276 [Require~Import~Homotopy.Homoto...] 0. secs (0.u,0.s)
Chars 277 - 302 [Require~Import~TruncType.] 0. secs (0.u,0.s)
Chars 303 - 326 [Require~Import~WildCat.] 0.011 secs (0.009u,0.001s)
Chars 377 - 408 [#[local]Open~Scope~pointed_scope.] 0. secs (0.u,0.s)
Chars 409 - 436 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 437 - 463 [#[local]Open~Scope~bg_scope.] 0. secs (0.u,0.s)
Chars 464 - 495 [#[local]Open~Scope~mc_mult_scope.] 0. secs (0.u,0.s)
Chars 858 - 885 [Section~LicataFinsterLemma.] 0. secs (0.u,0.s)
Chars 889 - 1036 [Context~`{Univalence}~(X~:~pTy...] 0.004 secs (0.003u,0.s)
Chars 1176 - 1245 [#[local]Definition~P~:~Susp~X~...] 0.001 secs (0.001u,0.s)
Chars 1249 - 1292 [#[local]Definition~codes~:~Sus...] 0. secs (0.u,0.s)
Chars 1295 - 1301 [Proof.] 0. secs (0.u,0.s)
Chars 5097 - 5140 [(pose~proof~(A~:~AdjunctionUni...] 34.745 secs (26.084u,0.242s)
Chars 5097 - 5140 [(pose~proof~(A~:~AdjunctionUni...] 40.049 secs (0.001u,0.023s)
Chars 5147 - 5266 [refine~~(_~~~o~(((idtoiso~(C:=...] 0.007 secs (0.007u,0.s)
Chars 5273 - 5372 [refine~~(_~~~o~NaturalTransfor...] 0.003 secs (0.003u,0.s)
Chars 5379 - 5641 [refine~~((idtoiso~(C:=_~->~_)~...] 0.007 secs (0.006u,0.s)
Chars 5648 - 5705 [refine~(NaturalTransformation....] 0.002 secs (0.002u,0.s)
Chars 5712 - 5800 [exact~~(NaturalTransformation....] 0.001 secs (0.001u,0.s)
Chars 5097 - 5140 [(pose~proof~(A~:~AdjunctionUni...] 0. secs (0.u,0.s)
Chars 5147 - 5266 [refine~~(_~~~o~(((idtoiso~(C:=...] 0. secs (0.u,0.s)
Chars 5273 - 5372 [refine~~(_~~~o~NaturalTransfor...] 0. secs (0.u,0.s)
Chars 5379 - 5641 [refine~~((idtoiso~(C:=_~->~_)~...] 0. secs (0.u,0.s)
Chars 5648 - 5705 [refine~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 5712 - 5800 [exact~~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 5805 - 5813 [Defined.] 0.004 secs (0.004u,0.s)
Chars 5819 - 5969 [Definition~counit_r~:~~~Natura...] 0.002 secs (0.002u,0.s)
Chars 5974 - 5980 [Proof.] 0. secs (0.u,0.s)
Chars 1618 - 1641 [(apply~Build_Is1Functor).] 40.168 secs (0.u,0.035s)
Chars 1644 - 1645 [-] 0. secs (0.u,0.s)
Chars 1646 - 1663 [(intros~X~Y~f~g~p).] 0. secs (0.u,0.s)
Chars 1668 - 1692 [srapply~Build_pHomotopy.] 0.002 secs (0.002u,0.s)
Chars 1697 - 1698 [+] 0. secs (0.u,0.s)
Chars 1699 - 1732 [(intros~x;~strip_truncations;~...] 0.064 secs (0.056u,0.006s)
Chars 1739 - 1773 [(change~(@tr~n~Y~(f~x)~=~tr~(g...] 0.002 secs (0.001u,0.s)
Chars 1780 - 1792 [(apply~ap,~p).] 0.002 secs (0.002u,0.s)
Chars 1797 - 1798 [+] 0. secs (0.u,0.s)
Chars 1799 - 1880 [exact~((ap~_~(dpoint_eq~p)~@~a...] 0.009 secs (0.009u,0.s)
Chars 1883 - 1884 [-] 0. secs (0.u,0.s)
Chars 1885 - 1894 [(intros~X).] 0. secs (0.u,0.s)
Chars 1899 - 1923 [srapply~Build_pHomotopy.] 0.002 secs (0.002u,0.s)
Chars 1928 - 1929 [{] 0. secs (0.u,0.s)
Chars 1930 - 1938 [intro~x.] 0. secs (0.u,0.s)
Chars 1945 - 1966 [by~strip_truncations.] 0.042 secs (0.031u,0.01s)
Chars 1967 - 1968 [}] 0. secs (0.u,0.s)
Chars 1973 - 1985 [reflexivity.] 0.003 secs (0.002u,0.s)
Chars 1988 - 1989 [-] 0. secs (0.u,0.s)
Chars 1990 - 2007 [(intros~X~Y~Z~f~g).] 0. secs (0.u,0.s)
Chars 2012 - 2036 [srapply~Build_pHomotopy.] 0.003 secs (0.003u,0.s)
Chars 2041 - 2042 [{] 0. secs (0.u,0.s)
Chars 2043 - 2051 [intro~x.] 0. secs (0.u,0.s)
Chars 2058 - 2079 [by~strip_truncations.] 0.076 secs (0.066u,0.009s)
Chars 2080 - 2081 [}] 0. secs (0.u,0.s)
Chars 2086 - 2104 [by~pointed_reduce.] 0.08 secs (0.067u,0.012s)
Chars 1618 - 1641 [(apply~Build_Is1Functor).] 0. secs (0.u,0.s)
Chars 1646 - 1663 [(intros~X~Y~f~g~p).] 0. secs (0.u,0.s)
Chars 1668 - 1692 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 1699 - 1732 [(intros~x;~strip_truncations;~...] 0.001 secs (0.001u,0.s)
Chars 1739 - 1773 [(change~(@tr~n~Y~(f~x)~=~tr~(g...] 0. secs (0.u,0.s)
Chars 1780 - 1792 [(apply~ap,~p).] 0. secs (0.u,0.s)
Chars 1799 - 1880 [exact~((ap~_~(dpoint_eq~p)~@~a...] 0.002 secs (0.002u,0.s)
Chars 1885 - 1894 [(intros~X).] 0. secs (0.u,0.s)
Chars 1899 - 1923 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 1930 - 1938 [intro~x.] 0. secs (0.u,0.s)
Chars 1945 - 1966 [by~strip_truncations.] 0. secs (0.u,0.s)
Chars 1973 - 1985 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 1990 - 2007 [(intros~X~Y~Z~f~g).] 0. secs (0.u,0.s)
Chars 2012 - 2036 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 2043 - 2051 [intro~x.] 0. secs (0.u,0.s)
Chars 2058 - 2079 [by~strip_truncations.] 0. secs (0.u,0.s)
Chars 2086 - 2104 [by~pointed_reduce.] 0.002 secs (0.002u,0.s)
Chars 2105 - 2113 [Defined.] 0.055 secs (0.047u,0.007s)
Chars 2115 - 2203 [Definition~ptr_functor_pconst~...] 0.002 secs (0.001u,0.s)
Chars 2204 - 2210 [Proof.] 0. secs (0.u,0.s)
Chars 7988 - 8002 [etransitivity.] 40.119 secs (0.u,0.023s)
Chars 8007 - 8008 [-] 0. secs (0.u,0.s)
Chars 8009 - 8042 [(apply~equiv_extendable_pathsp...] 0.001 secs (0.001u,0.s)
Chars 8047 - 8048 [-] 0. secs (0.u,0.s)
Chars 8049 - 8079 [(apply~equiv_pathsplit_isequiv).] 0.001 secs (0.001u,0.s)
Chars 7988 - 8002 [etransitivity.] 0. secs (0.u,0.s)
Chars 8009 - 8042 [(apply~equiv_extendable_pathsp...] 0. secs (0.u,0.s)
Chars 8049 - 8079 [(apply~equiv_pathsplit_isequiv).] 0. secs (0.u,0.s)
Chars 8082 - 8090 [Defined.] 0. secs (0.u,0.s)
Chars 8221 - 8418 [Definition~extension_isequiv_p...] 0.001 secs (0.001u,0.s)
Chars 8421 - 8427 [Proof.] 0. secs (0.u,0.s)
Chars 2213 - 2237 [srapply~Build_pHomotopy.] 1.655 secs (0.001u,0.034s)
Chars 2240 - 2241 [-] 0. secs (0.u,0.s)
Chars 2242 - 2283 [(intros~x;~strip_truncations;~...] 0.057 secs (0.049u,0.007s)
Chars 2286 - 2287 [-] 0. secs (0.u,0.s)
Chars 2288 - 2300 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 2213 - 2237 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 2242 - 2283 [(intros~x;~strip_truncations;~...] 0.001 secs (0.001u,0.s)
Chars 2288 - 2300 [reflexivity.] 0.001 secs (0.u,0.s)
Chars 2301 - 2309 [Defined.] 0.004 secs (0.001u,0.002s)
Chars 2311 - 2425 [Definition~ptr_pequiv~{X~Y~:~p...] 0.006 secs (0.006u,0.s)
Chars 2427 - 2536 [Definition~ptr_loops~`{Univale...] 0. secs (0.u,0.s)
Chars 2537 - 2543 [Proof.] 0. secs (0.u,0.s)
Chars 2653 - 2678 [(induction~n~as~[|~n~IHn]).] 16.686 secs (6.576u,-0.198s)
Chars 9203 - 9214 [(destruct~s).] 40.158 secs (0.003u,0.03s)
Chars 9217 - 9239 [refine~(cu_path~oE~_).] 0.003 secs (0.003u,0.s)
Chars 9242 - 9343 [refine~~(equiv_concat_l~~~~~(s...] 0.008 secs (0.007u,0.s)
Chars 9346 - 9424 [refine~(equiv_concat_l~(sq_con...] 0.005 secs (0.004u,0.s)
Chars 9427 - 9473 [refine~(equiv_moveR_equiv_M~(f...] 0.005 secs (0.005u,0.s)
Chars 9476 - 9501 [(apply~equiv_path_inverse).] 0.003 secs (0.003u,0.s)
Chars 9203 - 9214 [(destruct~s).] 0. secs (0.u,0.s)
Chars 9217 - 9239 [refine~(cu_path~oE~_).] 0. secs (0.u,0.s)
Chars 9242 - 9343 [refine~~(equiv_concat_l~~~~~(s...] 0.001 secs (0.001u,0.s)
Chars 9346 - 9424 [refine~(equiv_concat_l~(sq_con...] 0.001 secs (0.001u,0.s)
Chars 9427 - 9473 [refine~(equiv_moveR_equiv_M~(f...] 0.001 secs (0.001u,0.s)
Chars 9476 - 9501 [(apply~equiv_path_inverse).] 0.001 secs (0.001u,0.s)
Chars 9502 - 9510 [Defined.] 0.024 secs (0.019u,0.004s)
Chars 9605 - 9808 [Definition~equiv_cu_1G1~{A}~{a...] 0.026 secs (0.02u,0.005s)
Chars 9809 - 9815 [Proof.] 0. secs (0.u,0.s)
Chars 1015 - 1058 [(assert~(0~<~x)~by~(transitivi...] 40.18 secs (0.009u,0.031s)
Chars 1061 - 1102 [(apply~(strictly_order_reflect...] 0.023 secs (0.02u,0.003s)
Chars 1105 - 1133 [(rewrite~(recip_inverse'~x)).] 0.007 secs (0.006u,0.s)
Chars 1136 - 1154 [(rewrite~mult_comm).] 0.013 secs (0.012u,0.001s)
Chars 1157 - 1198 [(apply~(strictly_order_reflect...] 0.022 secs (0.02u,0.001s)
Chars 1201 - 1230 [(rewrite~mult_assoc,~mult_1_r).] 0.025 secs (0.021u,0.003s)
Chars 1233 - 1282 [(rewrite~(recip_inverse'~y),~m...] 0.019 secs (0.016u,0.003s)
Chars 1015 - 1058 [(assert~(0~<~x)~by~(transitivi...] 0.001 secs (0.001u,0.s)
Chars 1061 - 1102 [(apply~(strictly_order_reflect...] 0.001 secs (0.001u,0.s)
Chars 1105 - 1133 [(rewrite~(recip_inverse'~x)).] 0.001 secs (0.001u,0.s)
Chars 1136 - 1154 [(rewrite~mult_comm).] 0.001 secs (0.u,0.s)
Chars 1157 - 1198 [(apply~(strictly_order_reflect...] 0.001 secs (0.001u,0.s)
Chars 1201 - 1230 [(rewrite~mult_assoc,~mult_1_r).] 0.001 secs (0.001u,0.s)
Chars 1233 - 1282 [(rewrite~(recip_inverse'~y),~m...] 0.001 secs (0.001u,0.s)
Chars 1283 - 1287 [Qed.] 0.006 secs (0.006u,0.s)
Chars 1289 - 1474 [Lemma~flip_lt_recip_l~x~y~(Py~...] 0.018 secs (0.016u,0.001s)
Chars 1475 - 1481 [Proof.] 0. secs (0.u,0.s)
Chars 1548 - 1563 [(unfold~int_abs).] 40.169 secs (0.u,0.034s)
Chars 1564 - 1610 [(destruct~(int_abs_sig~Z~N~x)~...] 0.027 secs (0.023u,0.003s)
Chars 1611 - 1612 [-] 0. secs (0.u,0.s)
Chars 1613 - 1618 [left.] 0.002 secs (0.002u,0.s)
Chars 1619 - 1631 [(rewrite~<-~E).] 0.002 secs (0.002u,0.s)
Chars 1632 - 1638 [split.] 0.002 secs (0.002u,0.s)
Chars 1641 - 1642 [+] 0. secs (0.u,0.s)
Chars 1643 - 1678 [(eapply~@to_semiring_nonneg;~a...] 0.036 secs (0.032u,0.003s)
Chars 1681 - 1682 [+] 0. secs (0.u,0.s)
Chars 1683 - 1727 [(apply~(naturals.to_semiring_u...] 0.037 secs (0.029u,0.007s)
Chars 1728 - 1729 [-] 0. secs (0.u,0.s)
Chars 1730 - 1736 [right.] 0.002 secs (0.001u,0.001s)
Chars 1737 - 1743 [split.] 0.002 secs (0.002u,0.s)
Chars 1746 - 1747 [+] 0. secs (0.u,0.s)
Chars 1748 - 1773 [(apply~flip_nonpos_negate).] 0.028 secs (0.025u,0.002s)
Chars 1774 - 1786 [(rewrite~<-~E).] 0.002 secs (0.002u,0.s)
Chars 1787 - 1822 [(eapply~@to_semiring_nonneg;~a...] 0.037 secs (0.032u,0.004s)
Chars 1825 - 1826 [+] 0. secs (0.u,0.s)
Chars 1827 - 1839 [(rewrite~<-~E).] 0.002 secs (0.002u,0.s)
Chars 1840 - 1884 [(apply~(naturals.to_semiring_u...] 0.023 secs (0.015u,0.007s)
Chars 1548 - 1563 [(unfold~int_abs).] 0.001 secs (0.001u,0.s)
Chars 1564 - 1610 [(destruct~(int_abs_sig~Z~N~x)~...] 0.001 secs (0.001u,0.s)
Chars 1613 - 1618 [left.] 0.001 secs (0.001u,0.s)
Chars 1619 - 1631 [(rewrite~<-~E).] 0.001 secs (0.001u,0.s)
Chars 1632 - 1638 [split.] 0.001 secs (0.001u,0.s)
Chars 1643 - 1678 [(eapply~@to_semiring_nonneg;~a...] 0.009 secs (0.006u,0.002s)
Chars 1683 - 1727 [(apply~(naturals.to_semiring_u...] 0.001 secs (0.u,0.s)
Chars 1730 - 1736 [right.] 0.001 secs (0.u,0.001s)
Chars 1737 - 1743 [split.] 0.001 secs (0.u,0.s)
Chars 1748 - 1773 [(apply~flip_nonpos_negate).] 0.001 secs (0.001u,0.s)
Chars 1774 - 1786 [(rewrite~<-~E).] 0.001 secs (0.001u,0.s)
Chars 1787 - 1822 [(eapply~@to_semiring_nonneg;~a...] 0.009 secs (0.008u,0.s)
Chars 1827 - 1839 [(rewrite~<-~E).] 0.001 secs (0.001u,0.s)
Chars 1840 - 1884 [(apply~(naturals.to_semiring_u...] 0.001 secs (0.001u,0.s)
Chars 1885 - 1889 [Qed.] 0.007 secs (0.007u,0.s)
Chars 1891 - 1983 [Lemma~int_abs_sig_alt~x~:~~~si...] 0.001 secs (0.001u,0.s)
Chars 1984 - 1990 [Proof.] 0. secs (0.u,0.s)
Chars 12336 - 12354 [(destruct~rs,~p,~u).] 40.11 secs (0.006u,0.021s)
Chars 12357 - 12399 [(etransitivity;~[~~|~apply~eta...] 0.006 secs (0.005u,0.s)
Chars 12402 - 12417 [path_induction.] 0.011 secs (0.008u,0.002s)
Chars 12420 - 12432 [reflexivity.] 0.002 secs (0.001u,0.001s)
Chars 12336 - 12354 [(destruct~rs,~p,~u).] 0.001 secs (0.001u,0.s)
Chars 12357 - 12399 [(etransitivity;~[~~|~apply~eta...] 0.002 secs (0.001u,0.s)
Chars 12402 - 12417 [path_induction.] 0.001 secs (0.001u,0.s)
Chars 12420 - 12432 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 12433 - 12441 [Defined.] 0.019 secs (0.013u,0.006s)
Chars 12628 - 12882 [Definition~path_path_sigma~{A~...] 0.009 secs (0.006u,0.002s)
Chars 13505 - 13747 [Definition~transport_sigma~{A~...] 0.003 secs (0.003u,0.s)
Chars 13748 - 13754 [Proof.] 0. secs (0.u,0.s)
Chars 13757 - 13768 [(destruct~p).] 0.081 secs (0.002u,0.021s)
Chars 13770 - 13791 [(destruct~yz~as~[y~z]).] 0.002 secs (0.002u,0.s)
Chars 13792 - 13804 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 13757 - 13768 [(destruct~p).] 0. secs (0.u,0.s)
Chars 13770 - 13791 [(destruct~yz~as~[y~z]).] 0. secs (0.u,0.s)
Chars 13792 - 13804 [reflexivity.] 0.001 secs (0.u,0.s)
Chars 13805 - 13813 [Defined.] 0.001 secs (0.001u,0.s)
Chars 13904 - 14125 [Definition~transport_sigma'~{A...] 0.002 secs (0.001u,0.s)
Chars 14126 - 14132 [Proof.] 0. secs (0.u,0.s)
Chars 14135 - 14146 [(destruct~p).] 0.095 secs (0.u,0.024s)
Chars 14147 - 14159 [(destruct~yz).] 0.002 secs (0.001u,0.001s)
Chars 14160 - 14172 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 14135 - 14146 [(destruct~p).] 0. secs (0.u,0.s)
Chars 14147 - 14159 [(destruct~yz).] 0. secs (0.u,0.s)
Chars 14160 - 14172 [reflexivity.] 0. secs (0.u,0.s)
Chars 14173 - 14181 [Defined.] 0.001 secs (0.001u,0.s)
Chars 14320 - 14660 [Definition~transport_sigma_'~{...] 0.006 secs (0.005u,0.001s)
Chars 14661 - 14667 [Proof.] 0. secs (0.u,0.s)
Chars 14670 - 14681 [(destruct~p).] 0.079 secs (0.002u,0.023s)
Chars 14682 - 14694 [reflexivity.] 0.002 secs (0.001u,0.001s)
Chars 14670 - 14681 [(destruct~p).] 0.001 secs (0.u,0.001s)
Chars 14682 - 14694 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 14695 - 14703 [Defined.] 0.003 secs (0.002u,0.s)
Chars 14734 - 14899 [Definition~functor_sigma~`{P~:...] 0.002 secs (0.002u,0.s)
Chars 14901 - 15369 [Definition~ap_functor_sigma~`{...] 0.012 secs (0.009u,0.003s)
Chars 15370 - 15376 [Proof.] 0. secs (0.u,0.s)
Chars 2514 - 2549 [exists~(susp_nullgen~(acc_ngen...] 40.175 secs (0.002u,0.032s)
Chars 2552 - 2582 [(intros~A;~split;~intros~A_inO).] 0.001 secs (0.001u,0.s)
Chars 2585 - 2586 [{] 0. secs (0.u,0.s)
Chars 2587 - 2596 [(intros~i).] 0. secs (0.u,0.s)
Chars 2601 - 2698 [(apply~~~(ooextendable_compose...] 0.003 secs (0.003u,0.s)
Chars 2703 - 2751 [1:~(apply~ooextendable_equiv,~...] 0.005 secs (0.004u,0.s)
Chars 2756 - 2821 [(apply~(ooextendable_iff_funct...] 0.006 secs (0.004u,0.001s)
Chars 2828 - 2841 [(intros~[x~y]).] 0.001 secs (0.001u,0.s)
Chars 2846 - 2891 [refine~(ooextendable_postcompo...] 0.002 secs (0.u,0.001s)
Chars 2896 - 2938 [2:~(apply~inO_iff_isnull;~exac...] 0.003 secs (0.002u,0.s)
Chars 2943 - 2952 [(intros~b).] 0.001 secs (0.001u,0.s)
Chars 2957 - 2972 [(apply~dp_const).] 0.001 secs (0.001u,0.s)
Chars 2973 - 2974 [}] 0. secs (0.u,0.s)
Chars 2977 - 2978 [{] 0. secs (0.u,0.s)
Chars 2979 - 2990 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 2995 - 3030 [(apply~(inO_iff_isnull~O);~int...] 0.003 secs (0.003u,0.s)
Chars 3035 - 3056 [specialize~(A_inO~i).] 0.001 secs (0.001u,0.s)
Chars 3061 - 3148 [(assert~~~(ee~:~~~~ooExtendabl...] 0.003 secs (0.003u,0.s)
Chars 3153 - 3154 [{] 0. secs (0.u,0.s)
Chars 3155 - 3211 [refine~(cancelL_ooextendable~_...] 0.002 secs (0.002u,0.s)
Chars 3218 - 3243 [(apply~ooextendable_equiv).] 0.001 secs (0.001u,0.s)
Chars 3250 - 3276 [(apply~isequiv_contr_contr).] 0.005 secs (0.004u,0.s)
Chars 3277 - 3278 [}] 0. secs (0.u,0.s)
Chars 3283 - 3371 [(pose~proof~~~(fst~(ooextendab...] 0.005 secs (0.005u,0.s)
Chars 3376 - 3385 [(cbn~in~e).] 0.001 secs (0.001u,0.s)
Chars 3390 - 3435 [refine~(ooextendable_postcompo...] 0.002 secs (0.002u,0.s)
Chars 3440 - 3449 [(intros~b).] 0.001 secs (0.001u,0.s)
Chars 3454 - 3479 [(symmetry;~apply~dp_const).] 0.005 secs (0.004u,0.s)
Chars 3480 - 3481 [}] 0. secs (0.u,0.s)
Chars 2514 - 2549 [exists~(susp_nullgen~(acc_ngen...] 0. secs (0.u,0.s)
Chars 2552 - 2582 [(intros~A;~split;~intros~A_inO).] 0. secs (0.u,0.s)
Chars 2587 - 2596 [(intros~i).] 0. secs (0.u,0.s)
Chars 2601 - 2698 [(apply~~~(ooextendable_compose...] 0. secs (0.u,0.s)
Chars 2703 - 2751 [1:~(apply~ooextendable_equiv,~...] 0. secs (0.u,0.s)
Chars 2756 - 2821 [(apply~(ooextendable_iff_funct...] 0. secs (0.u,0.s)
Chars 2828 - 2841 [(intros~[x~y]).] 0. secs (0.u,0.s)
Chars 2846 - 2891 [refine~(ooextendable_postcompo...] 0. secs (0.u,0.s)
Chars 2896 - 2938 [2:~(apply~inO_iff_isnull;~exac...] 0. secs (0.u,0.s)
Chars 2943 - 2952 [(intros~b).] 0. secs (0.u,0.s)
Chars 2957 - 2972 [(apply~dp_const).] 0. secs (0.u,0.s)
Chars 2979 - 2990 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 2995 - 3030 [(apply~(inO_iff_isnull~O);~int...] 0. secs (0.u,0.s)
Chars 3035 - 3056 [specialize~(A_inO~i).] 0. secs (0.u,0.s)
Chars 3061 - 3148 [(assert~~~(ee~:~~~~ooExtendabl...] 0. secs (0.u,0.s)
Chars 3155 - 3211 [refine~(cancelL_ooextendable~_...] 0. secs (0.u,0.s)
Chars 3218 - 3243 [(apply~ooextendable_equiv).] 0. secs (0.u,0.s)
Chars 3250 - 3276 [(apply~isequiv_contr_contr).] 0. secs (0.u,0.s)
Chars 3283 - 3371 [(pose~proof~~~(fst~(ooextendab...] 0. secs (0.u,0.s)
Chars 3376 - 3385 [(cbn~in~e).] 0.001 secs (0.u,0.s)
Chars 3390 - 3435 [refine~(ooextendable_postcompo...] 0. secs (0.u,0.s)
Chars 3440 - 3449 [(intros~b).] 0.001 secs (0.001u,0.s)
Chars 3454 - 3479 [(symmetry;~apply~dp_const).] 0.002 secs (0.002u,0.s)
Chars 3482 - 3490 [Defined.] 0.012 secs (0.006u,0.005s)
Chars 3522 - 3592 [#[global]Instance~O_leq_SepO~~...] 0. secs (0.u,0.s)
Chars 3593 - 3599 [Proof.] 0. secs (0.u,0.s)
Chars 3602 - 3626 [(intros~A~?~x~y;~exact~_).] 0.575 secs (0.019u,0.037s)
Chars 3602 - 3626 [(intros~A~?~x~y;~exact~_).] 0. secs (0.u,0.s)
Chars 3627 - 3635 [Defined.] 0. secs (0.u,0.s)
Chars 3675 - 3809 [Definition~in_SepO_embedding~(...] 0. secs (0.u,0.s)
Chars 3810 - 3816 [Proof.] 0. secs (0.u,0.s)
     = true
     : bool
Chars 2624 - 2788 [(pose~(x0~:=~point~X);~~~pose~...] 40.205 secs (0.005u,0.042s)
Chars 2950 - 2973 [(cut~(IsConnected~0~BG)).] 0.001 secs (0.001u,0.s)
Chars 2976 - 2977 [{] 0. secs (0.u,0.s)
Chars 2978 - 3003 [exact~(Build_ooGroup~BG).] 0.001 secs (0.001u,0.s)
Chars 3004 - 3005 [}] 0. secs (0.u,0.s)
Chars 3008 - 3050 [(cut~(IsSurjection~(unit_name~...] 0.004 secs (0.003u,0.s)
Chars 3053 - 3054 [{] 0. secs (0.u,0.s)
Chars 3055 - 3100 [(intros;~refine~(conn_pointed_...] 0.005 secs (0.004u,0.s)
Chars 3101 - 3102 [}] 0. secs (0.u,0.s)
Chars 3105 - 3150 [(apply~BuildIsSurjection;~simp...] 0.006 secs (0.006u,0.s)
Chars 3153 - 3192 [(strip_truncations;~apply~tr;~...] 0.041 secs (0.034u,0.006s)
Chars 3195 - 3225 [(apply~path_sigma_hprop;~simpl).] 0.011 secs (0.009u,0.001s)
Chars 3228 - 3239 [exact~p^.] 0.001 secs (0.u,0.s)
Chars 2624 - 2788 [(pose~(x0~:=~point~X);~~~pose~...] 0. secs (0.u,0.s)
Chars 2950 - 2973 [(cut~(IsConnected~0~BG)).] 0. secs (0.u,0.s)
Chars 2978 - 3003 [exact~(Build_ooGroup~BG).] 0. secs (0.u,0.s)
Chars 3008 - 3050 [(cut~(IsSurjection~(unit_name~...] 0. secs (0.u,0.s)
Chars 3055 - 3100 [(intros;~refine~(conn_pointed_...] 0.001 secs (0.001u,0.s)
Chars 3105 - 3150 [(apply~BuildIsSurjection;~simp...] 0.002 secs (0.002u,0.s)
Chars 3153 - 3192 [(strip_truncations;~apply~tr;~...] 0.003 secs (0.003u,0.s)
Chars 3195 - 3225 [(apply~path_sigma_hprop;~simpl).] 0.002 secs (0.002u,0.s)
Chars 3228 - 3239 [exact~p^.] 0. secs (0.u,0.s)
Chars 3240 - 3248 [Defined.] 0.006 secs (0.006u,0.s)
Chars 3398 - 3463 [Definition~loops_group~(X~:~pT...] 0. secs (0.u,0.s)
Chars 3464 - 3470 [Proof.] 0. secs (0.u,0.s)
Chars 1775 - 1871 [(intros~?;~apply~equiv_iff_hpr...] 40.182 secs (0.003u,0.035s)
Chars 1775 - 1871 [(intros~?;~apply~equiv_iff_hpr...] 0. secs (0.u,0.s)
Chars 1872 - 1880 [Defined.] 0. secs (0.u,0.s)
Chars 1882 - 1996 [Definition~fcard_equiv~{X}~{Y}...] 0.001 secs (0.u,0.s)
Chars 1997 - 2003 [Proof.] 0. secs (0.u,0.s)
     = false
     : bool
     = true
     : bool
Chars 4715 - 4827 [(exists~(fun~_~:~Unit~=>~m);~s...] 40.063 secs (0.019u,0.025s)
Chars 4715 - 4827 [(exists~(fun~_~:~Unit~=>~m);~s...] 0.004 secs (0.003u,0.001s)
Chars 4832 - 4840 [Defined.] 0.005 secs (0.003u,0.002s)
Chars 4846 - 4871 [Variable~(F~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 4876 - 4891 [Variable~(a~:~D).] 0. secs (0.u,0.s)
Chars 4897 - 4911 [Section~slice.] 0. secs (0.u,0.s)
Chars 4918 - 5249 [Definition~slice_category_indu...] 0.012 secs (0.011u,0.s)
Chars 5257 - 5359 [Definition~slice_category_nt_i...] 0.001 secs (0.001u,0.s)
Chars 5366 - 5474 [Definition~slice_category_morp...] 0.001 secs (0.001u,0.s)
Chars 5479 - 5489 [End~slice.] 0. secs (0.u,0.s)
Chars 5495 - 5511 [Section~coslice.] 0. secs (0.u,0.s)
Chars 1945 - 1968 [(intros~[a~Ea]~[b~Eb]~E).] 40.157 secs (0.003u,0.041s)
Chars 1969 - 1989 [(change~(a~=~b)~in~E).] 0.001 secs (0.001u,0.s)
Chars 5518 - 5851 [Definition~coslice_category_in...] 0.011 secs (0.01u,0.001s)
Chars 5859 - 5965 [Definition~coslice_category_nt...] 0.001 secs (0.u,0.001s)
Chars 5972 - 6084 [Definition~coslice_category_mo...] 0.001 secs (0.001u,0.s)
Chars 6089 - 6101 [End~coslice.] 0. secs (0.u,0.s)
Chars 1990 - 2029 [(destruct~E;~apply~ap;~apply~p...] 0.024 secs (0.021u,0.002s)
Chars 1945 - 1968 [(intros~[a~Ea]~[b~Eb]~E).] 0. secs (0.u,0.s)
Chars 6104 - 6122 [End~slice_coslice.] 0.007 secs (0.005u,0.001s)
Chars 1969 - 1989 [(change~(a~=~b)~in~E).] 0. secs (0.u,0.s)
Chars 1990 - 2029 [(destruct~E;~apply~ap;~apply~p...] 0.002 secs (0.002u,0.s)
Chars 2030 - 2034 [Qed.] 0.001 secs (0.u,0.s)
Chars 2036 - 2075 [#[global]Instance~Qpos_isset~:...] 0. secs (0.u,0.s)
Chars 2076 - 2082 [Proof.] 0. secs (0.u,0.s)
Chars 6126 - 6296 [Definition~slice_category_over...] 0.012 secs (0.009u,0.002s)
Chars 6299 - 6473 [Definition~coslice_category_ov...] 0.01 secs (0.007u,0.003s)
Chars 6474 - 6509 [End~slice_category_induced_fun...] 0.015 secs (0.014u,0.s)
Chars 6577 - 6610 [Section~cat_over_induced_functor.] 0. secs (0.u,0.s)
Chars 6613 - 6641 [#[local]Open~Scope~type_scope.] 0. secs (0.u,0.s)
Chars 6645 - 6663 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 6666 - 6699 [Variable~(P~:~PreCategory~->~T...] 0. secs (0.u,0.s)
Chars 6702 - 6765 [Context~`{H0~:~forall~C~D,~P~C...] 0.001 secs (0.001u,0.s)
Chars 6769 - 6813 [#[local]Notation~cat~:=~(@sub_...] 0. secs (0.u,0.s)
Chars 6817 - 6969 [Definition~cat_over_induced_fu...] 0.011 secs (0.007u,0.004s)
Chars 6973 - 7127 [Definition~over_cat_induced_fu...] 0.005 secs (0.001u,0.003s)
Chars 7128 - 7157 [End~cat_over_induced_functor.] 0.003 secs (0.002u,0.s)
     = true
     : bool
Chars 876 - 900 [rapply~isconnected_susp.] 40.301 secs (0.039u,0.057s)
Chars 905 - 934 [rapply~contr_inhabited_hprop.] 0.047 secs (0.033u,0.013s)
Chars 939 - 965 [(apply~tr;~exact~(point~_)).] 0.003 secs (0.003u,0.s)
Chars 876 - 900 [rapply~isconnected_susp.] 0. secs (0.u,0.s)
Chars 905 - 934 [rapply~contr_inhabited_hprop.] 0. secs (0.u,0.s)
Chars 939 - 965 [(apply~tr;~exact~(point~_)).] 0. secs (0.u,0.s)
Chars 968 - 976 [Defined.] 0. secs (0.u,0.s)
Chars 1102 - 1224 [Lemma~natequiv_pi1bouquet_rec~...] 0.024 secs (0.023u,0.001s)
Chars 1227 - 1233 [Proof.] 0. secs (0.u,0.s)
Chars 2653 - 2678 [(induction~n~as~[|~n~IHn]).] 40.076 secs (0.001u,0.036s)
Chars 2681 - 2682 [-] 0. secs (0.u,0.s)
Chars 2683 - 2690 [(elim~k).] 0. secs (0.u,0.s)
Chars 2693 - 2694 [-] 0. secs (0.u,0.s)
Chars 2695 - 2718 [(destruct~k~as~[k|~[]]).] 0.001 secs (0.001u,0.s)
Chars 2723 - 2724 [+] 0. secs (0.u,0.s)
Chars 2725 - 2750 [(apply~(@leq_trans~_~n~_)).] 0.001 secs (0.u,0.001s)
Chars 2757 - 2758 [*] 0. secs (0.u,0.s)
Chars 2759 - 2769 [(apply~IHn).] 0. secs (0.u,0.s)
Chars 2776 - 2777 [*] 0. secs (0.u,0.s)
Chars 2778 - 2793 [by~apply~leq_S.] 0. secs (0.u,0.s)
Chars 2798 - 2799 [+] 0. secs (0.u,0.s)
Chars 2800 - 2815 [(apply~leq_refl).] 0. secs (0.u,0.s)
Chars 2653 - 2678 [(induction~n~as~[|~n~IHn]).] 0. secs (0.u,0.s)
Chars 2683 - 2690 [(elim~k).] 0. secs (0.u,0.s)
Chars 2695 - 2718 [(destruct~k~as~[k|~[]]).] 0. secs (0.u,0.s)
Chars 2725 - 2750 [(apply~(@leq_trans~_~n~_)).] 0. secs (0.u,0.s)
Chars 2759 - 2769 [(apply~IHn).] 0. secs (0.u,0.s)
Chars 2778 - 2793 [by~apply~leq_S.] 0. secs (0.u,0.s)
Chars 2800 - 2815 [(apply~leq_refl).] 0. secs (0.u,0.s)
Chars 2816 - 2824 [Defined.] 0.001 secs (0.u,0.s)
Chars 2826 - 2935 [#[universes(polymorphic=no)]~D...] 0.002 secs (0.001u,0.s)
Chars 2937 - 3229 [#[universes(polymorphic=no)]~F...] 0.004 secs (0.004u,0.s)
Chars 3231 - 3344 [Lemma~path_fin_to_finnat_fsucc...] 0. secs (0.u,0.s)
Chars 3345 - 3351 [Proof.] 0. secs (0.u,0.s)
Chars 1306 - 1323 [srapply~Susp_rec.] 40.245 secs (0.002u,0.051s)
Chars 1328 - 1360 [1:~refine~(Build_TruncType~_~X).] 0.003 secs (0.002u,0.s)
Chars 1365 - 1397 [1:~refine~(Build_TruncType~_~X).] 0.002 secs (0.002u,0.s)
Chars 1402 - 1410 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 1415 - 1436 [(apply~path_trunctype).] 0.001 secs (0.001u,0.s)
Chars 1441 - 1472 [(apply~(equiv_hspace_left_op~x)).] 0.002 secs (0.002u,0.s)
Chars 1306 - 1323 [srapply~Susp_rec.] 0. secs (0.u,0.s)
Chars 1328 - 1360 [1:~refine~(Build_TruncType~_~X).] 0. secs (0.u,0.s)
Chars 1365 - 1397 [1:~refine~(Build_TruncType~_~X).] 0. secs (0.u,0.s)
Chars 1402 - 1410 [intro~x.] 0. secs (0.u,0.s)
Chars 1415 - 1436 [(apply~path_trunctype).] 0. secs (0.u,0.s)
Chars 1441 - 1472 [(apply~(equiv_hspace_left_op~x)).] 0. secs (0.u,0.s)
Chars 1475 - 1483 [Defined.] 0. secs (0.u,0.s)
Chars 1487 - 1572 [#[local]~Definition~transport_...] 0.004 secs (0.003u,0.s)
Chars 1575 - 1581 [Proof.] 0. secs (0.u,0.s)
Chars 5987 - 6032 [(pose~proof~(A~:~AdjunctionCou...] 32.462 secs (23.741u,0.233s)
Chars 2083 - 2143 [(apply~(@HSet.ishset_hrel_subp...] 15.833 secs (1.234u,-0.108s)
Chars 5987 - 6032 [(pose~proof~(A~:~AdjunctionCou...] 40.049 secs (0.002u,0.021s)
Chars 6039 - 6155 [refine~~(((idtoiso~(C:=_~->~_)...] 0.006 secs (0.006u,0.s)
Chars 6162 - 6261 [refine~~(NaturalTransformation...] 0.003 secs (0.003u,0.s)
Chars 6268 - 6556 [refine~~(_~~~o~(((idtoiso~(C:=...] 0.009 secs (0.009u,0.s)
Chars 6563 - 6620 [refine~(NaturalTransformation....] 0.002 secs (0.002u,0.s)
Chars 6627 - 6715 [exact~~(NaturalTransformation....] 0.001 secs (0.u,0.s)
Chars 5987 - 6032 [(pose~proof~(A~:~AdjunctionCou...] 0. secs (0.u,0.s)
Chars 6039 - 6155 [refine~~(((idtoiso~(C:=_~->~_)...] 0. secs (0.u,0.s)
Chars 6162 - 6261 [refine~~(NaturalTransformation...] 0. secs (0.u,0.s)
Chars 6268 - 6556 [refine~~(_~~~o~(((idtoiso~(C:=...] 0. secs (0.u,0.s)
Chars 6563 - 6620 [refine~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 6627 - 6715 [exact~~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 6720 - 6728 [Defined.] 0.004 secs (0.004u,0.s)
Chars 6734 - 6780 [Create~HintDb~adjoint_pointwis...] 0. secs (0.u,0.s)
Chars 6785 - 7001 [Hint~Rewrite~~identity_of~left...] 0.002 secs (0.u,0.001s)
Chars 7007 - 7085 [Definition~pointwise_r~:~point...] 0.002 secs (0.001u,0.s)
Chars 7090 - 7096 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 8432 - 8443 [(intros~E~g).] 40.155 secs (0.001u,0.028s)
Chars 8448 - 8480 [(pose~(e~:=~Build_Equiv~_~_~_~...] 0.001 secs (0.001u,0.s)
Chars 8485 - 8501 [exists~(e^-1~g).] 0.003 secs (0.002u,0.001s)
Chars 8506 - 8518 [(apply~apD10).] 0.001 secs (0.001u,0.s)
Chars 8523 - 8543 [exact~(eisretr~e~g).] 0.001 secs (0.001u,0.s)
Chars 8432 - 8443 [(intros~E~g).] 0. secs (0.u,0.s)
Chars 8448 - 8480 [(pose~(e~:=~Build_Equiv~_~_~_~...] 0. secs (0.u,0.s)
Chars 8485 - 8501 [exists~(e^-1~g).] 0. secs (0.u,0.s)
Chars 8506 - 8518 [(apply~apD10).] 0. secs (0.u,0.s)
Chars 8523 - 8543 [exact~(eisretr~e~g).] 0. secs (0.u,0.s)
Chars 8546 - 8554 [Defined.] 0. secs (0.u,0.s)
Chars 8725 - 8919 [Definition~extendable_postcomp...] 0.001 secs (0.u,0.s)
Chars 8922 - 8928 [Proof.] 0. secs (0.u,0.s)
Chars 2546 - 2568 [srapply~Build_pEquiv'.] 40.169 secs (0.u,0.036s)
Chars 2571 - 2594 [1:~(apply~equiv_path_Tr).] 0.002 secs (0.001u,0.s)
Chars 2597 - 2609 [reflexivity.] 0.002 secs (0.001u,0.s)
Chars 2546 - 2568 [srapply~Build_pEquiv'.] 0. secs (0.u,0.s)
Chars 2571 - 2594 [1:~(apply~equiv_path_Tr).] 0. secs (0.u,0.s)
Chars 2597 - 2609 [reflexivity.] 0. secs (0.u,0.s)
Chars 2610 - 2618 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2620 - 2790 [Definition~ptr_iterated_loops~...] 0. secs (0.u,0.s)
Chars 2791 - 2797 [Proof.] 0. secs (0.u,0.s)
Chars 9818 - 9845 [refine~(cu_rot_tb_fb~oE~_).] 40.155 secs (0.003u,0.029s)
Chars 9848 - 9875 [refine~(cu_rot_tb_fb~oE~_).] 0.003 secs (0.002u,0.s)
Chars 9878 - 9910 [refine~(cu_ccGGGG~_~_~_~_~oE~_).] 0.004 secs (0.004u,0.s)
Chars 9913 - 9938 [1,~2:~exact~sq_tr_refl_v^.] 0.003 secs (0.002u,0.s)
Chars 9941 - 9968 [1,~2:~exact~(eisretr~tr~_)^.] 0.057 secs (0.049u,0.007s)
Chars 9971 - 10002 [refine~(_~oE~equiv_ap'~tr~_~_).] 0.003 secs (0.003u,0.s)
Chars 10005 - 10024 [(apply~equiv_cu_G11).] 0.002 secs (0.001u,0.001s)
Chars 9818 - 9845 [refine~(cu_rot_tb_fb~oE~_).] 0. secs (0.u,0.s)
Chars 9848 - 9875 [refine~(cu_rot_tb_fb~oE~_).] 0.001 secs (0.001u,0.s)
Chars 9878 - 9910 [refine~(cu_ccGGGG~_~_~_~_~oE~_).] 0.001 secs (0.001u,0.s)
Chars 9913 - 9938 [1,~2:~exact~sq_tr_refl_v^.] 0.001 secs (0.001u,0.s)
Chars 9941 - 9968 [1,~2:~exact~(eisretr~tr~_)^.] 0.001 secs (0.001u,0.s)
Chars 9971 - 10002 [refine~(_~oE~equiv_ap'~tr~_~_).] 0. secs (0.u,0.s)
Chars 10005 - 10024 [(apply~equiv_cu_G11).] 0. secs (0.u,0.s)
Chars 10025 - 10033 [Defined.] 0.012 secs (0.011u,0.001s)
Chars 10082 - 10287 [Definition~equiv_cu_11G~{A}~{a...] 0.005 secs (0.005u,0.s)
Chars 10288 - 10294 [Proof.] 0. secs (0.u,0.s)
Chars 1484 - 1523 [(set~(apy0~:=~positive_apart_z...] 40.194 secs (0.009u,0.033s)
Chars 1526 - 1564 [(set~(eq~:=~recip_involutive~(...] 0.011 secs (0.01u,0.s)
Chars 1567 - 1590 [(set~(eq'~:=~ap~pr1~eq)).] 0.004 secs (0.003u,0.s)
Chars 1593 - 1604 [(cbn~in~eq').] 0.003 secs (0.003u,0.s)
Chars 1607 - 1622 [(rewrite~<-~eq').] 0.004 secs (0.004u,0.s)
Chars 1625 - 1647 [(unfold~recip_on_apart).] 0.003 secs (0.002u,0.s)
Chars 1741 - 1761 [(set~(ltyx2~:=~ltyx)).] 0.005 secs (0.005u,0.s)
Chars 1764 - 1777 [(unfold~ltyx2).] 0.003 secs (0.003u,0.s)
Chars 1780 - 1850 [(rewrite~(recip_irrelevant~y~(...] 0.01 secs (0.01u,0.s)
Chars 1853 - 1935 [(set~~~(ltyx_recips~:=~~~~flip...] 0.007 secs (0.007u,0.s)
Chars 1938 - 1957 [(cbn~in~ltyx_recips).] 0.005 secs (0.005u,0.s)
Chars 1960 - 2074 [(rewrite~~~(recip_irrelevant~x...] 0.047 secs (0.04u,0.006s)
Chars 2077 - 2081 [(cbn).] 0.004 secs (0.004u,0.s)
Chars 2084 - 2162 [(rewrite~(recip_irrelevant~(//...] 0.018 secs (0.018u,0.s)
Chars 2165 - 2176 [assumption.] 0.004 secs (0.003u,0.s)
Chars 1484 - 1523 [(set~(apy0~:=~positive_apart_z...] 0.002 secs (0.002u,0.s)
Chars 1526 - 1564 [(set~(eq~:=~recip_involutive~(...] 0.002 secs (0.002u,0.s)
Chars 1567 - 1590 [(set~(eq'~:=~ap~pr1~eq)).] 0.002 secs (0.002u,0.s)
Chars 1593 - 1604 [(cbn~in~eq').] 0.002 secs (0.002u,0.s)
Chars 1607 - 1622 [(rewrite~<-~eq').] 0.002 secs (0.002u,0.s)
Chars 1625 - 1647 [(unfold~recip_on_apart).] 0.002 secs (0.002u,0.s)
Chars 1741 - 1761 [(set~(ltyx2~:=~ltyx)).] 0.003 secs (0.003u,0.s)
Chars 1764 - 1777 [(unfold~ltyx2).] 0.002 secs (0.002u,0.s)
Chars 1780 - 1850 [(rewrite~(recip_irrelevant~y~(...] 0.003 secs (0.002u,0.001s)
Chars 1853 - 1935 [(set~~~(ltyx_recips~:=~~~~flip...] 0.002 secs (0.002u,0.s)
Chars 1938 - 1957 [(cbn~in~ltyx_recips).] 0.004 secs (0.004u,0.s)
Chars 1960 - 2074 [(rewrite~~~(recip_irrelevant~x...] 0.003 secs (0.003u,0.s)
Chars 2077 - 2081 [(cbn).] 0.003 secs (0.003u,0.s)
Chars 2084 - 2162 [(rewrite~(recip_irrelevant~(//...] 0.003 secs (0.003u,0.s)
Chars 2165 - 2176 [assumption.] 0.003 secs (0.003u,0.s)
Chars 2177 - 2181 [Qed.] 0.016 secs (0.015u,0.s)
Chars 2182 - 2323 [Lemma~flip_lt_recip_r~(x~y~:~F...] 0.01 secs (0.009u,0.001s)
Chars 2324 - 2330 [Proof.] 0. secs (0.u,0.s)
Chars 1991 - 2039 [(destruct~(int_abs_spec~x)~as~...] 40.19 secs (0.014u,0.038s)
Chars 1991 - 2039 [(destruct~(int_abs_spec~x)~as~...] 0.003 secs (0.003u,0.s)
Chars 2040 - 2044 [Qed.] 0.003 secs (0.003u,0.s)
Chars 2046 - 2092 [Lemma~int_abs_nat~n~:~int_abs~...] 0.048 secs (0.043u,0.005s)
Chars 2093 - 2099 [Proof.] 0. secs (0.u,0.s)
Chars 3354 - 3377 [(apply~path_sigma_hprop).] 25.563 secs (15.225u,-0.108s)
Chars 15379 - 15439 [(destruct~u~as~[u1~u2];~destru...] 40.128 secs (0.017u,0.023s)
Chars 15442 - 15465 [(destruct~p;~simpl~in~q).] 0.046 secs (0.039u,0.006s)
Chars 15468 - 15479 [(destruct~q).] 0.01 secs (0.009u,0.001s)
Chars 15482 - 15494 [reflexivity.] 0.005 secs (0.005u,0.s)
Chars 15379 - 15439 [(destruct~u~as~[u1~u2];~destru...] 0.008 secs (0.006u,0.001s)
Chars 15442 - 15465 [(destruct~p;~simpl~in~q).] 0.005 secs (0.004u,0.s)
Chars 15468 - 15479 [(destruct~q).] 0.002 secs (0.002u,0.s)
Chars 15482 - 15494 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 15495 - 15503 [Defined.] 0.017 secs (0.015u,0.002s)
Chars 15529 - 15708 [#[global]~Instance~isequiv_fun...] 0.002 secs (0.001u,0.s)
Chars 15709 - 15715 [Proof.] 0. secs (0.u,0.s)
Chars 3819 - 3830 [(intros~x~y).] 40.169 secs (0.u,0.033s)
Chars 3833 - 3891 [refine~(inO_equiv_inO'~_~(equi...] 0.003 secs (0.001u,0.001s)
Chars 3819 - 3830 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 3833 - 3891 [refine~(inO_equiv_inO'~_~(equi...] 0. secs (0.u,0.s)
Chars 3892 - 3900 [Defined.] 0. secs (0.u,0.s)
Chars 4027 - 4173 [Corollary~istrunc_embedding_tr...] 0. secs (0.u,0.s)
Chars 4174 - 4180 [Proof.] 0. secs (0.u,0.s)
Finished failing transaction in 18.38 secs (9.812u,0.031s) (failure)
Chars 7103 - 8388 [Time~(exists~unit_r~counit_r;~...] 18.38 secs (9.812u,0.031s)
Chars 15718 - 15934 [(refine~~~(isequiv_adjointify~...] 5.592 secs (3.537u,-0.326s)
Chars 3473 - 3498 [(unfold~loops,~group_type).] 40.176 secs (0.u,0.042s)
Chars 3499 - 3505 [(simpl).] 0.002 secs (0.001u,0.s)
Chars 3508 - 3573 [exact~(equiv_path_sigma_hprop~...] 0.01 secs (0.01u,0.s)
Chars 3473 - 3498 [(unfold~loops,~group_type).] 0. secs (0.u,0.s)
Chars 3499 - 3505 [(simpl).] 0. secs (0.u,0.s)
Chars 3508 - 3573 [exact~(equiv_path_sigma_hprop~...] 0. secs (0.u,0.s)
Chars 3574 - 3582 [Defined.] 0.002 secs (0.001u,0.s)
Chars 3632 - 3687 [Definition~ooGroupHom~(G~H~:~o...] 0. secs (0.u,0.s)
Chars 3689 - 3771 [Definition~grouphom_fun~{G}~{H...] 0.004 secs (0.004u,0.s)
Chars 3773 - 3821 [Coercion~grouphom_fun~:~ooGrou...] 0. secs (0.u,0.s)
Chars 3893 - 4008 [Definition~group_loops_functor...] 0.001 secs (0.001u,0.s)
Chars 4009 - 4015 [Proof.] 0. secs (0.u,0.s)
Chars 2006 - 2051 [transitivity~(@fcard~Y~(finite...] 40.184 secs (0.002u,0.035s)
Chars 2054 - 2055 [-] 0. secs (0.u,0.s)
Chars 2056 - 2068 [reflexivity.] 0. secs (0.u,0.s)
Chars 2071 - 2072 [-] 0. secs (0.u,0.s)
Chars 2073 - 2114 [exact~(ap~(@fcard~Y)~(path_ish...] 0.002 secs (0.001u,0.s)
Chars 2006 - 2051 [transitivity~(@fcard~Y~(finite...] 0. secs (0.u,0.s)
Chars 2056 - 2068 [reflexivity.] 0. secs (0.u,0.s)
Chars 2073 - 2114 [exact~(ap~(@fcard~Y)~(path_ish...] 0. secs (0.u,0.s)
Chars 2115 - 2123 [Defined.] 0. secs (0.u,0.s)
Chars 2125 - 2243 [Definition~fcard_equiv'~{X}~{Y...] 0.004 secs (0.003u,0.s)
Chars 2327 - 2416 [#[global]~Instance~finite_fin~...] 0.001 secs (0.001u,0.s)
Chars 2454 - 2516 [#[global]Instance~finite_empty...] 0. secs (0.u,0.s)
Chars 2584 - 2626 [#[global]Instance~finite_unit~...] 0. secs (0.u,0.s)
Chars 2627 - 2633 [Proof.] 0. secs (0.u,0.s)
Chars 2083 - 2143 [(apply~(@HSet.ishset_hrel_subp...] 40.093 secs (0.002u,0.042s)
Chars 2144 - 2145 [-] 0. secs (0.u,0.s)
Chars 2146 - 2168 [(intros~e;~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 2169 - 2170 [-] 0. secs (0.u,0.s)
Chars 2171 - 2179 [(apply~_).] 0.167 secs (0.131u,0.035s)
Chars 2180 - 2181 [-] 0. secs (0.u,0.s)
Chars 2182 - 2195 [exact~pos_eq.] 0.001 secs (0.001u,0.s)
Chars 2083 - 2143 [(apply~(@HSet.ishset_hrel_subp...] 0. secs (0.u,0.s)
Chars 2146 - 2168 [(intros~e;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 2171 - 2179 [(apply~_).] 0. secs (0.u,0.s)
Chars 2182 - 2195 [exact~pos_eq.] 0. secs (0.u,0.s)
Chars 2196 - 2200 [Qed.] 0. secs (0.u,0.s)
Chars 2202 - 2239 [#[global]Instance~Qpos_one@{}~...] 0. secs (0.u,0.s)
Chars 2240 - 2246 [Proof.] 0. secs (0.u,0.s)
Chars 1258 - 1289 [nrefine~(natequiv_compose~_~_).] 40.254 secs (0.003u,0.055s)
Chars 1294 - 1362 [1:~refine~(natequiv_prewhisker...] 0.009 secs (0.008u,0.001s)
Chars 1416 - 1447 [nrefine~(natequiv_compose~_~_).] 0.003 secs (0.002u,0.s)
Chars 1448 - 1526 [1:~rapply~(natequiv_postwhiske...] 0.008 secs (0.006u,0.002s)
Chars 1560 - 1591 [nrefine~(natequiv_compose~_~_).] 0.003 secs (0.003u,0.s)
Chars 1596 - 1680 [1:~refine~(natequiv_prewhisker...] 0.008 secs (0.006u,0.001s)
Chars 1714 - 1745 [rapply~natequiv_bg_pi1_adjoint.] 0.011 secs (0.01u,0.s)
Chars 1258 - 1289 [nrefine~(natequiv_compose~_~_).] 0. secs (0.u,0.s)
Chars 1294 - 1362 [1:~refine~(natequiv_prewhisker...] 0. secs (0.u,0.s)
Chars 1416 - 1447 [nrefine~(natequiv_compose~_~_).] 0. secs (0.u,0.s)
Chars 1448 - 1526 [1:~rapply~(natequiv_postwhiske...] 0. secs (0.u,0.s)
Chars 1560 - 1591 [nrefine~(natequiv_compose~_~_).] 0. secs (0.u,0.s)
Chars 1596 - 1680 [1:~refine~(natequiv_prewhisker...] 0. secs (0.u,0.s)
Chars 1714 - 1745 [rapply~natequiv_bg_pi1_adjoint.] 0. secs (0.u,0.s)
Chars 1748 - 1756 [Defined.] 0.008 secs (0.006u,0.001s)
Chars 1826 - 1863 [#[local]Opaque~natequiv_pi1bou...] 0. secs (0.u,0.s)
Chars 1867 - 1963 [Theorem~equiv_pi1bouquet_rec~(...] 0.001 secs (0.001u,0.s)
Chars 1966 - 1972 [Proof.] 0. secs (0.u,0.s)
Chars 3354 - 3377 [(apply~path_sigma_hprop).] 40.074 secs (0.004u,0.036s)
Chars 3380 - 3401 [(apply~path_nat_fsucc).] 0.001 secs (0.001u,0.s)
Chars 3354 - 3377 [(apply~path_sigma_hprop).] 0. secs (0.u,0.s)
Chars 3380 - 3401 [(apply~path_nat_fsucc).] 0. secs (0.u,0.s)
Chars 3402 - 3410 [Defined.] 0.001 secs (0.001u,0.s)
Chars 3412 - 3504 [Lemma~path_fin_to_finnat_fin_z...] 0. secs (0.u,0.s)
Chars 3505 - 3511 [Proof.] 0. secs (0.u,0.s)
Chars 3514 - 3537 [(apply~path_sigma_hprop).] 0.328 secs (0.004u,0.037s)
Chars 3540 - 3564 [(apply~path_nat_fin_zero).] 0. secs (0.u,0.s)
Chars 3514 - 3537 [(apply~path_sigma_hprop).] 0. secs (0.u,0.s)
Chars 3540 - 3564 [(apply~path_nat_fin_zero).] 0. secs (0.u,0.s)
Chars 3565 - 3573 [Defined.] 0. secs (0.u,0.s)
Chars 3575 - 3694 [Lemma~path_fin_to_finnat_fin_i...] 0. secs (0.u,0.s)
Chars 3695 - 3701 [Proof.] 0. secs (0.u,0.s)
Chars 1586 - 1599 [(unfold~codes).] 40.225 secs (0.001u,0.05s)
Chars 1604 - 1631 [(rewrite~transport_idmap_ap).] 0.039 secs (0.031u,0.007s)
Chars 1636 - 1655 [(rewrite~ap_compose).] 0.009 secs (0.009u,0.s)
Chars 1660 - 1688 [(rewrite~Susp_rec_beta_merid).] 0.012 secs (0.011u,0.s)
Chars 1693 - 1714 [(rewrite~ap_trunctype).] 0.011 secs (0.011u,0.s)
Chars 1719 - 1764 [by~rewrite~transport_path_univ...] 0.01 secs (0.007u,0.002s)
Chars 1586 - 1599 [(unfold~codes).] 0.001 secs (0.001u,0.s)
Chars 1604 - 1631 [(rewrite~transport_idmap_ap).] 0.001 secs (0.001u,0.s)
Chars 1636 - 1655 [(rewrite~ap_compose).] 0.002 secs (0.002u,0.s)
Chars 1660 - 1688 [(rewrite~Susp_rec_beta_merid).] 0.002 secs (0.002u,0.s)
Chars 1693 - 1714 [(rewrite~ap_trunctype).] 0.002 secs (0.002u,0.s)
Chars 1719 - 1764 [by~rewrite~transport_path_univ...] 0.002 secs (0.002u,0.s)
Chars 1767 - 1775 [Defined.] 0.027 secs (0.025u,0.001s)
Chars 1779 - 1868 [#[local]~Definition~transport_...] 0.004 secs (0.002u,0.001s)
Chars 1871 - 1877 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 3704 - 3716 [reflexivity.] 1.42 secs (0.001u,0.035s)
Chars 3704 - 3716 [reflexivity.] 0. secs (0.u,0.s)
Chars 3717 - 3725 [Defined.] 0. secs (0.u,0.s)
Chars 3727 - 3819 [Lemma~path_fin_to_finnat_fin_l...] 0. secs (0.u,0.s)
Chars 3820 - 3826 [Proof.] 0. secs (0.u,0.s)
Chars 3829 - 3841 [reflexivity.] 0.108 secs (0.u,0.036s)
Chars 3829 - 3841 [reflexivity.] 0. secs (0.u,0.s)
Chars 3842 - 3850 [Defined.] 0. secs (0.u,0.s)
Chars 3852 - 3967 [Lemma~path_finnat_to_fin_succ~...] 0. secs (0.u,0.s)
Chars 3968 - 3974 [Proof.] 0. secs (0.u,0.s)
Chars 8933 - 8966 [(generalize~dependent~C;~rever...] 40.153 secs (0.001u,0.028s)
Chars 8971 - 9016 [(simple_induction~n~n~IH;~intr...] 0.004 secs (0.004u,0.s)
Chars 9021 - 9035 [1:~(apply~idmap).] 0. secs (0.u,0.s)
Chars 9040 - 9066 [refine~(functor_prod~_~_).] 0.001 secs (0.001u,0.s)
Chars 9071 - 9072 [-] 0. secs (0.u,0.s)
Chars 9073 - 9214 [(refine~(functor_forall~(funct...] 0.006 secs (0.004u,0.001s)
Chars 9221 - 9281 [(refine~(functor_sigma~(functo...] 0.003 secs (0.003u,0.s)
Chars 9288 - 9393 [(refine~(functor_forall~idmap~...] 0.005 secs (0.004u,0.s)
Chars 9400 - 9420 [(apply~moveR_equiv_M).] 0.001 secs (0.001u,0.s)
Chars 9425 - 9426 [-] 0. secs (0.u,0.s)
Chars 9427 - 9512 [(refine~(functor_forall~(funct...] 0.005 secs (0.004u,0.s)
Chars 9519 - 9636 [(refine~(functor_forall~(funct...] 0.007 secs (0.007u,0.s)
Chars 9643 - 9671 [(refine~(IH~_~_~_);~intros~b).] 0.002 secs (0.002u,0.s)
Chars 9678 - 9717 [(apply~equiv_inverse,~equiv_ap...] 0.003 secs (0.002u,0.s)
Chars 8933 - 8966 [(generalize~dependent~C;~rever...] 0. secs (0.u,0.s)
Chars 8971 - 9016 [(simple_induction~n~n~IH;~intr...] 0.001 secs (0.001u,0.s)
Chars 9021 - 9035 [1:~(apply~idmap).] 0. secs (0.u,0.s)
Chars 9040 - 9066 [refine~(functor_prod~_~_).] 0. secs (0.u,0.s)
Chars 9073 - 9214 [(refine~(functor_forall~(funct...] 0.001 secs (0.001u,0.s)
Chars 9221 - 9281 [(refine~(functor_sigma~(functo...] 0.001 secs (0.001u,0.s)
Chars 9288 - 9393 [(refine~(functor_forall~idmap~...] 0.038 secs (0.025u,0.013s)
Chars 9400 - 9420 [(apply~moveR_equiv_M).] 0. secs (0.u,0.s)
Chars 9427 - 9512 [(refine~(functor_forall~(funct...] 0.001 secs (0.001u,0.s)
Chars 9519 - 9636 [(refine~(functor_forall~(funct...] 0.003 secs (0.003u,0.s)
Chars 9643 - 9671 [(refine~(IH~_~_~_);~intros~b).] 0.001 secs (0.u,0.s)
Chars 9678 - 9717 [(apply~equiv_inverse,~equiv_ap...] 0.001 secs (0.001u,0.s)
Chars 9720 - 9728 [Defined.] 0.004 secs (0.004u,0.s)
Chars 9732 - 10025 [Definition~extendable_postcomp...] 0.002 secs (0.002u,0.s)
Chars 10115 - 10324 [Definition~extendable_compose~...] 0.001 secs (0.001u,0.s)
Chars 10327 - 10333 [Proof.] 0. secs (0.u,0.s)
Chars 2800 - 2811 [revert~A~n.] 40.174 secs (0.u,0.034s)
Chars 2814 - 2826 [(induction~k).] 0.001 secs (0.001u,0.s)
Chars 2829 - 2830 [{] 0. secs (0.u,0.s)
Chars 2831 - 2847 [(intros~A~n;~cbn).] 0. secs (0.u,0.s)
Chars 2852 - 2864 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 2865 - 2866 [}] 0. secs (0.u,0.s)
Chars 2869 - 2880 [(intros~A~n).] 0. secs (0.u,0.s)
Chars 2883 - 2902 [(cbn;~etransitivity).] 0.002 secs (0.002u,0.s)
Chars 2905 - 2924 [1:~(apply~ptr_loops).] 0.001 secs (0.001u,0.s)
Chars 2927 - 2947 [rapply~(emap~loops).] 0.01 secs (0.007u,0.002s)
Chars 2950 - 2960 [(apply~IHk).] 0.001 secs (0.001u,0.s)
Chars 2800 - 2811 [revert~A~n.] 0. secs (0.u,0.s)
Chars 2814 - 2826 [(induction~k).] 0. secs (0.u,0.s)
Chars 2831 - 2847 [(intros~A~n;~cbn).] 0. secs (0.u,0.s)
Chars 2852 - 2864 [reflexivity.] 0. secs (0.u,0.s)
Chars 2869 - 2880 [(intros~A~n).] 0. secs (0.u,0.s)
Chars 2883 - 2902 [(cbn;~etransitivity).] 0. secs (0.u,0.s)
Chars 2905 - 2924 [1:~(apply~ptr_loops).] 0. secs (0.u,0.s)
Chars 2927 - 2947 [rapply~(emap~loops).] 0. secs (0.u,0.s)
Chars 2950 - 2960 [(apply~IHk).] 0. secs (0.u,0.s)
Chars 2961 - 2969 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2971 - 3121 [Definition~ptr_loops_eq~`{Univ...] 0.001 secs (0.001u,0.s)
Chars 3123 - 3206 [Definition~pequiv_ptr_functor~...] 0. secs (0.u,0.s)
Chars 3207 - 3213 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 44.932 secs (4.728u,0.165s) (successful)
Chars 7103 - 8388 [Time~(exists~unit_r~counit_r;~...] 44.932 secs (4.728u,0.165s)
Finished transaction in 0.001 secs (0.001u,0.s) (successful)
Chars 7103 - 8388 [Time~(exists~unit_r~counit_r;~...] 0.001 secs (0.001u,0.s)
Chars 8406 - 8414 [Defined.] 0.197 secs (0.197u,0.s)
Chars 8417 - 8423 [End~r.] 0.015 secs (0.015u,0.s)
Chars 8424 - 8445 [End~AdjointPointwise.] 0.028 secs (0.028u,0.s)
Chars 10297 - 10324 [refine~(cu_rot_tb_fb~oE~_).] 40.15 secs (0.003u,0.029s)
Chars 10327 - 10359 [refine~(cu_ccGGGG~_~_~_~_~oE~_).] 0.004 secs (0.003u,0.001s)
Chars 10362 - 10387 [1-4:~exact~sq_tr_refl_v^.] 0.006 secs (0.005u,0.s)
Chars 10390 - 10412 [by~apply~equiv_cu_G11.] 0.002 secs (0.u,0.001s)
Chars 10297 - 10324 [refine~(cu_rot_tb_fb~oE~_).] 0. secs (0.u,0.s)
Chars 10327 - 10359 [refine~(cu_ccGGGG~_~_~_~_~oE~_).] 0.001 secs (0.001u,0.s)
Chars 10362 - 10387 [1-4:~exact~sq_tr_refl_v^.] 0.002 secs (0.002u,0.s)
Chars 10390 - 10412 [by~apply~equiv_cu_G11.] 0. secs (0.u,0.s)
Chars 10413 - 10421 [Defined.] 0.004 secs (0.003u,0.001s)
Chars 10423 - 10455 [Notation~cu_G11~:=~equiv_cu_G11.] 0. secs (0.u,0.s)
Chars 10456 - 10488 [Notation~cu_1G1~:=~equiv_cu_1G1.] 0. secs (0.u,0.s)
Chars 10489 - 10521 [Notation~cu_11G~:=~equiv_cu_11G.] 0. secs (0.u,0.s)
Chars 10562 - 10586 [Section~PathPathSquares.] 0. secs (0.u,0.s)
Chars 10590 - 10718 [Context~{A}~{x~y~:~A}~{a00~a10...] 0.001 secs (0.001u,0.s)
Chars 10722 - 10850 [Definition~equiv_cu_GG1~:~~~Pa...] 0.003 secs (0.003u,0.s)
Chars 10853 - 10859 [Proof.] 0. secs (0.u,0.s)
Chars 2333 - 2372 [(set~(apx0~:=~positive_apart_z...] 40.176 secs (0.005u,0.035s)
Chars 2375 - 2414 [(set~(apy0~:=~positive_apart_z...] 0.004 secs (0.004u,0.s)
Chars 2417 - 2458 [(change~x~with~((x;~apx0)~:~Ap...] 0.003 secs (0.003u,0.s)
Chars 2461 - 2500 [(rewrite~<-~(recip_involutive~...] 0.008 secs (0.007u,0.s)
Chars 2503 - 2530 [(unfold~recip_on_apart;~cbn).] 0.005 secs (0.005u,0.s)
Chars 2533 - 2572 [(pose~proof~(pos_recip_compat~...] 0.002 secs (0.002u,0.s)
Chars 2575 - 2644 [(rewrite~(recip_irrelevant~y~(...] 0.009 secs (0.008u,0.001s)
Chars 2647 - 2696 [(change~y~with~((y;~apy0)~:~Ap...] 0.004 secs (0.004u,0.s)
Chars 2699 - 2746 [(rewrite~<-~(recip_involutive~...] 0.009 secs (0.006u,0.002s)
Chars 2749 - 2792 [(unfold~recip_on_apart~in~ltyx...] 0.006 secs (0.006u,0.s)
Chars 2795 - 2906 [(rewrite~~~(recip_irrelevant~(...] 0.018 secs (0.012u,0.005s)
Chars 2909 - 2982 [(pose~proof~(flip_lt_recip_l~(...] 0.005 secs (0.005u,0.s)
Chars 2985 - 2997 [(cbn~in~ltxy).] 0.004 secs (0.004u,0.s)
Chars 3000 - 3165 [(rewrite~~~(recip_irrelevant~(...] 0.028 secs (0.026u,0.001s)
Chars 3168 - 3179 [assumption.] 0.002 secs (0.002u,0.s)
Chars 2333 - 2372 [(set~(apx0~:=~positive_apart_z...] 0.001 secs (0.001u,0.s)
Chars 2375 - 2414 [(set~(apy0~:=~positive_apart_z...] 0.001 secs (0.001u,0.s)
Chars 2417 - 2458 [(change~x~with~((x;~apx0)~:~Ap...] 0.001 secs (0.001u,0.s)
Chars 2461 - 2500 [(rewrite~<-~(recip_involutive~...] 0.001 secs (0.001u,0.s)
Chars 2503 - 2530 [(unfold~recip_on_apart;~cbn).] 0.004 secs (0.004u,0.s)
Chars 2533 - 2572 [(pose~proof~(pos_recip_compat~...] 0.001 secs (0.001u,0.s)
Chars 2575 - 2644 [(rewrite~(recip_irrelevant~y~(...] 0.001 secs (0.001u,0.s)
Chars 2647 - 2696 [(change~y~with~((y;~apy0)~:~Ap...] 0.001 secs (0.001u,0.s)
Chars 2699 - 2746 [(rewrite~<-~(recip_involutive~...] 0.001 secs (0.001u,0.s)
Chars 2749 - 2792 [(unfold~recip_on_apart~in~ltyx...] 0.005 secs (0.005u,0.s)
Chars 2795 - 2906 [(rewrite~~~(recip_irrelevant~(...] 0.001 secs (0.001u,0.s)
Chars 2909 - 2982 [(pose~proof~(flip_lt_recip_l~(...] 0.004 secs (0.004u,0.s)
Chars 2985 - 2997 [(cbn~in~ltxy).] 0.003 secs (0.002u,0.s)
Chars 3000 - 3165 [(rewrite~~~(recip_irrelevant~(...] 0.003 secs (0.003u,0.s)
Chars 3168 - 3179 [assumption.] 0.002 secs (0.002u,0.s)
Chars 3180 - 3184 [Qed.] 0.016 secs (0.013u,0.002s)
Chars 3186 - 3314 [Lemma~field_split2~(x~:~F)~:~~...] 0.047 secs (0.041u,0.004s)
Chars 3315 - 3321 [Proof.] 0. secs (0.u,0.s)
Chars 2100 - 2120 [(apply~(injective~f)).] 40.186 secs (0.011u,0.037s)
Chars 2121 - 2176 [(destruct~(int_abs_spec~(f~n))...] 0.012 secs (0.012u,0.s)
Chars 2177 - 2207 [(apply~naturals.negate_to_ring).] 0.031 secs (0.025u,0.005s)
Chars 2208 - 2230 [(rewrite~E,~involutive).] 0.02 secs (0.018u,0.001s)
Chars 2231 - 2239 [trivial.] 0.002 secs (0.002u,0.s)
Chars 2100 - 2120 [(apply~(injective~f)).] 0.001 secs (0.001u,0.s)
Chars 2121 - 2176 [(destruct~(int_abs_spec~(f~n))...] 0.004 secs (0.004u,0.s)
Chars 2177 - 2207 [(apply~naturals.negate_to_ring).] 0.001 secs (0.001u,0.s)
Chars 2208 - 2230 [(rewrite~E,~involutive).] 0.001 secs (0.001u,0.s)
Chars 2231 - 2239 [trivial.] 0.001 secs (0.001u,0.s)
Chars 2240 - 2244 [Qed.] 0.005 secs (0.004u,0.s)
Chars 2246 - 2300 [Lemma~int_abs_negate_nat~n~:~i...] 0.041 secs (0.034u,0.007s)
Chars 2301 - 2307 [Proof.] 0. secs (0.u,0.s)
Chars 15718 - 15934 [(refine~~~(isequiv_adjointify~...] 40.056 secs (0.01u,0.021s)
Chars 15937 - 15938 [-] 0. secs (0.u,0.s)
Chars 15939 - 15985 [(refine~(path_sigma'~_~(eisret...] 0.004 secs (0.004u,0.s)
Chars 15990 - 16076 [(abstract~(rewrite~(eisretr~(g...] 0.008 secs (0.007u,0.s)
Chars 16079 - 16080 [-] 0. secs (0.u,0.s)
Chars 16081 - 16127 [(refine~(path_sigma'~_~(eissec...] 0.004 secs (0.004u,0.s)
Chars 16132 - 16266 [refine~~((ap_transport~(eissec...] 0.007 secs (0.006u,0.s)
Chars 16271 - 16369 [(abstract~(rewrite~transport_c...] 0.013 secs (0.011u,0.001s)
Chars 15718 - 15934 [(refine~~~(isequiv_adjointify~...] 0.002 secs (0.002u,0.s)
Chars 15939 - 15985 [(refine~(path_sigma'~_~(eisret...] 0.002 secs (0.002u,0.s)
Chars 15990 - 16076 [(abstract~(rewrite~(eisretr~(g...] 0. secs (0.u,0.s)
Chars 16081 - 16127 [(refine~(path_sigma'~_~(eissec...] 0.002 secs (0.002u,0.s)
Chars 16132 - 16266 [refine~~((ap_transport~(eissec...] 0. secs (0.u,0.s)
Chars 16271 - 16369 [(abstract~(rewrite~transport_c...] 0. secs (0.u,0.s)
Chars 16370 - 16378 [Defined.] 0.008 secs (0.007u,0.s)
Chars 16380 - 16644 [Definition~equiv_functor_sigma...] 0.008 secs (0.006u,0.002s)
Chars 16646 - 16827 [Definition~equiv_functor_sigma...] 0.007 secs (0.004u,0.003s)
Chars 16829 - 16984 [Definition~equiv_functor_sigma...] 0.002 secs (0.001u,0.s)
Chars 16986 - 17144 [Definition~equiv_functor_sigma...] 0.008 secs (0.006u,0.001s)
Chars 17227 - 17342 [#[global]~Instance~isequiv_pr1...] 0. secs (0.u,0.s)
Chars 17343 - 17349 [Proof.] 0. secs (0.u,0.s)
Chars 17352 - 17454 [refine~(isequiv_adjointify~(@p...] 0.233 secs (0.002u,0.019s)
Chars 17457 - 17458 [-] 0. secs (0.u,0.s)
Chars 17459 - 17481 [(intros~a;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 17484 - 17485 [-] 0. secs (0.u,0.s)
Chars 17486 - 17499 [(intros~[a~p]).] 0.001 secs (0.u,0.s)
Chars 17504 - 17539 [refine~(path_sigma'~P~1~(contr...] 0.002 secs (0.002u,0.s)
Chars 17352 - 17454 [refine~(isequiv_adjointify~(@p...] 0. secs (0.u,0.s)
Chars 17459 - 17481 [(intros~a;~reflexivity).] 0. secs (0.u,0.s)
Chars 17486 - 17499 [(intros~[a~p]).] 0. secs (0.u,0.s)
Chars 17504 - 17539 [refine~(path_sigma'~P~1~(contr...] 0. secs (0.u,0.s)
Chars 17540 - 17548 [Defined.] 0.001 secs (0.001u,0.s)
Chars 17550 - 17683 [Definition~equiv_sigma_contr~{...] 0.003 secs (0.003u,0.s)
Chars 17769 - 17871 [Definition~equiv_contr_sigma~{...] 0.001 secs (0.001u,0.s)
Chars 17872 - 17878 [Proof.] 0. secs (0.u,0.s)
Chars 4183 - 4239 [exact~(@in_SepO_embedding~(Tr~...] 40.176 secs (0.u,0.035s)
Chars 4183 - 4239 [exact~(@in_SepO_embedding~(Tr~...] 0. secs (0.u,0.s)
Chars 4240 - 4248 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4250 - 4356 [#[global]~Instance~in_SepO_hpr...] 0. secs (0.u,0.s)
Chars 4357 - 4363 [Proof.] 0. secs (0.u,0.s)
Chars 4366 - 4407 [srapply~(in_SepO_embedding~O~(...] 0.177 secs (0.018u,0.036s)
Chars 4410 - 4430 [(intros~x~y;~exact~_).] 0.02 secs (0.017u,0.002s)
Chars 4366 - 4407 [srapply~(in_SepO_embedding~O~(...] 0. secs (0.u,0.s)
Chars 4410 - 4430 [(intros~x~y;~exact~_).] 0. secs (0.u,0.s)
Chars 4431 - 4439 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4472 - 4639 [Definition~sigma_closed_SepO~(...] 0.001 secs (0.001u,0.s)
Chars 4640 - 4646 [Proof.] 0. secs (0.u,0.s)
Chars 4018 - 4060 [(simple~refine~(Build_pMap~_~_...] 40.185 secs (0.003u,0.043s)
Chars 4063 - 4064 [-] 0. secs (0.u,0.s)
Chars 4065 - 4078 [(intros~[x~p]).] 0.001 secs (0.001u,0.s)
Chars 4083 - 4096 [exists~(f~x).] 0.001 secs (0.001u,0.s)
Chars 4101 - 4129 [(strip_truncations;~apply~tr).] 0.043 secs (0.036u,0.005s)
Chars 4134 - 4162 [exact~(ap~f~p~@~point_eq~f).] 0.002 secs (0.001u,0.s)
Chars 4165 - 4166 [-] 0. secs (0.u,0.s)
Chars 4167 - 4197 [(apply~path_sigma_hprop;~simpl).] 0.016 secs (0.014u,0.001s)
Chars 4202 - 4217 [(apply~point_eq).] 0.001 secs (0.u,0.s)
Chars 4018 - 4060 [(simple~refine~(Build_pMap~_~_...] 0. secs (0.u,0.s)
Chars 4065 - 4078 [(intros~[x~p]).] 0. secs (0.u,0.s)
Chars 4083 - 4096 [exists~(f~x).] 0. secs (0.u,0.s)
Chars 4101 - 4129 [(strip_truncations;~apply~tr).] 0.001 secs (0.001u,0.s)
Chars 4134 - 4162 [exact~(ap~f~p~@~point_eq~f).] 0. secs (0.u,0.s)
Chars 4167 - 4197 [(apply~path_sigma_hprop;~simpl).] 0.005 secs (0.005u,0.s)
Chars 4202 - 4217 [(apply~point_eq).] 0. secs (0.u,0.s)
Chars 2636 - 2678 [(refine~(finite_equiv'~(Fin~1)...] 40.181 secs (0.u,0.034s)
Chars 2681 - 2699 [(apply~sum_empty_l).] 0. secs (0.u,0.s)
Chars 2636 - 2678 [(refine~(finite_equiv'~(Fin~1)...] 0. secs (0.u,0.s)
Chars 2681 - 2699 [(apply~sum_empty_l).] 0. secs (0.u,0.s)
Chars 2700 - 2708 [Defined.] 0. secs (0.u,0.s)
Chars 2756 - 2854 [#[global]~Instance~finite_cont...] 0.005 secs (0.005u,0.s)
Chars 2944 - 3019 [Definition~finite_decidable_hp...] 0. secs (0.u,0.s)
Chars 3020 - 3026 [Proof.] 0. secs (0.u,0.s)
Chars 4218 - 4226 [Defined.] 0.02 secs (0.015u,0.004s)
Chars 4302 - 4459 [Definition~loops_functor_group...] 0.012 secs (0.01u,0.002s)
Chars 4460 - 4466 [Proof.] 0. secs (0.u,0.s)
Chars 2247 - 2256 [exists~1.] 40.179 secs (0.001u,0.042s)
Chars 2257 - 2270 [(apply~lt_0_1).] 0.011 secs (0.01u,0.s)
Chars 2247 - 2256 [exists~1.] 0. secs (0.u,0.s)
Chars 2257 - 2270 [(apply~lt_0_1).] 0. secs (0.u,0.s)
Chars 2271 - 2279 [Defined.] 0. secs (0.u,0.s)
Chars 2281 - 2320 [#[global]Instance~Qpos_mult@{}...] 0. secs (0.u,0.s)
Chars 2321 - 2327 [Proof.] 0. secs (0.u,0.s)
Chars 2328 - 2358 [(intros~a~b;~exists~('~a~*~'~b)).] 0.149 secs (0.003u,0.041s)
Chars 2359 - 2375 [solve_propholds.] 0.012 secs (0.012u,0.s)
Chars 2328 - 2358 [(intros~a~b;~exists~('~a~*~'~b)).] 0.001 secs (0.001u,0.s)
Chars 2359 - 2375 [solve_propholds.] 0. secs (0.u,0.s)
Chars 2376 - 2384 [Defined.] 0. secs (0.u,0.s)
Chars 2386 - 2447 [#[global]Instance~qpos_plus_co...] 0. secs (0.u,0.s)
Chars 2448 - 2454 [Proof.] 0. secs (0.u,0.s)
Chars 1977 - 2007 [(apply~natequiv_pi1bouquet_rec).] 40.237 secs (0.003u,0.052s)
Chars 1977 - 2007 [(apply~natequiv_pi1bouquet_rec).] 0. secs (0.u,0.s)
Chars 2010 - 2018 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2022 - 2208 [#[global]~Instance~is1natural_...] 0.027 secs (0.024u,0.003s)
Chars 2211 - 2217 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 1882 - 1895 [(unfold~codes).] 40.213 secs (0.002u,0.049s)
Chars 1900 - 1927 [(rewrite~transport_idmap_ap).] 0.006 secs (0.006u,0.s)
Chars 1932 - 1945 [(rewrite~ap_V).] 0.009 secs (0.007u,0.001s)
Chars 1950 - 1969 [(rewrite~ap_compose).] 0.012 secs (0.012u,0.s)
Chars 1974 - 2002 [(rewrite~Susp_rec_beta_merid).] 0.015 secs (0.014u,0.s)
Chars 2007 - 2028 [(rewrite~ap_trunctype).] 0.013 secs (0.01u,0.002s)
Chars 2033 - 2077 [(rewrite~transport_path_univer...] 0.01 secs (0.008u,0.s)
Chars 2082 - 2102 [(apply~moveR_equiv_V).] 0.003 secs (0.003u,0.s)
Chars 2107 - 2116 [symmetry.] 0.004 secs (0.004u,0.s)
Chars 2121 - 2146 [(cbn;~apply~left_identity).] 0.004 secs (0.003u,0.s)
Chars 1882 - 1895 [(unfold~codes).] 0.001 secs (0.001u,0.s)
Chars 1900 - 1927 [(rewrite~transport_idmap_ap).] 0.001 secs (0.001u,0.s)
Chars 1932 - 1945 [(rewrite~ap_V).] 0.002 secs (0.002u,0.s)
Chars 1950 - 1969 [(rewrite~ap_compose).] 0.002 secs (0.002u,0.s)
Chars 1974 - 2002 [(rewrite~Susp_rec_beta_merid).] 0.002 secs (0.001u,0.s)
Chars 2007 - 2028 [(rewrite~ap_trunctype).] 0.002 secs (0.002u,0.s)
Chars 2033 - 2077 [(rewrite~transport_path_univer...] 0.002 secs (0.002u,0.s)
Chars 2082 - 2102 [(apply~moveR_equiv_V).] 0.001 secs (0.u,0.s)
Chars 2107 - 2116 [symmetry.] 0. secs (0.u,0.s)
Chars 2121 - 2146 [(cbn;~apply~left_identity).] 0.001 secs (0.u,0.s)
Chars 2149 - 2157 [Defined.] 0.058 secs (0.049u,0.008s)
Chars 2161 - 2212 [#[local]Definition~encode~:~fo...] 0.001 secs (0.001u,0.s)
Chars 2215 - 2221 [Proof.] 0. secs (0.u,0.s)
Chars 3977 - 3981 [(cbn).] 40.168 secs (0.u,0.035s)
Chars 3982 - 3992 [(do~2~f_ap).] 0.004 secs (0.003u,0.s)
Chars 3993 - 4019 [by~apply~path_sigma_hprop.] 0.007 secs (0.006u,0.s)
Chars 3977 - 3981 [(cbn).] 0. secs (0.u,0.s)
Chars 3982 - 3992 [(do~2~f_ap).] 0. secs (0.u,0.s)
Chars 3993 - 4019 [by~apply~path_sigma_hprop.] 0. secs (0.u,0.s)
Chars 4020 - 4028 [Defined.] 0.004 secs (0.004u,0.s)
Chars 4030 - 4115 [Lemma~path_finnat_to_fin_zero~...] 0. secs (0.u,0.s)
Chars 4116 - 4122 [Proof.] 0. secs (0.u,0.s)
Chars 4125 - 4137 [reflexivity.] 0.159 secs (0.013u,0.041s)
Chars 4125 - 4137 [reflexivity.] 0. secs (0.u,0.s)
Chars 4138 - 4146 [Defined.] 0. secs (0.u,0.s)
Chars 4148 - 4266 [Lemma~path_finnat_to_fin_incl~...] 0. secs (0.u,0.s)
Chars 4267 - 4273 [Proof.] 0. secs (0.u,0.s)
Chars 17881 - 17997 [refine~~(equiv_adjointify~(fun...] 19.88 secs (17.472u,-0.21s)
Chars 10338 - 10415 [(revert~P;~simple_induction~n~...] 40.141 secs (0.006u,0.033s)
Chars 10420 - 10421 [-] 0. secs (0.u,0.s)
Chars 10422 - 10431 [(intros~h).] 0. secs (0.u,0.s)
Chars 10438 - 10485 [(exists~(fst~extg~(fst~extf~h)...] 0.003 secs (0.003u,0.s)
Chars 10492 - 10539 [refine~((fst~extg~(fst~extf~h)...] 0.003 secs (0.003u,0.s)
Chars 10546 - 10571 [exact~((fst~extf~h).2~a).] 0.001 secs (0.001u,0.s)
Chars 10576 - 10577 [-] 0. secs (0.u,0.s)
Chars 10578 - 10589 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 10596 - 10606 [(apply~IHn).] 0.001 secs (0.u,0.s)
Chars 10613 - 10614 [+] 0. secs (0.u,0.s)
Chars 10615 - 10636 [exact~(snd~extg~h~k).] 0.001 secs (0.001u,0.s)
Chars 10643 - 10644 [+] 0. secs (0.u,0.s)
Chars 10645 - 10680 [exact~(snd~extf~(h~oD~g)~(k~oD...] 0.002 secs (0.002u,0.s)
Chars 10338 - 10415 [(revert~P;~simple_induction~n~...] 0.002 secs (0.002u,0.s)
Chars 10422 - 10431 [(intros~h).] 0. secs (0.u,0.s)
Chars 10438 - 10485 [(exists~(fst~extg~(fst~extf~h)...] 0.001 secs (0.001u,0.s)
Chars 10492 - 10539 [refine~((fst~extg~(fst~extf~h)...] 0. secs (0.u,0.s)
Chars 10546 - 10571 [exact~((fst~extf~h).2~a).] 0. secs (0.u,0.s)
Chars 10578 - 10589 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 10596 - 10606 [(apply~IHn).] 0. secs (0.u,0.s)
Chars 10615 - 10636 [exact~(snd~extg~h~k).] 0. secs (0.u,0.s)
Chars 10645 - 10680 [exact~(snd~extf~(h~oD~g)~(k~oD...] 0. secs (0.u,0.s)
Chars 10683 - 10691 [Defined.] 0.002 secs (0.002u,0.s)
Chars 10721 - 10930 [Definition~cancelL_extendable~...] 0.001 secs (0.001u,0.s)
Chars 10933 - 10939 [Proof.] 0. secs (0.u,0.s)
Chars 3216 - 3224 [intro~e.] 40.17 secs (0.u,0.034s)
Chars 3227 - 3248 [srapply~Build_pEquiv.] 0.054 secs (0.046u,0.008s)
Chars 3251 - 3278 [1:~rapply~(fmap~(pTr~_)~e).] 0.002 secs (0.002u,0.s)
Chars 3281 - 3289 [exact~_.] 0.017 secs (0.017u,0.s)
Chars 3216 - 3224 [intro~e.] 0. secs (0.u,0.s)
Chars 3227 - 3248 [srapply~Build_pEquiv.] 0. secs (0.u,0.s)
Chars 3251 - 3278 [1:~rapply~(fmap~(pTr~_)~e).] 0. secs (0.u,0.s)
Chars 3281 - 3289 [exact~_.] 0. secs (0.u,0.s)
Chars 3290 - 3298 [Defined.] 0. secs (0.u,0.s)
Chars 3417 - 3525 [Definition~path_Tr_commutes~(n...] 0.002 secs (0.002u,0.s)
Chars 3526 - 3532 [Proof.] 0. secs (0.u,0.s)
Chars 3535 - 3556 [(intro~p;~induction~p).] 0.197 secs (0.003u,0.036s)
Chars 3559 - 3571 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 3535 - 3556 [(intro~p;~induction~p).] 0.001 secs (0.001u,0.s)
Chars 3559 - 3571 [reflexivity.] 0. secs (0.u,0.s)
Chars 3572 - 3580 [Defined.] 0.003 secs (0.001u,0.001s)
Chars 3634 - 3754 [Definition~ptr_loops_commutes~...] 0.004 secs (0.004u,0.s)
Chars 3755 - 3761 [Proof.] 0. secs (0.u,0.s)
Chars 10864 - 10887 [(destruct~p0x,~p1x,~a00).] 40.165 secs (0.006u,0.032s)
Chars 10892 - 10915 [refine~(_~oE~sq_G1^-1).] 0.002 secs (0.002u,0.s)
Chars 10920 - 10954 [refine~(_~oE~equiv_ap'~sq_G1~_...] 0.002 secs (0.001u,0.001s)
Chars 10959 - 10972 [exact~cu_G11.] 0.004 secs (0.004u,0.s)
Chars 10864 - 10887 [(destruct~p0x,~p1x,~a00).] 0. secs (0.u,0.s)
Chars 10892 - 10915 [refine~(_~oE~sq_G1^-1).] 0. secs (0.u,0.s)
Chars 10920 - 10954 [refine~(_~oE~equiv_ap'~sq_G1~_...] 0. secs (0.u,0.s)
Chars 10959 - 10972 [exact~cu_G11.] 0. secs (0.u,0.s)
Chars 10975 - 10983 [Defined.] 0.006 secs (0.004u,0.001s)
Chars 10987 - 11113 [Definition~equiv_cu_1GG~:~~~Pa...] 0.004 secs (0.004u,0.s)
Chars 11116 - 11122 [Proof.] 0. secs (0.u,0.s)
Chars 3324 - 3353 [(rewrite~<-~plus_mult_distr_l).] 40.203 secs (0.013u,0.035s)
Chars 3356 - 3420 [(rewrite~<-~(mult_1_l~(recip'~...] 0.021 secs (0.019u,0.001s)
Chars 3423 - 3452 [(rewrite~<-~plus_mult_distr_r).] 0.012 secs (0.011u,0.s)
Chars 3455 - 3513 [(rewrite~(recip_inverse'~2~(po...] 0.018 secs (0.016u,0.001s)
Chars 3516 - 3533 [(rewrite~mult_1_r).] 0.01 secs (0.009u,0.001s)
Chars 3536 - 3548 [reflexivity.] 0. secs (0.u,0.s)
Chars 3324 - 3353 [(rewrite~<-~plus_mult_distr_l).] 0.001 secs (0.001u,0.s)
Chars 3356 - 3420 [(rewrite~<-~(mult_1_l~(recip'~...] 0.001 secs (0.001u,0.s)
Chars 3423 - 3452 [(rewrite~<-~plus_mult_distr_r).] 0.001 secs (0.u,0.s)
Chars 3455 - 3513 [(rewrite~(recip_inverse'~2~(po...] 0.001 secs (0.u,0.s)
Chars 3516 - 3533 [(rewrite~mult_1_r).] 0. secs (0.u,0.s)
Chars 3536 - 3548 [reflexivity.] 0. secs (0.u,0.s)
Chars 3549 - 3553 [Qed.] 0.009 secs (0.008u,0.s)
Chars 2308 - 2328 [(apply~(injective~f)).] 40.187 secs (0.015u,0.032s)
Chars 3554 - 3567 [End~contents.] 0.159 secs (0.145u,0.013s)
Chars 2329 - 2377 [(destruct~(int_abs_spec~(-~f~n...] 0.012 secs (0.012u,0.s)
Chars 2378 - 2379 [-] 0. secs (0.u,0.s)
Chars 2380 - 2389 [symmetry.] 0.004 secs (0.004u,0.s)
Chars 2390 - 2420 [(apply~naturals.negate_to_ring).] 0.044 secs (0.035u,0.008s)
Chars 2421 - 2445 [(apply~symmetry;~trivial).] 0.007 secs (0.007u,0.s)
Chars 2446 - 2447 [-] 0. secs (0.u,0.s)
Chars 2448 - 2472 [(rewrite~involutive~in~E).] 0.019 secs (0.017u,0.001s)
Chars 2473 - 2481 [trivial.] 0.002 secs (0.002u,0.s)
Chars 2308 - 2328 [(apply~(injective~f)).] 0.001 secs (0.001u,0.s)
Chars 2329 - 2377 [(destruct~(int_abs_spec~(-~f~n...] 0.001 secs (0.001u,0.s)
Chars 2380 - 2389 [symmetry.] 0.001 secs (0.u,0.s)
Chars 2390 - 2420 [(apply~naturals.negate_to_ring).] 0.001 secs (0.001u,0.s)
Chars 2421 - 2445 [(apply~symmetry;~trivial).] 0.003 secs (0.003u,0.s)
Chars 2448 - 2472 [(rewrite~involutive~in~E).] 0.001 secs (0.001u,0.s)
Chars 2473 - 2481 [trivial.] 0.001 secs (0.001u,0.s)
Chars 2482 - 2486 [Qed.] 0.006 secs (0.006u,0.s)
Chars 2488 - 2548 [Lemma~int_abs_negate~x~:~int_a...] 0.075 secs (0.066u,0.009s)
Chars 2549 - 2555 [Proof.] 0. secs (0.u,0.s)
Chars 17881 - 17997 [refine~~(equiv_adjointify~(fun...] 40.051 secs (0.003u,0.022s)
Chars 18000 - 18001 [-] 0. secs (0.u,0.s)
Chars 18002 - 18018 [(intros~p;~simpl).] 0.001 secs (0.001u,0.s)
Chars 18023 - 18068 [exact~(ap~(fun~q~=>~q~#~p)~(pa...] 0.005 secs (0.003u,0.002s)
Chars 18071 - 18072 [-] 0. secs (0.u,0.s)
Chars 18073 - 18086 [(intros~[a~p]).] 0.002 secs (0.002u,0.s)
Chars 18091 - 18126 [refine~(path_sigma'~_~(contr~a...] 0.002 secs (0.002u,0.s)
Chars 18131 - 18150 [(apply~transport_pV).] 0.002 secs (0.002u,0.s)
Chars 17881 - 17997 [refine~~(equiv_adjointify~(fun...] 0. secs (0.u,0.s)
Chars 18002 - 18018 [(intros~p;~simpl).] 0.001 secs (0.u,0.s)
Chars 18023 - 18068 [exact~(ap~(fun~q~=>~q~#~p)~(pa...] 0. secs (0.u,0.s)
Chars 18073 - 18086 [(intros~[a~p]).] 0. secs (0.u,0.s)
Chars 18091 - 18126 [refine~(path_sigma'~_~(contr~a...] 0. secs (0.u,0.s)
Chars 18131 - 18150 [(apply~transport_pV).] 0. secs (0.u,0.s)
Chars 18151 - 18159 [Defined.] 0.004 secs (0.004u,0.s)
Chars 18481 - 18599 [Definition~equiv_sigma_assoc~`...] 0.001 secs (0.u,0.s)
Chars 18600 - 18606 [Proof.] 0. secs (0.u,0.s)
Chars 4649 - 4668 [(intros~[x~u]~[y~v]).] 40.122 secs (0.001u,0.034s)
Chars 4671 - 4694 [specialize~(A_inO~x~y).] 0. secs (0.u,0.s)
Chars 4697 - 4741 [(pose~proof~(fun~p~:~x~=~y~=>~...] 0.001 secs (0.u,0.s)
Chars 4744 - 4760 [(pose~@inO_sigma).] 0. secs (0.u,0.s)
Chars 4797 - 4848 [refine~(inO_equiv_inO'~_~(equi...] 0.156 secs (0.127u,0.028s)
Chars 4649 - 4668 [(intros~[x~u]~[y~v]).] 0. secs (0.u,0.s)
Chars 4671 - 4694 [specialize~(A_inO~x~y).] 0. secs (0.u,0.s)
Chars 4697 - 4741 [(pose~proof~(fun~p~:~x~=~y~=>~...] 0. secs (0.u,0.s)
Chars 4744 - 4760 [(pose~@inO_sigma).] 0. secs (0.u,0.s)
Chars 4797 - 4848 [refine~(inO_equiv_inO'~_~(equi...] 0. secs (0.u,0.s)
Chars 4849 - 4857 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4885 - 5026 [#[global]~Instance~issurjectiv...] 0. secs (0.u,0.s)
Chars 5027 - 5033 [Proof.] 0. secs (0.u,0.s)
Chars 3029 - 3056 [(destruct~(dec~X)~as~[x|~nx]).] 40.184 secs (0.001u,0.035s)
Chars 3059 - 3060 [-] 0. secs (0.u,0.s)
Chars 3061 - 3115 [(assert~(Contr~X)~by~exact~(co...] 0.001 secs (0.001u,0.s)
Chars 3120 - 3128 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 3131 - 3132 [-] 0. secs (0.u,0.s)
Chars 3133 - 3169 [refine~(finite_equiv~Empty~nx^...] 0.003 secs (0.003u,0.s)
Chars 3029 - 3056 [(destruct~(dec~X)~as~[x|~nx]).] 0. secs (0.u,0.s)
Chars 3061 - 3115 [(assert~(Contr~X)~by~exact~(co...] 0. secs (0.u,0.s)
Chars 3120 - 3128 [exact~_.] 0. secs (0.u,0.s)
Chars 3133 - 3169 [refine~(finite_equiv~Empty~nx^...] 0. secs (0.u,0.s)
Chars 3170 - 3178 [Defined.] 0. secs (0.u,0.s)
Chars 3180 - 3250 [#[export]Hint~Immediate~finite...] 0. secs (0.u,0.s)
Chars 3333 - 3401 [#[global]Instance~finite_merel...] 0. secs (0.u,0.s)
Chars 3402 - 3408 [Proof.] 0. secs (0.u,0.s)
Chars 4469 - 4478 [(intros~x).] 40.211 secs (0.002u,0.042s)
Chars 4481 - 4531 [(apply~(equiv_inj~(equiv_path_...] 0.062 secs (0.045u,0.016s)
Chars 4534 - 4540 [(simpl).] 0.034 secs (0.033u,0.s)
Chars 4543 - 4575 [(unfold~pr1_path;~rewrite~!ap_...] 0.102 secs (0.086u,0.015s)
Chars 4578 - 4617 [(rewrite~ap_V,~!ap_pr1_path_si...] 0.137 secs (0.123u,0.013s)
Chars 4620 - 4645 [(apply~whiskerL,~whiskerR).] 0.012 secs (0.01u,0.001s)
Chars 4648 - 4792 [transitivity~~(ap~(fun~X0~:~{x...] 0.026 secs (0.025u,0.s)
Chars 4795 - 4796 [-] 0. secs (0.u,0.s)
Chars 4797 - 4901 [(match~goal~with~~|~|-~ap~?f~(...] 0.015 secs (0.014u,0.s)
Chars 4904 - 4905 [-] 0. secs (0.u,0.s)
Chars 4906 - 4935 [(rewrite~ap_compose;~apply~ap).] 0.02 secs (0.018u,0.s)
Chars 4940 - 4970 [(apply~ap_pr1_path_sigma_hprop).] 0.003 secs (0.003u,0.s)
Chars 4469 - 4478 [(intros~x).] 0. secs (0.u,0.s)
Chars 4481 - 4531 [(apply~(equiv_inj~(equiv_path_...] 0. secs (0.u,0.s)
Chars 4534 - 4540 [(simpl).] 0. secs (0.u,0.s)
Chars 4543 - 4575 [(unfold~pr1_path;~rewrite~!ap_...] 0.009 secs (0.009u,0.s)
Chars 4578 - 4617 [(rewrite~ap_V,~!ap_pr1_path_si...] 0.005 secs (0.005u,0.s)
Chars 4620 - 4645 [(apply~whiskerL,~whiskerR).] 0.019 secs (0.015u,0.004s)
Chars 4648 - 4792 [transitivity~~(ap~(fun~X0~:~{x...] 0.002 secs (0.002u,0.s)
Chars 4797 - 4901 [(match~goal~with~~|~|-~ap~?f~(...] 0.002 secs (0.002u,0.s)
Chars 4906 - 4935 [(rewrite~ap_compose;~apply~ap).] 0.003 secs (0.003u,0.s)
Chars 4940 - 4970 [(apply~ap_pr1_path_sigma_hprop).] 0.001 secs (0.001u,0.s)
Chars 4971 - 4975 [Qed.] 0.182 secs (0.177u,0.004s)
Chars 4977 - 5123 [Definition~grouphom_compose~{G...] 0.001 secs (0.001u,0.s)
Chars 5151 - 5379 [Definition~group_loops_functor...] 0.004 secs (0.004u,0.s)
Chars 5380 - 5386 [Proof.] 0. secs (0.u,0.s)
Chars 2455 - 2459 [(hnf).] 40.193 secs (0.001u,0.04s)
Chars 2460 - 2467 [(intros).] 0. secs (0.u,0.s)
Chars 2468 - 2481 [(apply~pos_eq).] 0.001 secs (0.001u,0.s)
Chars 2482 - 2513 [(change~('~x~+~'~y~=~'~y~+~'~x)).] 0.007 secs (0.007u,0.s)
Chars 2514 - 2530 [(apply~plus_comm).] 0.006 secs (0.006u,0.s)
Chars 2455 - 2459 [(hnf).] 0. secs (0.u,0.s)
Chars 2460 - 2467 [(intros).] 0. secs (0.u,0.s)
Chars 2468 - 2481 [(apply~pos_eq).] 0. secs (0.u,0.s)
Chars 2482 - 2513 [(change~('~x~+~'~y~=~'~y~+~'~x)).] 0. secs (0.u,0.s)
Chars 2514 - 2530 [(apply~plus_comm).] 0. secs (0.u,0.s)
Chars 2531 - 2535 [Qed.] 0. secs (0.u,0.s)
Chars 2537 - 2598 [#[global]Instance~qpos_mult_co...] 0. secs (0.u,0.s)
Chars 2599 - 2605 [Proof.] 0. secs (0.u,0.s)
Chars 2222 - 2283 [rapply~(is1natural_natequiv~_~...] 40.253 secs (0.006u,0.052s)
Chars 2222 - 2283 [rapply~(is1natural_natequiv~_~...] 0. secs (0.u,0.s)
Chars 2286 - 2294 [Defined.] 0.005 secs (0.003u,0.001s)
Chars 2409 - 2475 [Definition~pi1bouquet_incl~(S~...] 0. secs (0.u,0.s)
Chars 2478 - 2484 [Proof.] 0. secs (0.u,0.s)
Chars 2226 - 2234 [intro~x.] 40.191 secs (0.u,0.052s)
Chars 2239 - 2257 [srapply~Trunc_rec.] 0.021 secs (0.013u,0.007s)
Chars 2262 - 2270 [intro~p.] 0.001 secs (0.001u,0.s)
Chars 2275 - 2310 [exact~(transport~codes~p~mon_u...] 0.009 secs (0.009u,0.s)
Chars 2226 - 2234 [intro~x.] 0. secs (0.u,0.s)
Chars 2239 - 2257 [srapply~Trunc_rec.] 0. secs (0.u,0.s)
Chars 2262 - 2270 [intro~p.] 0. secs (0.u,0.s)
Chars 2275 - 2310 [exact~(transport~codes~p~mon_u...] 0. secs (0.u,0.s)
Chars 2313 - 2321 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2325 - 2381 [#[local]Definition~decode'~:~X...] 0.001 secs (0.001u,0.s)
Chars 2384 - 2390 [Proof.] 0. secs (0.u,0.s)
Chars 4276 - 4301 [(induction~n~as~[|~n~IHn]).] 40.158 secs (0.u,0.037s)
Chars 4304 - 4305 [-] 0. secs (0.u,0.s)
Chars 4306 - 4330 [(elim~(not_lt_n_0~_~u.2)).] 0.001 secs (0.001u,0.s)
Chars 4333 - 4334 [-] 0. secs (0.u,0.s)
Chars 4335 - 4355 [(destruct~u~as~[x~h]).] 0.002 secs (0.001u,0.s)
Chars 4360 - 4396 [(destruct~x~as~[|~x];~[~reflex...] 0.003 secs (0.003u,0.s)
Chars 4401 - 4469 [refine~((ap~_~(ap~_~(path_succ...] 0.004 secs (0.003u,0.s)
Chars 4474 - 4521 [refine~(_~@~ap~fsucc~(IHn~(x;~...] 0.003 secs (0.003u,0.s)
Chars 4526 - 4598 [by~induction~(path_finnat_to_f...] 0.006 secs (0.005u,0.s)
Chars 4276 - 4301 [(induction~n~as~[|~n~IHn]).] 0. secs (0.u,0.s)
Chars 4306 - 4330 [(elim~(not_lt_n_0~_~u.2)).] 0. secs (0.u,0.s)
Chars 4335 - 4355 [(destruct~u~as~[x~h]).] 0. secs (0.u,0.s)
Chars 4360 - 4396 [(destruct~x~as~[|~x];~[~reflex...] 0.001 secs (0.001u,0.s)
Chars 4401 - 4469 [refine~((ap~_~(ap~_~(path_succ...] 0. secs (0.u,0.s)
Chars 4474 - 4521 [refine~(_~@~ap~fsucc~(IHn~(x;~...] 0. secs (0.u,0.s)
Chars 4526 - 4598 [by~induction~(path_finnat_to_f...] 0. secs (0.u,0.s)
Chars 4599 - 4607 [Defined.] 0.008 secs (0.006u,0.001s)
Chars 4609 - 4694 [Lemma~path_finnat_to_fin_last~...] 0. secs (0.u,0.s)
Chars 4695 - 4701 [Proof.] 0. secs (0.u,0.s)
Chars 18609 - 18620 [make_equiv.] 18.008 secs (0.016u,0.023s)
Chars 18609 - 18620 [make_equiv.] 0. secs (0.u,0.s)
Chars 18621 - 18629 [Defined.] 0.006 secs (0.004u,0.001s)
Chars 18631 - 18773 [Definition~equiv_sigma_assoc'~...] 0.001 secs (0.001u,0.s)
Chars 18774 - 18780 [Proof.] 0. secs (0.u,0.s)
Chars 18783 - 18794 [make_equiv.] 0.156 secs (0.014u,0.023s)
Chars 18783 - 18794 [make_equiv.] 0. secs (0.u,0.s)
Chars 18795 - 18803 [Defined.] 0.005 secs (0.004u,0.s)
Chars 18805 - 18898 [Definition~equiv_sigma_prod~`(...] 0.033 secs (0.018u,0.015s)
Chars 18899 - 18905 [Proof.] 0. secs (0.u,0.s)
Chars 18908 - 18919 [make_equiv.] 0.107 secs (0.011u,0.027s)
Chars 18908 - 18919 [make_equiv.] 0. secs (0.u,0.s)
Chars 18920 - 18928 [Defined.] 0.004 secs (0.003u,0.s)
Chars 18930 - 18998 [Definition~equiv_sigma_prod0~(...] 0. secs (0.u,0.s)
Chars 18999 - 19005 [Proof.] 0. secs (0.u,0.s)
Chars 19008 - 19019 [make_equiv.] 0.089 secs (0.005u,0.022s)
Chars 19008 - 19019 [make_equiv.] 0. secs (0.u,0.s)
Chars 19020 - 19028 [Defined.] 0.001 secs (0.001u,0.s)
Chars 19030 - 19137 [Definition~equiv_sigma_prod1~(...] 0.02 secs (0.019u,0.s)
Chars 19159 - 19269 [Definition~equiv_sigma_symm~`(...] 0.001 secs (0.001u,0.s)
Chars 19270 - 19276 [Proof.] 0. secs (0.u,0.s)
Chars 19279 - 19290 [make_equiv.] 0.105 secs (0.016u,0.021s)
Chars 19279 - 19290 [make_equiv.] 0. secs (0.u,0.s)
Chars 19291 - 19299 [Defined.] 0.004 secs (0.004u,0.s)
Chars 19301 - 19451 [Definition~equiv_sigma_symm'~{...] 0.001 secs (0.u,0.s)
Chars 19452 - 19458 [Proof.] 0. secs (0.u,0.s)
Chars 19461 - 19472 [make_equiv.] 0.104 secs (0.012u,0.025s)
Chars 19461 - 19472 [make_equiv.] 0. secs (0.u,0.s)
Chars 19473 - 19481 [Defined.] 0.006 secs (0.003u,0.003s)
Chars 19483 - 19555 [Definition~equiv_sigma_symm0~(...] 0. secs (0.u,0.s)
Chars 19556 - 19562 [Proof.] 0. secs (0.u,0.s)
Chars 19565 - 19576 [make_equiv.] 0.073 secs (0.002u,0.024s)
Chars 19565 - 19576 [make_equiv.] 0. secs (0.u,0.s)
Chars 19577 - 19585 [Defined.] 0.001 secs (0.001u,0.s)
Chars 19671 - 19914 [#[global]~Instance~isequiv_sig...] 0.007 secs (0.005u,0.001s)
Chars 19916 - 20080 [Definition~equiv_sig_ind~`{P~:...] 0.002 secs (0.002u,0.s)
Chars 20111 - 20297 [Definition~equiv_sig_ind'~`{P~...] 0.002 secs (0.001u,0.s)
Chars 20344 - 20546 [Definition~sig_coind_uncurried...] 0.002 secs (0.002u,0.s)
Chars 20548 - 20739 [Definition~sig_coind~`{A~:~X~-...] 0.001 secs (0.001u,0.s)
Chars 20741 - 21129 [#[global]~Instance~isequiv_sig...] 0.009 secs (0.006u,0.002s)
Chars 21131 - 21337 [Definition~equiv_sig_coind~`(A...] 0.003 secs (0.003u,0.s)
Chars 21377 - 21503 [#[global]~Instance~istrunc_sig...] 0. secs (0.u,0.s)
Chars 21504 - 21510 [Proof.] 0. secs (0.u,0.s)
Chars 10944 - 11022 [(revert~P;~simple_induction~n~...] 40.15 secs (0.006u,0.027s)
Chars 11027 - 11028 [-] 0. secs (0.u,0.s)
Chars 11029 - 11038 [(intros~h).] 0. secs (0.u,0.s)
Chars 11045 - 11085 [(exists~((fst~extgf~h).1~oD~g)...] 0.003 secs (0.003u,0.s)
Chars 11092 - 11118 [exact~((fst~extgf~h).2~a).] 0.002 secs (0.002u,0.s)
Chars 11123 - 11124 [-] 0. secs (0.u,0.s)
Chars 11125 - 11136 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 11143 - 11171 [(pose~(h'~:=~(fst~extg~h).1)).] 0.001 secs (0.001u,0.s)
Chars 11178 - 11206 [(pose~(k'~:=~(fst~extg~k).1)).] 0.002 secs (0.002u,0.s)
Chars 11213 - 11306 [refine~~(extendable_postcompos...] 0.003 secs (0.002u,0.001s)
Chars 11313 - 11314 [+] 0. secs (0.u,0.s)
Chars 11315 - 11324 [(intros~b).] 0.001 secs (0.001u,0.s)
Chars 11333 - 11396 [exact~(equiv_concat_lr~((fst~e...] 0.003 secs (0.003u,0.s)
Chars 11403 - 11404 [+] 0. secs (0.u,0.s)
Chars 11405 - 11475 [(apply~(IHn~(fun~c~=>~h'~c~=~k...] 0.003 secs (0.003u,0.s)
Chars 10944 - 11022 [(revert~P;~simple_induction~n~...] 0.002 secs (0.u,0.002s)
Chars 11029 - 11038 [(intros~h).] 0. secs (0.u,0.s)
Chars 11045 - 11085 [(exists~((fst~extgf~h).1~oD~g)...] 0.001 secs (0.001u,0.s)
Chars 11092 - 11118 [exact~((fst~extgf~h).2~a).] 0. secs (0.u,0.s)
Chars 11125 - 11136 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 11143 - 11171 [(pose~(h'~:=~(fst~extg~h).1)).] 0. secs (0.u,0.s)
Chars 11178 - 11206 [(pose~(k'~:=~(fst~extg~k).1)).] 0. secs (0.u,0.s)
Chars 11213 - 11306 [refine~~(extendable_postcompos...] 0. secs (0.u,0.s)
Chars 11315 - 11324 [(intros~b).] 0. secs (0.u,0.s)
Chars 11333 - 11396 [exact~(equiv_concat_lr~((fst~e...] 0. secs (0.u,0.s)
Chars 11405 - 11475 [(apply~(IHn~(fun~c~=>~h'~c~=~k...] 0. secs (0.u,0.s)
Chars 11478 - 11486 [Defined.] 0.003 secs (0.003u,0.s)
Chars 11490 - 11702 [Definition~cancelR_extendable~...] 0.002 secs (0.002u,0.s)
Chars 11705 - 11711 [Proof.] 0. secs (0.u,0.s)
Chars 3764 - 3788 [srapply~Build_pHomotopy.] 40.179 secs (0.003u,0.033s)
Chars 3791 - 3792 [-] 0. secs (0.u,0.s)
Chars 3793 - 3801 [intro~p.] 0. secs (0.u,0.s)
Chars 3806 - 3812 [(simpl).] 0.002 secs (0.002u,0.s)
Chars 3817 - 3832 [refine~(_~@~_).] 0.002 secs (0.002u,0.s)
Chars 3837 - 3838 [+] 0. secs (0.u,0.s)
Chars 3839 - 3862 [(apply~path_Tr_commutes).] 0.003 secs (0.001u,0.001s)
Chars 3867 - 3868 [+] 0. secs (0.u,0.s)
Chars 3869 - 3894 [(symmetry;~refine~(_~@~_)).] 0.006 secs (0.006u,0.s)
Chars 3901 - 3902 [*] 0. secs (0.u,0.s)
Chars 3903 - 3919 [(apply~concat_1p).] 0.002 secs (0.002u,0.s)
Chars 3926 - 3927 [*] 0. secs (0.u,0.s)
Chars 3928 - 3944 [(apply~concat_p1).] 0.002 secs (0.001u,0.s)
Chars 3947 - 3948 [-] 0. secs (0.u,0.s)
Chars 3949 - 3955 [(simpl).] 0.007 secs (0.006u,0.s)
Chars 3960 - 3972 [reflexivity.] 0.005 secs (0.003u,0.001s)
Chars 3764 - 3788 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 3793 - 3801 [intro~p.] 0. secs (0.u,0.s)
Chars 3806 - 3812 [(simpl).] 0. secs (0.u,0.s)
Chars 3817 - 3832 [refine~(_~@~_).] 0.001 secs (0.001u,0.s)
Chars 3839 - 3862 [(apply~path_Tr_commutes).] 0. secs (0.u,0.s)
Chars 3869 - 3894 [(symmetry;~refine~(_~@~_)).] 0.002 secs (0.001u,0.s)
Chars 3903 - 3919 [(apply~concat_1p).] 0.001 secs (0.001u,0.s)
Chars 3928 - 3944 [(apply~concat_p1).] 0. secs (0.u,0.s)
Chars 3949 - 3955 [(simpl).] 0.004 secs (0.003u,0.s)
Chars 3960 - 3972 [reflexivity.] 0.001 secs (0.u,0.s)
Chars 3973 - 3981 [Defined.] 0.031 secs (0.028u,0.003s)
Chars 11127 - 11150 [(destruct~px0,~px1,~a01).] 40.172 secs (0.011u,0.031s)
Chars 11155 - 11177 [refine~(_~oE~sq_1G^-1).] 0.002 secs (0.001u,0.001s)
Chars 11182 - 11216 [refine~(_~oE~equiv_ap'~sq_1G~_...] 0.002 secs (0.002u,0.s)
Chars 11221 - 11234 [exact~cu_11G.] 0.004 secs (0.004u,0.s)
Chars 11127 - 11150 [(destruct~px0,~px1,~a01).] 0. secs (0.u,0.s)
Chars 11155 - 11177 [refine~(_~oE~sq_1G^-1).] 0. secs (0.u,0.s)
Chars 11182 - 11216 [refine~(_~oE~equiv_ap'~sq_1G~_...] 0. secs (0.u,0.s)
Chars 11221 - 11234 [exact~cu_11G.] 0. secs (0.u,0.s)
Chars 11237 - 11245 [Defined.] 0.005 secs (0.003u,0.001s)
Chars 11249 - 11371 [Definition~equiv_cu_G1G~:~~~Pa...] 0.003 secs (0.003u,0.s)
Chars 11374 - 11380 [Proof.] 0. secs (0.u,0.s)
Chars 11385 - 11408 [(destruct~p0x,~p1x,~a10).] 0.264 secs (0.016u,0.033s)
Chars 11413 - 11435 [refine~(_~oE~sq_G1^-1).] 0.002 secs (0.002u,0.s)
Chars 11440 - 11474 [refine~(_~oE~equiv_ap'~sq_1G~_...] 0.002 secs (0.002u,0.s)
Chars 11479 - 11492 [exact~cu_G11.] 0.004 secs (0.004u,0.s)
Chars 11385 - 11408 [(destruct~p0x,~p1x,~a10).] 0. secs (0.u,0.s)
Chars 11413 - 11435 [refine~(_~oE~sq_G1^-1).] 0. secs (0.u,0.s)
Chars 11440 - 11474 [refine~(_~oE~equiv_ap'~sq_1G~_...] 0. secs (0.u,0.s)
Chars 11479 - 11492 [exact~cu_G11.] 0. secs (0.u,0.s)
Chars 11495 - 11503 [Defined.] 0.005 secs (0.005u,0.s)
Chars 11505 - 11525 [End~PathPathSquares.] 0.018 secs (0.017u,0.s)
Chars 11527 - 11559 [Notation~cu_GG1~:=~equiv_cu_GG1.] 0. secs (0.u,0.s)
Chars 11560 - 11592 [Notation~cu_G1G~:=~equiv_cu_G1G.] 0. secs (0.u,0.s)
Chars 11593 - 11625 [Notation~cu_1GG~:=~equiv_cu_1GG.] 0. secs (0.u,0.s)
Chars 11626 - 11667 [Arguments~cu_GG1~{_~_~_~_~_~_~...] 0. secs (0.u,0.s)
Chars 11668 - 11709 [Arguments~cu_G1G~{_~_~_~_~_~_~...] 0. secs (0.u,0.s)
Chars 11710 - 11751 [Arguments~cu_1GG~{_~_~_~_~_~_~...] 0. secs (0.u,0.s)
Chars 11808 - 12425 [Definition~equiv_cu_ds~{A}~{B}...] 0.037 secs (0.033u,0.004s)
Chars 12426 - 12432 [Proof.] 0. secs (0.u,0.s)
Chars 2556 - 2599 [(destruct~(int_abs_spec~x)~as~...] 40.178 secs (0.007u,0.034s)
Chars 2600 - 2601 [-] 0. secs (0.u,0.s)
Chars 2602 - 2647 [(path_via~(int_abs~Z~N~(-~f~(i...] 0.116 secs (0.09u,0.025s)
Chars 2650 - 2675 [(apply~int_abs_negate_nat).] 0.002 secs (0.002u,0.s)
Chars 2676 - 2677 [-] 0. secs (0.u,0.s)
Chars 2678 - 2690 [(rewrite~<-~E).] 0.002 secs (0.002u,0.s)
Chars 2691 - 2709 [(apply~int_abs_nat).] 0.002 secs (0.002u,0.s)
Chars 2556 - 2599 [(destruct~(int_abs_spec~x)~as~...] 0.001 secs (0.001u,0.s)
Chars 2602 - 2647 [(path_via~(int_abs~Z~N~(-~f~(i...] 0.001 secs (0.u,0.s)
Chars 2650 - 2675 [(apply~int_abs_negate_nat).] 0.001 secs (0.001u,0.s)
Chars 2678 - 2690 [(rewrite~<-~E).] 0.001 secs (0.001u,0.s)
Chars 2691 - 2709 [(apply~int_abs_nat).] 0.001 secs (0.001u,0.s)
Chars 2710 - 2714 [Qed.] 0.006 secs (0.004u,0.001s)
Chars 2716 - 2768 [Lemma~int_abs_0_alt~x~:~int_ab...] 0.039 secs (0.035u,0.003s)
Chars 2769 - 2775 [Proof.] 0. secs (0.u,0.s)
Chars 5036 - 5071 [(pose~(im~:=~himage~(to~(Sep~O...] 40.133 secs (0.001u,0.026s)
Chars 5074 - 5120 [(pose~proof~(in_SepO_embedding...] 0.005 secs (0.005u,0.s)
Chars 5123 - 5154 [(pose~(s~:=~O_rec~(factor1~im))).] 0.002 secs (0.002u,0.s)
Chars 5157 - 5194 [(assert~(h~:~factor2~im~o~s~==...] 0.003 secs (0.002u,0.s)
Chars 5197 - 5198 [-] 0. secs (0.u,0.s)
Chars 5199 - 5235 [(apply~O_indpaths;~intros~x;~s...] 0.006 secs (0.005u,0.001s)
Chars 5240 - 5259 [(rewrite~O_rec_beta).] 0.002 secs (0.002u,0.s)
Chars 5264 - 5283 [(apply~fact_factors).] 0.002 secs (0.002u,0.s)
Chars 5286 - 5287 [-] 0. secs (0.u,0.s)
Chars 5288 - 5312 [(apply~BuildIsSurjection).] 0.001 secs (0.001u,0.s)
Chars 5317 - 5326 [(intros~z).] 0.001 secs (0.001u,0.s)
Chars 5331 - 5358 [(specialize~(h~z);~cbn~in~h).] 0.003 secs (0.002u,0.s)
Chars 5363 - 5383 [(set~(w~:=~s~z)~in~*).] 0.002 secs (0.002u,0.s)
Chars 5388 - 5410 [(destruct~w~as~[w1~w2]).] 0.003 secs (0.003u,0.s)
Chars 5415 - 5426 [(destruct~h).] 0.002 secs (0.001u,0.s)
Chars 5431 - 5440 [exact~w2.] 0.001 secs (0.001u,0.s)
Chars 5036 - 5071 [(pose~(im~:=~himage~(to~(Sep~O...] 0. secs (0.u,0.s)
Chars 5074 - 5120 [(pose~proof~(in_SepO_embedding...] 0. secs (0.u,0.s)
Chars 5123 - 5154 [(pose~(s~:=~O_rec~(factor1~im))).] 0. secs (0.u,0.s)
Chars 5157 - 5194 [(assert~(h~:~factor2~im~o~s~==...] 0. secs (0.u,0.s)
Chars 5199 - 5235 [(apply~O_indpaths;~intros~x;~s...] 0.002 secs (0.001u,0.s)
Chars 5240 - 5259 [(rewrite~O_rec_beta).] 0. secs (0.u,0.s)
Chars 5264 - 5283 [(apply~fact_factors).] 0. secs (0.u,0.s)
Chars 5288 - 5312 [(apply~BuildIsSurjection).] 0. secs (0.u,0.s)
Chars 5317 - 5326 [(intros~z).] 0. secs (0.u,0.s)
Chars 5331 - 5358 [(specialize~(h~z);~cbn~in~h).] 0.001 secs (0.u,0.s)
Chars 5363 - 5383 [(set~(w~:=~s~z)~in~*).] 0. secs (0.u,0.s)
Chars 5388 - 5410 [(destruct~w~as~[w1~w2]).] 0. secs (0.u,0.s)
Chars 5415 - 5426 [(destruct~h).] 0.001 secs (0.001u,0.s)
Chars 5431 - 5440 [exact~w2.] 0.034 secs (0.028u,0.005s)
Chars 5441 - 5449 [Defined.] 0.003 secs (0.003u,0.s)
Chars 5484 - 5644 [Definition~almost_inSepO_typeO...] 0.001 secs (0.u,0.s)
Chars 5645 - 5651 [Proof.] 0. secs (0.u,0.s)
Chars 3504 - 3563 [(destruct~fX~as~[[|~n]~e];~ref...] 40.306 secs (0.103u,0.051s)
Chars 3566 - 3567 [-] 0. secs (0.u,0.s)
Chars 3568 - 3574 [right.] 0. secs (0.u,0.s)
Chars 3579 - 3620 [(intros~x;~strip_truncations;~...] 0.065 secs (0.054u,0.01s)
Chars 3623 - 3624 [-] 0. secs (0.u,0.s)
Chars 3625 - 3630 [left.] 0. secs (0.u,0.s)
Chars 3635 - 3681 [(strip_truncations;~exact~(tr~...] 0.029 secs (0.025u,0.003s)
Chars 3504 - 3563 [(destruct~fX~as~[[|~n]~e];~ref...] 0. secs (0.u,0.s)
Chars 3568 - 3574 [right.] 0. secs (0.u,0.s)
Chars 3579 - 3620 [(intros~x;~strip_truncations;~...] 0. secs (0.u,0.s)
Chars 3625 - 3630 [left.] 0. secs (0.u,0.s)
Chars 3635 - 3681 [(strip_truncations;~exact~(tr~...] 0. secs (0.u,0.s)
Chars 3682 - 3690 [Defined.] 0.003 secs (0.002u,0.s)
Chars 3741 - 3813 [#[global]Instance~finite_paths...] 0. secs (0.u,0.s)
Chars 3814 - 3820 [Proof.] 0. secs (0.u,0.s)
Chars 5389 - 5398 [(intros~g).] 40.203 secs (0.001u,0.04s)
Chars 5401 - 5439 [(unfold~grouphom_fun,~grouphom...] 0.001 secs (0.001u,0.s)
Chars 5442 - 5492 [refine~(pointed_htpy~(fmap_com...] 0.016 secs (0.011u,0.s)
Chars 5495 - 5533 [(pose~(p~:=~eisretr~(loops_gro...] 0.016 secs (0.015u,0.s)
Chars 5536 - 5738 [(change~~~~(fmap~loops~(group_...] 0.02 secs (0.018u,0.001s)
Chars 5741 - 5754 [(rewrite~<-~p).] 0.005 secs (0.004u,0.s)
Chars 5757 - 5786 [(rewrite~!loops_functor_group).] 1.061 secs (0.998u,0.06s)
Chars 5789 - 5798 [(apply~ap).] 0.002 secs (0.002u,0.s)
Chars 2606 - 2640 [(hnf;~intros;~apply~pos_eq,~mu...] 40.2 secs (0.004u,0.044s)
Chars 2606 - 2640 [(hnf;~intros;~apply~pos_eq,~mu...] 0.001 secs (0.001u,0.s)
Chars 2641 - 2645 [Qed.] 0. secs (0.u,0.s)
Chars 2647 - 2690 [#[global]Instance~pos_recip@{}...] 0. secs (0.u,0.s)
Chars 2691 - 2697 [Proof.] 0. secs (0.u,0.s)
Chars 5801 - 5836 [(symmetry;~rapply~(fmap_comp~l...] 0.195 secs (0.193u,0.001s)
Chars 5389 - 5398 [(intros~g).] 0. secs (0.u,0.s)
Chars 5401 - 5439 [(unfold~grouphom_fun,~grouphom...] 0. secs (0.u,0.s)
Chars 5442 - 5492 [refine~(pointed_htpy~(fmap_com...] 0. secs (0.u,0.s)
Chars 5495 - 5533 [(pose~(p~:=~eisretr~(loops_gro...] 0. secs (0.u,0.s)
Chars 5536 - 5738 [(change~~~~(fmap~loops~(group_...] 0.001 secs (0.001u,0.s)
Chars 5741 - 5754 [(rewrite~<-~p).] 0.001 secs (0.001u,0.s)
Chars 5757 - 5786 [(rewrite~!loops_functor_group).] 0.001 secs (0.001u,0.s)
Chars 5789 - 5798 [(apply~ap).] 0. secs (0.u,0.s)
Chars 5801 - 5836 [(symmetry;~rapply~(fmap_comp~l...] 0.001 secs (0.001u,0.s)
Chars 5837 - 5841 [Qed.] 0.017 secs (0.017u,0.s)
Chars 5843 - 5916 [Definition~grouphom_idmap~(G~:...] 0. secs (0.u,0.s)
Chars 5918 - 6043 [Definition~group_loops_functor...] 0.003 secs (0.003u,0.s)
Chars 6044 - 6050 [Proof.] 0. secs (0.u,0.s)
Chars 2698 - 2707 [(intros~e).] 0.149 secs (0.u,0.041s)
Chars 2708 - 2723 [exists~(/~'~e).] 0.002 secs (0.002u,0.s)
Chars 2724 - 2751 [(apply~pos_dec_recip_compat).] 0.009 secs (0.005u,0.003s)
Chars 2752 - 2768 [solve_propholds.] 0.001 secs (0.001u,0.s)
Chars 2698 - 2707 [(intros~e).] 0. secs (0.u,0.s)
Chars 2708 - 2723 [exists~(/~'~e).] 0. secs (0.u,0.s)
Chars 2724 - 2751 [(apply~pos_dec_recip_compat).] 0. secs (0.u,0.s)
Chars 2752 - 2768 [solve_propholds.] 0. secs (0.u,0.s)
Chars 2769 - 2777 [Defined.] 0. secs (0.u,0.s)
Chars 2779 - 2823 [#[global]Instance~pos_of_nat@{...] 0. secs (0.u,0.s)
Chars 2824 - 2830 [Proof.] 0. secs (0.u,0.s)
Chars 2831 - 2840 [(intros~n).] 0.151 secs (0.001u,0.04s)
Chars 2841 - 2860 [(destruct~n~as~[|~k]).] 0.001 secs (0.001u,0.s)
Chars 2861 - 2862 [-] 0. secs (0.u,0.s)
Chars 2863 - 2885 [(exists~1;~apply~lt_0_1).] 0.013 secs (0.012u,0.s)
Chars 2886 - 2887 [-] 0. secs (0.u,0.s)
Chars 2888 - 2930 [exists~(naturals_to_semiring~n...] 0.008 secs (0.008u,0.s)
Chars 2933 - 2956 [(induction~k~as~[|~k~Ik]).] 0.002 secs (0.001u,0.s)
Chars 2959 - 2960 [+] 0. secs (0.u,0.s)
Chars 2961 - 2976 [(change~(0~<~1)).] 0.003 secs (0.002u,0.s)
Chars 2977 - 2990 [(apply~lt_0_1).] 0.04 secs (0.031u,0.008s)
Chars 2993 - 2994 [+] 0. secs (0.u,0.s)
Chars 2995 - 3045 [(change~(0~<~1~+~naturals_to_s...] 0.01 secs (0.007u,0.002s)
Chars 3050 - 3111 [(set~(K~:=~naturals_to_semirin...] 0.007 secs (0.006u,0.s)
Chars 3116 - 3138 [(apply~pos_plus_compat).] 0.014 secs (0.013u,0.s)
Chars 3143 - 3144 [*] 0. secs (0.u,0.s)
Chars 3145 - 3158 [(apply~lt_0_1).] 0.013 secs (0.011u,0.001s)
Chars 3163 - 3164 [*] 0. secs (0.u,0.s)
Chars 3165 - 3173 [trivial.] 0.001 secs (0.001u,0.s)
Chars 2831 - 2840 [(intros~n).] 0. secs (0.u,0.s)
Chars 2841 - 2860 [(destruct~n~as~[|~k]).] 0. secs (0.u,0.s)
Chars 2863 - 2885 [(exists~1;~apply~lt_0_1).] 0.001 secs (0.001u,0.s)
Chars 2888 - 2930 [exists~(naturals_to_semiring~n...] 0. secs (0.u,0.s)
Chars 2933 - 2956 [(induction~k~as~[|~k~Ik]).] 0.001 secs (0.001u,0.s)
Chars 2961 - 2976 [(change~(0~<~1)).] 0. secs (0.u,0.s)
Chars 2977 - 2990 [(apply~lt_0_1).] 0. secs (0.u,0.s)
Chars 2995 - 3045 [(change~(0~<~1~+~naturals_to_s...] 0.001 secs (0.001u,0.s)
Chars 3050 - 3111 [(set~(K~:=~naturals_to_semirin...] 0.002 secs (0.002u,0.s)
Chars 3116 - 3138 [(apply~pos_plus_compat).] 0. secs (0.u,0.s)
Chars 3145 - 3158 [(apply~lt_0_1).] 0. secs (0.u,0.s)
Chars 3165 - 3173 [trivial.] 0. secs (0.u,0.s)
Chars 3174 - 3182 [Defined.] 0.001 secs (0.001u,0.s)
Chars 3184 - 3232 [Lemma~pos_recip_r@{}~:~forall~...] 0.001 secs (0.001u,0.s)
Chars 3233 - 3239 [Proof.] 0. secs (0.u,0.s)
Chars 2489 - 2517 [rapply~equiv_pi1bouquet_rec.] 40.249 secs (0.009u,0.053s)
Chars 2522 - 2540 [(apply~grp_homo_id).] 0. secs (0.u,0.s)
Chars 2489 - 2517 [rapply~equiv_pi1bouquet_rec.] 0. secs (0.u,0.s)
Chars 2522 - 2540 [(apply~grp_homo_id).] 0. secs (0.u,0.s)
Chars 2543 - 2551 [Defined.] 0.001 secs (0.u,0.001s)
Chars 2626 - 2739 [#[global]~Instance~isfreegroup...] 0.005 secs (0.004u,0.001s)
Chars 2742 - 2748 [Proof.] 0. secs (0.u,0.s)
Chars 2395 - 2403 [intro~x.] 40.228 secs (0.u,0.051s)
Chars 2408 - 2449 [exact~(tr~(merid~x~@~(merid~mo...] 0.006 secs (0.006u,0.s)
Chars 2395 - 2403 [intro~x.] 0. secs (0.u,0.s)
Chars 2408 - 2449 [exact~(tr~(merid~x~@~(merid~mo...] 0. secs (0.u,0.s)
Chars 2452 - 2460 [Defined.] 0. secs (0.u,0.s)
Chars 2464 - 2592 [#[local]~Definition~transport_...] 0.006 secs (0.005u,0.s)
Chars 2595 - 2601 [Proof.] 0. secs (0.u,0.s)
Chars 4704 - 4729 [(induction~n~as~[|~n~IHn]).] 40.152 secs (0.u,0.037s)
Chars 4732 - 4733 [-] 0. secs (0.u,0.s)
Chars 4734 - 4746 [reflexivity.] 0. secs (0.u,0.s)
Chars 4749 - 4750 [-] 0. secs (0.u,0.s)
Chars 4751 - 4772 [exact~(ap~fsucc~IHn).] 0.001 secs (0.001u,0.s)
Chars 4704 - 4729 [(induction~n~as~[|~n~IHn]).] 0. secs (0.u,0.s)
Chars 4734 - 4746 [reflexivity.] 0. secs (0.u,0.s)
Chars 4751 - 4772 [exact~(ap~fsucc~IHn).] 0. secs (0.u,0.s)
Chars 4773 - 4781 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4783 - 4883 [Lemma~path_finnat_to_fin_to_fi...] 0. secs (0.u,0.s)
Chars 4884 - 4890 [Proof.] 0. secs (0.u,0.s)
Chars 21513 - 21536 [generalize~dependent~A.] 40.113 secs (0.u,0.02s)
Chars 21539 - 21576 [(induction~n;~simpl;~intros~A~...] 0.002 secs (0.002u,0.s)
Chars 21579 - 21580 [{] 0. secs (0.u,0.s)
Chars 21581 - 21622 [exists~(center~A;~center~(P~(c...] 0.002 secs (0.002u,0.s)
Chars 21627 - 21640 [(intros~[a~?]).] 0.001 secs (0.001u,0.s)
Chars 21645 - 21695 [refine~(path_sigma'~P~(contr~a...] 0.002 secs (0.002u,0.s)
Chars 21696 - 21697 [}] 0. secs (0.u,0.s)
Chars 21700 - 21711 [(intros~u~v).] 0. secs (0.u,0.s)
Chars 21714 - 21778 [refine~(istrunc_isequiv_istrun...] 0.008 secs (0.008u,0.s)
Chars 21513 - 21536 [generalize~dependent~A.] 0. secs (0.u,0.s)
Chars 21539 - 21576 [(induction~n;~simpl;~intros~A~...] 0.001 secs (0.001u,0.s)
Chars 21581 - 21622 [exists~(center~A;~center~(P~(c...] 0. secs (0.u,0.s)
Chars 21627 - 21640 [(intros~[a~?]).] 0. secs (0.u,0.s)
Chars 21645 - 21695 [refine~(path_sigma'~P~(contr~a...] 0. secs (0.u,0.s)
Chars 21700 - 21711 [(intros~u~v).] 0. secs (0.u,0.s)
Chars 21714 - 21778 [refine~(istrunc_isequiv_istrun...] 0. secs (0.u,0.s)
Chars 21779 - 21787 [Defined.] 0.002 secs (0.002u,0.s)
Chars 21863 - 22015 [Definition~ishprop_sigma_disjo...] 0.001 secs (0.001u,0.s)
Chars 22016 - 22022 [Proof.] 0. secs (0.u,0.s)
Chars 11716 - 11794 [(revert~P;~simple_induction~n~...] 40.158 secs (0.007u,0.027s)
Chars 11799 - 11800 [-] 0. secs (0.u,0.s)
Chars 11801 - 11810 [(intros~h).] 0. secs (0.u,0.s)
Chars 11817 - 11859 [(exists~(fst~extgf~(h~oD~f)).1...] 0.004 secs (0.004u,0.s)
Chars 11866 - 11940 [(refine~((fst~(snd~extf~((fst~...] 0.006 secs (0.004u,0.001s)
Chars 11947 - 11978 [(apply~(fst~extgf~(h~oD~f)).2).] 0.003 secs (0.003u,0.s)
Chars 11983 - 11984 [-] 0. secs (0.u,0.s)
Chars 11985 - 11996 [(intros~h~k).] 0.001 secs (0.u,0.001s)
Chars 12003 - 12013 [(apply~IHn).] 0.001 secs (0.u,0.s)
Chars 12020 - 12021 [+] 0. secs (0.u,0.s)
Chars 12022 - 12057 [(apply~(snd~extf~(h~oD~g)~(k~o...] 0.003 secs (0.003u,0.s)
Chars 12064 - 12065 [+] 0. secs (0.u,0.s)
Chars 12066 - 12088 [(apply~(snd~extgf~h~k)).] 0.002 secs (0.001u,0.s)
Chars 11716 - 11794 [(revert~P;~simple_induction~n~...] 0.002 secs (0.u,0.001s)
Chars 11801 - 11810 [(intros~h).] 0. secs (0.u,0.s)
Chars 11817 - 11859 [(exists~(fst~extgf~(h~oD~f)).1...] 0.001 secs (0.001u,0.s)
Chars 11866 - 11940 [(refine~((fst~(snd~extf~((fst~...] 0.001 secs (0.001u,0.s)
Chars 11947 - 11978 [(apply~(fst~extgf~(h~oD~f)).2).] 0. secs (0.u,0.s)
Chars 11985 - 11996 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 12003 - 12013 [(apply~IHn).] 0. secs (0.u,0.s)
Chars 12022 - 12057 [(apply~(snd~extf~(h~oD~g)~(k~o...] 0. secs (0.u,0.s)
Chars 12066 - 12088 [(apply~(snd~extgf~h~k)).] 0. secs (0.u,0.s)
Chars 12091 - 12099 [Defined.] 0.003 secs (0.002u,0.s)
Chars 12143 - 12317 [Definition~extendable_homotopi...] 0.001 secs (0.001u,0.s)
Chars 12320 - 12326 [Proof.] 0. secs (0.u,0.s)
Chars 12435 - 12446 [(destruct~s).] 40.16 secs (0.006u,0.031s)
Chars 12449 - 12462 [(apply~cu_GG1).] 0.009 secs (0.009u,0.s)
Chars 12435 - 12446 [(destruct~s).] 0.001 secs (0.001u,0.s)
Chars 12449 - 12462 [(apply~cu_GG1).] 0.001 secs (0.001u,0.s)
Chars 12463 - 12471 [Defined.] 0.005 secs (0.005u,0.s)
Chars 12473 - 12503 [Notation~cu_ds~:=~equiv_cu_ds.] 0. secs (0.u,0.s)
Chars 12561 - 13033 [Definition~equiv_dp_cu~{A~B~:~...] 0.028 secs (0.025u,0.003s)
Chars 13034 - 13040 [Proof.] 0. secs (0.u,0.s)
Chars 2776 - 2793 [(split;~intros~E1).] 40.169 secs (0.004u,0.034s)
Chars 2794 - 2795 [-] 0. secs (0.u,0.s)
Chars 2796 - 2915 [(destruct~(int_abs_spec~x)~as~...] 0.036 secs (0.031u,0.004s)
Chars 2916 - 2917 [-] 0. secs (0.u,0.s)
Chars 2918 - 2953 [(rewrite~E1,~<-~(preserves_0~(...] 0.006 secs (0.006u,0.s)
Chars 2954 - 2972 [(apply~int_abs_nat).] 0.002 secs (0.002u,0.s)
Chars 2776 - 2793 [(split;~intros~E1).] 0.003 secs (0.001u,0.001s)
Chars 2796 - 2915 [(destruct~(int_abs_spec~x)~as~...] 0.008 secs (0.006u,0.s)
Chars 2918 - 2953 [(rewrite~E1,~<-~(preserves_0~(...] 0.014 secs (0.01u,0.004s)
Chars 2954 - 2972 [(apply~int_abs_nat).] 0.001 secs (0.001u,0.s)
Chars 2973 - 2977 [Qed.] 0.006 secs (0.004u,0.001s)
Chars 2979 - 3032 [Lemma~int_abs_ne_0~x~:~int_abs...] 0.039 secs (0.034u,0.005s)
Chars 3033 - 3039 [Proof.] 0. secs (0.u,0.s)
Chars 5654 - 5678 [(exists~(A~<~>~B);~split).] 40.167 secs (0.002u,0.034s)
Chars 5681 - 5682 [-] 0. secs (0.u,0.s)
Chars 5683 - 5691 [exact~_.] 0.026 secs (0.019u,0.006s)
Chars 5694 - 5695 [-] 0. secs (0.u,0.s)
Chars 5696 - 5733 [refine~(equiv_path_TypeO~O~A~B...] 0.002 secs (0.002u,0.s)
Chars 5738 - 5764 [(apply~equiv_path_universe).] 0.001 secs (0.001u,0.s)
Chars 5654 - 5678 [(exists~(A~<~>~B);~split).] 0. secs (0.u,0.s)
Chars 5683 - 5691 [exact~_.] 0. secs (0.u,0.s)
Chars 5696 - 5733 [refine~(equiv_path_TypeO~O~A~B...] 0. secs (0.u,0.s)
Chars 5738 - 5764 [(apply~equiv_path_universe).] 0. secs (0.u,0.s)
Chars 5765 - 5773 [Defined.] 0.001 secs (0.u,0.s)
Chars 5801 - 5955 [#[global]~Instance~inSepO_sigm...] 0.001 secs (0.u,0.001s)
Chars 5956 - 5962 [Proof.] 0. secs (0.u,0.s)
Chars 4086 - 4119 [(pose~proof~(merely_equiv_fin~...] 40.184 secs (0.u,0.036s)
Chars 4122 - 4140 [strip_truncations.] 0.053 secs (0.053u,0.s)
Chars 4143 - 4179 [refine~(finite_equiv~_~(ap~e)^...] 0.099 secs (0.08u,0.018s)
Chars 4182 - 4220 [(apply~finite_decidable_hprop;...] 0.073 secs (0.068u,0.004s)
Chars 4086 - 4119 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 4122 - 4140 [strip_truncations.] 0. secs (0.u,0.s)
Chars 4143 - 4179 [refine~(finite_equiv~_~(ap~e)^...] 0. secs (0.u,0.s)
Chars 4182 - 4220 [(apply~finite_decidable_hprop;...] 0. secs (0.u,0.s)
Chars 4221 - 4229 [Defined.] 0.002 secs (0.002u,0.s)
Chars 4285 - 4347 [#[global]Instance~finite_succ~...] 0. secs (0.u,0.s)
Chars 4348 - 4354 [Proof.] 0. secs (0.u,0.s)
Chars 6053 - 6062 [(intros~g).] 40.216 secs (0.u,0.043s)
Chars 6065 - 6096 [refine~(fmap_id~loops~_~g~@~_).] 0.009 secs (0.007u,0.001s)
Chars 6099 - 6138 [(rewrite~<-~(eisretr~(loops_gr...] 0.018 secs (0.014u,0.003s)
Chars 6141 - 6177 [(unfold~grouphom_fun,~grouphom...] 0.001 secs (0.001u,0.s)
Chars 3240 - 3260 [(intros;~apply~pos_eq).] 40.194 secs (0.002u,0.041s)
Chars 3261 - 3299 [(unfold~dec_recip,~cast,~pos_r...] 0.003 secs (0.003u,0.s)
Chars 3300 - 3323 [(change~('~e~/~'~e~=~1)).] 0.007 secs (0.006u,0.s)
Chars 3324 - 3348 [(apply~dec_recip_inverse).] 0.004 secs (0.004u,0.s)
Chars 3349 - 3366 [(apply~lt_ne_flip).] 0.01 secs (0.007u,0.002s)
Chars 3367 - 3383 [solve_propholds.] 0.001 secs (0.001u,0.s)
Chars 3240 - 3260 [(intros;~apply~pos_eq).] 0.001 secs (0.001u,0.s)
Chars 3261 - 3299 [(unfold~dec_recip,~cast,~pos_r...] 0.002 secs (0.002u,0.s)
Chars 3300 - 3323 [(change~('~e~/~'~e~=~1)).] 0.001 secs (0.001u,0.s)
Chars 3324 - 3348 [(apply~dec_recip_inverse).] 0. secs (0.u,0.s)
Chars 3349 - 3366 [(apply~lt_ne_flip).] 0. secs (0.u,0.s)
Chars 3367 - 3383 [solve_propholds.] 0. secs (0.u,0.s)
Chars 3384 - 3388 [Qed.] 0.001 secs (0.u,0.001s)
Chars 3390 - 3452 [Lemma~pos_recip_r'@{}~:~forall...] 0.002 secs (0.002u,0.s)
Chars 3453 - 3459 [Proof.] 0. secs (0.u,0.s)
Chars 6180 - 6209 [(rewrite~!loops_functor_group).] 0.429 secs (0.391u,0.034s)
Chars 6212 - 6260 [exact~(ap~(loops_group~X)~(fma...] 0.049 secs (0.049u,0.s)
Chars 6053 - 6062 [(intros~g).] 0. secs (0.u,0.s)
Chars 6065 - 6096 [refine~(fmap_id~loops~_~g~@~_).] 0. secs (0.u,0.s)
Chars 6099 - 6138 [(rewrite~<-~(eisretr~(loops_gr...] 0. secs (0.u,0.s)
Chars 6141 - 6177 [(unfold~grouphom_fun,~grouphom...] 0. secs (0.u,0.s)
Chars 6180 - 6209 [(rewrite~!loops_functor_group).] 0. secs (0.u,0.s)
Chars 6212 - 6260 [exact~(ap~(loops_group~X)~(fma...] 0. secs (0.u,0.s)
Chars 6261 - 6265 [Qed.] 0.015 secs (0.012u,0.002s)
Chars 6482 - 6727 [Ltac~~grouphom_reduce~:=~~~unf...] 0. secs (0.u,0.s)
Chars 6729 - 6872 [Definition~compose_grouphom~{G...] 0.002 secs (0.002u,0.s)
Chars 6873 - 6879 [Proof.] 0. secs (0.u,0.s)
Chars 3460 - 3467 [(intros).] 0.518 secs (0.001u,0.041s)
Chars 3468 - 3491 [(change~('~(e~/~e)~=~1)).] 0.003 secs (0.001u,0.001s)
Chars 3492 - 3512 [(rewrite~pos_recip_r).] 0.001 secs (0.001u,0.s)
Chars 3513 - 3525 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 3460 - 3467 [(intros).] 0.001 secs (0.u,0.s)
Chars 3468 - 3491 [(change~('~(e~/~e)~=~1)).] 0. secs (0.u,0.s)
Chars 3492 - 3512 [(rewrite~pos_recip_r).] 0. secs (0.u,0.s)
Chars 3513 - 3525 [reflexivity.] 0. secs (0.u,0.s)
Chars 3526 - 3530 [Qed.] 0. secs (0.u,0.s)
Chars 3532 - 3581 [Lemma~pos_mult_1_r@{}~:~forall...] 0. secs (0.u,0.s)
Chars 3582 - 3588 [Proof.] 0. secs (0.u,0.s)
Chars 2753 - 2794 [(apply~equiv_isfregroupon_iseq...] 40.256 secs (0.008u,0.053s)
Chars 2799 - 2807 [intro~G.] 0. secs (0.u,0.s)
Chars 2812 - 2840 [snrapply~isequiv_homotopic'.] 0.003 secs (0.003u,0.s)
Chars 2845 - 2875 [1:~(apply~equiv_pi1bouquet_rec).] 0.002 secs (0.002u,0.s)
Chars 2880 - 2889 [(intros~f).] 0. secs (0.u,0.s)
Chars 2894 - 2960 [refine~(_~@~@is1natural_equiv_...] 0.006 secs (0.006u,0.s)
Chars 2965 - 2987 [(simpl;~f_ap;~symmetry).] 0.088 secs (0.069u,0.019s)
Chars 2992 - 3018 [rapply~(cat_idr_strong~f).] 0.232 secs (0.185u,0.046s)
Chars 2753 - 2794 [(apply~equiv_isfregroupon_iseq...] 0. secs (0.u,0.s)
Chars 2799 - 2807 [intro~G.] 0. secs (0.u,0.s)
Chars 2812 - 2840 [snrapply~isequiv_homotopic'.] 0. secs (0.u,0.s)
Chars 2845 - 2875 [1:~(apply~equiv_pi1bouquet_rec).] 0. secs (0.u,0.s)
Chars 2880 - 2889 [(intros~f).] 0. secs (0.u,0.s)
Chars 2894 - 2960 [refine~(_~@~@is1natural_equiv_...] 0. secs (0.u,0.s)
Chars 2965 - 2987 [(simpl;~f_ap;~symmetry).] 0.001 secs (0.001u,0.s)
Chars 2992 - 3018 [rapply~(cat_idr_strong~f).] 0. secs (0.u,0.s)
Chars 3021 - 3029 [Defined.] 0.141 secs (0.138u,0.002s)
Chars 3031 - 3052 [End~AssumeUnivalence.] 0.023 secs (0.023u,0.s)
Chars 2606 - 2615 [(unfold~P).] 40.23 secs (0.u,0.052s)
Chars 2620 - 2635 [(unfold~decode').] 0.002 secs (0.002u,0.s)
Chars 2640 - 2666 [(rewrite~transport_compose).] 0.006 secs (0.006u,0.s)
Chars 2671 - 2692 [(generalize~(merid~x)).] 0.004 secs (0.004u,0.s)
Chars 2697 - 2738 [(generalize~(merid~y~@~(merid~...] 0.008 secs (0.007u,0.s)
Chars 2743 - 2755 [(intros~p~[]).] 0.003 secs (0.003u,0.s)
Chars 2760 - 2774 [(cbn;~apply~ap).] 0.004 secs (0.004u,0.s)
Chars 2779 - 2788 [symmetry.] 0.003 secs (0.003u,0.s)
Chars 2793 - 2809 [(apply~concat_p1).] 0.001 secs (0.001u,0.s)
Chars 2606 - 2615 [(unfold~P).] 0.001 secs (0.001u,0.s)
Chars 2620 - 2635 [(unfold~decode').] 0.001 secs (0.001u,0.s)
Chars 2640 - 2666 [(rewrite~transport_compose).] 0.001 secs (0.001u,0.s)
Chars 2671 - 2692 [(generalize~(merid~x)).] 0.001 secs (0.001u,0.s)
Chars 2697 - 2738 [(generalize~(merid~y~@~(merid~...] 0.001 secs (0.u,0.s)
Chars 2743 - 2755 [(intros~p~[]).] 0.001 secs (0.001u,0.s)
Chars 2760 - 2774 [(cbn;~apply~ap).] 0.002 secs (0.001u,0.s)
Chars 2779 - 2788 [symmetry.] 0. secs (0.u,0.s)
Chars 2793 - 2809 [(apply~concat_p1).] 0. secs (0.u,0.s)
Chars 2812 - 2820 [Defined.] 0.007 secs (0.005u,0.001s)
Chars 2824 - 2895 [#[local]Definition~encode_Nort...] 0.001 secs (0.001u,0.s)
Chars 2898 - 2904 [Proof.] 0. secs (0.u,0.s)
Chars 4893 - 4918 [(induction~n~as~[|~n~IHn]).] 40.187 secs (0.001u,0.036s)
Chars 4921 - 4922 [-] 0. secs (0.u,0.s)
Chars 4923 - 4947 [(elim~(not_lt_n_0~_~u.2)).] 0.001 secs (0.001u,0.s)
Chars 4950 - 4951 [-] 0. secs (0.u,0.s)
Chars 4952 - 4972 [(destruct~u~as~[x~h]).] 0.001 secs (0.001u,0.s)
Chars 4977 - 5000 [(apply~path_sigma_hprop).] 0.006 secs (0.005u,0.s)
Chars 5005 - 5025 [(destruct~x~as~[|~x]).] 0.002 secs (0.002u,0.s)
Chars 5030 - 5031 [+] 0. secs (0.u,0.s)
Chars 5032 - 5079 [exact~(ap~pr1~(path_fin_to_fin...] 0.004 secs (0.004u,0.s)
Chars 5084 - 5085 [+] 0. secs (0.u,0.s)
Chars 5086 - 5131 [refine~((path_fin_to_finnat_fs...] 0.003 secs (0.002u,0.s)
Chars 5138 - 5179 [exact~(ap~S~(IHn~(x;~leq_S_n~_...] 0.003 secs (0.002u,0.s)
Chars 4893 - 4918 [(induction~n~as~[|~n~IHn]).] 0. secs (0.u,0.s)
Chars 4923 - 4947 [(elim~(not_lt_n_0~_~u.2)).] 0. secs (0.u,0.s)
Chars 4952 - 4972 [(destruct~u~as~[x~h]).] 0. secs (0.u,0.s)
Chars 4977 - 5000 [(apply~path_sigma_hprop).] 0. secs (0.u,0.s)
Chars 5005 - 5025 [(destruct~x~as~[|~x]).] 0. secs (0.u,0.s)
Chars 5032 - 5079 [exact~(ap~pr1~(path_fin_to_fin...] 0. secs (0.u,0.s)
Chars 5086 - 5131 [refine~((path_fin_to_finnat_fs...] 0. secs (0.u,0.s)
Chars 5138 - 5179 [exact~(ap~S~(IHn~(x;~leq_S_n~_...] 0.001 secs (0.001u,0.s)
Chars 5180 - 5188 [Defined.] 0.009 secs (0.009u,0.s)
Chars 5190 - 5284 [Lemma~path_fin_to_finnat_to_fi...] 0. secs (0.u,0.s)
Chars 5285 - 5291 [Proof.] 0. secs (0.u,0.s)
Chars 22025 - 22078 [(intros~dj;~apply~hprop_allpat...] 40.122 secs (0.002u,0.022s)
Chars 22081 - 22121 [refine~(path_sigma'~P~(dj~x~y~...] 0.001 secs (0.001u,0.s)
Chars 22124 - 22143 [(apply~path_ishprop).] 0.001 secs (0.001u,0.s)
Chars 22025 - 22078 [(intros~dj;~apply~hprop_allpat...] 0.001 secs (0.001u,0.s)
Chars 22081 - 22121 [refine~(path_sigma'~P~(dj~x~y~...] 0. secs (0.u,0.s)
Chars 22124 - 22143 [(apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 22144 - 22152 [Defined.] 0.001 secs (0.u,0.s)
Chars 22308 - 22488 [Definition~path_sigma_hprop~{A...] 0.007 secs (0.006u,0.s)
Chars 22490 - 22649 [#[global]~Instance~isequiv_pat...] 0.006 secs (0.006u,0.s)
Chars 22651 - 22723 [#[export]Hint~Immediate~isequi...] 0. secs (0.u,0.s)
Chars 22725 - 22914 [Definition~equiv_path_sigma_hp...] 0.006 secs (0.006u,0.s)
Chars 22916 - 23092 [Definition~isequiv_pr1_path_hp...] 0.019 secs (0.018u,0.001s)
Chars 23094 - 23164 [#[export]Hint~Immediate~isequi...] 0.015 secs (0.012u,0.002s)
Chars 23229 - 23376 [Definition~isequiv_ap_pr1_hpro...] 0.004 secs (0.004u,0.s)
Chars 23419 - 23555 [Definition~path_sigma_hprop_1~...] 0.001 secs (0.001u,0.s)
Chars 23556 - 23562 [Proof.] 0. secs (0.u,0.s)
H11
H13
H13
Chars 12331 - 12403 [(revert~C;~simple_induction~n~...] 40.153 secs (0.005u,0.028s)
Chars 12408 - 12409 [-] 0. secs (0.u,0.s)
Chars 12410 - 12419 [(intros~h).] 0. secs (0.u,0.s)
Chars 12426 - 12482 [(exists~(fst~extf~(fun~a~=>~(p...] 0.004 secs (0.003u,0.s)
Chars 12489 - 12554 [refine~((apD~(fst~extf~(fun~a~...] 0.005 secs (0.004u,0.001s)
Chars 12561 - 12585 [(apply~moveR_transport_p).] 0.002 secs (0.002u,0.s)
Chars 12592 - 12639 [exact~((fst~extf~(fun~a~=>~(p~...] 0.003 secs (0.003u,0.s)
Chars 12644 - 12645 [-] 0. secs (0.u,0.s)
Chars 12646 - 12657 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 12664 - 12690 [(apply~IHn,~(snd~extf~h~k)).] 0.002 secs (0.002u,0.s)
Chars 12331 - 12403 [(revert~C;~simple_induction~n~...] 0.002 secs (0.001u,0.001s)
Chars 12410 - 12419 [(intros~h).] 0. secs (0.u,0.s)
Chars 12426 - 12482 [(exists~(fst~extf~(fun~a~=>~(p...] 0.001 secs (0.u,0.s)
Chars 12489 - 12554 [refine~((apD~(fst~extf~(fun~a~...] 0. secs (0.u,0.s)
Chars 12561 - 12585 [(apply~moveR_transport_p).] 0. secs (0.u,0.s)
Chars 12592 - 12639 [exact~((fst~extf~(fun~a~=>~(p~...] 0. secs (0.u,0.s)
Chars 12646 - 12657 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 12664 - 12690 [(apply~IHn,~(snd~extf~h~k)).] 0. secs (0.u,0.s)
Chars 12693 - 12701 [Defined.] 0.003 secs (0.003u,0.s)
Chars 12747 - 12883 [Definition~extendable_equiv~(n...] 0. secs (0.u,0.s)
Chars 12886 - 12892 [Proof.] 0. secs (0.u,0.s)
Chars 13043 - 13078 [(destruct~p;~symmetry;~exact~c...] 40.166 secs (0.016u,0.03s)
Chars 13043 - 13078 [(destruct~p;~symmetry;~exact~c...] 0.004 secs (0.004u,0.s)
Chars 13079 - 13087 [Defined.] 0.008 secs (0.007u,0.s)
Chars 13089 - 13119 [Notation~dp_cu~:=~equiv_dp_cu.] 0. secs (0.u,0.s)
Chars 13174 - 13904 [Definition~equiv_cu_flip_lr~{A...] 0.06 secs (0.049u,0.01s)
Chars 13905 - 13911 [Proof.] 0. secs (0.u,0.s)
Chars 3040 - 3067 [(destruct~(int_abs_0_alt~x)).] 40.178 secs (0.004u,0.034s)
Chars 3068 - 3092 [(split;~intros~E1~E2;~auto).] 0.012 secs (0.01u,0.001s)
Chars 3040 - 3067 [(destruct~(int_abs_0_alt~x)).] 0.001 secs (0.001u,0.s)
Chars 3068 - 3092 [(split;~intros~E1~E2;~auto).] 0.008 secs (0.006u,0.001s)
Chars 3093 - 3097 [Qed.] 0.003 secs (0.002u,0.s)
Chars 3099 - 3135 [Lemma~int_abs_0~:~int_abs~Z~N~...] 0.039 secs (0.032u,0.006s)
Chars 3136 - 3142 [Proof.] 0. secs (0.u,0.s)
Chars 4357 - 4396 [refine~(Build_Finite~_~(fcard~...] 29.283 secs (17.911u,-0.252s)
Chars 3143 - 3171 [(apply~int_abs_0_alt;~trivial).] 1.089 secs (0.004u,0.034s)
Chars 3143 - 3171 [(apply~int_abs_0_alt;~trivial).] 0.002 secs (0.001u,0.001s)
Chars 3172 - 3176 [Qed.] 0.001 secs (0.001u,0.s)
Chars 3178 - 3238 [Lemma~int_abs_nonneg~x~:~0~≤~x...] 0.041 secs (0.036u,0.003s)
Chars 3239 - 3245 [Proof.] 0. secs (0.u,0.s)
Chars 5965 - 5976 [(intros~u~v).] 40.164 secs (0.001u,0.034s)
Chars 5979 - 6030 [refine~(inO_equiv_inO'~_~(equi...] 0.144 secs (0.132u,0.011s)
Chars 5965 - 5976 [(intros~u~v).] 0. secs (0.u,0.s)
Chars 5979 - 6030 [refine~(inO_equiv_inO'~_~(equi...] 0. secs (0.u,0.s)
Chars 6031 - 6039 [Defined.] 0.001 secs (0.001u,0.s)
Chars 6096 - 6221 [#[global]~Instance~reflectsD_S...] 0.001 secs (0.001u,0.s)
Chars 6222 - 6228 [Proof.] 0. secs (0.u,0.s)
Chars 4357 - 4396 [refine~(Build_Finite~_~(fcard~...] 40.068 secs (0.001u,0.033s)
Chars 4399 - 4431 [(pose~proof~(merely_equiv_fin~...] 0.001 secs (0.001u,0.s)
Chars 4434 - 4462 [(strip_truncations;~apply~tr).] 0.024 secs (0.022u,0.001s)
Chars 4465 - 4493 [(refine~(_~+E~1);~assumption).] 0.002 secs (0.001u,0.s)
Chars 4357 - 4396 [refine~(Build_Finite~_~(fcard~...] 0. secs (0.u,0.s)
Chars 4399 - 4431 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 4434 - 4462 [(strip_truncations;~apply~tr).] 0. secs (0.u,0.s)
Chars 4465 - 4493 [(refine~(_~+E~1);~assumption).] 0. secs (0.u,0.s)
Chars 4494 - 4502 [Defined.] 0.002 secs (0.001u,0.s)
Chars 4504 - 4581 [Definition~fcard_succ~X~`{Fini...] 0.002 secs (0.001u,0.001s)
Chars 4679 - 4760 [#[global]~Instance~decidablepa...] 0. secs (0.u,0.s)
Chars 4761 - 4767 [Proof.] 0. secs (0.u,0.s)
Chars 6882 - 6908 [(intros~g;~grouphom_reduce).] 40.316 secs (0.081u,0.058s)
Chars 6911 - 6940 [exact~(ap_compose~phi~psi~g).] 0.002 secs (0.002u,0.s)
Chars 6882 - 6908 [(intros~g;~grouphom_reduce).] 0. secs (0.u,0.s)
Chars 6911 - 6940 [exact~(ap_compose~phi~psi~g).] 0. secs (0.u,0.s)
Chars 6941 - 6945 [Qed.] 0.036 secs (0.026u,0.003s)
Chars 6947 - 7015 [Definition~idmap_grouphom~(G~:...] 0. secs (0.u,0.s)
Chars 7016 - 7022 [Proof.] 0. secs (0.u,0.s)
Chars 3589 - 3609 [(intros;~apply~pos_eq).] 40.192 secs (0.u,0.044s)
Chars 3610 - 3625 [(apply~mult_1_r).] 0.006 secs (0.006u,0.s)
Chars 3589 - 3609 [(intros;~apply~pos_eq).] 0.001 secs (0.001u,0.s)
Chars 3610 - 3625 [(apply~mult_1_r).] 0. secs (0.u,0.s)
Chars 3626 - 3630 [Qed.] 0. secs (0.u,0.s)
Chars 3632 - 3687 [Lemma~pos_split2@{}~:~forall~e...] 0.003 secs (0.003u,0.s)
Chars 3688 - 3694 [Proof.] 0. secs (0.u,0.s)
[DEBUG] All good, a was instantiated with b's type (tFalse)
Chars 2909 - 2913 [(cbn).] 40.24 secs (0.u,0.051s)
Chars 2918 - 2945 [(rewrite~transport_idmap_ap).] 0.004 secs (0.003u,0.001s)
Chars 2950 - 2969 [(rewrite~ap_compose).] 0.005 secs (0.004u,0.s)
Chars 2974 - 2988 [(rewrite~ap_pp).] 0.006 secs (0.005u,0.s)
Chars 2993 - 3006 [(rewrite~ap_V).] 0.006 secs (0.005u,0.s)
Chars 3011 - 3041 [(rewrite~2!Susp_rec_beta_merid).] 0.024 secs (0.022u,0.001s)
Chars 3046 - 3074 [(rewrite~<-~path_trunctype_V).] 0.007 secs (0.007u,0.s)
Chars 3079 - 3108 [(rewrite~<-~path_trunctype_pp).] 0.006 secs (0.004u,0.001s)
Chars 3113 - 3134 [(rewrite~ap_trunctype).] 0.005 secs (0.005u,0.s)
Chars 3139 - 3181 [(rewrite~transport_path_univer...] 0.004 secs (0.004u,0.s)
Chars 3186 - 3211 [(apply~moveR_equiv_V;~cbn).] 0.014 secs (0.013u,0.s)
Chars 3216 - 3262 [exact~(right_identity~_~@~(lef...] 0.005 secs (0.004u,0.s)
Chars 2909 - 2913 [(cbn).] 0. secs (0.u,0.s)
Chars 2918 - 2945 [(rewrite~transport_idmap_ap).] 0.001 secs (0.u,0.s)
Chars 2950 - 2969 [(rewrite~ap_compose).] 0.001 secs (0.001u,0.s)
Chars 2974 - 2988 [(rewrite~ap_pp).] 0.022 secs (0.015u,0.006s)
Chars 2993 - 3006 [(rewrite~ap_V).] 0.001 secs (0.001u,0.s)
Chars 3011 - 3041 [(rewrite~2!Susp_rec_beta_merid).] 0.001 secs (0.u,0.s)
Chars 3046 - 3074 [(rewrite~<-~path_trunctype_V).] 0.001 secs (0.u,0.s)
Chars 3079 - 3108 [(rewrite~<-~path_trunctype_pp).] 0.001 secs (0.001u,0.s)
Chars 3113 - 3134 [(rewrite~ap_trunctype).] 0.001 secs (0.001u,0.s)
Chars 3139 - 3181 [(rewrite~transport_path_univer...] 0.001 secs (0.u,0.s)
Chars 3186 - 3211 [(apply~moveR_equiv_V;~cbn).] 0.002 secs (0.002u,0.s)
Chars 3216 - 3262 [exact~(right_identity~_~@~(lef...] 0. secs (0.u,0.s)
Chars 3265 - 3273 [Defined.] 0.037 secs (0.031u,0.005s)
Chars 3277 - 3390 [#[local]~Definition~merid_mu~(...] 0.007 secs (0.007u,0.s)
Chars 3393 - 3399 [Proof.] 0. secs (0.u,0.s)
Chars 5294 - 5319 [(induction~n~as~[|~n~IHn]).] 40.161 secs (0.001u,0.035s)
Chars 5322 - 5323 [-] 0. secs (0.u,0.s)
Chars 5324 - 5331 [(elim~k).] 0. secs (0.u,0.s)
Chars 5334 - 5335 [-] 0. secs (0.u,0.s)
Chars 5336 - 5359 [(destruct~k~as~[k|~[]]).] 0.002 secs (0.002u,0.s)
Chars 5364 - 5365 [+] 0. secs (0.u,0.s)
Chars 5366 - 5385 [specialize~(IHn~k).] 0.001 secs (0.001u,0.s)
Chars 5392 - 5447 [refine~(path_finnat_to_fin_inc...] 0.003 secs (0.003u,0.s)
Chars 5454 - 5478 [exact~(ap~fin_incl~IHn).] 0.001 secs (0.001u,0.s)
Chars 5483 - 5484 [+] 0. secs (0.u,0.s)
Chars 5485 - 5515 [(apply~path_finnat_to_fin_last).] 0.001 secs (0.001u,0.s)
Chars 5294 - 5319 [(induction~n~as~[|~n~IHn]).] 0. secs (0.u,0.s)
Chars 5324 - 5331 [(elim~k).] 0. secs (0.u,0.s)
Chars 5336 - 5359 [(destruct~k~as~[k|~[]]).] 0. secs (0.u,0.s)
Chars 5366 - 5385 [specialize~(IHn~k).] 0. secs (0.u,0.s)
Chars 5392 - 5447 [refine~(path_finnat_to_fin_inc...] 0. secs (0.u,0.s)
Chars 5454 - 5478 [exact~(ap~fin_incl~IHn).] 0. secs (0.u,0.s)
Chars 5485 - 5515 [(apply~path_finnat_to_fin_last).] 0. secs (0.u,0.s)
Chars 5516 - 5524 [Defined.] 0.003 secs (0.003u,0.s)
Chars 5526 - 5702 [Definition~equiv_fin_finnat~(n...] 0.009 secs (0.007u,0.001s)
Chars 23565 - 23589 [(unfold~path_sigma_hprop).] 40.123 secs (0.001u,0.02s)
Chars 23592 - 23624 [(unfold~isequiv_pr1_contr;~sim...] 0.002 secs (0.002u,0.s)
Chars 23640 - 23756 [refine~~(ap~(fun~p~=>~match~p~...] 0.004 secs (0.004u,0.s)
Chars 23565 - 23589 [(unfold~path_sigma_hprop).] 0. secs (0.u,0.s)
Chars 23592 - 23624 [(unfold~isequiv_pr1_contr;~sim...] 0.001 secs (0.001u,0.s)
Chars 23640 - 23756 [refine~~(ap~(fun~p~=>~match~p~...] 0. secs (0.u,0.s)
Chars 23757 - 23765 [Defined.] 0.002 secs (0.002u,0.s)
Chars 23767 - 23985 [Definition~path_sigma_hprop_V~...] 0.004 secs (0.004u,0.s)
Chars 23986 - 23992 [Proof.] 0. secs (0.u,0.s)
Chars 12897 - 12964 [(revert~C;~simple_induction~n~...] 40.155 secs (0.004u,0.028s)
Chars 12969 - 12970 [-] 0. secs (0.u,0.s)
Chars 12971 - 12980 [(intros~h).] 0. secs (0.u,0.s)
Chars 12987 - 13040 [(exists~(fun~b~=>~eisretr~f~b~...] 0.004 secs (0.003u,0.s)
Chars 13047 - 13088 [refine~(transport2~C~(eisadj~f...] 0.002 secs (0.001u,0.s)
Chars 13095 - 13137 [refine~((transport_compose~C~f...] 0.002 secs (0.001u,0.s)
Chars 13144 - 13172 [exact~(apD~h~(eissect~f~a)).] 0.002 secs (0.001u,0.001s)
Chars 13177 - 13178 [-] 0. secs (0.u,0.s)
Chars 13179 - 13190 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 13197 - 13207 [(apply~IHn).] 0. secs (0.u,0.s)
Chars 12897 - 12964 [(revert~C;~simple_induction~n~...] 0.001 secs (0.u,0.001s)
Chars 12971 - 12980 [(intros~h).] 0. secs (0.u,0.s)
Chars 12987 - 13040 [(exists~(fun~b~=>~eisretr~f~b~...] 0. secs (0.u,0.s)
Chars 13047 - 13088 [refine~(transport2~C~(eisadj~f...] 0. secs (0.u,0.s)
Chars 13095 - 13137 [refine~((transport_compose~C~f...] 0. secs (0.u,0.s)
Chars 13144 - 13172 [exact~(apD~h~(eissect~f~a)).] 0. secs (0.u,0.s)
Chars 13179 - 13190 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 13197 - 13207 [(apply~IHn).] 0. secs (0.u,0.s)
Chars 13210 - 13218 [Defined.] 0.002 secs (0.001u,0.s)
Chars 13259 - 13416 [Definition~extendable_contr~(n...] 0. secs (0.u,0.s)
Chars 13419 - 13425 [Proof.] 0. secs (0.u,0.s)
Chars 13914 - 13934 [(destruct~si1i,~si0i).] 40.168 secs (0.012u,0.03s)
Chars 13937 - 13965 [refine~(cu_GGcccc~_~_~oE~_).] 0.004 secs (0.004u,0.s)
Chars 13968 - 13997 [1,~2:~exact~(eisretr~sq_G1~_).] 0.013 secs (0.012u,0.s)
Chars 14000 - 14021 [refine~(cu_GG1~oE~_).] 0.022 secs (0.019u,0.002s)
Chars 14024 - 14048 [refine~(sq_flip_h~oE~_).] 0.003 secs (0.002u,0.s)
Chars 14051 - 14075 [refine~(cu_GG1^-1~oE~_).] 0.004 secs (0.004u,0.s)
Chars 14078 - 14105 [refine~(cu_GGGGcc~_~_~_~_).] 0.004 secs (0.004u,0.s)
Chars 14108 - 14138 [all:~exact~(eisretr~sq_G1~_)^.] 0.009 secs (0.007u,0.002s)
Chars 13914 - 13934 [(destruct~si1i,~si0i).] 0.001 secs (0.001u,0.s)
Chars 13937 - 13965 [refine~(cu_GGcccc~_~_~oE~_).] 0.001 secs (0.001u,0.s)
Chars 13968 - 13997 [1,~2:~exact~(eisretr~sq_G1~_).] 0. secs (0.u,0.s)
Chars 14000 - 14021 [refine~(cu_GG1~oE~_).] 0.001 secs (0.001u,0.s)
Chars 14024 - 14048 [refine~(sq_flip_h~oE~_).] 0.001 secs (0.001u,0.s)
Chars 14051 - 14075 [refine~(cu_GG1^-1~oE~_).] 0.001 secs (0.001u,0.s)
Chars 14078 - 14105 [refine~(cu_GGGGcc~_~_~_~_).] 0.001 secs (0.u,0.s)
Chars 14108 - 14138 [all:~exact~(eisretr~sq_G1~_)^.] 0.002 secs (0.002u,0.s)
Chars 14139 - 14147 [Defined.] 0.019 secs (0.016u,0.002s)
Chars 14149 - 14189 [Notation~cu_flip_lr~:=~equiv_c...] 0. secs (0.u,0.s)
Chars 14248 - 14913 [Definition~cu_fill_left~{A}~{x...] 0.007 secs (0.005u,0.002s)
Chars 14914 - 14920 [Proof.] 0. secs (0.u,0.s)
Chars 3246 - 3256 [(intros~E1).] 40.173 secs (0.001u,0.033s)
Chars 3257 - 3310 [(destruct~(int_abs_spec~x)~as~...] 0.012 secs (0.01u,0.001s)
Chars 3311 - 3332 [(assert~(Hrw~:~x~=~0)).] 0.002 secs (0.002u,0.s)
Chars 3333 - 3334 [-] 0. secs (0.u,0.s)
Chars 3335 - 3369 [(apply~(antisymmetry~(<=));~tr...] 0.07 secs (0.054u,0.015s)
Chars 3370 - 3371 [-] 0. secs (0.u,0.s)
Chars 3372 - 3416 [(rewrite~Hrw,~int_abs_0,~(pres...] 0.008 secs (0.007u,0.s)
Chars 3417 - 3425 [trivial.] 0.002 secs (0.002u,0.s)
Chars 3246 - 3256 [(intros~E1).] 0.001 secs (0.001u,0.s)
Chars 3257 - 3310 [(destruct~(int_abs_spec~x)~as~...] 0.004 secs (0.004u,0.s)
Chars 3311 - 3332 [(assert~(Hrw~:~x~=~0)).] 0.001 secs (0.001u,0.s)
Chars 3335 - 3369 [(apply~(antisymmetry~(<=));~tr...] 0.004 secs (0.003u,0.s)
Chars 3372 - 3416 [(rewrite~Hrw,~int_abs_0,~(pres...] 0.001 secs (0.001u,0.s)
Chars 3417 - 3425 [trivial.] 0.001 secs (0.001u,0.s)
Chars 3426 - 3430 [Qed.] 0.004 secs (0.004u,0.s)
Chars 3432 - 3493 [Lemma~int_abs_nonpos~x~:~x~≤~0...] 0.046 secs (0.035u,0.008s)
Chars 3494 - 3500 [Proof.] 0. secs (0.u,0.s)
Chars 6231 - 6264 [srapply~reflectsD_from_inO_sigma.] 40.316 secs (0.088u,0.062s)
Chars 6231 - 6264 [srapply~reflectsD_from_inO_sigma.] 0. secs (0.u,0.s)
Chars 6265 - 6273 [Defined.] 0. secs (0.u,0.s)
Chars 6412 - 6704 [Definition~isequiv_toSepO_inO~...] 0.006 secs (0.004u,0.002s)
Chars 6706 - 6990 [Definition~equiv_toSepO_inO~`{...] 0.004 secs (0.004u,0.s)
Chars 7065 - 7090 [Section~JoinConstruction.] 0. secs (0.u,0.s)
Chars 7093 - 7107 [Universe~i,j.] 0. secs (0.u,0.s)
Chars 7110 - 7280 [Context~{X~:~Type@{i}}~{Y~:~Ty...] 0. secs (0.u,0.s)
Chars 7283 - 7317 [Definition~jc_image@{}~:~Type@...] 0. secs (0.u,0.s)
Chars 7318 - 7327 [Admitted.] 0. secs (0.u,0.s)
Chars 7330 - 7371 [Definition~jc_factor1@{}~:~X~-...] 0. secs (0.u,0.s)
Chars 7372 - 7381 [Admitted.] 0. secs (0.u,0.s)
Chars 7384 - 7425 [Definition~jc_factor2@{}~:~jc_...] 0. secs (0.u,0.s)
Chars 7426 - 7435 [Admitted.] 0. secs (0.u,0.s)
Chars 7438 - 7494 [Definition~jc_factors@{}~:~jc_...] 0. secs (0.u,0.s)
Chars 7495 - 7504 [Admitted.] 0. secs (0.u,0.s)
Chars 7507 - 7570 [#[global]Instance~jc_factor1_i...] 0. secs (0.u,0.s)
Chars 7571 - 7580 [Admitted.] 0. secs (0.u,0.s)
Chars 7583 - 7641 [#[global]Instance~jc_factor2_i...] 0. secs (0.u,0.s)
Chars 7642 - 7651 [Admitted.] 0. secs (0.u,0.s)
Chars 7652 - 7673 [End~JoinConstruction.] 0.001 secs (0.001u,0.s)
Chars 7930 - 7997 [Fail~Goal~_~forall~O~:~Reflect...] 0. secs (0.u,0.s)
Chars 8143 - 8279 [#[global]~Instance~SepO_lex_le...] 0.001 secs (0.001u,0.s)
Chars 8280 - 8286 [Proof.] 0. secs (0.u,0.s)
Chars 4770 - 4803 [(pose~proof~(merely_equiv_fin~...] 40.161 secs (0.001u,0.036s)
Chars 4806 - 4824 [strip_truncations.] 0.043 secs (0.035u,0.007s)
Chars 4827 - 4866 [refine~(decidablepaths_equiv~_...] 0.005 secs (0.005u,0.s)
Chars 4770 - 4803 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 4806 - 4824 [strip_truncations.] 0. secs (0.u,0.s)
Chars 4827 - 4866 [refine~(decidablepaths_equiv~_...] 0. secs (0.u,0.s)
Chars 4867 - 4875 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5176 - 5260 [#[global]~Instance~decidable_f...] 0. secs (0.u,0.s)
Chars 5261 - 5267 [Proof.] 0. secs (0.u,0.s)
Chars 7025 - 7051 [(intros~g;~grouphom_reduce).] 40.202 secs (0.01u,0.042s)
Chars 7054 - 7073 [exact~(ap_idmap~g).] 0.001 secs (0.001u,0.s)
Chars 7025 - 7051 [(intros~g;~grouphom_reduce).] 0. secs (0.u,0.s)
Chars 7054 - 7073 [exact~(ap_idmap~g).] 0. secs (0.u,0.s)
Chars 7074 - 7078 [Qed.] 0.005 secs (0.004u,0.s)
Chars 7080 - 7178 [Definition~grouphom_pp~{G}~{H}...] 0.002 secs (0.001u,0.s)
Chars 7179 - 7185 [Proof.] 0. secs (0.u,0.s)
Chars 3695 - 3702 [(intros).] 40.173 secs (0.u,0.041s)
Chars 3703 - 3726 [(path_via~(e~*~(2~/~2))).] 0.013 secs (0.012u,0.s)
Chars 3727 - 3728 [-] 0. secs (0.u,0.s)
Chars 3729 - 3774 [(rewrite~pos_recip_r,~pos_mult...] 0.003 secs (0.003u,0.s)
Chars 3775 - 3776 [-] 0. secs (0.u,0.s)
Chars 3777 - 3790 [(apply~pos_eq).] 0.001 secs (0.u,0.s)
Chars 3791 - 3834 [(change~('~e~*~(2~/~2)~=~'~e~/...] 0.02 secs (0.018u,0.002s)
Chars 3837 - 3860 [ring_tac.ring_with_nat.] 0.211 secs (0.167u,0.043s)
Chars 3695 - 3702 [(intros).] 0. secs (0.u,0.s)
Chars 3703 - 3726 [(path_via~(e~*~(2~/~2))).] 0. secs (0.u,0.s)
Chars 3729 - 3774 [(rewrite~pos_recip_r,~pos_mult...] 0.001 secs (0.001u,0.s)
Chars 3777 - 3790 [(apply~pos_eq).] 0. secs (0.u,0.s)
Chars 3791 - 3834 [(change~('~e~*~(2~/~2)~=~'~e~/...] 0. secs (0.u,0.s)
Chars 3837 - 3860 [ring_tac.ring_with_nat.] 0.001 secs (0.001u,0.s)
Chars 3861 - 3865 [Qed.] 0.07 secs (0.065u,0.003s)
Chars 3867 - 3930 [Lemma~pos_split3@{}~:~forall~e...] 0.008 secs (0.006u,0.001s)
Chars 3931 - 3937 [Proof.] 0. secs (0.u,0.s)
0.032000
0.032000
0.064000
0.000000
Chars 7188 - 7204 [grouphom_reduce.] 0.96 secs (0.049u,0.052s)
Chars 7207 - 7231 [exact~(ap_pp~phi~g1~g2).] 0.002 secs (0.001u,0.001s)
Chars 7188 - 7204 [grouphom_reduce.] 0. secs (0.u,0.s)
Chars 7207 - 7231 [exact~(ap_pp~phi~g1~g2).] 0. secs (0.u,0.s)
Chars 7232 - 7236 [Qed.] 0.03 secs (0.023u,0.006s)
Chars 7238 - 7317 [Definition~grouphom_V~{G}~{H}~...] 0.001 secs (0.u,0.001s)
Chars 7318 - 7324 [Proof.] 0. secs (0.u,0.s)
Chars 3404 - 3507 [(set~~~(Q~:=~~~~fun~a~b~:~X~=>...] 40.258 secs (0.015u,0.054s)
Chars 3512 - 3732 [(srapply~~~(@wedge_incl_elim_u...] 0.066 secs (0.06u,0.005s)
Chars 3737 - 3746 [(unfold~Q).] 0.002 secs (0.002u,0.s)
Chars 3751 - 3767 [srefine~(_;~_;~_).] 0.007 secs (0.006u,0.s)
Chars 3772 - 3773 [{] 0. secs (0.u,0.s)
Chars 3774 - 3782 [intro~b.] 0.002 secs (0.002u,0.s)
Chars 3789 - 3798 [(apply~ap).] 0.003 secs (0.003u,0.s)
Chars 3805 - 3814 [symmetry.] 0.004 secs (0.004u,0.s)
Chars 3821 - 3852 [refine~(concat_pp_p~_~_~_~@~_).] 0.004 secs (0.004u,0.s)
Chars 3859 - 3891 [refine~(ap~_~(concat_Vp~_)~@~_).] 0.004 secs (0.002u,0.001s)
Chars 3898 - 3923 [refine~(concat_p1~_~@~_).] 0.003 secs (0.003u,0.s)
Chars 3930 - 3939 [(apply~ap).] 0.002 secs (0.002u,0.s)
Chars 3946 - 3971 [exact~(left_identity~b)^.] 0.003 secs (0.003u,0.s)
Chars 3972 - 3973 [}] 0. secs (0.u,0.s)
Chars 3978 - 3979 [{] 0. secs (0.u,0.s)
Chars 3980 - 3988 [intro~a.] 0.002 secs (0.002u,0.s)
Chars 3995 - 4004 [(apply~ap).] 0.003 secs (0.003u,0.s)
Chars 4011 - 4020 [symmetry.] 0.004 secs (0.004u,0.s)
Chars 4027 - 4087 [refine~(ap~(fun~x~=>~concat~x~...] 0.006 secs (0.005u,0.s)
Chars 4094 - 4119 [refine~(concat_1p~_~@~_).] 0.003 secs (0.002u,0.s)
Chars 4126 - 4135 [(apply~ap).] 0.002 secs (0.002u,0.s)
Chars 4142 - 4168 [exact~(right_identity~a)^.] 0.003 secs (0.002u,0.s)
Chars 4169 - 4170 [}] 0. secs (0.u,0.s)
Chars 4175 - 4181 [(simpl).] 0.016 secs (0.015u,0.s)
Chars 4186 - 4199 [(apply~ap,~ap).] 0.032 secs (0.025u,0.006s)
Chars 4204 - 4219 [(rewrite~<-~coh).] 0.019 secs (0.014u,0.004s)
Chars 4224 - 4246 [(rewrite~?concat_p_pp).] 0.091 secs (0.071u,0.019s)
Chars 4251 - 4266 [(apply~whiskerR).] 0.009 secs (0.008u,0.s)
Chars 4271 - 4305 [(generalize~(merid~(mon_unit~:...] 0.013 secs (0.011u,0.002s)
Chars 4310 - 4323 [by~intros~[].] 0.012 secs (0.01u,0.001s)
Chars 3404 - 3507 [(set~~~(Q~:=~~~~fun~a~b~:~X~=>...] 0.001 secs (0.001u,0.s)
Chars 3512 - 3732 [(srapply~~~(@wedge_incl_elim_u...] 0.002 secs (0.001u,0.001s)
Chars 3737 - 3746 [(unfold~Q).] 0.001 secs (0.001u,0.s)
Chars 3751 - 3767 [srefine~(_;~_;~_).] 0.004 secs (0.004u,0.s)
Chars 3774 - 3782 [intro~b.] 0.002 secs (0.002u,0.s)
Chars 3789 - 3798 [(apply~ap).] 0.002 secs (0.002u,0.s)
Chars 3805 - 3814 [symmetry.] 0.002 secs (0.002u,0.s)
Chars 3821 - 3852 [refine~(concat_pp_p~_~_~_~@~_).] 0.002 secs (0.002u,0.s)
Chars 3859 - 3891 [refine~(ap~_~(concat_Vp~_)~@~_).] 0.002 secs (0.002u,0.s)
Chars 3898 - 3923 [refine~(concat_p1~_~@~_).] 0.001 secs (0.u,0.s)
Chars 3930 - 3939 [(apply~ap).] 0.001 secs (0.001u,0.s)
Chars 3946 - 3971 [exact~(left_identity~b)^.] 0.001 secs (0.001u,0.s)
Chars 3980 - 3988 [intro~a.] 0.002 secs (0.001u,0.s)
Chars 3995 - 4004 [(apply~ap).] 0.002 secs (0.002u,0.s)
Chars 4011 - 4020 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 4027 - 4087 [refine~(ap~(fun~x~=>~concat~x~...] 0.002 secs (0.001u,0.s)
Chars 4094 - 4119 [refine~(concat_1p~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 4126 - 4135 [(apply~ap).] 0.001 secs (0.001u,0.s)
Chars 4142 - 4168 [exact~(right_identity~a)^.] 0.001 secs (0.001u,0.s)
Chars 4175 - 4181 [(simpl).] 0.006 secs (0.004u,0.001s)
Chars 4186 - 4199 [(apply~ap,~ap).] 0.006 secs (0.006u,0.s)
Chars 4204 - 4219 [(rewrite~<-~coh).] 0.026 secs (0.021u,0.004s)
Chars 4224 - 4246 [(rewrite~?concat_p_pp).] 0.004 secs (0.004u,0.s)
Chars 4251 - 4266 [(apply~whiskerR).] 0.004 secs (0.004u,0.s)
Chars 4271 - 4305 [(generalize~(merid~(mon_unit~:...] 0.003 secs (0.002u,0.s)
Chars 4310 - 4323 [by~intros~[].] 0.003 secs (0.003u,0.s)
Chars 4326 - 4334 [Defined.] 0.076 secs (0.071u,0.005s)
Chars 4338 - 4389 [#[local]Definition~decode~:~fo...] 0.001 secs (0.001u,0.s)
Chars 4392 - 4398 [Proof.] 0. secs (0.u,0.s)
Chars 23995 - 24013 [(destruct~p;~simpl).] 40.126 secs (0.004u,0.02s)
Chars 24016 - 24043 [(rewrite~(path_ishprop~x~y)).] 0.002 secs (0.002u,0.s)
Chars 24046 - 24115 [refine~(path_sigma_hprop_1~_~@...] 0.003 secs (0.003u,0.s)
Chars 23995 - 24013 [(destruct~p;~simpl).] 0.001 secs (0.u,0.s)
Chars 24016 - 24043 [(rewrite~(path_ishprop~x~y)).] 0. secs (0.u,0.s)
Chars 24046 - 24115 [refine~(path_sigma_hprop_1~_~@...] 0. secs (0.u,0.s)
Chars 24116 - 24120 [Qed.] 0.003 secs (0.003u,0.s)
Chars 24122 - 24450 [Definition~path_sigma_hprop_pp...] 0.006 secs (0.006u,0.s)
Chars 24451 - 24457 [Proof.] 0. secs (0.u,0.s)
Chars 13430 - 13519 [(generalize~dependent~C;~simpl...] 39.171 secs (33.052u,0.073s)
Chars 13430 - 13519 [(generalize~dependent~C;~simpl...] 40.064 secs (0.002u,0.032s)
Chars 13524 - 13525 [-] 0. secs (0.u,0.s)
Chars 13526 - 13535 [(intros~h).] 0. secs (0.u,0.s)
Chars 13542 - 13579 [(exists~(fun~_~=>~center~_);~i...] 0.003 secs (0.003u,0.s)
Chars 13586 - 13598 [(apply~contr).] 0.001 secs (0.u,0.s)
Chars 13603 - 13604 [-] 0. secs (0.u,0.s)
Chars 13605 - 13616 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 13623 - 13642 [(apply~IHn;~exact~_).] 0.007 secs (0.007u,0.s)
Chars 13430 - 13519 [(generalize~dependent~C;~simpl...] 0.001 secs (0.001u,0.s)
Chars 13526 - 13535 [(intros~h).] 0. secs (0.u,0.s)
Chars 13542 - 13579 [(exists~(fun~_~=>~center~_);~i...] 0. secs (0.u,0.s)
Chars 13586 - 13598 [(apply~contr).] 0. secs (0.u,0.s)
Chars 13605 - 13616 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 13623 - 13642 [(apply~IHn;~exact~_).] 0. secs (0.u,0.s)
Chars 13645 - 13653 [Defined.] 0.001 secs (0.u,0.s)
Chars 13708 - 13912 [Definition~extendable_homotopy...] 0.001 secs (0.001u,0.s)
Chars 13915 - 13921 [Proof.] 0. secs (0.u,0.s)
Chars 13926 - 14009 [(revert~C~h~k;~simple_inductio...] 0.884 secs (0.003u,0.031s)
Chars 14014 - 14015 [-] 0. secs (0.u,0.s)
Chars 14016 - 14025 [(intros~p).] 0. secs (0.u,0.s)
Chars 14032 - 14060 [exact~(fst~(snd~ext~h~k)~p).] 0.002 secs (0.002u,0.s)
Chars 14065 - 14066 [-] 0. secs (0.u,0.s)
Chars 14067 - 14078 [(intros~p~q).] 0.001 secs (0.001u,0.s)
Chars 14085 - 14100 [(apply~IHn,~ext).] 0.004 secs (0.004u,0.s)
Chars 13926 - 14009 [(revert~C~h~k;~simple_inductio...] 0.002 secs (0.002u,0.s)
Chars 14016 - 14025 [(intros~p).] 0. secs (0.u,0.s)
Chars 14032 - 14060 [exact~(fst~(snd~ext~h~k)~p).] 0. secs (0.u,0.s)
Chars 14067 - 14078 [(intros~p~q).] 0. secs (0.u,0.s)
Chars 14085 - 14100 [(apply~IHn,~ext).] 0. secs (0.u,0.s)
Chars 14103 - 14111 [Defined.] 0.002 secs (0.u,0.002s)
Chars 14145 - 14339 [Definition~ooExtendableAlong@{...] 0. secs (0.u,0.s)
Chars 14411 - 14484 [#[global]Arguments~ooExtendabl...] 0. secs (0.u,0.s)
Chars 14520 - 14868 [Definition~lift_ooextendableal...] 0.001 secs (0.001u,0.s)
Chars 14987 - 15206 [Definition~isequiv_ooextendabl...] 0.005 secs (0.001u,0.003s)
Chars 15210 - 15397 [Definition~equiv_ooextendable_...] 0.001 secs (0.001u,0.s)
Chars 15400 - 15406 [Proof.] 0. secs (0.u,0.s)
Chars 14923 - 14943 [(destruct~si0i,~si1i).] 40.169 secs (0.007u,0.033s)
Chars 14946 - 14971 [(set~(a~:=~sq_G1^-1~s1ii)).] 0.009 secs (0.005u,0.003s)
Chars 14974 - 14999 [(set~(b~:=~sq_G1^-1~sii0)).] 0.008 secs (0.008u,0.s)
Chars 15002 - 15027 [(set~(c~:=~sq_G1^-1~sii1)).] 0.01 secs (0.009u,0.s)
Chars 15030 - 15062 [(rewrite~<-~(eisretr~sq_G1~s1i...] 0.01 secs (0.008u,0.001s)
Chars 15065 - 15097 [(rewrite~<-~(eisretr~sq_G1~sii...] 0.01 secs (0.009u,0.001s)
Chars 15100 - 15132 [(rewrite~<-~(eisretr~sq_G1~sii...] 0.01 secs (0.01u,0.s)
Chars 15135 - 15165 [(change~(sq_G1^-1~s1ii)~with~a).] 0.003 secs (0.003u,0.s)
Chars 15168 - 15198 [(change~(sq_G1^-1~sii0)~with~b).] 0.003 secs (0.003u,0.s)
Chars 15201 - 15231 [(change~(sq_G1^-1~sii1)~with~c).] 0.003 secs (0.003u,0.s)
Chars 15234 - 15250 [clearbody~a~b~c.] 0.002 secs (0.002u,0.s)
Chars 15253 - 15274 [clear~s1ii~sii0~sii1.] 0.001 secs (0.001u,0.s)
Chars 15277 - 15308 [refine~(sq_G1~((b~@~a)~@~c^);~_).] 0.003 secs (0.002u,0.s)
Chars 15311 - 15337 [by~destruct~a,~b,~c,~p0i1.] 0.028 secs (0.018u,0.009s)
Chars 14923 - 14943 [(destruct~si0i,~si1i).] 0.001 secs (0.001u,0.s)
Chars 14946 - 14971 [(set~(a~:=~sq_G1^-1~s1ii)).] 0. secs (0.u,0.s)
Chars 14974 - 14999 [(set~(b~:=~sq_G1^-1~sii0)).] 0. secs (0.u,0.s)
Chars 15002 - 15027 [(set~(c~:=~sq_G1^-1~sii1)).] 0.001 secs (0.001u,0.s)
Chars 15030 - 15062 [(rewrite~<-~(eisretr~sq_G1~s1i...] 0.001 secs (0.001u,0.s)
Chars 15065 - 15097 [(rewrite~<-~(eisretr~sq_G1~sii...] 0.001 secs (0.001u,0.s)
Chars 15100 - 15132 [(rewrite~<-~(eisretr~sq_G1~sii...] 0.001 secs (0.u,0.s)
Chars 15135 - 15165 [(change~(sq_G1^-1~s1ii)~with~a).] 0.001 secs (0.001u,0.s)
Chars 15168 - 15198 [(change~(sq_G1^-1~sii0)~with~b).] 0.001 secs (0.001u,0.s)
Chars 15201 - 15231 [(change~(sq_G1^-1~sii1)~with~c).] 0.001 secs (0.001u,0.s)
Chars 15234 - 15250 [clearbody~a~b~c.] 0.001 secs (0.001u,0.s)
Chars 15253 - 15274 [clear~s1ii~sii0~sii1.] 0. secs (0.u,0.s)
Chars 15277 - 15308 [refine~(sq_G1~((b~@~a)~@~c^);~_).] 0. secs (0.u,0.s)
Chars 15311 - 15337 [by~destruct~a,~b,~c,~p0i1.] 0. secs (0.u,0.s)
Chars 15338 - 15346 [Defined.] 0.01 secs (0.01u,0.s)
Chars 15348 - 15974 [Definition~cu_fill_right~{A}~{...] 0.006 secs (0.005u,0.s)
Chars 15975 - 15981 [Proof.] 0. secs (0.u,0.s)
Chars 15411 - 15456 [(refine~(equiv_functor_forall'...] 5.821 secs (0.002u,0.028s)
Chars 15461 - 15494 [(apply~equiv_extendable_pathsp...] 0.001 secs (0.001u,0.s)
Chars 15411 - 15456 [(refine~(equiv_functor_forall'...] 0. secs (0.u,0.s)
Chars 15461 - 15494 [(apply~equiv_extendable_pathsp...] 0. secs (0.u,0.s)
Chars 15497 - 15505 [Defined.] 0.001 secs (0.001u,0.s)
Chars 15509 - 15643 [#[global]~Instance~ishprop_ooe...] 0. secs (0.u,0.s)
Chars 15646 - 15652 [Proof.] 0. secs (0.u,0.s)
Chars 3501 - 3510 [(intros~E).] 40.161 secs (0.001u,0.031s)
Chars 3511 - 3558 [(rewrite~<-~int_abs_negate,~in...] 0.068 secs (0.056u,0.012s)
Chars 3559 - 3584 [(apply~flip_nonpos_negate).] 0.039 secs (0.027u,0.011s)
Chars 3585 - 3593 [trivial.] 0.002 secs (0.002u,0.s)
Chars 3501 - 3510 [(intros~E).] 0.001 secs (0.001u,0.s)
Chars 3511 - 3558 [(rewrite~<-~int_abs_negate,~in...] 0.003 secs (0.002u,0.s)
Chars 3559 - 3584 [(apply~flip_nonpos_negate).] 0.001 secs (0.001u,0.s)
Chars 3585 - 3593 [trivial.] 0.001 secs (0.001u,0.s)
Chars 3594 - 3598 [Qed.] 0.002 secs (0.002u,0.s)
Chars 3600 - 3636 [Lemma~int_abs_1~:~int_abs~Z~N~...] 0.047 secs (0.03u,0.016s)
Chars 3637 - 3643 [Proof.] 0. secs (0.u,0.s)
Chars 8289 - 8443 [(assert~~~(e~:~~~~forall~P~:~X...] 40.186 secs (0.004u,0.033s)
Chars 8446 - 8449 [2:~{] 0. secs (0.u,0.s)
Chars 8450 - 8567 [(unshelve~econstructor;~intros...] 0.012 secs (0.011u,0.001s)
Chars 8574 - 8575 [-] 0. secs (0.u,0.s)
Chars 8576 - 8587 [exact~ee.1.] 0.001 secs (0.001u,0.s)
Chars 8594 - 8595 [-] 0. secs (0.u,0.s)
Chars 8596 - 8611 [(simpl;~exact~_).] 0.008 secs (0.007u,0.s)
Chars 8618 - 8619 [-] 0. secs (0.u,0.s)
Chars 8620 - 8646 [(intros~x;~cbn;~apply~ee.2).] 0.005 secs (0.005u,0.s)
Chars 8647 - 8648 [}] 0. secs (0.u,0.s)
Chars 8651 - 8660 [(intros~P).] 0. secs (0.u,0.s)
Chars 8663 - 8728 [(assert~(ls~:~forall~A~B~:~Typ...] 0.002 secs (0.001u,0.001s)
Chars 8731 - 8732 [{] 0. secs (0.u,0.s)
Chars 8733 - 8744 [(intros~A~B).] 0. secs (0.u,0.s)
Chars 8749 - 8787 [(pose~(q~:=~almost_inSepO_type...] 0.001 secs (0.u,0.s)
Chars 8792 - 8813 [exact~(q.1;~snd~q.2).] 0.002 secs (0.002u,0.s)
Chars 8814 - 8815 [}] 0. secs (0.u,0.s)
Chars 8818 - 8846 [(pose~(p~:=~jc_factor2~P~ls)).] 0.001 secs (0.001u,0.s)
Chars 8849 - 8879 [(set~(J~:=~jc_image~P~ls)~in~p).] 0.002 secs (0.002u,0.s)
Chars 8882 - 8904 [(assert~(In~(Sep~O)~J)).] 0.001 secs (0.001u,0.s)
Chars 8907 - 8908 [{] 0. secs (0.u,0.s)
Chars 8909 - 8920 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 8925 - 8971 [(pose~(q~:=~almost_inSepO_type...] 0.001 secs (0.001u,0.s)
Chars 8976 - 9006 [refine~(inO_equiv_inO'~q.1~_).] 0.059 secs (0.046u,0.012s)
Chars 9011 - 9027 [refine~(_~oE~_).] 0.001 secs (0.001u,0.s)
Chars 9032 - 9033 [-] 0. secs (0.u,0.s)
Chars 9034 - 9077 [(symmetry;~srapply~(equiv_ap_i...] 0.008 secs (0.005u,0.002s)
Chars 9082 - 9083 [-] 0. secs (0.u,0.s)
Chars 9084 - 9100 [exact~(snd~q.2).] 0.002 secs (0.002u,0.s)
Chars 9101 - 9102 [}] 0. secs (0.u,0.s)
Chars 9105 - 9149 [(pose~(O_rec~(O:=Sep~O)~(jc_fa...] 0.003 secs (0.003u,0.s)
Chars 9152 - 9167 [exists~(p~o~j).] 0.003 secs (0.003u,0.s)
Chars 9170 - 9190 [(intros~x;~subst~p~j).] 0.002 secs (0.002u,0.s)
Chars 9193 - 9212 [(rewrite~O_rec_beta).] 0.004 secs (0.003u,0.s)
Chars 9215 - 9232 [(apply~equiv_path).] 0.001 secs (0.u,0.001s)
Chars 9235 - 9266 [exact~(jc_factors~P~ls~x)~..1.] 0.002 secs (0.002u,0.s)
Chars 8289 - 8443 [(assert~~~(e~:~~~~forall~P~:~X...] 0. secs (0.u,0.s)
Chars 8450 - 8567 [(unshelve~econstructor;~intros...] 0.007 secs (0.006u,0.s)
Chars 8576 - 8587 [exact~ee.1.] 0. secs (0.u,0.s)
Chars 8596 - 8611 [(simpl;~exact~_).] 0.002 secs (0.002u,0.s)
Chars 8620 - 8646 [(intros~x;~cbn;~apply~ee.2).] 0.004 secs (0.004u,0.s)
Chars 8651 - 8660 [(intros~P).] 0. secs (0.u,0.s)
Chars 8663 - 8728 [(assert~(ls~:~forall~A~B~:~Typ...] 0. secs (0.u,0.s)
Chars 8733 - 8744 [(intros~A~B).] 0. secs (0.u,0.s)
Chars 8749 - 8787 [(pose~(q~:=~almost_inSepO_type...] 0. secs (0.u,0.s)
Chars 8792 - 8813 [exact~(q.1;~snd~q.2).] 0. secs (0.u,0.s)
Chars 8818 - 8846 [(pose~(p~:=~jc_factor2~P~ls)).] 0. secs (0.u,0.s)
Chars 8849 - 8879 [(set~(J~:=~jc_image~P~ls)~in~p).] 0. secs (0.u,0.s)
Chars 8882 - 8904 [(assert~(In~(Sep~O)~J)).] 0. secs (0.u,0.s)
Chars 8909 - 8920 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 8925 - 8971 [(pose~(q~:=~almost_inSepO_type...] 0. secs (0.u,0.s)
Chars 8976 - 9006 [refine~(inO_equiv_inO'~q.1~_).] 0. secs (0.u,0.s)
Chars 9011 - 9027 [refine~(_~oE~_).] 0. secs (0.u,0.s)
Chars 9034 - 9077 [(symmetry;~srapply~(equiv_ap_i...] 0.001 secs (0.u,0.s)
Chars 9084 - 9100 [exact~(snd~q.2).] 0. secs (0.u,0.s)
Chars 9105 - 9149 [(pose~(O_rec~(O:=Sep~O)~(jc_fa...] 0. secs (0.u,0.s)
Chars 9152 - 9167 [exists~(p~o~j).] 0.001 secs (0.001u,0.s)
Chars 9170 - 9190 [(intros~x;~subst~p~j).] 0.001 secs (0.001u,0.s)
Chars 9193 - 9212 [(rewrite~O_rec_beta).] 0.001 secs (0.u,0.s)
Chars 9215 - 9232 [(apply~equiv_path).] 0. secs (0.u,0.s)
Chars 9235 - 9266 [exact~(jc_factors~P~ls~x)~..1.] 0. secs (0.u,0.s)
Chars 9267 - 9275 [Defined.] 0.01 secs (0.002u,0.007s)
Chars 5525 - 5549 [(destruct~fX~as~[[|~n]~e]).] 40.162 secs (0.001u,0.034s)
Chars 5552 - 5553 [-] 0. secs (0.u,0.s)
Chars 5554 - 5570 [(right;~intros~x).] 0. secs (0.u,0.s)
Chars 5575 - 5606 [(strip_truncations;~exact~(e~x)).] 0.134 secs (0.098u,0.035s)
Chars 5609 - 5610 [-] 0. secs (0.u,0.s)
Chars 5611 - 5616 [left.] 0. secs (0.u,0.s)
Chars 5621 - 5662 [(strip_truncations;~exact~(e^-...] 0.039 secs (0.035u,0.004s)
Chars 5525 - 5549 [(destruct~fX~as~[[|~n]~e]).] 0. secs (0.u,0.s)
Chars 5554 - 5570 [(right;~intros~x).] 0. secs (0.u,0.s)
Chars 5575 - 5606 [(strip_truncations;~exact~(e~x)).] 0. secs (0.u,0.s)
Chars 5611 - 5616 [left.] 0. secs (0.u,0.s)
Chars 5621 - 5662 [(strip_truncations;~exact~(e^-...] 0. secs (0.u,0.s)
Chars 5663 - 5671 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5762 - 5843 [#[global]~Instance~decidable_m...] 0. secs (0.u,0.s)
Chars 5844 - 5850 [Proof.] 0. secs (0.u,0.s)
Chars 5853 - 5861 [exact~_.] 0.345 secs (0.036u,0.038s)
Chars 5853 - 5861 [exact~_.] 0. secs (0.u,0.s)
Chars 5862 - 5870 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5944 - 6016 [Definition~merely_decidable_fi...] 0. secs (0.u,0.s)
Chars 6017 - 6023 [Proof.] 0. secs (0.u,0.s)
Chars 3938 - 3945 [(intros).] 40.155 secs (0.002u,0.039s)
Chars 3946 - 3969 [(path_via~(e~*~(3~/~3))).] 0.015 secs (0.01u,0.004s)
Chars 3970 - 3971 [-] 0. secs (0.u,0.s)
Chars 3972 - 4017 [(rewrite~pos_recip_r,~pos_mult...] 0.003 secs (0.003u,0.s)
Chars 4018 - 4019 [-] 0. secs (0.u,0.s)
Chars 4020 - 4033 [(apply~pos_eq).] 0.002 secs (0.002u,0.s)
Chars 4034 - 4087 [(change~('~e~*~(3~/~3)~=~'~e~/...] 0.039 secs (0.034u,0.004s)
Chars 4090 - 4113 [ring_tac.ring_with_nat.] 0.284 secs (0.242u,0.038s)
Chars 3938 - 3945 [(intros).] 0.001 secs (0.001u,0.s)
Chars 3946 - 3969 [(path_via~(e~*~(3~/~3))).] 0.001 secs (0.001u,0.s)
Chars 3972 - 4017 [(rewrite~pos_recip_r,~pos_mult...] 0.001 secs (0.001u,0.s)
Chars 4020 - 4033 [(apply~pos_eq).] 0.001 secs (0.u,0.s)
Chars 4034 - 4087 [(change~('~e~*~(3~/~3)~=~'~e~/...] 0.001 secs (0.u,0.s)
Chars 4090 - 4113 [ring_tac.ring_with_nat.] 0.001 secs (0.001u,0.s)
Chars 4114 - 4118 [Qed.] 0.092 secs (0.088u,0.004s)
Chars 4120 - 4182 [#[global]Instance~Qpos_mult_as...] 0. secs (0.u,0.s)
Chars 4183 - 4189 [Proof.] 0. secs (0.u,0.s)
Chars 7327 - 7343 [grouphom_reduce.] 40.266 secs (0.037u,0.053s)
Chars 7346 - 7365 [exact~(ap_V~phi~g).] 0.001 secs (0.001u,0.s)
Chars 7327 - 7343 [grouphom_reduce.] 0. secs (0.u,0.s)
Chars 7346 - 7365 [exact~(ap_V~phi~g).] 0. secs (0.u,0.s)
Chars 7366 - 7370 [Qed.] 0.019 secs (0.014u,0.004s)
Chars 7372 - 7435 [Definition~grouphom_1~{G}~{H}~...] 0.001 secs (0.001u,0.s)
Chars 7436 - 7442 [Proof.] 0. secs (0.u,0.s)
Chars 7445 - 7461 [grouphom_reduce.] 0.412 secs (0.016u,0.046s)
Chars 7464 - 7476 [reflexivity.] 0. secs (0.u,0.s)
Chars 7445 - 7461 [grouphom_reduce.] 0. secs (0.u,0.s)
Chars 7464 - 7476 [reflexivity.] 0. secs (0.u,0.s)
Chars 7477 - 7481 [Qed.] 0.009 secs (0.007u,0.001s)
Chars 7483 - 7789 [Definition~grouphom_pp_p~{G}~{...] 0.019 secs (0.016u,0.002s)
Chars 7790 - 7796 [Proof.] 0. secs (0.u,0.s)
Chars 4403 - 4425 [(srapply~Susp_ind;~cbn).] 40.261 secs (0.016u,0.056s)
Chars 4430 - 4447 [1:~(apply~decode').] 0.001 secs (0.001u,0.s)
Chars 4452 - 4453 [{] 0. secs (0.u,0.s)
Chars 4454 - 4462 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 4469 - 4488 [(apply~tr,~merid,~x).] 0.002 secs (0.002u,0.s)
Chars 4489 - 4490 [}] 0. secs (0.u,0.s)
Chars 4495 - 4503 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 4508 - 4537 [srapply~dp_path_transport^-1.] 0.023 secs (0.019u,0.003s)
Chars 4542 - 4557 [(apply~dp_arrow).] 0.003 secs (0.003u,0.s)
Chars 4562 - 4570 [intro~y.] 0.001 secs (0.001u,0.s)
Chars 4575 - 4599 [(apply~dp_path_transport).] 0.002 secs (0.002u,0.s)
Chars 4604 - 4634 [(rewrite~transport_codes_merid).] 0.005 secs (0.004u,0.s)
Chars 4639 - 4665 [(rewrite~transport_decode').] 0.005 secs (0.004u,0.001s)
Chars 4670 - 4679 [symmetry.] 0.004 secs (0.003u,0.s)
Chars 4684 - 4699 [(apply~merid_mu).] 0.002 secs (0.001u,0.s)
Chars 4403 - 4425 [(srapply~Susp_ind;~cbn).] 0.003 secs (0.003u,0.s)
Chars 4430 - 4447 [1:~(apply~decode').] 0. secs (0.u,0.s)
Chars 4454 - 4462 [intro~x.] 0. secs (0.u,0.s)
Chars 4469 - 4488 [(apply~tr,~merid,~x).] 0. secs (0.u,0.s)
Chars 4495 - 4503 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 4508 - 4537 [srapply~dp_path_transport^-1.] 0.001 secs (0.001u,0.s)
Chars 4542 - 4557 [(apply~dp_arrow).] 0.001 secs (0.001u,0.s)
Chars 4562 - 4570 [intro~y.] 0.001 secs (0.001u,0.s)
Chars 4575 - 4599 [(apply~dp_path_transport).] 0.001 secs (0.001u,0.s)
Chars 4604 - 4634 [(rewrite~transport_codes_merid).] 0.001 secs (0.001u,0.s)
Chars 4639 - 4665 [(rewrite~transport_decode').] 0.001 secs (0.001u,0.s)
Chars 4670 - 4679 [symmetry.] 0.001 secs (0.u,0.s)
Chars 4684 - 4699 [(apply~merid_mu).] 0.001 secs (0.001u,0.s)
Chars 4702 - 4710 [Defined.] 0.033 secs (0.024u,0.009s)
Chars 4714 - 4797 [#[local]~Definition~decode_enc...] 0.001 secs (0.001u,0.s)
Chars 4800 - 4806 [Proof.] 0. secs (0.u,0.s)
Chars 24460 - 24474 [(destruct~p,~q).] 40.123 secs (0.004u,0.021s)
Chars 24477 - 24504 [(rewrite~(path_ishprop~y~x)).] 0.003 secs (0.003u,0.s)
Chars 24507 - 24534 [(rewrite~(path_ishprop~z~x)).] 0.003 secs (0.002u,0.s)
Chars 24537 - 24596 [refine~(_~@~(ap~(fun~z~=>~z~@~...] 0.004 secs (0.004u,0.s)
Chars 24599 - 24620 [(apply~(concat_1p~_)^).] 0.001 secs (0.001u,0.s)
Chars 24460 - 24474 [(destruct~p,~q).] 0. secs (0.u,0.s)
Chars 24477 - 24504 [(rewrite~(path_ishprop~y~x)).] 0. secs (0.u,0.s)
Chars 24507 - 24534 [(rewrite~(path_ishprop~z~x)).] 0. secs (0.u,0.s)
Chars 24537 - 24596 [refine~(_~@~(ap~(fun~z~=>~z~@~...] 0. secs (0.u,0.s)
Chars 24599 - 24620 [(apply~(concat_1p~_)^).] 0. secs (0.u,0.s)
Chars 24621 - 24625 [Qed.] 0.006 secs (0.004u,0.001s)
Chars 24775 - 24977 [Definition~path_sigma_hprop_ap...] 0.016 secs (0.015u,0.s)
Chars 24978 - 25176 [Definition~path_sigma_hprop_pr...] 0.017 secs (0.015u,0.001s)
Chars 25177 - 25383 [Definition~ap_pr1_path_sigma_h...] 0.01 secs (0.007u,0.003s)
Chars 25384 - 25588 [Definition~pr1_path_path_sigma...] 0.009 secs (0.009u,0.s)
Chars 25626 - 25871 [Definition~hfiber_functor_sigm...] 0.003 secs (0.002u,0.s)
Chars 25872 - 25878 [Proof.] 0. secs (0.u,0.s)
Chars 15984 - 15997 [refine~(_;~_).] 34.542 secs (19.765u,-0.399s)
Chars 15984 - 15997 [refine~(_;~_).] 40.062 secs (0.002u,0.03s)
Chars 16000 - 16020 [(apply~cu_flip_lr^-1).] 0.02 secs (0.018u,0.001s)
Chars 16023 - 16042 [(apply~cu_fill_left).] 0.009 secs (0.007u,0.002s)
Chars 15984 - 15997 [refine~(_;~_).] 0.001 secs (0.u,0.001s)
Chars 16000 - 16020 [(apply~cu_flip_lr^-1).] 0. secs (0.u,0.s)
Chars 16023 - 16042 [(apply~cu_fill_left).] 0.001 secs (0.001u,0.s)
Chars 16043 - 16051 [Defined.] 0.004 secs (0.004u,0.s)
Chars 16053 - 16717 [Definition~cu_fill_top~{A}~{x0...] 0.007 secs (0.007u,0.s)
Chars 16718 - 16724 [Proof.] 0. secs (0.u,0.s)
Chars 15657 - 15728 [refine~(istrunc_equiv_istrunc~...] 40.207 secs (0.041u,0.038s)
Chars 15657 - 15728 [refine~(istrunc_equiv_istrunc~...] 0. secs (0.u,0.s)
Chars 15731 - 15739 [Defined.] 0.001 secs (0.001u,0.s)
Chars 15743 - 15995 [Definition~equiv_ooextendable_...] 0.005 secs (0.003u,0.002s)
Chars 15999 - 16271 [Definition~ooextendable_postco...] 0.003 secs (0.003u,0.s)
Chars 16275 - 16523 [Definition~ooextendable_postco...] 0.002 secs (0.001u,0.s)
Chars 16527 - 16799 [Definition~ooextendable_compos...] 0.003 secs (0.002u,0.s)
Chars 16803 - 17075 [Definition~cancelL_ooextendabl...] 0.003 secs (0.002u,0.001s)
Chars 17079 - 17356 [Definition~cancelR_ooextendabl...] 0.003 secs (0.002u,0.s)
Chars 17360 - 17585 [Definition~ooextendable_homoto...] 0.002 secs (0.002u,0.s)
Chars 17589 - 17754 [Definition~ooextendable_equiv~...] 0.001 secs (0.u,0.s)
Chars 17758 - 17944 [Definition~ooextendable_contr~...] 0.001 secs (0.001u,0.s)
Chars 17948 - 18141 [Definition~ooextendable_homoto...] 0.001 secs (0.001u,0.s)
Chars 18144 - 18150 [Proof.] 0. secs (0.u,0.s)
Chars 3644 - 3664 [(apply~(injective~f)).] 40.198 secs (0.015u,0.037s)
Chars 3665 - 3694 [(rewrite~(preserves_1~(f:=f))).] 0.006 secs (0.005u,0.001s)
Chars 3695 - 3733 [(apply~int_abs_nonneg;~solve_p...] 0.02 secs (0.019u,0.s)
Chars 3644 - 3664 [(apply~(injective~f)).] 0.001 secs (0.001u,0.s)
Chars 3665 - 3694 [(rewrite~(preserves_1~(f:=f))).] 0.001 secs (0.u,0.s)
Chars 3695 - 3733 [(apply~int_abs_nonneg;~solve_p...] 0.002 secs (0.002u,0.s)
Chars 3734 - 3738 [Qed.] 0.002 secs (0.001u,0.s)
Chars 3740 - 3848 [Lemma~int_abs_nonneg_plus~x~y~...] 0.16 secs (0.129u,0.03s)
Chars 3849 - 3855 [Proof.] 0. secs (0.u,0.s)
Chars 18155 - 18200 [(intros~ext~n;~apply~extendabl...] 8.34 secs (2.478u,-0.44s)
Chars 6026 - 6053 [(apply~O_decidable;~exact~_).] 40.196 secs (0.007u,0.036s)
Chars 6026 - 6053 [(apply~O_decidable;~exact~_).] 0. secs (0.u,0.s)
Chars 6054 - 6062 [Defined.] 0. secs (0.u,0.s)
Chars 6311 - 6592 [Definition~finite_ind_hprop~`{...] 0.003 secs (0.003u,0.s)
Chars 6593 - 6599 [Proof.] 0. secs (0.u,0.s)
Chars 4190 - 4194 [(hnf).] 40.196 secs (0.001u,0.041s)
Chars 4195 - 4215 [(intros;~apply~pos_eq).] 0.002 secs (0.u,0.001s)
Chars 4216 - 4233 [(apply~mult_assoc).] 0.008 secs (0.007u,0.s)
Chars 4190 - 4194 [(hnf).] 0. secs (0.u,0.s)
Chars 4195 - 4215 [(intros;~apply~pos_eq).] 0.001 secs (0.001u,0.s)
Chars 4216 - 4233 [(apply~mult_assoc).] 0. secs (0.u,0.s)
Chars 4234 - 4238 [Qed.] 0.001 secs (0.001u,0.s)
Chars 4240 - 4302 [#[global]Instance~Qpos_plus_as...] 0. secs (0.u,0.s)
Chars 4303 - 4309 [Proof.] 0. secs (0.u,0.s)
Chars 7799 - 7815 [grouphom_reduce.] 40.737 secs (0.476u,0.1s)
Chars 7799 - 7815 [grouphom_reduce.] 0. secs (0.u,0.s)
Chars 7816 - 7822 [Abort.] 0. secs (0.u,0.s)
Chars 7845 - 7863 [Section~Subgroups.] 0. secs (0.u,0.s)
Chars 7866 - 7934 [Context~{G~H~:~ooGroup}~(incl~...] 0.001 secs (0.001u,0.s)
Chars 8059 - 8139 [Definition~in_coset~:~G~->~G~-...] 0.001 secs (0.001u,0.s)
Chars 8143 - 8206 [#[global]Instance~ishprop_in_c...] 0. secs (0.u,0.s)
Chars 8209 - 8215 [Proof.] 0. secs (0.u,0.s)
Chars 4811 - 4819 [intro~x.] 40.186 secs (0.u,0.053s)
Chars 4824 - 4842 [srapply~Trunc_ind.] 0.065 secs (0.053u,0.012s)
Chars 4847 - 4855 [intro~p.] 0. secs (0.u,0.s)
Chars 4860 - 4876 [(destruct~p;~compute).] 0.003 secs (0.003u,0.s)
Chars 4881 - 4901 [(apply~ap,~concat_pV).] 0.008 secs (0.008u,0.s)
Chars 4811 - 4819 [intro~x.] 0. secs (0.u,0.s)
Chars 4824 - 4842 [srapply~Trunc_ind.] 0. secs (0.u,0.s)
Chars 4847 - 4855 [intro~p.] 0. secs (0.u,0.s)
Chars 4860 - 4876 [(destruct~p;~compute).] 0.001 secs (0.001u,0.s)
Chars 4881 - 4901 [(apply~ap,~concat_pV).] 0.003 secs (0.003u,0.s)
Chars 4904 - 4912 [Defined.] 0.008 secs (0.006u,0.001s)
Chars 5084 - 5138 [Lemma~licata_finster~:~pTr~1~(...] 0. secs (0.u,0.s)
Chars 5141 - 5147 [Proof.] 0. secs (0.u,0.s)
Chars 8220 - 8228 [exact~_.] 3.708 secs (0.021u,0.049s)
Chars 8220 - 8228 [exact~_.] 0. secs (0.u,0.s)
Chars 8231 - 8239 [Defined.] 0. secs (0.u,0.s)
Chars 8243 - 8296 [#[global]Instance~reflexive_co...] 0. secs (0.u,0.s)
Chars 8299 - 8305 [Proof.] 0. secs (0.u,0.s)
Chars 25881 - 25910 [(unfold~hfiber,~functor_sigma).] 40.118 secs (0.001u,0.02s)
Chars 25913 - 25952 [refine~(_~oE~equiv_functor_sig...] 0.002 secs (0.001u,0.s)
Chars 25955 - 25998 [2:~(intros;~symmetry;~apply~eq...] 0.004 secs (0.004u,0.s)
Chars 26001 - 26076 [transitivity~{w~:~{x~:~A~&~f~x...] 0.006 secs (0.006u,0.s)
Chars 26079 - 26092 [1:~make_equiv.] 0.051 secs (0.046u,0.005s)
Chars 26095 - 26145 [(apply~equiv_functor_sigma_id;...] 0.005 secs (0.005u,0.s)
Chars 26148 - 26194 [(apply~equiv_functor_sigma_id;...] 0.003 secs (0.002u,0.s)
Chars 26197 - 26227 [(apply~equiv_moveL_transport_V).] 0.001 secs (0.u,0.s)
Chars 25881 - 25910 [(unfold~hfiber,~functor_sigma).] 0. secs (0.u,0.s)
Chars 25913 - 25952 [refine~(_~oE~equiv_functor_sig...] 0. secs (0.u,0.s)
Chars 25955 - 25998 [2:~(intros;~symmetry;~apply~eq...] 0.001 secs (0.001u,0.s)
Chars 26001 - 26076 [transitivity~{w~:~{x~:~A~&~f~x...] 0.001 secs (0.001u,0.s)
Chars 26079 - 26092 [1:~make_equiv.] 0. secs (0.u,0.s)
Chars 26095 - 26145 [(apply~equiv_functor_sigma_id;...] 0.002 secs (0.002u,0.s)
Chars 26148 - 26194 [(apply~equiv_functor_sigma_id;...] 0.001 secs (0.001u,0.s)
Chars 26197 - 26227 [(apply~equiv_moveL_transport_V).] 0. secs (0.u,0.s)
Chars 26228 - 26236 [Defined.] 0.053 secs (0.037u,0.015s)
Chars 26238 - 26444 [#[global]~Instance~istruncmap_...] 0.002 secs (0.001u,0.s)
Chars 26445 - 26451 [Proof.] 0. secs (0.u,0.s)
Chars 16727 - 16740 [refine~(_;~_).] 40.145 secs (0.002u,0.028s)
Chars 16743 - 16762 [(apply~cu_rot_tb_fb).] 0.005 secs (0.005u,0.s)
Chars 16765 - 16784 [(apply~cu_rot_tb_fb).] 0.006 secs (0.005u,0.s)
Chars 16787 - 16824 [refine~(cu_Gccccc~(eisretr~tr~...] 0.014 secs (0.013u,0.s)
Chars 16827 - 16846 [(apply~cu_fill_left).] 0.008 secs (0.006u,0.001s)
Chars 16727 - 16740 [refine~(_;~_).] 0. secs (0.u,0.s)
Chars 16743 - 16762 [(apply~cu_rot_tb_fb).] 0. secs (0.u,0.s)
Chars 16765 - 16784 [(apply~cu_rot_tb_fb).] 0. secs (0.u,0.s)
Chars 16787 - 16824 [refine~(cu_Gccccc~(eisretr~tr~...] 0.001 secs (0.001u,0.s)
Chars 16827 - 16846 [(apply~cu_fill_left).] 0.001 secs (0.001u,0.s)
Chars 16847 - 16855 [Defined.] 0.008 secs (0.008u,0.s)
Chars 16857 - 17484 [Definition~cu_fill_bottom~{A}~...] 0.007 secs (0.007u,0.s)
Chars 17485 - 17491 [Proof.] 0. secs (0.u,0.s)
Chars 18155 - 18200 [(intros~ext~n;~apply~extendabl...] 40.059 secs (0.002u,0.028s)
Chars 18155 - 18200 [(intros~ext~n;~apply~extendabl...] 0. secs (0.u,0.s)
Chars 18203 - 18211 [Defined.] 0. secs (0.u,0.s)
Chars 18506 - 18720 [Definition~ooextendable_isnull...] 0.001 secs (0.001u,0.s)
Chars 18723 - 18729 [Proof.] 0. secs (0.u,0.s)
Chars 3856 - 3863 [(intros).] 40.154 secs (0.002u,0.034s)
Chars 3864 - 3884 [(apply~(injective~f)).] 0.018 secs (0.015u,0.002s)
Chars 3885 - 3939 [(rewrite~(preserves_plus~(f:=f...] 0.076 secs (0.068u,0.007s)
Chars 3940 - 3973 [(apply~nonneg_plus_compat;~tri...] 0.031 secs (0.024u,0.006s)
Chars 3856 - 3863 [(intros).] 0.001 secs (0.u,0.s)
Chars 3864 - 3884 [(apply~(injective~f)).] 0.001 secs (0.001u,0.s)
Chars 3885 - 3939 [(rewrite~(preserves_plus~(f:=f...] 0.005 secs (0.005u,0.s)
Chars 3940 - 3973 [(apply~nonneg_plus_compat;~tri...] 0.003 secs (0.001u,0.001s)
Chars 3974 - 3978 [Qed.] 0.004 secs (0.002u,0.001s)
Chars 3980 - 4059 [Lemma~int_abs_mult~x~y~:~int_a...] 0.139 secs (0.107u,0.029s)
Chars 4060 - 4066 [Proof.] 0. secs (0.u,0.s)
Chars 6602 - 6635 [(pose~proof~(merely_equiv_fin~...] 40.18 secs (0.001u,0.033s)
Chars 6638 - 6656 [strip_truncations.] 0.106 secs (0.084u,0.021s)
Chars 6659 - 6716 [(pose~proof~(transportD~Finite...] 0.008 secs (0.005u,0.002s)
Chars 6719 - 6769 [refine~(transport~(P~X)~(path_...] 0.002 secs (0.002u,0.s)
Chars 6772 - 6803 [(generalize~(fcard~X);~intros~n).] 0.002 secs (0.002u,0.s)
Chars 6806 - 6829 [(induction~n~as~[|~n~IH]).] 0.001 secs (0.001u,0.s)
Chars 6832 - 6833 [-] 0. secs (0.u,0.s)
Chars 6834 - 6843 [exact~f0.] 0.001 secs (0.001u,0.s)
Chars 6846 - 6847 [-] 0. secs (0.u,0.s)
Chars 6848 - 6913 [refine~(transport~(P~(Fin~n.+1...] 0.003 secs (0.002u,0.001s)
Chars 6602 - 6635 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 6638 - 6656 [strip_truncations.] 0. secs (0.u,0.s)
Chars 6659 - 6716 [(pose~proof~(transportD~Finite...] 0. secs (0.u,0.s)
Chars 6719 - 6769 [refine~(transport~(P~X)~(path_...] 0. secs (0.u,0.s)
Chars 6772 - 6803 [(generalize~(fcard~X);~intros~n).] 0.001 secs (0.001u,0.s)
Chars 6806 - 6829 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 6834 - 6843 [exact~f0.] 0. secs (0.u,0.s)
Chars 6848 - 6913 [refine~(transport~(P~(Fin~n.+1...] 0. secs (0.u,0.s)
Chars 6914 - 6922 [Defined.] 0.003 secs (0.002u,0.001s)
Chars 6980 - 7035 [Definition~finite_choice~{X}~`...] 0. secs (0.u,0.s)
Chars 7036 - 7042 [Proof.] 0. secs (0.u,0.s)
Chars 4310 - 4314 [(hnf).] 40.188 secs (0.u,0.042s)
Chars 4315 - 4335 [(intros;~apply~pos_eq).] 0.002 secs (0.002u,0.s)
Chars 4336 - 4353 [(apply~plus_assoc).] 0.008 secs (0.006u,0.001s)
Chars 4310 - 4314 [(hnf).] 0. secs (0.u,0.s)
Chars 4315 - 4335 [(intros;~apply~pos_eq).] 0.001 secs (0.001u,0.s)
Chars 4336 - 4353 [(apply~plus_assoc).] 0. secs (0.u,0.s)
Chars 4354 - 4358 [Qed.] 0.001 secs (0.001u,0.s)
Chars 4360 - 4423 [#[global]Instance~Qpos_mult_1_...] 0.001 secs (0.u,0.s)
Chars 4424 - 4430 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 5152 - 5174 [srapply~Build_pEquiv'.] 40.188 secs (0.002u,0.04s)
Chars 5179 - 5180 [{] 0. secs (0.u,0.s)
Chars 5181 - 5206 [srapply~equiv_adjointify.] 0.002 secs (0.002u,0.s)
Chars 5213 - 5237 [1:~exact~(encode~North).] 0.003 secs (0.003u,0.s)
Chars 5244 - 5261 [1:~exact~decode'.] 0.001 secs (0.001u,0.s)
Chars 5268 - 5305 [1:~(intro;~apply~encode_North_...] 0.003 secs (0.003u,0.s)
Chars 5312 - 5339 [(intro;~apply~decode_encode).] 0.006 secs (0.006u,0.s)
Chars 5340 - 5341 [}] 0. secs (0.u,0.s)
Chars 5346 - 5358 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 5152 - 5174 [srapply~Build_pEquiv'.] 0. secs (0.u,0.s)
Chars 5181 - 5206 [srapply~equiv_adjointify.] 0. secs (0.u,0.s)
Chars 5213 - 5237 [1:~exact~(encode~North).] 0. secs (0.u,0.s)
Chars 5244 - 5261 [1:~exact~decode'.] 0. secs (0.u,0.s)
Chars 5268 - 5305 [1:~(intro;~apply~encode_North_...] 0.001 secs (0.001u,0.s)
Chars 5312 - 5339 [(intro;~apply~decode_encode).] 0.002 secs (0.002u,0.s)
Chars 5346 - 5358 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 5361 - 5369 [Defined.] 0.003 secs (0.003u,0.s)
Chars 5371 - 5394 [End~LicataFinsterLemma.] 0.319 secs (0.294u,0.024s)
Chars 5397 - 5422 [Section~EilenbergMacLane.] 0. secs (0.u,0.s)
Chars 5425 - 5447 [Context~`{Univalence}.] 0. secs (0.u,0.s)
Chars 5451 - 5668 [Fixpoint~EilenbergMacLane~(G~:...] 0.003 secs (0.003u,0.s)
Chars 5672 - 5722 [Notation~"'K('~G~,~n~)"~:=~(Ei...] 0. secs (0.u,0.s)
Chars 5726 - 5796 [#[global]Instance~istrunc_em~~...] 0. secs (0.u,0.s)
Chars 5799 - 5805 [Proof.] 0. secs (0.u,0.s)
Chars 8310 - 8319 [(intros~g).] 40.23 secs (0.u,0.042s)
Chars 8324 - 8369 [exact~(1;~grouphom_1~incl~@~(c...] 0.002 secs (0.002u,0.s)
Chars 8310 - 8319 [(intros~g).] 0. secs (0.u,0.s)
Chars 8324 - 8369 [exact~(1;~grouphom_1~incl~@~(c...] 0. secs (0.u,0.s)
Chars 8372 - 8380 [Defined.] 0.001 secs (0.001u,0.s)
Chars 8384 - 8437 [#[global]Instance~symmetric_co...] 0. secs (0.u,0.s)
Chars 8440 - 8446 [Proof.] 0. secs (0.u,0.s)
Chars 26454 - 26467 [(intros~[a~b]).] 40.118 secs (0.002u,0.02s)
Chars 26470 - 26540 [exact~(istrunc_equiv_istrunc~_...] 0.008 secs (0.005u,0.002s)
Chars 26454 - 26467 [(intros~[a~b]).] 0. secs (0.u,0.s)
Chars 26470 - 26540 [exact~(istrunc_equiv_istrunc~_...] 0. secs (0.u,0.s)
Chars 26541 - 26549 [Defined.] 0.003 secs (0.003u,0.s)
Chars 26572 - 26763 [Definition~hfiber_functor_sigm...] 0.001 secs (0.001u,0.s)
Chars 26764 - 26770 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 17494 - 17507 [refine~(_;~_).] 40.155 secs (0.003u,0.027s)
Chars 17510 - 17529 [(apply~cu_rot_tb_fb).] 0.005 secs (0.005u,0.s)
Chars 17532 - 17551 [(apply~cu_rot_tb_fb).] 0.027 secs (0.016u,0.01s)
Chars 17554 - 17591 [refine~(cu_cGcccc~(eisretr~tr~...] 0.014 secs (0.014u,0.s)
Chars 17594 - 17614 [(apply~cu_fill_right).] 0.009 secs (0.007u,0.001s)
Chars 17494 - 17507 [refine~(_;~_).] 0.001 secs (0.001u,0.s)
Chars 17510 - 17529 [(apply~cu_rot_tb_fb).] 0. secs (0.u,0.s)
Chars 17532 - 17551 [(apply~cu_rot_tb_fb).] 0.001 secs (0.001u,0.s)
Chars 17554 - 17591 [refine~(cu_cGcccc~(eisretr~tr~...] 0.001 secs (0.001u,0.s)
Chars 17594 - 17614 [(apply~cu_fill_right).] 0.001 secs (0.001u,0.s)
Chars 17615 - 17623 [Defined.] 0.012 secs (0.007u,0.004s)
Chars 17625 - 18291 [Definition~cu_fill_front~{A}~{...] 0.007 secs (0.007u,0.s)
Chars 18292 - 18298 [Proof.] 0. secs (0.u,0.s)
Chars 18301 - 18314 [refine~(_;~_).] 0.591 secs (0.001u,0.031s)
Chars 18317 - 18336 [(apply~cu_rot_tb_fb).] 0.005 secs (0.004u,0.s)
Chars 18339 - 18358 [(apply~cu_fill_left).] 0.009 secs (0.008u,0.s)
Chars 18301 - 18314 [refine~(_;~_).] 0.001 secs (0.001u,0.s)
Chars 18317 - 18336 [(apply~cu_rot_tb_fb).] 0. secs (0.u,0.s)
Chars 18339 - 18358 [(apply~cu_fill_left).] 0.001 secs (0.001u,0.s)
Chars 18359 - 18367 [Defined.] 0.005 secs (0.003u,0.001s)
Chars 18369 - 18994 [Definition~cu_fill_back~{A}~{x...] 0.007 secs (0.004u,0.002s)
Chars 18995 - 19001 [Proof.] 0. secs (0.u,0.s)
Chars 18734 - 18763 [(intros~orth~n;~revert~C~orth).] 40.154 secs (0.u,0.029s)
Chars 18768 - 18827 [(induction~n~as~[|~n~IHn];~int...] 0.005 secs (0.002u,0.003s)
Chars 18832 - 18833 [-] 0. secs (0.u,0.s)
Chars 18834 - 18843 [(intros~g).] 0. secs (0.u,0.s)
Chars 18850 - 18917 [exists~(fun~b~=>~(fst~(orth~b~...] 0.006 secs (0.005u,0.001s)
Chars 18924 - 18933 [(intros~a).] 0.001 secs (0.001u,0.s)
Chars 18940 - 18976 [(rewrite~(path_unit~tt~(const~...] 0.003 secs (0.003u,0.s)
Chars 18983 - 19028 [exact~((fst~(orth~(f~a)~1%nat)...] 0.004 secs (0.004u,0.s)
Chars 19033 - 19034 [-] 0. secs (0.u,0.s)
Chars 19035 - 19046 [(intros~h~k).] 0.001 secs (0.001u,0.s)
Chars 19053 - 19073 [(apply~IHn;~intros~b).] 0.002 secs (0.002u,0.s)
Chars 19080 - 19114 [(apply~ooextendable_homotopy,~...] 0.002 secs (0.001u,0.s)
Chars 18734 - 18763 [(intros~orth~n;~revert~C~orth).] 0. secs (0.u,0.s)
Chars 18768 - 18827 [(induction~n~as~[|~n~IHn];~int...] 0.002 secs (0.002u,0.s)
Chars 18834 - 18843 [(intros~g).] 0. secs (0.u,0.s)
Chars 18850 - 18917 [exists~(fun~b~=>~(fst~(orth~b~...] 0. secs (0.u,0.s)
Chars 18924 - 18933 [(intros~a).] 0.001 secs (0.001u,0.s)
Chars 18940 - 18976 [(rewrite~(path_unit~tt~(const~...] 0. secs (0.u,0.s)
Chars 18983 - 19028 [exact~((fst~(orth~(f~a)~1%nat)...] 0.001 secs (0.001u,0.s)
Chars 19035 - 19046 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 19053 - 19073 [(apply~IHn;~intros~b).] 0.001 secs (0.001u,0.s)
Chars 19080 - 19114 [(apply~ooextendable_homotopy,~...] 0. secs (0.u,0.s)
Chars 19117 - 19125 [Defined.] 0.003 secs (0.001u,0.001s)
Chars 19127 - 19142 [End~Extensions.] 0.18 secs (0.16u,0.019s)
Chars 19301 - 19471 [Definition~cyl_extension~{A}~{...] 0.002 secs (0.002u,0.s)
Chars 19472 - 19478 [Proof.] 0. secs (0.u,0.s)
Chars 4067 - 4087 [(apply~(injective~f)).] 40.193 secs (0.014u,0.036s)
Chars 4088 - 4120 [(rewrite~(preserves_mult~(f:=f...] 0.006 secs (0.005u,0.001s)
Chars 4121 - 4222 [(destruct~(int_abs_spec~x)~as~...] 0.041 secs (0.034u,0.004s)
Chars 4223 - 4224 [-] 0. secs (0.u,0.s)
Chars 4225 - 4256 [(rewrite~int_abs_nonneg;~trivi...] 0.009 secs (0.009u,0.s)
Chars 4257 - 4290 [(apply~nonneg_mult_compat;~tri...] 0.028 secs (0.025u,0.002s)
Chars 4291 - 4292 [-] 0. secs (0.u,0.s)
Chars 4293 - 4316 [(rewrite~int_abs_nonpos).] 0.003 secs (0.002u,0.001s)
Chars 4319 - 4320 [+] 0. secs (0.u,0.s)
Chars 4321 - 4347 [(apply~negate_mult_distr_r).] 0.013 secs (0.012u,0.s)
Chars 4350 - 4351 [+] 0. secs (0.u,0.s)
Chars 4352 - 4385 [(apply~nonneg_nonpos_mult;~tri...] 0.034 secs (0.033u,0.s)
Chars 4386 - 4387 [-] 0. secs (0.u,0.s)
Chars 4388 - 4411 [(rewrite~int_abs_nonpos).] 0.003 secs (0.003u,0.s)
Chars 4414 - 4415 [+] 0. secs (0.u,0.s)
Chars 4416 - 4442 [(apply~negate_mult_distr_l).] 0.013 secs (0.008u,0.004s)
Chars 4445 - 4446 [+] 0. secs (0.u,0.s)
Chars 4447 - 4480 [(apply~nonpos_nonneg_mult;~tri...] 0.036 secs (0.031u,0.003s)
Chars 4481 - 4482 [-] 0. secs (0.u,0.s)
Chars 4483 - 4506 [(rewrite~int_abs_nonneg).] 0.004 secs (0.004u,0.s)
Chars 4509 - 4510 [+] 0. secs (0.u,0.s)
Chars 4511 - 4545 [(symmetry;~apply~negate_mult_n...] 0.018 secs (0.015u,0.003s)
Chars 4548 - 4549 [+] 0. secs (0.u,0.s)
Chars 4550 - 4576 [(apply~nonpos_mult;~trivial).] 0.034 secs (0.029u,0.005s)
Chars 4067 - 4087 [(apply~(injective~f)).] 0.001 secs (0.001u,0.s)
Chars 4088 - 4120 [(rewrite~(preserves_mult~(f:=f...] 0.001 secs (0.001u,0.s)
Chars 4121 - 4222 [(destruct~(int_abs_spec~x)~as~...] 0.014 secs (0.01u,0.003s)
Chars 4225 - 4256 [(rewrite~int_abs_nonneg;~trivi...] 0.004 secs (0.003u,0.s)
Chars 4257 - 4290 [(apply~nonneg_mult_compat;~tri...] 0.004 secs (0.004u,0.s)
Chars 4293 - 4316 [(rewrite~int_abs_nonpos).] 0.001 secs (0.001u,0.s)
Chars 4321 - 4347 [(apply~negate_mult_distr_r).] 0.001 secs (0.001u,0.s)
Chars 4352 - 4385 [(apply~nonneg_nonpos_mult;~tri...] 0.004 secs (0.004u,0.s)
Chars 4388 - 4411 [(rewrite~int_abs_nonpos).] 0.001 secs (0.001u,0.s)
Chars 4416 - 4442 [(apply~negate_mult_distr_l).] 0.001 secs (0.001u,0.s)
Chars 4447 - 4480 [(apply~nonpos_nonneg_mult;~tri...] 0.004 secs (0.004u,0.s)
Chars 4483 - 4506 [(rewrite~int_abs_nonneg).] 0.001 secs (0.001u,0.s)
Chars 4511 - 4545 [(symmetry;~apply~negate_mult_n...] 0.003 secs (0.003u,0.s)
Chars 4550 - 4576 [(apply~nonpos_mult;~trivial).] 0.004 secs (0.004u,0.s)
Chars 4577 - 4581 [Qed.] 0.016 secs (0.015u,0.s)
Chars 4582 - 4595 [End~contents.] 0.33 secs (0.32u,0.01s)
find_witness Control.TimeoutChars 7045 - 7069 [(intros~P~oP~f;~clear~oP).] 40.182 secs (0.u,0.034s)
Chars 7072 - 7105 [(pose~proof~(merely_equiv_fin~...] 0.001 secs (0.001u,0.s)
Chars 7108 - 7126 [strip_truncations.] 0.036 secs (0.033u,0.002s)
Chars 7129 - 7150 [(set~(P'~:=~P~o~e^-1)).] 0.004 secs (0.003u,0.s)
Chars 7153 - 7216 [(pose~proof~((fun~x~=>~f~(e^-1...] 0.002 secs (0.002u,0.s)
Chars 7219 - 7287 [refine~(Trunc_functor~(X:=fora...] 0.002 secs (0.001u,0.001s)
Chars 7290 - 7291 [-] 0. secs (0.u,0.s)
Chars 7292 - 7334 [(intros~g~x;~exact~(eissect~e~...] 0.003 secs (0.003u,0.s)
Chars 7337 - 7338 [-] 0. secs (0.u,0.s)
Chars 7339 - 7365 [(clearbody~P';~clear~f~P~e).] 0.001 secs (0.001u,0.s)
Chars 7370 - 7415 [(generalize~dependent~(fcard~X...] 0.002 secs (0.002u,0.s)
Chars 7420 - 7443 [(induction~n~as~[|~n~IH]).] 0.001 secs (0.001u,0.s)
Chars 7448 - 7449 [+] 0. secs (0.u,0.s)
Chars 7450 - 7475 [exact~(tr~(Empty_ind~P)).] 0.001 secs (0.001u,0.s)
Chars 7480 - 7481 [+] 0. secs (0.u,0.s)
Chars 7482 - 7518 [specialize~(IH~(P~o~inl)~(f~o~...] 0.004 secs (0.003u,0.001s)
Chars 7525 - 7550 [(pose~proof~(f~(inr~tt))~as~e).] 0.002 secs (0.002u,0.s)
Chars 7557 - 7575 [strip_truncations.] 0.114 secs (0.095u,0.019s)
Chars 7582 - 7621 [exact~(tr~(sum_ind~P~IH~(Unit_...] 0.002 secs (0.002u,0.s)
Chars 7045 - 7069 [(intros~P~oP~f;~clear~oP).] 0. secs (0.u,0.s)
Chars 7072 - 7105 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 7108 - 7126 [strip_truncations.] 0. secs (0.u,0.s)
Chars 7129 - 7150 [(set~(P'~:=~P~o~e^-1)).] 0. secs (0.u,0.s)
Chars 7153 - 7216 [(pose~proof~((fun~x~=>~f~(e^-1...] 0. secs (0.u,0.s)
Chars 7219 - 7287 [refine~(Trunc_functor~(X:=fora...] 0. secs (0.u,0.s)
Chars 7292 - 7334 [(intros~g~x;~exact~(eissect~e~...] 0. secs (0.u,0.s)
Chars 7339 - 7365 [(clearbody~P';~clear~f~P~e).] 0. secs (0.u,0.s)
Chars 7370 - 7415 [(generalize~dependent~(fcard~X...] 0. secs (0.u,0.s)
Chars 7420 - 7443 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 7450 - 7475 [exact~(tr~(Empty_ind~P)).] 0. secs (0.u,0.s)
Chars 7482 - 7518 [specialize~(IH~(P~o~inl)~(f~o~...] 0. secs (0.u,0.s)
Chars 7525 - 7550 [(pose~proof~(f~(inr~tt))~as~e).] 0. secs (0.u,0.s)
Chars 7557 - 7575 [strip_truncations.] 0. secs (0.u,0.s)
Chars 7582 - 7621 [exact~(tr~(sum_ind~P~IH~(Unit_...] 0. secs (0.u,0.s)
Chars 7622 - 7630 [Defined.] 0.007 secs (0.007u,0.s)
Chars 7632 - 7694 [Corollary~isprojective_fin_n~(...] 0. secs (0.u,0.s)
Chars 7695 - 7701 [Proof.] 0. secs (0.u,0.s)
Chars 4431 - 4470 [(hnf;~intros;~apply~pos_eq;~ap...] 40.198 secs (0.008u,0.042s)
Chars 4431 - 4470 [(hnf;~intros;~apply~pos_eq;~ap...] 0.002 secs (0.002u,0.s)
Chars 4471 - 4475 [Qed.] 0. secs (0.u,0.s)
Chars 4477 - 4541 [#[global]Instance~Qpos_mult_1_...] 0.001 secs (0.001u,0.s)
Chars 4542 - 4548 [Proof.] 0. secs (0.u,0.s)
Chars 4549 - 4588 [(hnf;~intros;~apply~pos_eq;~ap...] 0.214 secs (0.009u,0.044s)
Chars 4549 - 4588 [(hnf;~intros;~apply~pos_eq;~ap...] 0.003 secs (0.002u,0.s)
Chars 4589 - 4593 [Qed.] 0. secs (0.u,0.s)
Chars 4595 - 4678 [Lemma~pos_recip_through_plus@{...] 0.002 secs (0.002u,0.s)
Chars 4679 - 4685 [Proof.] 0. secs (0.u,0.s)
Chars 19004 - 19017 [refine~(_;~_).] 21.349 secs (0.001u,0.031s)
Chars 19020 - 19039 [(apply~cu_rot_tb_fb).] 0.005 secs (0.005u,0.s)
Chars 19042 - 19062 [(apply~cu_fill_right).] 0.009 secs (0.007u,0.002s)
Chars 19004 - 19017 [refine~(_;~_).] 0. secs (0.u,0.s)
Chars 19020 - 19039 [(apply~cu_rot_tb_fb).] 0. secs (0.u,0.s)
Chars 19042 - 19062 [(apply~cu_fill_right).] 0. secs (0.u,0.s)
Chars 19063 - 19071 [Defined.] 0.004 secs (0.003u,0.s)
Chars 19306 - 22330 [Definition~cu_concat_lr~{A}~~~...] 0.176 secs (0.148u,0.027s)
Chars 22536 - 22592 [Notation~"x~'@lr'~y"~:=~(cu_co...] 0. secs (0.u,0.s)
Chars 22594 - 22638 [#[local]Notation~apc~:=~(ap_co...] 0. secs (0.u,0.s)
Chars 22675 - 22941 [Definition~sq_ap_compose~{A~B~...] 0.012 secs (0.011u,0.001s)
Chars 22942 - 22948 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 22951 - 22965 [by~destruct~s.] 0.129 secs (0.015u,0.031s)
Chars 22951 - 22965 [by~destruct~s.] 0.001 secs (0.001u,0.s)
Chars 22966 - 22974 [Defined.] 0.004 secs (0.003u,0.s)
Chars 22976 - 23014 [#[local]Notation~api~:=~(ap_id...] 0. secs (0.u,0.s)
Chars 23050 - 23262 [Definition~sq_ap_idmap~{A~:~Ty...] 0.004 secs (0.003u,0.s)
Chars 23263 - 23269 [Proof.] 0. secs (0.u,0.s)
Chars 23272 - 23286 [by~destruct~s.] 0.117 secs (0.013u,0.03s)
Chars 23272 - 23286 [by~destruct~s.] 0. secs (0.u,0.s)
Chars 23287 - 23295 [Defined.] 0.002 secs (0.002u,0.s)
Chars 23297 - 23332 [#[local]Notation~apn~:=~(ap_na...] 0. secs (0.u,0.s)
Chars 23366 - 23626 [Definition~sq_ap_nat~{A~B~:~Ty...] 0.02 secs (0.012u,0.007s)
Chars 23627 - 23633 [Proof.] 0. secs (0.u,0.s)
Chars 5810 - 5839 [(destruct~n~as~[|~[]];~exact~_).] 40.283 secs (0.031u,0.06s)
Chars 5810 - 5839 [(destruct~n~as~[|~[]];~exact~_).] 0. secs (0.u,0.s)
Chars 5842 - 5850 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5854 - 5938 [#[global]~Instance~isconnected...] 0. secs (0.u,0.s)
Chars 5941 - 5947 [Proof.] 0. secs (0.u,0.s)
Chars 8451 - 8470 [(intros~g1~g2~[h~p]).] 40.211 secs (0.001u,0.042s)
Chars 8475 - 8487 [exists~h^.] 0.001 secs (0.u,0.s)
Chars 8492 - 8568 [refine~~(((grouphom_V~incl~h~@...] 0.006 secs (0.005u,0.001s)
Chars 8451 - 8470 [(intros~g1~g2~[h~p]).] 0. secs (0.u,0.s)
Chars 8475 - 8487 [exists~h^.] 0. secs (0.u,0.s)
Chars 8492 - 8568 [refine~~(((grouphom_V~incl~h~@...] 0. secs (0.u,0.s)
Chars 8571 - 8579 [Defined.] 0.004 secs (0.003u,0.s)
Chars 8583 - 8638 [#[global]Instance~transitive_c...] 0. secs (0.u,0.s)
Chars 8641 - 8647 [Proof.] 0. secs (0.u,0.s)
Chars 26773 - 26824 [refine~(_~oE~hfiber_functor_si...] 37.443 secs (34.254u,-0.467s)
Chars 26773 - 26824 [refine~(_~oE~hfiber_functor_si...] 40.048 secs (0.002u,0.021s)
Chars 26827 - 26930 [exact~~(equiv_contr_sigma~~~~~...] 0.008 secs (0.006u,0.001s)
Chars 26773 - 26824 [refine~(_~oE~hfiber_functor_si...] 0. secs (0.u,0.s)
Chars 26827 - 26930 [exact~~(equiv_contr_sigma~~~~~...] 0. secs (0.u,0.s)
Chars 26931 - 26939 [Defined.] 0.001 secs (0.001u,0.s)
Chars 27009 - 27187 [Definition~istruncmap_from_fun...] 0.001 secs (0.001u,0.s)
Chars 27188 - 27194 [Proof.] 0. secs (0.u,0.s)
Chars 7704 - 7751 [(apply~(iff_isoprojective_haso...] 26.498 secs (14.498u,-0.586s)
Chars 19481 - 19536 [(srefine~(Cyl_ind_dp~C~g~(ext....] 40.157 secs (0.003u,0.03s)
Chars 19539 - 19540 [+] 0. secs (0.u,0.s)
Chars 19541 - 19573 [refine~((ext.2~a)^~@Dl~_)%dpath.] 0.002 secs (0.002u,0.s)
Chars 19578 - 19591 [(apply~dp_apD).] 0.001 secs (0.u,0.s)
Chars 19594 - 19595 [+] 0. secs (0.u,0.s)
Chars 19596 - 19608 [reflexivity.] 0.002 secs (0.001u,0.s)
Chars 19481 - 19536 [(srefine~(Cyl_ind_dp~C~g~(ext....] 0.002 secs (0.002u,0.s)
Chars 19541 - 19573 [refine~((ext.2~a)^~@Dl~_)%dpath.] 0. secs (0.u,0.s)
Chars 19578 - 19591 [(apply~dp_apD).] 0. secs (0.u,0.s)
Chars 19596 - 19608 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 19669 - 19677 [Defined.] 0.003 secs (0.002u,0.s)
Chars 19679 - 19836 [Definition~cyl_extendable~(n~:...] 0.002 secs (0.001u,0.s)
Chars 19837 - 19843 [Proof.] 0. secs (0.u,0.s)
Chars 19846 - 19920 [(revert~C~ext;~simple_inductio...] 0.083 secs (0.003u,0.031s)
Chars 19923 - 19924 [-] 0. secs (0.u,0.s)
Chars 19925 - 19934 [(intros~g).] 0.001 secs (0.001u,0.s)
Chars 19939 - 19959 [(apply~cyl_extension).] 0.001 secs (0.001u,0.s)
Chars 19964 - 19982 [exact~(fst~ext~g).] 0.001 secs (0.001u,0.s)
Chars 19985 - 19986 [-] 0. secs (0.u,0.s)
Chars 19987 - 20008 [(intros~h~k;~apply~IH).] 0.002 secs (0.002u,0.s)
Chars 20013 - 20033 [exact~(snd~ext~h~k).] 0.002 secs (0.002u,0.s)
Chars 19846 - 19920 [(revert~C~ext;~simple_inductio...] 0.002 secs (0.002u,0.s)
Chars 19925 - 19934 [(intros~g).] 0. secs (0.u,0.s)
Chars 19939 - 19959 [(apply~cyl_extension).] 0. secs (0.u,0.s)
Chars 19964 - 19982 [exact~(fst~ext~g).] 0. secs (0.u,0.s)
Chars 19987 - 20008 [(intros~h~k;~apply~IH).] 0.001 secs (0.001u,0.s)
Chars 20013 - 20033 [exact~(snd~ext~h~k).] 0. secs (0.u,0.s)
Chars 20034 - 20042 [Defined.] 0.002 secs (0.002u,0.s)
Chars 20044 - 20236 [Definition~cyl_ooextendable~{A...] 0.003 secs (0.002u,0.s)
Chars 20238 - 20434 [Definition~cyl_extension'~{A}~...] 0.008 secs (0.006u,0.002s)
Chars 20435 - 20441 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 7704 - 7751 [(apply~(iff_isoprojective_haso...] 40.083 secs (0.012u,0.035s)
Chars 7754 - 7775 [rapply~finite_choice.] 0.001 secs (0.001u,0.s)
Chars 7704 - 7751 [(apply~(iff_isoprojective_haso...] 0. secs (0.u,0.s)
Chars 7754 - 7775 [rapply~finite_choice.] 0. secs (0.u,0.s)
Chars 7776 - 7784 [Defined.] 0. secs (0.u,0.s)
Chars 8522 - 8594 [#[global]Instance~finite_sum~~...] 0. secs (0.u,0.s)
Chars 8595 - 8601 [Proof.] 0. secs (0.u,0.s)
Chars 4686 - 4693 [(intros).] 40.201 secs (0.001u,0.042s)
Chars 4694 - 4723 [(path_via~((a~+~b)~*~(c~/~c))).] 0.012 secs (0.006u,0.006s)
Chars 4724 - 4725 [-] 0. secs (0.u,0.s)
Chars 4726 - 4777 [(rewrite~pos_recip_r;~apply~po...] 0.011 secs (0.01u,0.s)
Chars 4778 - 4779 [-] 0. secs (0.u,0.s)
Chars 4780 - 4816 [(apply~pos_eq;~ring_tac.ring_w...] 0.299 secs (0.255u,0.043s)
Chars 4686 - 4693 [(intros).] 0. secs (0.u,0.s)
Chars 4694 - 4723 [(path_via~((a~+~b)~*~(c~/~c))).] 0. secs (0.u,0.s)
Chars 4726 - 4777 [(rewrite~pos_recip_r;~apply~po...] 0.001 secs (0.001u,0.s)
Chars 4780 - 4816 [(apply~pos_eq;~ring_tac.ring_w...] 0.002 secs (0.001u,0.s)
Chars 4817 - 4821 [Qed.] 0.084 secs (0.078u,0.005s)
Chars 4823 - 4881 [Lemma~pos_unconjugate@{}~:~for...] 0.001 secs (0.001u,0.s)
Chars 4882 - 4888 [Proof.] 0. secs (0.u,0.s)
Chars 23636 - 23678 [(destruct~s~as~[x];~cbn;~by~de...] 40.23 secs (0.07u,0.043s)
Chars 23636 - 23678 [(destruct~s~as~[x];~cbn;~by~de...] 0.006 secs (0.005u,0.s)
Chars 23679 - 23687 [Defined.] 0.016 secs (0.013u,0.002s)
Chars 8652 - 8684 [(intros~g1~g2~g3~[h1~p1]~[h2~p...] 40.215 secs (0.004u,0.044s)
Chars 8689 - 8706 [exists~(h1~@~h2).] 0.002 secs (0.002u,0.s)
Chars 8711 - 8843 [refine~~(((grouphom_pp~incl~h1...] 0.006 secs (0.005u,0.s)
Chars 8652 - 8684 [(intros~g1~g2~g3~[h1~p1]~[h2~p...] 0. secs (0.u,0.s)
Chars 8689 - 8706 [exists~(h1~@~h2).] 0. secs (0.u,0.s)
Chars 8711 - 8843 [refine~~(((grouphom_pp~incl~h1...] 0.001 secs (0.001u,0.s)
Chars 8846 - 8854 [Defined.] 0.006 secs (0.004u,0.001s)
Chars 23724 - 24010 [Definition~sq_ap_uncurry~{A}~{...] 0.052 secs (0.039u,0.012s)
Chars 24011 - 24017 [Proof.] 0. secs (0.u,0.s)
Chars 8929 - 9005 [Definition~equiv_coset_subgrou...] 0. secs (0.u,0.s)
Chars 9008 - 9014 [Proof.] 0. secs (0.u,0.s)
Chars 5952 - 5973 [(induction~n;~exact~_).] 40.302 secs (0.044u,0.062s)
Chars 5952 - 5973 [(induction~n;~exact~_).] 0. secs (0.u,0.s)
Chars 5976 - 5984 [Defined.] 0.002 secs (0.002u,0.s)
Chars 5988 - 6017 [#[local]Open~Scope~trunc_scope.] 0. secs (0.u,0.s)
Chars 6234 - 6362 [#[local]~Lemma~pequiv_ptr_loop...] 0.001 secs (0.u,0.s)
Chars 6365 - 6371 [Proof.] 0. secs (0.u,0.s)
Chars 24020 - 24037 [by~destruct~p,~q.] 0.28 secs (0.044u,0.04s)
Chars 24020 - 24037 [by~destruct~p,~q.] 0.002 secs (0.001u,0.s)
Chars 24038 - 24046 [Defined.] 0.016 secs (0.015u,0.001s)
Chars 24067 - 24810 [Definition~cu_ap~{A}~{B}~{x000...] 0.018 secs (0.017u,0.001s)
Chars 24811 - 24817 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 27197 - 27208 [(intros~a~v).] 40.134 secs (0.001u,0.02s)
Chars 27211 - 27282 [exact~(istrunc_equiv_istrunc~_...] 0.003 secs (0.003u,0.s)
Chars 27197 - 27208 [(intros~a~v).] 0. secs (0.u,0.s)
Chars 27211 - 27282 [exact~(istrunc_equiv_istrunc~_...] 0. secs (0.u,0.s)
Chars 27283 - 27291 [Defined.] 0.001 secs (0.u,0.s)
Chars 20444 - 20465 [rapply~cyl_extension.] 40.161 secs (0.003u,0.03s)
Chars 20468 - 20492 [exists~(ext.1~o~pr_cyl).] 0.056 secs (0.041u,0.014s)
Chars 20495 - 20517 [(intros~x;~apply~ext.2).] 0.003 secs (0.003u,0.s)
Chars 20444 - 20465 [rapply~cyl_extension.] 0. secs (0.u,0.s)
Chars 20468 - 20492 [exists~(ext.1~o~pr_cyl).] 0. secs (0.u,0.s)
Chars 20495 - 20517 [(intros~x;~apply~ext.2).] 0. secs (0.u,0.s)
Chars 20518 - 20526 [Defined.] 0.002 secs (0.002u,0.s)
Chars 20528 - 20696 [Definition~cyl_extendable'~(n~...] 0.002 secs (0.002u,0.s)
Chars 20697 - 20703 [Proof.] 0. secs (0.u,0.s)
Chars 8604 - 8637 [(pose~proof~(merely_equiv_fin~...] 40.188 secs (0.001u,0.033s)
Chars 8640 - 8658 [strip_truncations.] 0.035 secs (0.033u,0.001s)
Chars 8661 - 8712 [refine~(finite_equiv~_~(functo...] 0.025 secs (0.022u,0.002s)
Chars 8715 - 8746 [(generalize~(fcard~Y);~intros~n).] 0.001 secs (0.001u,0.s)
Chars 8749 - 8772 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 8775 - 8776 [-] 0. secs (0.u,0.s)
Chars 8777 - 8822 [refine~(finite_equiv~_~(sum_em...] 0.004 secs (0.004u,0.s)
Chars 8825 - 8826 [-] 0. secs (0.u,0.s)
Chars 8827 - 8880 [refine~(finite_equiv~_~(equiv_...] 0.006 secs (0.006u,0.s)
Chars 8604 - 8637 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 8640 - 8658 [strip_truncations.] 0. secs (0.u,0.s)
Chars 8661 - 8712 [refine~(finite_equiv~_~(functo...] 0. secs (0.u,0.s)
Chars 8715 - 8746 [(generalize~(fcard~Y);~intros~n).] 0. secs (0.u,0.s)
Chars 8749 - 8772 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 8777 - 8822 [refine~(finite_equiv~_~(sum_em...] 0. secs (0.u,0.s)
Chars 8827 - 8880 [refine~(finite_equiv~_~(equiv_...] 0. secs (0.u,0.s)
Chars 8881 - 8889 [Defined.] 0.003 secs (0.003u,0.s)
Chars 9058 - 9089 [Goal~_~fcard~(Fin~3~+~Fin~4)~=~7.] 0.008 secs (0.005u,0.002s)
Chars 9092 - 9104 [reflexivity.] 0.092 secs (0.001u,0.034s)
Chars 9092 - 9104 [reflexivity.] 0. secs (0.u,0.s)
Chars 9105 - 9111 [Abort.] 0. secs (0.u,0.s)
Chars 9113 - 9200 [Definition~fcard_sum~X~Y~`{Fin...] 0.009 secs (0.008u,0.001s)
Chars 9201 - 9207 [Proof.] 0. secs (0.u,0.s)
Chars 4889 - 4896 [(intros).] 40.196 secs (0.001u,0.045s)
Chars 4897 - 4918 [(path_via~(a~/~a~*~b)).] 0.01 secs (0.009u,0.001s)
Chars 4919 - 4920 [-] 0. secs (0.u,0.s)
Chars 4921 - 4957 [(apply~pos_eq;~ring_tac.ring_w...] 0.176 secs (0.148u,0.027s)
Chars 4958 - 4959 [-] 0. secs (0.u,0.s)
Chars 4960 - 5000 [(rewrite~pos_recip_r;~apply~Qp...] 0.002 secs (0.002u,0.s)
Chars 4889 - 4896 [(intros).] 0. secs (0.u,0.s)
Chars 4897 - 4918 [(path_via~(a~/~a~*~b)).] 0. secs (0.u,0.s)
Chars 4921 - 4957 [(apply~pos_eq;~ring_tac.ring_w...] 0.001 secs (0.001u,0.s)
Chars 4960 - 5000 [(rewrite~pos_recip_r;~apply~Qp...] 0.001 secs (0.001u,0.s)
Chars 5001 - 5005 [Qed.] 0.035 secs (0.031u,0.003s)
Chars 5007 - 5042 [Lemma~Qpos_recip_1~:~/~1~=~1~:...] 0.001 secs (0.001u,0.s)
Chars 5043 - 5049 [Proof.] 0. secs (0.u,0.s)
Chars 9019 - 9060 [simple~refine~(equiv_adjointif...] 40.224 secs (0.001u,0.042s)
Chars 9065 - 9066 [-] 0. secs (0.u,0.s)
Chars 9067 - 9093 [(intros~[?~[h~?]];~exact~h).] 0.003 secs (0.003u,0.s)
Chars 9098 - 9099 [-] 0. secs (0.u,0.s)
Chars 9100 - 9148 [(intros~h;~exists~(incl~h^~@~g...] 0.006 secs (0.006u,0.s)
Chars 9155 - 9226 [(abstract~(rewrite~inv_pp,~gro...] 0.022 secs (0.019u,0.002s)
Chars 9231 - 9232 [-] 0. secs (0.u,0.s)
Chars 9233 - 9255 [(intros~h;~reflexivity).] 0.003 secs (0.003u,0.s)
Chars 9260 - 9261 [-] 0. secs (0.u,0.s)
Chars 9262 - 9280 [(intros~[g'~[h~p]]).] 0.009 secs (0.007u,0.001s)
Chars 9287 - 9317 [(apply~path_sigma_hprop;~simpl).] 0.011 secs (0.007u,0.003s)
Chars 9324 - 9362 [refine~((grouphom_V~incl~h~@@~...] 0.003 secs (0.002u,0.s)
Chars 9369 - 9394 [(apply~moveR_Vp,~moveL_pM).] 0.003 secs (0.002u,0.s)
Chars 9395 - 9406 [exact~p^.] 0.001 secs (0.001u,0.s)
Chars 9019 - 9060 [simple~refine~(equiv_adjointif...] 0. secs (0.u,0.s)
Chars 9067 - 9093 [(intros~[?~[h~?]];~exact~h).] 0. secs (0.u,0.s)
Chars 9100 - 9148 [(intros~h;~exists~(incl~h^~@~g...] 0.001 secs (0.001u,0.s)
Chars 9155 - 9226 [(abstract~(rewrite~inv_pp,~gro...] 0. secs (0.u,0.s)
Chars 9233 - 9255 [(intros~h;~reflexivity).] 0.002 secs (0.001u,0.s)
Chars 9262 - 9280 [(intros~[g'~[h~p]]).] 0.002 secs (0.002u,0.s)
Chars 9287 - 9317 [(apply~path_sigma_hprop;~simpl).] 0.003 secs (0.002u,0.s)
Chars 9324 - 9362 [refine~((grouphom_V~incl~h~@@~...] 0. secs (0.u,0.s)
Chars 9369 - 9394 [(apply~moveR_Vp,~moveL_pM).] 0. secs (0.u,0.s)
Chars 9395 - 9406 [exact~p^.] 0. secs (0.u,0.s)
Chars 6376 - 6398 [snrapply~Build_pEquiv.] 40.25 secs (0.003u,0.052s)
Chars 6403 - 6447 [1:~rapply~(fmap~(pTr~_)~(loop_...] 0.01 secs (0.008u,0.002s)
Chars 6452 - 6479 [nrapply~O_inverts_conn_map.] 0.003 secs (0.003u,0.s)
Chars 6484 - 6518 [nrapply~(isconnmap_pred_add~n....] 0.004 secs (0.004u,0.s)
Chars 9409 - 9417 [Defined.] 0.014 secs (0.012u,0.001s)
Chars 9421 - 9460 [Definition~cosets~:=~Quotient~...] 0. secs (0.u,0.s)
Chars 6523 - 6554 [(rewrite~2!trunc_index_add_succ).] 0.002 secs (0.002u,0.s)
Chars 6559 - 6590 [rapply~conn_map_loop_susp_unit.] 0.017 secs (0.015u,0.001s)
Chars 6376 - 6398 [snrapply~Build_pEquiv.] 0. secs (0.u,0.s)
Chars 6403 - 6447 [1:~rapply~(fmap~(pTr~_)~(loop_...] 0. secs (0.u,0.s)
Chars 6452 - 6479 [nrapply~O_inverts_conn_map.] 0. secs (0.u,0.s)
Chars 6484 - 6518 [nrapply~(isconnmap_pred_add~n....] 0. secs (0.u,0.s)
Chars 6523 - 6554 [(rewrite~2!trunc_index_add_succ).] 0. secs (0.u,0.s)
Chars 6559 - 6590 [rapply~conn_map_loop_susp_unit.] 0. secs (0.u,0.s)
Chars 6593 - 6601 [Defined.] 0.002 secs (0.001u,0.s)
Chars 6605 - 6690 [Lemma~pequiv_loops_em_em~(G~:~...] 0.001 secs (0.001u,0.s)
Chars 6693 - 6699 [Proof.] 0. secs (0.u,0.s)
Chars 9462 - 9476 [End~Subgroups.] 0.034 secs (0.033u,0.s)
Chars 9559 - 9641 [#[global]~Instance~isgraph_oog...] 0. secs (0.u,0.s)
Chars 9642 - 9750 [#[global]~Instance~is01cat_oog...] 0.001 secs (0.001u,0.s)
Chars 9751 - 9843 [#[global]~Instance~is2graph_oo...] 0.003 secs (0.003u,0.s)
Chars 9844 - 9930 [#[global]~Instance~is1cat_oogr...] 0.004 secs (0.004u,0.s)
Chars 9965 - 10064 [Definition~group_to_oogroup~:~...] 0.001 secs (0.001u,0.s)
Chars 10066 - 10140 [#[global]~Instance~is0functor_...] 0. secs (0.u,0.s)
Chars 10141 - 10147 [Proof.] 0. secs (0.u,0.s)
Chars 24820 - 24834 [by~destruct~c.] 40.181 secs (0.021u,0.034s)
Chars 24820 - 24834 [by~destruct~c.] 0.001 secs (0.001u,0.s)
Chars 24835 - 24843 [Defined.] 0.004 secs (0.003u,0.s)
Chars 10150 - 10176 [snrapply~Build_Is0Functor.] 0.198 secs (0.002u,0.04s)
Chars 10179 - 10192 [(intros~G~H~f).] 0. secs (0.u,0.s)
Chars 10195 - 10230 [by~rapply~(fmap~pClassifyingSp...] 0.005 secs (0.004u,0.s)
Chars 10150 - 10176 [snrapply~Build_Is0Functor.] 0. secs (0.u,0.s)
Chars 10179 - 10192 [(intros~G~H~f).] 0. secs (0.u,0.s)
Chars 10195 - 10230 [by~rapply~(fmap~pClassifyingSp...] 0. secs (0.u,0.s)
Chars 10231 - 10239 [Defined.] 0. secs (0.u,0.s)
Chars 10241 - 10315 [#[global]~Instance~is1functor_...] 0.002 secs (0.002u,0.s)
Chars 10316 - 10322 [Proof.] 0. secs (0.u,0.s)
Chars 20706 - 20728 [rapply~cyl_extendable.] 40.164 secs (0.001u,0.032s)
Chars 20731 - 20780 [refine~(cancelL_extendable~n~C...] 0.003 secs (0.003u,0.s)
Chars 20783 - 20807 [rapply~extendable_equiv.] 0.005 secs (0.005u,0.s)
Chars 20706 - 20728 [rapply~cyl_extendable.] 0. secs (0.u,0.s)
Chars 20731 - 20780 [refine~(cancelL_extendable~n~C...] 0. secs (0.u,0.s)
Chars 20783 - 20807 [rapply~extendable_equiv.] 0. secs (0.u,0.s)
Chars 20808 - 20816 [Defined.] 0.001 secs (0.001u,0.s)
Chars 20818 - 21022 [Definition~cyl_ooextendable'~{...] 0.003 secs (0.002u,0.001s)
Chars 21071 - 21423 [Definition~extension_functor_p...] 0.003 secs (0.003u,0.s)
Chars 21424 - 21430 [Proof.] 0. secs (0.u,0.s)
Chars 9210 - 9240 [refine~(_~@~nat_add_comm~_~_).] 40.189 secs (0.001u,0.034s)
Chars 9243 - 9276 [(pose~proof~(merely_equiv_fin~...] 0.001 secs (0.001u,0.s)
Chars 9279 - 9297 [strip_truncations.] 0.056 secs (0.039u,0.016s)
Chars 9300 - 9335 [refine~(fcard_equiv'~(1~+E~e)~...] 0.011 secs (0.011u,0.s)
Chars 9338 - 9398 [refine~(_~@~ap~(fun~y~=>~y~+~f...] 0.008 secs (0.006u,0.001s)
Chars 9401 - 9432 [(generalize~(fcard~Y);~intros~n).] 0.001 secs (0.001u,0.s)
Chars 9435 - 9458 [(induction~n~as~[|~n~IH]).] 0.001 secs (0.001u,0.s)
Chars 9461 - 9462 [-] 0. secs (0.u,0.s)
Chars 9463 - 9503 [refine~(fcard_equiv~(sum_empty...] 0.015 secs (0.014u,0.s)
Chars 9506 - 9507 [-] 0. secs (0.u,0.s)
Chars 9508 - 9560 [refine~(fcard_equiv~(equiv_sum...] 0.021 secs (0.018u,0.002s)
Chars 9565 - 9581 [exact~(ap~S~IH).] 0.002 secs (0.001u,0.s)
find_witness Control.TimeoutChars 9210 - 9240 [refine~(_~@~nat_add_comm~_~_).] 0. secs (0.u,0.s)
Chars 9243 - 9276 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 9279 - 9297 [strip_truncations.] 0. secs (0.u,0.s)
Chars 9300 - 9335 [refine~(fcard_equiv'~(1~+E~e)~...] 0. secs (0.u,0.s)
Chars 9338 - 9398 [refine~(_~@~ap~(fun~y~=>~y~+~f...] 0. secs (0.u,0.s)
Chars 9401 - 9432 [(generalize~(fcard~Y);~intros~n).] 0. secs (0.u,0.s)
Chars 9435 - 9458 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 9463 - 9503 [refine~(fcard_equiv~(sum_empty...] 0. secs (0.u,0.s)
Chars 9508 - 9560 [refine~(fcard_equiv~(equiv_sum...] 0. secs (0.u,0.s)
Chars 9565 - 9581 [exact~(ap~S~IH).] 0. secs (0.u,0.s)
Chars 9582 - 9590 [Defined.] 0.005 secs (0.003u,0.001s)
Chars 9620 - 9693 [#[global]Instance~finite_prod~...] 0. secs (0.u,0.s)
Chars 9694 - 9700 [Proof.] 0. secs (0.u,0.s)
Chars 5050 - 5063 [(apply~pos_eq).] 40.191 secs (0.002u,0.043s)
Chars 5064 - 5082 [exact~dec_recip_1.] 0.052 secs (0.041u,0.01s)
Chars 5050 - 5063 [(apply~pos_eq).] 0. secs (0.u,0.s)
Chars 5064 - 5082 [exact~dec_recip_1.] 0. secs (0.u,0.s)
Chars 5083 - 5087 [Qed.] 0. secs (0.u,0.s)
Chars 5089 - 5149 [Lemma~Qpos_plus_mult_distr_l~:...] 0. secs (0.u,0.s)
Chars 5150 - 5156 [Proof.] 0. secs (0.u,0.s)
Chars 6704 - 6715 [(destruct~n).] 40.245 secs (0.001u,0.052s)
Chars 6720 - 6747 [1:~(apply~pequiv_loops_bg_g).] 0.001 secs (0.001u,0.s)
Chars 6752 - 6815 [(change~(loops~(pTr~n.+2~(psus...] 0.003 secs (0.003u,0.s)
Chars 6820 - 6856 [refine~(_~o*E~(ptr_loops~_~_)^...] 0.002 secs (0.001u,0.s)
Chars 6861 - 6872 [(destruct~n).] 0.001 secs (0.001u,0.s)
Chars 6877 - 6878 [{] 0. secs (0.u,0.s)
Chars 6879 - 6902 [srapply~licata_finster.] 0.012 secs (0.009u,0.002s)
Chars 6909 - 6921 [reflexivity.] 0.004 secs (0.004u,0.s)
Chars 6922 - 6923 [}] 0. secs (0.u,0.s)
Chars 6928 - 6970 [refine~((pequiv_ptr~(n:=n.+2))...] 0.004 secs (0.003u,0.s)
Chars 6975 - 7015 [(symmetry;~rapply~pequiv_ptr_l...] 0.04 secs (0.03u,0.01s)
Chars 6704 - 6715 [(destruct~n).] 0. secs (0.u,0.s)
Chars 6720 - 6747 [1:~(apply~pequiv_loops_bg_g).] 0. secs (0.u,0.s)
Chars 6752 - 6815 [(change~(loops~(pTr~n.+2~(psus...] 0. secs (0.u,0.s)
Chars 6820 - 6856 [refine~(_~o*E~(ptr_loops~_~_)^...] 0. secs (0.u,0.s)
Chars 6861 - 6872 [(destruct~n).] 0. secs (0.u,0.s)
Chars 6879 - 6902 [srapply~licata_finster.] 0. secs (0.u,0.s)
Chars 6909 - 6921 [reflexivity.] 0. secs (0.u,0.s)
Chars 6928 - 6970 [refine~((pequiv_ptr~(n:=n.+2))...] 0. secs (0.u,0.s)
Chars 6975 - 7015 [(symmetry;~rapply~pequiv_ptr_l...] 0. secs (0.u,0.s)
Chars 7018 - 7026 [Defined.] 0.01 secs (0.009u,0.001s)
Chars 7030 - 7121 [Definition~pequiv_loops_em_g~(...] 0. secs (0.u,0.s)
Chars 7124 - 7130 [Proof.] 0. secs (0.u,0.s)
Chars 10325 - 10364 [(snrapply~Build_Is1Functor;~hn...] 40.242 secs (0.012u,0.042s)
Chars 10367 - 10406 [1:~by~rapply~(fmap2~pClassifyi...] 0.015 secs (0.015u,0.s)
Chars 10409 - 10450 [1:~by~rapply~(fmap_id~pClassif...] 0.012 secs (0.012u,0.s)
Chars 10453 - 10493 [by~rapply~(fmap_comp~pClassify...] 0.021 secs (0.018u,0.002s)
Chars 10325 - 10364 [(snrapply~Build_Is1Functor;~hn...] 0.002 secs (0.002u,0.s)
Chars 10367 - 10406 [1:~by~rapply~(fmap2~pClassifyi...] 0. secs (0.u,0.s)
Chars 10409 - 10450 [1:~by~rapply~(fmap_id~pClassif...] 0. secs (0.u,0.s)
Chars 10453 - 10493 [by~rapply~(fmap_comp~pClassify...] 0. secs (0.u,0.s)
Chars 10494 - 10502 [Defined.] 0.004 secs (0.002u,0.002s)
find_witness Control.TimeoutChars 21433 - 21447 [srefine~(_;~_).] 40.15 secs (0.001u,0.028s)
Chars 21450 - 21451 [-] 0. secs (0.u,0.s)
Chars 21452 - 21478 [(intros~[a'~b'];~revert~b').] 0.002 secs (0.002u,0.s)
Chars 21483 - 21510 [refine~(fst~(eg~a')~_).1.] 0.002 secs (0.002u,0.s)
Chars 21515 - 21535 [(intros~b;~revert~a').] 0.001 secs (0.001u,0.s)
Chars 21540 - 21570 [refine~(fst~(ef~(g~b))~_).1.] 0.002 secs (0.002u,0.s)
Chars 21575 - 21584 [(intros~a).] 0. secs (0.u,0.s)
Chars 21589 - 21605 [exact~(s~(a,~b)).] 0.001 secs (0.001u,0.s)
Chars 21608 - 21609 [-] 0. secs (0.u,0.s)
Chars 21610 - 21628 [(intros~[a~b];~cbn).] 0.004 secs (0.003u,0.s)
Chars 21633 - 21669 [refine~((fst~(eg~(f~a))~_).2~b...] 0.003 secs (0.003u,0.s)
Chars 21674 - 21705 [exact~((fst~(ef~(g~b))~_).2~a).] 0.002 secs (0.001u,0.s)
Chars 21433 - 21447 [srefine~(_;~_).] 0. secs (0.u,0.s)
Chars 21452 - 21478 [(intros~[a'~b'];~revert~b').] 0.001 secs (0.u,0.s)
Chars 21483 - 21510 [refine~(fst~(eg~a')~_).1.] 0. secs (0.u,0.s)
Chars 21515 - 21535 [(intros~b;~revert~a').] 0.001 secs (0.001u,0.s)
Chars 21540 - 21570 [refine~(fst~(ef~(g~b))~_).1.] 0. secs (0.u,0.s)
Chars 21575 - 21584 [(intros~a).] 0. secs (0.u,0.s)
Chars 21589 - 21605 [exact~(s~(a,~b)).] 0. secs (0.u,0.s)
Chars 21610 - 21628 [(intros~[a~b];~cbn).] 0.002 secs (0.002u,0.s)
Chars 21633 - 21669 [refine~((fst~(eg~(f~a))~_).2~b...] 0. secs (0.u,0.s)
Chars 21674 - 21705 [exact~((fst~(ef~(g~b))~_).2~a).] 0. secs (0.u,0.s)
Chars 21706 - 21714 [Defined.] 0.003 secs (0.002u,0.s)
Chars 21716 - 22030 [Definition~extendable_functor_...] 0.002 secs (0.001u,0.001s)
Chars 22031 - 22037 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 9703 - 9736 [(pose~proof~(merely_equiv_fin~...] 40.181 secs (0.001u,0.035s)
Chars 9739 - 9757 [strip_truncations.] 0.035 secs (0.032u,0.002s)
Chars 9760 - 9812 [refine~(finite_equiv~_~(functo...] 0.034 secs (0.025u,0.009s)
Chars 9815 - 9846 [(generalize~(fcard~Y);~intros~n).] 0.001 secs (0.001u,0.s)
Chars 9849 - 9872 [(induction~n~as~[|~n~IH]).] 0.001 secs (0.001u,0.s)
Chars 9875 - 9876 [-] 0. secs (0.u,0.s)
Chars 9877 - 9923 [refine~(finite_equiv~_~(prod_e...] 0.004 secs (0.003u,0.s)
Chars 9926 - 9927 [-] 0. secs (0.u,0.s)
Chars 9928 - 9997 [refine~(finite_equiv~_~(sum_di...] 0.025 secs (0.022u,0.002s)
Chars 10002 - 10047 [refine~(finite_equiv~_~(prod_u...] 0.005 secs (0.005u,0.s)
Chars 9703 - 9736 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 9739 - 9757 [strip_truncations.] 0. secs (0.u,0.s)
Chars 9760 - 9812 [refine~(finite_equiv~_~(functo...] 0. secs (0.u,0.s)
Chars 9815 - 9846 [(generalize~(fcard~Y);~intros~n).] 0. secs (0.u,0.s)
Chars 9849 - 9872 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 9877 - 9923 [refine~(finite_equiv~_~(prod_e...] 0. secs (0.u,0.s)
Chars 9928 - 9997 [refine~(finite_equiv~_~(sum_di...] 0. secs (0.u,0.s)
Chars 10002 - 10047 [refine~(finite_equiv~_~(prod_u...] 0. secs (0.u,0.s)
Chars 10048 - 10056 [Defined.] 0.004 secs (0.004u,0.s)
Chars 10058 - 10144 [Definition~fcard_prod~X~Y~`{Fi...] 0.014 secs (0.012u,0.001s)
Chars 10145 - 10151 [Proof.] 0. secs (0.u,0.s)
Chars 5157 - 5161 [(hnf).] 40.178 secs (0.u,0.043s)
Chars 5162 - 5200 [(intros;~apply~pos_eq,~plus_mu...] 0.009 secs (0.008u,0.001s)
Chars 5157 - 5161 [(hnf).] 0. secs (0.u,0.s)
Chars 5162 - 5200 [(intros;~apply~pos_eq,~plus_mu...] 0.001 secs (0.001u,0.s)
Chars 5201 - 5205 [Qed.] 0.001 secs (0.u,0.s)
Chars 5207 - 5246 [#[global]Instance~Qpos_meet@{}...] 0. secs (0.u,0.s)
Chars 5247 - 5253 [Proof.] 0. secs (0.u,0.s)
Chars 5254 - 5265 [(intros~a~b).] 0.166 secs (0.u,0.041s)
Chars 5266 - 5292 [exists~(meet~('~a)~('~b)).] 0.003 secs (0.003u,0.s)
Chars 5293 - 5314 [(apply~not_le_lt_flip).] 0.008 secs (0.008u,0.s)
Chars 5315 - 5324 [(intros~E).] 0.001 secs (0.001u,0.s)
Chars 5325 - 5450 [(destruct~(total_meet_either~(...] 0.044 secs (0.043u,0.001s)
Chars 5254 - 5265 [(intros~a~b).] 0. secs (0.u,0.s)
Chars 5266 - 5292 [exists~(meet~('~a)~('~b)).] 0. secs (0.u,0.s)
Chars 5293 - 5314 [(apply~not_le_lt_flip).] 0. secs (0.u,0.s)
Chars 5315 - 5324 [(intros~E).] 0. secs (0.u,0.s)
Chars 5325 - 5450 [(destruct~(total_meet_either~(...] 0.007 secs (0.007u,0.s)
Chars 5451 - 5459 [Defined.] 0.002 secs (0.001u,0.s)
Chars 5461 - 5500 [#[global]Instance~Qpos_join@{}...] 0. secs (0.u,0.s)
Chars 5501 - 5507 [Proof.] 0. secs (0.u,0.s)
Chars 5508 - 5519 [(intros~a~b).] 0.165 secs (0.u,0.041s)
Chars 5520 - 5546 [exists~(join~('~a)~('~b)).] 0.003 secs (0.003u,0.s)
Chars 5547 - 5568 [(apply~not_le_lt_flip).] 0.009 secs (0.009u,0.s)
Chars 5569 - 5578 [(intros~E).] 0.001 secs (0.001u,0.s)
Chars 5579 - 5704 [(destruct~(total_join_either~(...] 0.039 secs (0.036u,0.002s)
Chars 5508 - 5519 [(intros~a~b).] 0. secs (0.u,0.s)
Chars 5520 - 5546 [exists~(join~('~a)~('~b)).] 0. secs (0.u,0.s)
Chars 5547 - 5568 [(apply~not_le_lt_flip).] 0. secs (0.u,0.s)
Chars 5569 - 5578 [(intros~E).] 0. secs (0.u,0.s)
Chars 5579 - 5704 [(destruct~(total_join_either~(...] 0.007 secs (0.006u,0.s)
Chars 5705 - 5713 [Defined.] 0.002 secs (0.001u,0.s)
Chars 5715 - 5812 [Lemma~Q_sum_eq_join_meet@{}~:~...] 0.002 secs (0.001u,0.s)
Chars 5813 - 5819 [Proof.] 0. secs (0.u,0.s)
Chars 7135 - 7147 [(induction~n).] 40.258 secs (0.u,0.055s)
Chars 7152 - 7153 [-] 0. secs (0.u,0.s)
Chars 7154 - 7166 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 7171 - 7172 [-] 0. secs (0.u,0.s)
Chars 7173 - 7223 [refine~(IHn~o*E~_~o*E~unfold_i...] 0.002 secs (0.002u,0.s)
Chars 7230 - 7287 [exact~(emap~(iterated_loops~n)...] 0.025 secs (0.024u,0.s)
Chars 7135 - 7147 [(induction~n).] 0. secs (0.u,0.s)
Chars 7154 - 7166 [reflexivity.] 0. secs (0.u,0.s)
Chars 7173 - 7223 [refine~(IHn~o*E~_~o*E~unfold_i...] 0. secs (0.u,0.s)
Chars 7230 - 7287 [exact~(emap~(iterated_loops~n)...] 0. secs (0.u,0.s)
Chars 7290 - 7298 [Defined.] 0.003 secs (0.002u,0.s)
Chars 7368 - 7465 [Definition~equiv_g_pi_n_em~(G~...] 0. secs (0.u,0.s)
Chars 7468 - 7474 [Proof.] 0. secs (0.u,0.s)
Chars 22040 - 22118 [(revert~P~ef~eg;~simple_induct...] 40.16 secs (0.007u,0.029s)
Chars 22121 - 22122 [-] 0. secs (0.u,0.s)
Chars 22123 - 22152 [(apply~extension_functor_prod).] 0.002 secs (0.002u,0.s)
Chars 22157 - 22158 [+] 0. secs (0.u,0.s)
Chars 22159 - 22205 [(intros~b';~exact~(fst~(ef~b')...] 0.003 secs (0.003u,0.s)
Chars 22210 - 22211 [+] 0. secs (0.u,0.s)
Chars 22212 - 22258 [(intros~a';~exact~(fst~(eg~a')...] 0.003 secs (0.003u,0.s)
Chars 22261 - 22262 [-] 0. secs (0.u,0.s)
Chars 22263 - 22284 [(intros~h~k;~apply~IH).] 0.002 secs (0.u,0.001s)
Chars 22289 - 22290 [+] 0. secs (0.u,0.s)
Chars 22291 - 22322 [(intros~b';~apply~(snd~(ef~b'))).] 0.003 secs (0.003u,0.s)
Chars 22327 - 22328 [+] 0. secs (0.u,0.s)
Chars 22329 - 22360 [(intros~a';~apply~(snd~(eg~a'))).] 0.003 secs (0.003u,0.s)
Chars 22040 - 22118 [(revert~P~ef~eg;~simple_induct...] 0.003 secs (0.003u,0.s)
Chars 22123 - 22152 [(apply~extension_functor_prod).] 0.001 secs (0.001u,0.s)
Chars 22159 - 22205 [(intros~b';~exact~(fst~(ef~b')...] 0.001 secs (0.001u,0.s)
Chars 22212 - 22258 [(intros~a';~exact~(fst~(eg~a')...] 0.001 secs (0.001u,0.s)
Chars 22263 - 22284 [(intros~h~k;~apply~IH).] 0.002 secs (0.002u,0.s)
Chars 22291 - 22322 [(intros~b';~apply~(snd~(ef~b'))).] 0.001 secs (0.001u,0.s)
Chars 22329 - 22360 [(intros~a';~apply~(snd~(eg~a'))).] 0.001 secs (0.001u,0.s)
Chars 22361 - 22369 [Defined.] 0.004 secs (0.003u,0.s)
Chars 22371 - 22763 [Definition~ooextendable_functo...] 0.004 secs (0.004u,0.s)
Chars 22813 - 23115 [Definition~extension_functor_s...] 0.002 secs (0.002u,0.s)
Chars 23116 - 23122 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 10154 - 10187 [(pose~proof~(merely_equiv_fin~...] 40.184 secs (0.001u,0.034s)
Chars 10190 - 10208 [strip_truncations.] 0.045 secs (0.04u,0.004s)
Chars 10211 - 10246 [refine~(fcard_equiv'~(e~*E~1)~...] 0.023 secs (0.018u,0.004s)
Chars 10249 - 10307 [refine~(_~@~ap~(fun~x~=>~x~*~f...] 0.007 secs (0.006u,0.001s)
Chars 10310 - 10341 [(generalize~(fcard~X);~intros~n).] 0.002 secs (0.002u,0.s)
Chars 10344 - 10367 [(induction~n~as~[|~n~IH]).] 0.001 secs (0.001u,0.s)
Chars 10370 - 10371 [-] 0. secs (0.u,0.s)
Chars 10372 - 10410 [refine~(fcard_equiv~(prod_empt...] 0.017 secs (0.013u,0.003s)
Chars 10413 - 10414 [-] 0. secs (0.u,0.s)
Chars 10415 - 10471 [refine~(fcard_equiv~(sum_distr...] 0.075 secs (0.064u,0.01s)
Chars 10476 - 10503 [refine~(fcard_sum~_~_~@~_).] 0.003 secs (0.002u,0.s)
Chars 10508 - 10514 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 10519 - 10549 [refine~(_~@~nat_add_comm~_~_).] 0.001 secs (0.001u,0.s)
Chars 10554 - 10577 [refine~(ap011~add~_~_).] 0.001 secs (0.u,0.s)
Chars 10582 - 10583 [+] 0. secs (0.u,0.s)
Chars 10584 - 10593 [(apply~IH).] 0.001 secs (0.001u,0.s)
Chars 10598 - 10599 [+] 0. secs (0.u,0.s)
Chars 10600 - 10632 [(apply~fcard_equiv',~prod_unit...] 0.001 secs (0.001u,0.s)
Chars 10154 - 10187 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 10190 - 10208 [strip_truncations.] 0. secs (0.u,0.s)
Chars 10211 - 10246 [refine~(fcard_equiv'~(e~*E~1)~...] 0. secs (0.u,0.s)
Chars 10249 - 10307 [refine~(_~@~ap~(fun~x~=>~x~*~f...] 0. secs (0.u,0.s)
Chars 10310 - 10341 [(generalize~(fcard~X);~intros~n).] 0. secs (0.u,0.s)
Chars 10344 - 10367 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 10372 - 10410 [refine~(fcard_equiv~(prod_empt...] 0. secs (0.u,0.s)
Chars 10415 - 10471 [refine~(fcard_equiv~(sum_distr...] 0. secs (0.u,0.s)
Chars 10476 - 10503 [refine~(fcard_sum~_~_~@~_).] 0. secs (0.u,0.s)
Chars 10508 - 10514 [(simpl).] 0. secs (0.u,0.s)
Chars 10519 - 10549 [refine~(_~@~nat_add_comm~_~_).] 0. secs (0.u,0.s)
Chars 10554 - 10577 [refine~(ap011~add~_~_).] 0. secs (0.u,0.s)
Chars 10584 - 10593 [(apply~IH).] 0. secs (0.u,0.s)
Chars 10600 - 10632 [(apply~fcard_equiv',~prod_unit...] 0. secs (0.u,0.s)
Chars 10635 - 10643 [Defined.] 0.006 secs (0.006u,0.s)
Chars 10760 - 10892 [#[global]~Instance~finite_fora...] 0. secs (0.u,0.s)
Chars 10893 - 10899 [Proof.] 0. secs (0.u,0.s)
Chars 5820 - 5834 [(intros~?~?~?~?~E).] 40.188 secs (0.u,0.042s)
Chars 5835 - 5870 [(destruct~(total~le~a~c)~as~[E...] 0.006 secs (0.004u,0.002s)
Chars 5871 - 5872 [-] 0. secs (0.u,0.s)
Chars 5873 - 5897 [(rewrite~(join_r~_~_~E1)).] 0.004 secs (0.004u,0.s)
Chars 5898 - 5921 [(rewrite~meet_r;~trivial).] 0.008 secs (0.005u,0.002s)
Chars 5924 - 5961 [(apply~(order_preserving~(+b))...] 0.028 secs (0.022u,0.005s)
Chars 5964 - 5980 [(rewrite~E~in~E1).] 0.001 secs (0.001u,0.s)
Chars 5981 - 6012 [(apply~(order_reflecting~(c~+))).] 0.022 secs (0.014u,0.008s)
Chars 6013 - 6021 [trivial.] 0.001 secs (0.001u,0.s)
Chars 6022 - 6023 [-] 0. secs (0.u,0.s)
Chars 6024 - 6048 [(rewrite~(join_l~_~_~E1)).] 0.005 secs (0.004u,0.s)
Chars 6051 - 6074 [(rewrite~meet_l;~trivial).] 0.008 secs (0.007u,0.001s)
Chars 6077 - 6108 [(apply~(order_reflecting~(a~+))).] 0.021 secs (0.016u,0.004s)
Chars 6109 - 6119 [(rewrite~E).] 0.001 secs (0.001u,0.s)
Chars 6120 - 6151 [(apply~(order_preserving~(+d))).] 0.034 secs (0.032u,0.001s)
Chars 6154 - 6162 [trivial.] 0.001 secs (0.u,0.001s)
Chars 5820 - 5834 [(intros~?~?~?~?~E).] 0. secs (0.u,0.s)
Chars 5835 - 5870 [(destruct~(total~le~a~c)~as~[E...] 0. secs (0.u,0.s)
Chars 5873 - 5897 [(rewrite~(join_r~_~_~E1)).] 0. secs (0.u,0.s)
Chars 5898 - 5921 [(rewrite~meet_r;~trivial).] 0.002 secs (0.002u,0.s)
Chars 5924 - 5961 [(apply~(order_preserving~(+b))...] 0. secs (0.u,0.s)
Chars 5964 - 5980 [(rewrite~E~in~E1).] 0. secs (0.u,0.s)
Chars 5981 - 6012 [(apply~(order_reflecting~(c~+))).] 0. secs (0.u,0.s)
Chars 6013 - 6021 [trivial.] 0. secs (0.u,0.s)
Chars 6024 - 6048 [(rewrite~(join_l~_~_~E1)).] 0. secs (0.u,0.s)
Chars 6051 - 6074 [(rewrite~meet_l;~trivial).] 0.002 secs (0.002u,0.s)
Chars 6077 - 6108 [(apply~(order_reflecting~(a~+))).] 0. secs (0.u,0.s)
Chars 6109 - 6119 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 6120 - 6151 [(apply~(order_preserving~(+d))).] 0. secs (0.u,0.s)
Chars 6154 - 6162 [trivial.] 0. secs (0.u,0.s)
Chars 6163 - 6167 [Qed.] 0.002 secs (0.002u,0.s)
Chars 6169 - 6270 [Lemma~Qpos_sum_eq_join_meet@{}...] 0.002 secs (0.002u,0.s)
Chars 6271 - 6277 [Proof.] 0. secs (0.u,0.s)
Chars 7479 - 7491 [(induction~n).] 40.261 secs (0.001u,0.053s)
Chars 7496 - 7497 [-] 0. secs (0.u,0.s)
Chars 7498 - 7521 [(apply~grp_iso_g_pi1_bg).] 0.002 secs (0.002u,0.s)
Chars 7526 - 7527 [-] 0. secs (0.u,0.s)
Chars 7528 - 7577 [snrapply~(transitive_groupisom...] 0.002 secs (0.u,0.001s)
Chars 7584 - 7593 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 7600 - 7669 [snrapply~(transitive_groupisom...] 0.003 secs (0.003u,0.s)
Chars 7676 - 7731 [(apply~(groupiso_pi_functor~_~...] 0.004 secs (0.004u,0.s)
Chars 7479 - 7491 [(induction~n).] 0. secs (0.u,0.s)
Chars 7498 - 7521 [(apply~grp_iso_g_pi1_bg).] 0. secs (0.u,0.s)
Chars 7528 - 7577 [snrapply~(transitive_groupisom...] 0. secs (0.u,0.s)
Chars 7584 - 7593 [symmetry.] 0. secs (0.u,0.s)
Chars 7600 - 7669 [snrapply~(transitive_groupisom...] 0. secs (0.u,0.s)
Chars 7676 - 7731 [(apply~(groupiso_pi_functor~_~...] 0. secs (0.u,0.s)
Chars 7734 - 7742 [Defined.] 0.003 secs (0.002u,0.s)
Chars 7744 - 7765 [End~EilenbergMacLane.] 0.021 secs (0.019u,0.001s)
Chars 23125 - 23139 [srefine~(_;~_).] 40.155 secs (0.001u,0.029s)
Chars 23142 - 23143 [-] 0. secs (0.u,0.s)
Chars 23144 - 23167 [(intros~[a~v];~revert~v).] 0.002 secs (0.001u,0.s)
Chars 23172 - 23198 [refine~(fst~(ef~a)~_).1.] 0.001 secs (0.001u,0.s)
Chars 23203 - 23212 [(intros~u).] 0. secs (0.u,0.s)
Chars 23217 - 23233 [exact~(s~(a;~u)).] 0.001 secs (0.001u,0.s)
Chars 23236 - 23237 [-] 0. secs (0.u,0.s)
Chars 23238 - 23256 [(intros~[a~u];~cbn).] 0.004 secs (0.003u,0.s)
Chars 23261 - 23288 [exact~((fst~(ef~a)~_).2~u).] 0.002 secs (0.002u,0.s)
Chars 23125 - 23139 [srefine~(_;~_).] 0. secs (0.u,0.s)
Chars 23144 - 23167 [(intros~[a~v];~revert~v).] 0.001 secs (0.u,0.s)
Chars 23172 - 23198 [refine~(fst~(ef~a)~_).1.] 0. secs (0.u,0.s)
Chars 23203 - 23212 [(intros~u).] 0. secs (0.u,0.s)
Chars 23217 - 23233 [exact~(s~(a;~u)).] 0. secs (0.u,0.s)
Chars 23238 - 23256 [(intros~[a~u];~cbn).] 0.002 secs (0.u,0.001s)
Chars 23261 - 23288 [exact~((fst~(ef~a)~_).2~u).] 0. secs (0.u,0.s)
Chars 23289 - 23297 [Defined.] 0.002 secs (0.001u,0.s)
Chars 23299 - 23550 [Definition~extendable_functor_...] 0.002 secs (0.002u,0.s)
Chars 23551 - 23557 [Proof.] 0. secs (0.u,0.s)
Chars 23560 - 23632 [(revert~C~ef;~simple_induction...] 3.337 secs (-2.906u,-0.899s)
find_witness Control.TimeoutChars 10902 - 10935 [(pose~proof~(merely_equiv_fin~...] 40.181 secs (0.001u,0.035s)
Chars 10938 - 10956 [strip_truncations.] 0.051 secs (0.043u,0.008s)
Chars 10959 - 11073 [(simple~refine~~~(finite_equiv...] 0.064 secs (0.054u,0.01s)
Chars 11076 - 11077 [{] 0. secs (0.u,0.s)
Chars 11078 - 11129 [(intros~x;~refine~(equiv_trans...] 0.002 secs (0.002u,0.s)
Chars 11130 - 11131 [}] 0. secs (0.u,0.s)
Chars 11134 - 11189 [(set~(Y'~:=~Y~o~e^-1);~change~...] 0.007 secs (0.006u,0.001s)
Chars 11192 - 11259 [(assert~(forall~x,~Finite~(Y'~...] 0.005 secs (0.004u,0.s)
Chars 11262 - 11308 [(generalize~dependent~(fcard~X...] 0.002 secs (0.001u,0.s)
Chars 11311 - 11334 [(induction~n~as~[|~n~IH]).] 0.001 secs (0.001u,0.s)
Chars 11337 - 11338 [-] 0. secs (0.u,0.s)
Chars 11339 - 11347 [exact~_.] 0.007 secs (0.007u,0.s)
Chars 11350 - 11351 [-] 0. secs (0.u,0.s)
Chars 11352 - 11397 [refine~(finite_equiv~_~(equiv_...] 0.079 secs (0.066u,0.012s)
Chars 11402 - 11420 [(apply~finite_prod).] 0.002 secs (0.002u,0.s)
Chars 11425 - 11426 [+] 0. secs (0.u,0.s)
Chars 11427 - 11445 [(apply~IH;~exact~_).] 0.003 secs (0.003u,0.s)
Chars 11450 - 11451 [+] 0. secs (0.u,0.s)
Chars 11452 - 11512 [refine~(finite_equiv~_~(@Unit_...] 0.015 secs (0.009u,0.006s)
Chars 11519 - 11556 [refine~(isequiv_unit_ind~(Y'~o...] 0.003 secs (0.003u,0.s)
Chars 10902 - 10935 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 10938 - 10956 [strip_truncations.] 0. secs (0.u,0.s)
Chars 10959 - 11073 [(simple~refine~~~(finite_equiv...] 0. secs (0.u,0.s)
Chars 11078 - 11129 [(intros~x;~refine~(equiv_trans...] 0. secs (0.u,0.s)
Chars 11134 - 11189 [(set~(Y'~:=~Y~o~e^-1);~change~...] 0. secs (0.u,0.s)
Chars 11192 - 11259 [(assert~(forall~x,~Finite~(Y'~...] 0.001 secs (0.001u,0.s)
Chars 11262 - 11308 [(generalize~dependent~(fcard~X...] 0. secs (0.u,0.s)
Chars 11311 - 11334 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 11339 - 11347 [exact~_.] 0. secs (0.u,0.s)
Chars 11352 - 11397 [refine~(finite_equiv~_~(equiv_...] 0. secs (0.u,0.s)
Chars 11402 - 11420 [(apply~finite_prod).] 0. secs (0.u,0.s)
Chars 11427 - 11445 [(apply~IH;~exact~_).] 0.001 secs (0.001u,0.s)
Chars 11452 - 11512 [refine~(finite_equiv~_~(@Unit_...] 0. secs (0.u,0.s)
Chars 11519 - 11556 [refine~(isequiv_unit_ind~(Y'~o...] 0. secs (0.u,0.s)
Chars 11557 - 11565 [Defined.] 0.007 secs (0.007u,0.s)
Chars 11567 - 11640 [#[local]Hint~Extern~4~~=>~(pro...] 0. secs (0.u,0.s)
Chars 11642 - 11750 [Definition~fcard_arrow~`{Funex...] 0.024 secs (0.021u,0.003s)
Chars 11751 - 11757 [Proof.] 0. secs (0.u,0.s)
Chars 6278 - 6292 [(intros~?~?~?~?~E).] 40.187 secs (0.001u,0.041s)
Chars 6293 - 6331 [(apply~pos_eq;~apply~Q_sum_eq_...] 0.003 secs (0.003u,0.s)
Chars 6332 - 6368 [(change~('~a~+~'~b)~with~('~(a...] 0.004 secs (0.003u,0.s)
Chars 6369 - 6391 [(rewrite~E;~reflexivity).] 0.003 secs (0.003u,0.s)
Chars 6278 - 6292 [(intros~?~?~?~?~E).] 0. secs (0.u,0.s)
Chars 6293 - 6331 [(apply~pos_eq;~apply~Q_sum_eq_...] 0.002 secs (0.001u,0.s)
Chars 6332 - 6368 [(change~('~a~+~'~b)~with~('~(a...] 0. secs (0.u,0.s)
Chars 6369 - 6391 [(rewrite~E;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 6392 - 6396 [Qed.] 0.001 secs (0.001u,0.s)
Chars 6398 - 6495 [Lemma~Qpos_le_lt_min~:~~~foral...] 0.003 secs (0.003u,0.s)
Chars 6496 - 6502 [Proof.] 0. secs (0.u,0.s)
Chars 23560 - 23632 [(revert~C~ef;~simple_induction...] 40.066 secs (0.004u,0.032s)
Chars 23635 - 23636 [-] 0. secs (0.u,0.s)
Chars 23637 - 23670 [(apply~extension_functor_sigma...] 0.002 secs (0.002u,0.s)
Chars 23675 - 23720 [(intros~a;~exact~(fst~(ef~a),~...] 0.003 secs (0.002u,0.s)
Chars 23723 - 23724 [-] 0. secs (0.u,0.s)
Chars 23725 - 23746 [(intros~h~k;~apply~IH).] 0.002 secs (0.002u,0.s)
Chars 23751 - 23780 [(intros~a;~apply~(snd~(ef~a))).] 0.003 secs (0.003u,0.s)
Chars 23560 - 23632 [(revert~C~ef;~simple_induction...] 0.003 secs (0.003u,0.s)
Chars 23637 - 23670 [(apply~extension_functor_sigma...] 0. secs (0.u,0.s)
Chars 23675 - 23720 [(intros~a;~exact~(fst~(ef~a),~...] 0.001 secs (0.001u,0.s)
Chars 23725 - 23746 [(intros~h~k;~apply~IH).] 0.001 secs (0.001u,0.s)
Chars 23751 - 23780 [(intros~a;~apply~(snd~(ef~a))).] 0.001 secs (0.001u,0.s)
Chars 23781 - 23789 [Defined.] 0.003 secs (0.003u,0.s)
Chars 23791 - 24108 [Definition~ooextendable_functo...] 0.003 secs (0.003u,0.s)
Chars 24522 - 24750 [Definition~HomotopyExtensionAl...] 0.002 secs (0.001u,0.001s)
Chars 24752 - 25143 [Fixpoint~HomotopyExtendableAlo...] 0.003 secs (0.002u,0.001s)
Chars 25145 - 25293 [Definition~ooHomotopyExtendabl...] 0.001 secs (0.001u,0.s)
Chars 25295 - 25682 [Definition~extension_functor_s...] 0.004 secs (0.004u,0.s)
Chars 25683 - 25689 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 40.511 secs (0.134u,0.105s) (successful)
Chars 11760 - 11793 [(pose~proof~(merely_equiv_fin~...] 40.167 secs (0.001u,0.034s)
Chars 11796 - 11814 [strip_truncations.] 0.059 secs (0.052u,0.006s)
Chars 11817 - 11869 [refine~(fcard_equiv~(functor_a...] 0.066 secs (0.053u,0.013s)
Chars 11872 - 11935 [refine~(_~@~ap~(fun~x~=>~nat_e...] 0.007 secs (0.005u,0.002s)
Chars 11938 - 11969 [(generalize~(fcard~X);~intros~n).] 0.002 secs (0.002u,0.s)
Chars 11972 - 11995 [(induction~n~as~[|~n~IH]).] 0.001 secs (0.001u,0.s)
Chars 11998 - 11999 [-] 0. secs (0.u,0.s)
Chars 12000 - 12012 [reflexivity.] 0. secs (0.u,0.s)
Chars 12015 - 12016 [-] 0. secs (0.u,0.s)
Chars 12017 - 12085 [refine~(fcard_equiv~(equiv_sum...] 0.114 secs (0.098u,0.015s)
Chars 12090 - 12118 [refine~(fcard_prod~_~_~@~_).] 0.004 secs (0.003u,0.001s)
Chars 12123 - 12141 [(apply~(ap011~mul)).] 0.002 secs (0.002u,0.s)
Chars 12146 - 12147 [+] 0. secs (0.u,0.s)
Chars 12148 - 12159 [assumption.] 0.001 secs (0.001u,0.s)
Chars 12164 - 12165 [+] 0. secs (0.u,0.s)
Chars 12166 - 12222 [refine~(fcard_equiv~(@Unit_ind...] 0.014 secs (0.014u,0.s)
Chars 11760 - 11793 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 11796 - 11814 [strip_truncations.] 0. secs (0.u,0.s)
Chars 11817 - 11869 [refine~(fcard_equiv~(functor_a...] 0. secs (0.u,0.s)
Chars 11872 - 11935 [refine~(_~@~ap~(fun~x~=>~nat_e...] 0. secs (0.u,0.s)
Chars 11938 - 11969 [(generalize~(fcard~X);~intros~n).] 0. secs (0.u,0.s)
Chars 11972 - 11995 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 12000 - 12012 [reflexivity.] 0. secs (0.u,0.s)
Chars 12017 - 12085 [refine~(fcard_equiv~(equiv_sum...] 0. secs (0.u,0.s)
Chars 12090 - 12118 [refine~(fcard_prod~_~_~@~_).] 0. secs (0.u,0.s)
Chars 12123 - 12141 [(apply~(ap011~mul)).] 0. secs (0.u,0.s)
Chars 12148 - 12159 [assumption.] 0. secs (0.u,0.s)
Chars 12166 - 12222 [refine~(fcard_equiv~(@Unit_ind...] 0. secs (0.u,0.s)
Chars 12223 - 12231 [Defined.] 0.014 secs (0.012u,0.002s)
Chars 12284 - 12335 [Goal~_~forall~fs~:~Funext,~fca...] 0.05 secs (0.042u,0.007s)
Chars 12338 - 12350 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 12338 - 12350 [reflexivity.] 0. secs (0.u,0.s)
Chars 12351 - 12357 [Abort.] 0. secs (0.u,0.s)
Chars 12414 - 12484 [#[global]Instance~finite_aut~~...] 0. secs (0.u,0.s)
Chars 12485 - 12491 [Proof.] 0. secs (0.u,0.s)
Chars 6503 - 6516 [(intros~a~b~E).] 40.198 secs (0.002u,0.041s)
Chars 6517 - 6536 [exists~(a~/~2),(a~/~2).] 0.007 secs (0.007u,0.s)
Chars 6537 - 6571 [(simple~refine~(exist~_~_~_);~...] 0.004 secs (0.004u,0.s)
Chars 6572 - 6573 [-] 0. secs (0.u,0.s)
Chars 6574 - 6607 [exists~('~(a~/~2)~+~('~b~-~'~a)).] 0.008 secs (0.007u,0.001s)
Chars 6610 - 6640 [(apply~nonneg_plus_lt_compat_r).] 0.013 secs (0.01u,0.003s)
Chars 6643 - 6644 [+] 0. secs (0.u,0.s)
Chars 6645 - 6681 [(apply~(snd~(flip_nonneg_minus...] 0.016 secs (0.013u,0.002s)
Chars 6682 - 6690 [trivial.] 0.001 secs (0.001u,0.s)
Chars 6693 - 6694 [+] 0. secs (0.u,0.s)
Chars 6695 - 6711 [solve_propholds.] 0.002 secs (0.002u,0.s)
Chars 6712 - 6713 [-] 0. secs (0.u,0.s)
Chars 6714 - 6720 [split.] 0.003 secs (0.003u,0.s)
Chars 6723 - 6724 [+] 0. secs (0.u,0.s)
Chars 6725 - 6742 [(apply~pos_split2).] 0.001 secs (0.001u,0.s)
Chars 6745 - 6746 [+] 0. secs (0.u,0.s)
Chars 6747 - 6760 [(apply~pos_eq).] 0.003 secs (0.003u,0.s)
Chars 6761 - 6784 [(unfold~cast~at~2;~simpl).] 0.006 secs (0.006u,0.s)
Chars 6789 - 6812 [(unfold~cast~at~3;~simpl).] 0.006 secs (0.005u,0.s)
Chars 6817 - 6873 [(set~(a'~:=~a~/~2);~rewrite~(p...] 0.013 secs (0.013u,0.s)
Chars 6878 - 6922 [(ring_tac.ring_with_integers~(...] 0.38 secs (0.337u,0.042s)
Chars 6503 - 6516 [(intros~a~b~E).] 0. secs (0.u,0.s)
Chars 6517 - 6536 [exists~(a~/~2),(a~/~2).] 0. secs (0.u,0.s)
Chars 6537 - 6571 [(simple~refine~(exist~_~_~_);~...] 0.002 secs (0.002u,0.s)
Chars 6574 - 6607 [exists~('~(a~/~2)~+~('~b~-~'~a)).] 0. secs (0.u,0.s)
Chars 6610 - 6640 [(apply~nonneg_plus_lt_compat_r).] 0.001 secs (0.001u,0.s)
Chars 6645 - 6681 [(apply~(snd~(flip_nonneg_minus...] 0. secs (0.u,0.s)
Chars 6682 - 6690 [trivial.] 0. secs (0.u,0.s)
Chars 6695 - 6711 [solve_propholds.] 0. secs (0.u,0.s)
Chars 6714 - 6720 [split.] 0.002 secs (0.002u,0.s)
Chars 6725 - 6742 [(apply~pos_split2).] 0. secs (0.u,0.s)
Chars 6747 - 6760 [(apply~pos_eq).] 0.001 secs (0.001u,0.s)
Chars 6761 - 6784 [(unfold~cast~at~2;~simpl).] 0.003 secs (0.003u,0.s)
Chars 6789 - 6812 [(unfold~cast~at~3;~simpl).] 0.004 secs (0.004u,0.s)
Chars 6817 - 6873 [(set~(a'~:=~a~/~2);~rewrite~(p...] 0.004 secs (0.004u,0.s)
Chars 6878 - 6922 [(ring_tac.ring_with_integers~(...] 0.001 secs (0.001u,0.s)
Chars 6923 - 6927 [Qed.] 0.138 secs (0.132u,0.005s)
Chars 6929 - 7017 [Lemma~Qpos_lt_min@{}~:~~~foral...] 0.001 secs (0.001u,0.s)
Chars 7018 - 7024 [Proof.] 0. secs (0.u,0.s)
Chars 25692 - 25706 [srefine~(_;~_).] 40.152 secs (0.001u,0.029s)
Chars 25709 - 25710 [-] 0. secs (0.u,0.s)
Chars 25711 - 25736 [(intros~[b~v];~revert~b~v).] 0.002 secs (0.002u,0.s)
Chars 25741 - 25763 [refine~(fst~ef~_).1.] 0.002 secs (0.002u,0.s)
Chars 25768 - 25777 [(intros~a).] 0. secs (0.u,0.s)
Chars 25782 - 25808 [refine~(fst~(eg~a)~_).1.] 0.002 secs (0.002u,0.s)
Chars 25813 - 25822 [(intros~u).] 0.001 secs (0.001u,0.s)
Chars 25827 - 25843 [exact~(s~(a;~u)).] 0.001 secs (0.001u,0.s)
Chars 25846 - 25847 [-] 0. secs (0.u,0.s)
Chars 25848 - 25866 [(intros~[a~u];~cbn).] 0.004 secs (0.003u,0.s)
Chars 25871 - 25901 [refine~((fst~ef~_).2~_~_~@~_).] 0.003 secs (0.001u,0.001s)
Chars 25906 - 25933 [exact~((fst~(eg~a)~_).2~u).] 0.002 secs (0.002u,0.s)
Chars 25692 - 25706 [srefine~(_;~_).] 0. secs (0.u,0.s)
Chars 25711 - 25736 [(intros~[b~v];~revert~b~v).] 0.001 secs (0.u,0.001s)
Chars 25741 - 25763 [refine~(fst~ef~_).1.] 0. secs (0.u,0.s)
Chars 25768 - 25777 [(intros~a).] 0. secs (0.u,0.s)
Chars 25782 - 25808 [refine~(fst~(eg~a)~_).1.] 0. secs (0.u,0.s)
Chars 25813 - 25822 [(intros~u).] 0. secs (0.u,0.s)
Chars 25827 - 25843 [exact~(s~(a;~u)).] 0. secs (0.u,0.s)
Chars 25848 - 25866 [(intros~[a~u];~cbn).] 0.002 secs (0.001u,0.s)
Chars 25871 - 25901 [refine~((fst~ef~_).2~_~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 25906 - 25933 [exact~((fst~(eg~a)~_).2~u).] 0.001 secs (0.001u,0.s)
Chars 25934 - 25942 [Defined.] 0.004 secs (0.002u,0.001s)
Chars 25944 - 26292 [Definition~extendable_functor_...] 0.003 secs (0.002u,0.001s)
Chars 26293 - 26299 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 0. secs (0.u,0.s) (successful)
Chars 12494 - 12527 [(pose~proof~(merely_equiv_fin~...] 40.182 secs (0.001u,0.033s)
Chars 12530 - 12548 [strip_truncations.] 0.035 secs (0.029u,0.006s)
Chars 12551 - 12621 [refine~(finite_equiv~_~(equiv_...] 0.043 secs (0.039u,0.003s)
Chars 12624 - 12655 [(generalize~(fcard~X);~intros~n).] 0.001 secs (0.001u,0.s)
Chars 12658 - 12681 [(induction~n~as~[|~n~IH]).] 0.001 secs (0.001u,0.s)
Chars 12684 - 12685 [-] 0. secs (0.u,0.s)
Chars 12686 - 12694 [exact~_.] 0.009 secs (0.009u,0.s)
Chars 12697 - 12698 [-] 0. secs (0.u,0.s)
Chars 12699 - 12747 [refine~(finite_equiv~_~(equiv_...] 0.026 secs (0.023u,0.002s)
Chars 12494 - 12527 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 12530 - 12548 [strip_truncations.] 0. secs (0.u,0.s)
Chars 12551 - 12621 [refine~(finite_equiv~_~(equiv_...] 0. secs (0.u,0.s)
Chars 12624 - 12655 [(generalize~(fcard~X);~intros~n).] 0. secs (0.u,0.s)
Chars 12658 - 12681 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 12686 - 12694 [exact~_.] 0. secs (0.u,0.s)
Chars 12699 - 12747 [refine~(finite_equiv~_~(equiv_...] 0. secs (0.u,0.s)
Chars 12748 - 12756 [Defined.] 0.003 secs (0.002u,0.s)
Chars 12758 - 12843 [Definition~fcard_aut~`{Funext}...] 0.02 secs (0.019u,0.s)
Chars 12844 - 12850 [Proof.] 0. secs (0.u,0.s)
Chars 7025 - 7032 [(intros).] 40.188 secs (0.u,0.043s)
Chars 7033 - 7074 [(destruct~(total~le~('~a)~('~b...] 0.008 secs (0.006u,0.002s)
Chars 7075 - 7076 [-] 0. secs (0.u,0.s)
Chars 7077 - 7106 [(apply~Qpos_le_lt_min;~trivial).] 0.003 secs (0.002u,0.s)
Chars 7107 - 7108 [-] 0. secs (0.u,0.s)
Chars 7109 - 7135 [(apply~Qpos_le_lt_min~in~E).] 0.001 secs (0.001u,0.s)
Chars 7136 - 7172 [(destruct~E~as~[c~[cb~[ca~[E1~...] 0.005 secs (0.004u,0.s)
Chars 7175 - 7195 [(exists~c,ca,cb;~auto).] 0.004 secs (0.003u,0.s)
Chars 7025 - 7032 [(intros).] 0. secs (0.u,0.s)
Chars 7033 - 7074 [(destruct~(total~le~('~a)~('~b...] 0. secs (0.u,0.s)
Chars 7077 - 7106 [(apply~Qpos_le_lt_min;~trivial).] 0.001 secs (0.001u,0.s)
Chars 7109 - 7135 [(apply~Qpos_le_lt_min~in~E).] 0. secs (0.u,0.s)
Chars 7136 - 7172 [(destruct~E~as~[c~[cb~[ca~[E1~...] 0.001 secs (0.001u,0.s)
Chars 7175 - 7195 [(exists~c,ca,cb;~auto).] 0.001 secs (0.001u,0.s)
Chars 7196 - 7200 [Qed.] 0.003 secs (0.002u,0.s)
Chars 7202 - 7253 [Definition~Qpos_diff~:~forall~...] 0. secs (0.u,0.s)
Chars 7254 - 7260 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 26302 - 26380 [(revert~C~ef~eg;~simple_induct...] 40.166 secs (0.008u,0.029s)
Chars 26383 - 26384 [-] 0. secs (0.u,0.s)
Chars 26385 - 26415 [(apply~extension_functor_sigma).] 0.002 secs (0.002u,0.s)
Chars 26420 - 26421 [+] 0. secs (0.u,0.s)
Chars 26422 - 26452 [exact~(fst~ef,~fun~_~_~=>~tt).] 0.002 secs (0.002u,0.s)
Chars 26457 - 26458 [+] 0. secs (0.u,0.s)
Chars 26459 - 26504 [(intros~a;~exact~(fst~(eg~a),~...] 0.004 secs (0.004u,0.s)
Chars 26507 - 26508 [-] 0. secs (0.u,0.s)
Chars 26509 - 26530 [(intros~h~k;~apply~IH).] 0.018 secs (0.018u,0.s)
Chars 26535 - 26536 [+] 0. secs (0.u,0.s)
Chars 26537 - 26556 [exact~(snd~ef~h~k).] 0.002 secs (0.002u,0.s)
Chars 26561 - 26562 [+] 0. secs (0.u,0.s)
Chars 26563 - 26592 [(intros~a;~apply~(snd~(eg~a))).] 0.004 secs (0.002u,0.001s)
Chars 26302 - 26380 [(revert~C~ef~eg;~simple_induct...] 0.004 secs (0.004u,0.s)
Chars 26385 - 26415 [(apply~extension_functor_sigma).] 0.001 secs (0.001u,0.s)
Chars 26422 - 26452 [exact~(fst~ef,~fun~_~_~=>~tt).] 0.001 secs (0.001u,0.s)
Chars 26459 - 26504 [(intros~a;~exact~(fst~(eg~a),~...] 0.002 secs (0.002u,0.s)
Chars 26509 - 26530 [(intros~h~k;~apply~IH).] 0.002 secs (0.001u,0.s)
Chars 26537 - 26556 [exact~(snd~ef~h~k).] 0.001 secs (0.001u,0.s)
Chars 26563 - 26592 [(intros~a;~apply~(snd~(eg~a))).] 0.002 secs (0.002u,0.s)
Chars 26593 - 26601 [Defined.] 0.005 secs (0.004u,0.s)
Chars 26603 - 27015 [Definition~ooextendable_functo...] 0.005 secs (0.004u,0.001s)
Chars 27063 - 27366 [Definition~extension_functor_s...] 0.005 secs (0.004u,0.s)
Chars 27367 - 27373 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 7261 - 7287 [(intros~q~r~E;~exists~(r~-~q)).] 26.793 secs (0.001u,0.044s)
Chars 7288 - 7323 [(apply~(snd~(flip_pos_minus~_~...] 0.013 secs (0.01u,0.002s)
Chars 7261 - 7287 [(intros~q~r~E;~exists~(r~-~q)).] 0.001 secs (0.001u,0.s)
Chars 7288 - 7323 [(apply~(snd~(flip_pos_minus~_~...] 0. secs (0.u,0.s)
Chars 7324 - 7332 [Defined.] 0. secs (0.u,0.s)
Chars 7334 - 7400 [Lemma~Qpos_diff_pr@{}~:~forall...] 0.001 secs (0.u,0.s)
Chars 7401 - 7407 [Proof.] 0. secs (0.u,0.s)
Chars 12853 - 12886 [(pose~proof~(merely_equiv_fin~...] 40.185 secs (0.001u,0.034s)
Chars 12889 - 12907 [strip_truncations.] 0.052 secs (0.044u,0.007s)
Chars 12910 - 12982 [refine~(fcard_equiv~(equiv_fun...] 0.051 secs (0.042u,0.008s)
Chars 12985 - 13016 [(generalize~(fcard~X);~intros~n).] 0.001 secs (0.001u,0.s)
Chars 13019 - 13042 [(induction~n~as~[|~n~IH]).] 0.001 secs (0.001u,0.s)
Chars 13045 - 13046 [-] 0. secs (0.u,0.s)
Chars 13047 - 13059 [reflexivity.] 0. secs (0.u,0.s)
Chars 13062 - 13063 [-] 0. secs (0.u,0.s)
Chars 13064 - 13114 [refine~(fcard_equiv~(equiv_fin...] 0.079 secs (0.071u,0.007s)
Chars 13119 - 13147 [refine~(fcard_prod~_~_~@~_).] 0.004 secs (0.003u,0.s)
Chars 13152 - 13164 [(apply~ap011).] 0.001 secs (0.001u,0.s)
Chars 13169 - 13170 [+] 0. secs (0.u,0.s)
Chars 13171 - 13183 [reflexivity.] 0. secs (0.u,0.s)
Chars 13188 - 13189 [+] 0. secs (0.u,0.s)
Chars 13190 - 13201 [assumption.] 0.001 secs (0.001u,0.s)
Chars 12853 - 12886 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 12889 - 12907 [strip_truncations.] 0. secs (0.u,0.s)
Chars 12910 - 12982 [refine~(fcard_equiv~(equiv_fun...] 0. secs (0.u,0.s)
Chars 12985 - 13016 [(generalize~(fcard~X);~intros~n).] 0. secs (0.u,0.s)
Chars 13019 - 13042 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 13047 - 13059 [reflexivity.] 0. secs (0.u,0.s)
Chars 13064 - 13114 [refine~(fcard_equiv~(equiv_fin...] 0. secs (0.u,0.s)
Chars 13119 - 13147 [refine~(fcard_prod~_~_~@~_).] 0. secs (0.u,0.s)
Chars 13152 - 13164 [(apply~ap011).] 0. secs (0.u,0.s)
Chars 13171 - 13183 [reflexivity.] 0. secs (0.u,0.s)
Chars 13190 - 13201 [assumption.] 0. secs (0.u,0.s)
Chars 13202 - 13210 [Defined.] 0.007 secs (0.005u,0.001s)
Chars 13243 - 13295 [Goal~_~forall~fs~:~Funext,~fca...] 0.08 secs (0.07u,0.009s)
Chars 13298 - 13310 [reflexivity.] 0.002 secs (0.001u,0.s)
Chars 13298 - 13310 [reflexivity.] 0. secs (0.u,0.s)
Chars 13311 - 13317 [Abort.] 0. secs (0.u,0.s)
Chars 13444 - 13561 [#[global]~Instance~finite_sigm...] 0.001 secs (0.001u,0.s)
Chars 13562 - 13568 [Proof.] 0. secs (0.u,0.s)
Chars 27376 - 27416 [srefine~(sum_ind~_~_~_;~sum_in...] 40.155 secs (0.002u,0.029s)
Chars 27419 - 27420 [+] 0. secs (0.u,0.s)
Chars 27421 - 27448 [exact~(fst~ef~(h~o~inl)).1.] 0.003 secs (0.003u,0.s)
Chars 27451 - 27452 [+] 0. secs (0.u,0.s)
Chars 27453 - 27480 [exact~(fst~eg~(h~o~inr)).1.] 0.003 secs (0.003u,0.s)
Chars 27483 - 27484 [+] 0. secs (0.u,0.s)
Chars 27485 - 27512 [exact~(fst~ef~(h~o~inl)).2.] 0.004 secs (0.004u,0.s)
Chars 27515 - 27516 [+] 0. secs (0.u,0.s)
Chars 27517 - 27544 [exact~(fst~eg~(h~o~inr)).2.] 0.004 secs (0.004u,0.s)
Chars 27376 - 27416 [srefine~(sum_ind~_~_~_;~sum_in...] 0. secs (0.u,0.s)
Chars 27421 - 27448 [exact~(fst~ef~(h~o~inl)).1.] 0. secs (0.u,0.s)
Chars 27453 - 27480 [exact~(fst~eg~(h~o~inr)).1.] 0. secs (0.u,0.s)
Chars 27485 - 27512 [exact~(fst~ef~(h~o~inl)).2.] 0.001 secs (0.u,0.s)
Chars 27517 - 27544 [exact~(fst~eg~(h~o~inr)).2.] 0.001 secs (0.001u,0.s)
Chars 27545 - 27553 [Defined.] 0.003 secs (0.001u,0.001s)
Chars 27555 - 27821 [Definition~extendable_functor_...] 0.004 secs (0.004u,0.s)
Chars 27822 - 27828 [Proof.] 0. secs (0.u,0.s)
Chars 7408 - 7421 [(intros~q~r~E).] 40.242 secs (0.001u,0.042s)
Chars 7422 - 7447 [(change~(r~=~q~+~(r~-~q))).] 0.003 secs (0.003u,0.s)
Chars 7448 - 7501 [(abstract~ring_tac.ring_with_i...] 0.196 secs (0.173u,0.021s)
Chars 7408 - 7421 [(intros~q~r~E).] 0. secs (0.u,0.s)
Chars 7422 - 7447 [(change~(r~=~q~+~(r~-~q))).] 0. secs (0.u,0.s)
Chars 7448 - 7501 [(abstract~ring_tac.ring_with_i...] 0.007 secs (0.007u,0.s)
Chars 7502 - 7506 [Qed.] 0.016 secs (0.015u,0.001s)
Chars 7509 - 7584 [Lemma~Qmeet_plus_l~:~forall~a~...] 0.002 secs (0.001u,0.001s)
Chars 7585 - 7591 [Proof.] 0. secs (0.u,0.s)
Chars 13571 - 13604 [(pose~proof~(merely_equiv_fin~...] 40.182 secs (0.001u,0.034s)
Chars 13607 - 13625 [strip_truncations.] 0.038 secs (0.028u,0.009s)
Chars 13628 - 13768 [refine~~(finite_equiv'~_~~~~~(...] 0.033 secs (0.028u,0.005s)
Chars 13889 - 13921 [(set~(Y'~:=~fun~x~=>~Y~(e^-1~x...] 0.001 secs (0.001u,0.s)
Chars 13924 - 13991 [(assert~(forall~x,~Finite~(Y'~...] 0.006 secs (0.006u,0.s)
Chars 13994 - 14040 [(generalize~dependent~(fcard~X...] 0.002 secs (0.002u,0.s)
Chars 14043 - 14066 [(induction~n~as~[|~n~IH]).] 0.001 secs (0.001u,0.s)
Chars 14069 - 14070 [-] 0. secs (0.u,0.s)
Chars 14071 - 14108 [refine~(finite_equiv~Empty~pr1...] 0.004 secs (0.003u,0.s)
Chars 14111 - 14112 [-] 0. secs (0.u,0.s)
Chars 14113 - 14176 [refine~(finite_equiv~_~(equiv_...] 0.045 secs (0.038u,0.006s)
Chars 14181 - 14198 [(apply~finite_sum).] 0.001 secs (0.001u,0.s)
Chars 14203 - 14204 [+] 0. secs (0.u,0.s)
Chars 14205 - 14223 [(apply~IH;~exact~_).] 0.003 secs (0.003u,0.s)
Chars 14228 - 14229 [+] 0. secs (0.u,0.s)
Chars 14230 - 14281 [refine~(finite_equiv~_~(equiv_...] 0.01 secs (0.009u,0.s)
Chars 13571 - 13604 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 13607 - 13625 [strip_truncations.] 0. secs (0.u,0.s)
Chars 13628 - 13768 [refine~~(finite_equiv'~_~~~~~(...] 0. secs (0.u,0.s)
Chars 13889 - 13921 [(set~(Y'~:=~fun~x~=>~Y~(e^-1~x...] 0. secs (0.u,0.s)
Chars 13924 - 13991 [(assert~(forall~x,~Finite~(Y'~...] 0.001 secs (0.001u,0.s)
Chars 13994 - 14040 [(generalize~dependent~(fcard~X...] 0. secs (0.u,0.s)
Chars 14043 - 14066 [(induction~n~as~[|~n~IH]).] 0. secs (0.u,0.s)
Chars 14071 - 14108 [refine~(finite_equiv~Empty~pr1...] 0. secs (0.u,0.s)
Chars 14113 - 14176 [refine~(finite_equiv~_~(equiv_...] 0. secs (0.u,0.s)
Chars 14181 - 14198 [(apply~finite_sum).] 0. secs (0.u,0.s)
Chars 14205 - 14223 [(apply~IH;~exact~_).] 0.001 secs (0.001u,0.s)
Chars 14230 - 14281 [refine~(finite_equiv~_~(equiv_...] 0. secs (0.u,0.s)
Chars 14282 - 14290 [Defined.] 0.013 secs (0.011u,0.001s)
Chars 14506 - 14592 [Definition~finadd~{X}~`{Finite...] 0.015 secs (0.013u,0.002s)
Chars 14594 - 14736 [Definition~fcard_sigma~{X}~(Y~...] 0.013 secs (0.011u,0.001s)
Chars 14737 - 14743 [Proof.] 0. secs (0.u,0.s)
Chars 27831 - 27908 [(revert~P~ef~eg;~induction~n~a...] 40.124 secs (0.003u,0.03s)
Chars 27911 - 27912 [-] 0. secs (0.u,0.s)
Chars 27913 - 27951 [(intros~h;~apply~extension_fun...] 0.002 secs (0.002u,0.s)
Chars 27956 - 27957 [+] 0. secs (0.u,0.s)
Chars 27958 - 27988 [exact~(fst~ef,~fun~_~_~=>~tt).] 0.001 secs (0.001u,0.s)
Chars 27993 - 27994 [+] 0. secs (0.u,0.s)
Chars 27995 - 28025 [exact~(fst~eg,~fun~_~_~=>~tt).] 0.001 secs (0.001u,0.s)
Chars 28028 - 28029 [-] 0. secs (0.u,0.s)
Chars 28030 - 28041 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 28046 - 28055 [(apply~IH).] 0. secs (0.u,0.s)
Chars 28060 - 28061 [+] 0. secs (0.u,0.s)
Chars 28062 - 28097 [exact~(snd~ef~(h~o~inl)~(k~o~i...] 0.003 secs (0.002u,0.s)
Chars 28102 - 28103 [+] 0. secs (0.u,0.s)
Chars 28104 - 28139 [exact~(snd~eg~(h~o~inr)~(k~o~i...] 0.002 secs (0.002u,0.s)
Chars 27831 - 27908 [(revert~P~ef~eg;~induction~n~a...] 0.002 secs (0.002u,0.s)
Chars 27913 - 27951 [(intros~h;~apply~extension_fun...] 0.001 secs (0.001u,0.s)
Chars 27958 - 27988 [exact~(fst~ef,~fun~_~_~=>~tt).] 0. secs (0.u,0.s)
Chars 27995 - 28025 [exact~(fst~eg,~fun~_~_~=>~tt).] 0. secs (0.u,0.s)
Chars 28030 - 28041 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 28046 - 28055 [(apply~IH).] 0. secs (0.u,0.s)
Chars 28062 - 28097 [exact~(snd~ef~(h~o~inl)~(k~o~i...] 0. secs (0.u,0.s)
Chars 28104 - 28139 [exact~(snd~eg~(h~o~inr)~(k~o~i...] 0. secs (0.u,0.s)
Chars 28140 - 28148 [Defined.] 0.002 secs (0.001u,0.s)
Chars 28150 - 28408 [Definition~ooextendable_functo...] 0.002 secs (0.001u,0.001s)
Chars 28409 - 28415 [Proof.] 0. secs (0.u,0.s)
Chars 7592 - 7599 [(intros).] 40.203 secs (0.001u,0.042s)
Chars 7600 - 7633 [(destruct~(total~le~b~c)~as~[E...] 0.005 secs (0.005u,0.s)
Chars 7634 - 7635 [-] 0. secs (0.u,0.s)
Chars 7636 - 7659 [(rewrite~(meet_l~_~_~E)).] 0.004 secs (0.004u,0.s)
Chars 7660 - 7673 [(apply~meet_l).] 0.003 secs (0.003u,0.s)
Chars 7676 - 7709 [(apply~(order_preserving~(a~+)...] 0.015 secs (0.012u,0.002s)
Chars 7710 - 7711 [-] 0. secs (0.u,0.s)
Chars 7712 - 7735 [(rewrite~(meet_r~_~_~E)).] 0.004 secs (0.004u,0.s)
Chars 7736 - 7749 [(apply~meet_r).] 0.003 secs (0.002u,0.s)
Chars 7752 - 7785 [(apply~(order_preserving~(a~+)...] 0.016 secs (0.014u,0.001s)
Chars 7592 - 7599 [(intros).] 0. secs (0.u,0.s)
Chars 7600 - 7633 [(destruct~(total~le~b~c)~as~[E...] 0. secs (0.u,0.s)
Chars 7636 - 7659 [(rewrite~(meet_l~_~_~E)).] 0. secs (0.u,0.s)
Chars 7660 - 7673 [(apply~meet_l).] 0. secs (0.u,0.s)
Chars 7676 - 7709 [(apply~(order_preserving~(a~+)...] 0. secs (0.u,0.s)
Chars 7712 - 7735 [(rewrite~(meet_r~_~_~E)).] 0. secs (0.u,0.s)
Chars 7736 - 7749 [(apply~meet_r).] 0. secs (0.u,0.s)
Chars 7752 - 7785 [(apply~(order_preserving~(a~+)...] 0. secs (0.u,0.s)
Chars 7786 - 7790 [Qed.] 0.001 secs (0.001u,0.s)
Chars 7792 - 7840 [Lemma~Qabs_nonneg@{}~:~forall~...] 0.001 secs (0.001u,0.s)
Chars 7841 - 7847 [Proof.] 0. secs (0.u,0.s)
Chars 14746 - 14778 [(set~(f~:=~fun~x~=>~fcard~(Y~x...] 40.189 secs (0.002u,0.034s)
Chars 14781 - 14853 [(set~(g~:=~fun~x~=>~merely_equ...] 0.002 secs (0.002u,0.s)
Chars 14856 - 14894 [(apply~finite_choice~in~g;~[~~...] 0.011 secs (0.009u,0.001s)
Chars 14897 - 14915 [strip_truncations.] 0.044 secs (0.039u,0.005s)
Chars 14918 - 14932 [(unfold~finadd).] 0. secs (0.u,0.s)
Chars 14935 - 14984 [refine~(fcard_equiv'~(equiv_fu...] 0.002 secs (0.001u,0.s)
Chars 14746 - 14778 [(set~(f~:=~fun~x~=>~fcard~(Y~x...] 0. secs (0.u,0.s)
Chars 14781 - 14853 [(set~(g~:=~fun~x~=>~merely_equ...] 0. secs (0.u,0.s)
Chars 14856 - 14894 [(apply~finite_choice~in~g;~[~~...] 0.001 secs (0.001u,0.s)
Chars 14897 - 14915 [strip_truncations.] 0. secs (0.u,0.s)
Chars 14918 - 14932 [(unfold~finadd).] 0. secs (0.u,0.s)
Chars 14935 - 14984 [refine~(fcard_equiv'~(equiv_fu...] 0. secs (0.u,0.s)
Chars 14985 - 14993 [Defined.] 0.003 secs (0.003u,0.s)
Chars 15073 - 15151 [Definition~finadd_const~X~`{Fi...] 0.001 secs (0.001u,0.s)
Chars 15152 - 15158 [Proof.] 0. secs (0.u,0.s)
DIO_ELEM_H10C_SAT
     : DIO_ELEM_SAT ⪯ H10C_SAT
FRACTRAN_HALTING_DIO_LOGIC_SAT
     : Halt_FRACTRAN ⪯ DIO_LOGIC_SAT
DIO_LOGIC_ELEM_SAT
     : DIO_LOGIC_SAT ⪯ DIO_ELEM_SAT
Chars 28418 - 28482 [(intros~n;~apply~extendable_fu...] 40.125 secs (0.003u,0.023s)
Chars 28418 - 28482 [(intros~n;~apply~extendable_fu...] 0.002 secs (0.002u,0.s)
Chars 28483 - 28491 [Defined.] 0.001 secs (0.001u,0.s)
Chars 29010 - 29466 [Definition~extension_functor_c...] 0.012 secs (0.01u,0.002s)
Chars 29467 - 29473 [Proof.] 0. secs (0.u,0.s)
Chars 7848 - 7929 [(intros~q;~destruct~(total_abs...] 40.206 secs (0.015u,0.042s)
Chars 7930 - 7931 [-] 0. secs (0.u,0.s)
Chars 7932 - 7940 [trivial.] 0.001 secs (0.001u,0.s)
Chars 7941 - 7942 [-] 0. secs (0.u,0.s)
Chars 7943 - 7968 [(apply~flip_nonneg_negate).] 0.018 secs (0.016u,0.001s)
Chars 7970 - 7997 [(rewrite~involutive;~trivial).] 0.025 secs (0.02u,0.004s)
Chars 7848 - 7929 [(intros~q;~destruct~(total_abs...] 0.005 secs (0.004u,0.001s)
Chars 7932 - 7940 [trivial.] 0. secs (0.u,0.s)
Chars 7943 - 7968 [(apply~flip_nonneg_negate).] 0. secs (0.u,0.s)
Chars 7970 - 7997 [(rewrite~involutive;~trivial).] 0.001 secs (0.001u,0.s)
Chars 7998 - 8002 [Qed.] 0.002 secs (0.001u,0.s)
Chars 8004 - 8063 [Lemma~Qabs_nonpos_0@{}~:~foral...] 0.002 secs (0.002u,0.s)
Chars 8064 - 8070 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 15161 - 15194 [transitivity~(fcard~(X~*~Fin~n)).] 40.203 secs (0.014u,0.037s)
Chars 15197 - 15198 [-] 0. secs (0.u,0.s)
Chars 15199 - 15250 [exact~(fcard_equiv'~(equiv_sig...] 0.001 secs (0.001u,0.s)
Chars 15253 - 15254 [-] 0. secs (0.u,0.s)
Chars 15255 - 15284 [exact~(fcard_prod~X~(Fin~n)).] 0.003 secs (0.003u,0.s)
Chars 15161 - 15194 [transitivity~(fcard~(X~*~Fin~n)).] 0. secs (0.u,0.s)
Chars 15199 - 15250 [exact~(fcard_equiv'~(equiv_sig...] 0. secs (0.u,0.s)
Chars 15255 - 15284 [exact~(fcard_prod~X~(Fin~n)).] 0. secs (0.u,0.s)
Chars 15285 - 15293 [Defined.] 0.002 secs (0.001u,0.s)
Chars 15369 - 15474 [Definition~finite_hfiber~{X}~{...] 0. secs (0.u,0.s)
Chars 15475 - 15481 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutSSTS01_undec
     : undecidable SSTS01
Chars 15484 - 15492 [exact~_.] 21.007 secs (0.024u,0.042s)
Chars 15484 - 15492 [exact~_.] 0. secs (0.u,0.s)
Chars 15493 - 15501 [Defined.] 0. secs (0.u,0.s)
Chars 15628 - 15744 [Definition~fcard_domain~{X}~{Y...] 0.044 secs (0.034u,0.009s)
Chars 15745 - 15751 [Proof.] 0. secs (0.u,0.s)
find_witness Fun.Finally_raised: Control.TimeoutRA_UNIV_HALT_undec
     : undecidable RA_UNIV_HALT
Chars 29556 - 29587 [(set~(C'~:=~C~o~pr_cylcoeq~p~q)).] 40.163 secs (0.011u,0.029s)
Chars 29590 - 29631 [(set~(s'~:=~fun~x~=>~pr_cyl_cy...] 0.011 secs (0.008u,0.002s)
Chars 29634 - 29686 [(assert~(e~:~ExtensionAlong~(c...] 0.005 secs (0.005u,0.s)
Chars 29689 - 29692 [2:~{] 0. secs (0.u,0.s)
Chars 29693 - 29754 [(pose~(ex~:=~fst~(extendable_e...] 0.028 secs (0.024u,0.004s)
Chars 29761 - 29785 [(exists~ex.1;~intros~x).] 0.008 secs (0.008u,0.s)
Chars 29792 - 29847 [(apply~(equiv_inj~(transport~C...] 0.01 secs (0.007u,0.002s)
Chars 29854 - 29908 [exact~((apD~_~(pr_cyl_cylcoeq~...] 0.01 secs (0.008u,0.001s)
Chars 29909 - 29910 [}] 0. secs (0.u,0.s)
Chars 30190 - 30250 [(pose~(ea1~:=~fun~u~=>~(fst~(c...] 0.008 secs (0.006u,0.002s)
Chars 30253 - 30364 [(assert~~~(eb''~:~~~~forall~u~...] 0.011 secs (0.01u,0.s)
Chars 30367 - 30368 [{] 0. secs (0.u,0.s)
Chars 30369 - 30380 [(intros~u~v).] 0.004 secs (0.004u,0.s)
Chars 30385 - 30416 [rapply~extendable_postcompose'.] 0.059 secs (0.036u,0.023s)
Chars 30421 - 30424 [2:~{] 0. secs (0.u,0.s)
Chars 30425 - 30468 [rapply~(cancelL_extendable~1~_...] 0.015 secs (0.012u,0.003s)
Chars 30477 - 30478 [-] 0. secs (0.u,0.s)
Chars 30479 - 30503 [rapply~extendable_equiv.] 0.014 secs (0.012u,0.001s)
Chars 30512 - 30513 [-] 0. secs (0.u,0.s)
Chars 30514 - 30566 [exact~(eh~(fun~x~=>~cglue~x~#~...] 0.014 secs (0.012u,0.002s)
Chars 30567 - 30568 [}] 0. secs (0.u,0.s)
Chars 30573 - 30592 [(intros~x;~subst~C').] 0.011 secs (0.009u,0.002s)
Chars 30597 - 30629 [refine~(_~oE~dp_path_transport).] 0.01 secs (0.008u,0.001s)
Chars 30634 - 30685 [refine~((dp_compose~(pr_cylcoe...] 0.011 secs (0.01u,0.s)
Chars 30690 - 30725 [(symmetry;~srapply~equiv_ds_fi...] 0.022 secs (0.02u,0.001s)
Chars 30730 - 30759 [3:~rapply~ap_pr_cylcoeq_cglue.] 0.015 secs (0.013u,0.001s)
Chars 30764 - 30813 [all:~srapply~(transport~(fun~r...] 0.311 secs (0.29u,0.02s)
Chars 30818 - 30888 [3:~exact~(dp_inverse~(dp_compo...] 0.022 secs (0.016u,0.005s)
Chars 30893 - 30963 [4:~exact~(dp_inverse~(dp_compo...] 0.021 secs (0.021u,0.s)
Chars 30968 - 31102 [1:~~(change~(fun~y~=>~pr_cylco...] 0.018 secs (0.018u,0.s)
Chars 31107 - 31241 [2:~~(change~(fun~y~=>~pr_cylco...] 0.017 secs (0.017u,0.s)
Chars 31246 - 31292 [all:~refine~((ap_V~_~(eissect~...] 0.037 secs (0.037u,0.s)
Chars 31297 - 31364 [all:~exact~(ap_compose~(fun~x~...] 0.025 secs (0.025u,0.s)
Chars 31365 - 31366 [}] 0. secs (0.u,0.s)
Chars 31369 - 31440 [(pose~(eb1~:=~fun~u~v~w~=>~(fs...] 0.03 secs (0.027u,0.002s)
Chars 31567 - 31602 [(srefine~(_;~_);~srapply~Coeq_...] 0.022 secs (0.021u,0.s)
Chars 31605 - 31606 [+] 0. secs (0.u,0.s)
Chars 31607 - 31631 [exact~(ea1~(s'~o~coeq)).] 0.008 secs (0.008u,0.s)
Chars 31634 - 31635 [+] 0. secs (0.u,0.s)
Chars 31636 - 31656 [(apply~eb1;~intros~b).] 0.014 secs (0.014u,0.s)
Chars 31661 - 31715 [rapply~(dp_compose'~_~_~(ap_cy...] 0.021 secs (0.021u,0.s)
Chars 31720 - 31748 [exact~(dp_apD~s'~(cglue~b)).] 0.007 secs (0.007u,0.s)
Chars 31751 - 31752 [+] 0. secs (0.u,0.s)
Chars 31823 - 31845 [(intros~a;~reflexivity).] 0.016 secs (0.015u,0.s)
Chars 31848 - 31849 [+] 0. secs (0.u,0.s)
Chars 31918 - 31927 [(intros~b).] 0.007 secs (0.007u,0.s)
Chars 31932 - 31944 [(apply~ds_dp).] 0.056 secs (0.056u,0.s)
Chars 31949 - 31962 [rapply~ds_G1.] 0.506 secs (0.498u,0.007s)
Chars 31967 - 32031 [refine~(dp_apD_compose'~_~_~(a...] 0.023 secs (0.023u,0.s)
Chars 32036 - 32056 [(apply~moveR_equiv_V).] 0.018 secs (0.018u,0.s)
Chars 32061 - 32096 [rapply~(Coeq_ind_dp_beta_cglue...] 0.299 secs (0.286u,0.012s)
Chars 29556 - 29587 [(set~(C'~:=~C~o~pr_cylcoeq~p~q)).] 0.001 secs (0.001u,0.s)
Chars 29590 - 29631 [(set~(s'~:=~fun~x~=>~pr_cyl_cy...] 0.001 secs (0.001u,0.s)
Chars 29634 - 29686 [(assert~(e~:~ExtensionAlong~(c...] 0.002 secs (0.002u,0.s)
Chars 29693 - 29754 [(pose~(ex~:=~fst~(extendable_e...] 0.002 secs (0.002u,0.s)
Chars 29761 - 29785 [(exists~ex.1;~intros~x).] 0.005 secs (0.005u,0.s)
Chars 29792 - 29847 [(apply~(equiv_inj~(transport~C...] 0.002 secs (0.002u,0.s)
Chars 29854 - 29908 [exact~((apD~_~(pr_cyl_cylcoeq~...] 0.003 secs (0.002u,0.s)
Chars 30190 - 30250 [(pose~(ea1~:=~fun~u~=>~(fst~(c...] 0.002 secs (0.002u,0.s)
Chars 30253 - 30364 [(assert~~~(eb''~:~~~~forall~u~...] 0.003 secs (0.003u,0.s)
Chars 30369 - 30380 [(intros~u~v).] 0.003 secs (0.003u,0.s)
Chars 30385 - 30416 [rapply~extendable_postcompose'.] 0.003 secs (0.003u,0.s)
Chars 30425 - 30468 [rapply~(cancelL_extendable~1~_...] 0.003 secs (0.003u,0.s)
Chars 30479 - 30503 [rapply~extendable_equiv.] 0.003 secs (0.003u,0.s)
Chars 30514 - 30566 [exact~(eh~(fun~x~=>~cglue~x~#~...] 0.003 secs (0.003u,0.s)
Chars 30573 - 30592 [(intros~x;~subst~C').] 0.008 secs (0.008u,0.s)
Chars 30597 - 30629 [refine~(_~oE~dp_path_transport).] 0.004 secs (0.004u,0.s)
Chars 30634 - 30685 [refine~((dp_compose~(pr_cylcoe...] 0.004 secs (0.004u,0.s)
Chars 30690 - 30725 [(symmetry;~srapply~equiv_ds_fi...] 0.008 secs (0.008u,0.s)
Chars 30730 - 30759 [3:~rapply~ap_pr_cylcoeq_cglue.] 0.004 secs (0.004u,0.s)
Chars 30764 - 30813 [all:~srapply~(transport~(fun~r...] 0.007 secs (0.007u,0.s)
Chars 30818 - 30888 [3:~exact~(dp_inverse~(dp_compo...] 0.004 secs (0.004u,0.s)
Chars 30893 - 30963 [4:~exact~(dp_inverse~(dp_compo...] 0.003 secs (0.003u,0.s)
Chars 30968 - 31102 [1:~~(change~(fun~y~=>~pr_cylco...] 0.004 secs (0.004u,0.s)
Chars 31107 - 31241 [2:~~(change~(fun~y~=>~pr_cylco...] 0.004 secs (0.004u,0.s)
Chars 31246 - 31292 [all:~refine~((ap_V~_~(eissect~...] 0.008 secs (0.008u,0.s)
Chars 31297 - 31364 [all:~exact~(ap_compose~(fun~x~...] 0.008 secs (0.008u,0.s)
Chars 31369 - 31440 [(pose~(eb1~:=~fun~u~v~w~=>~(fs...] 0.003 secs (0.003u,0.s)
Chars 31567 - 31602 [(srefine~(_;~_);~srapply~Coeq_...] 0.017 secs (0.016u,0.s)
Chars 31607 - 31631 [exact~(ea1~(s'~o~coeq)).] 0.005 secs (0.005u,0.s)
Chars 31636 - 31656 [(apply~eb1;~intros~b).] 0.012 secs (0.012u,0.s)
Chars 31661 - 31715 [rapply~(dp_compose'~_~_~(ap_cy...] 0.006 secs (0.006u,0.s)
Chars 31720 - 31748 [exact~(dp_apD~s'~(cglue~b)).] 0.006 secs (0.006u,0.s)
Chars 31823 - 31845 [(intros~a;~reflexivity).] 0.015 secs (0.015u,0.s)
Chars 31918 - 31927 [(intros~b).] 0.007 secs (0.007u,0.s)
Chars 31932 - 31944 [(apply~ds_dp).] 0.1 secs (0.1u,0.s)
Chars 31949 - 31962 [rapply~ds_G1.] 0.009 secs (0.009u,0.s)
Chars 31967 - 32031 [refine~(dp_apD_compose'~_~_~(a...] 0.009 secs (0.009u,0.s)
Chars 32036 - 32056 [(apply~moveR_equiv_V).] 0.011 secs (0.011u,0.s)
Chars 32061 - 32096 [rapply~(Coeq_ind_dp_beta_cglue...] 0.01 secs (0.01u,0.s)
Chars 32097 - 32105 [Defined.] 0.541 secs (0.539u,0.s)
Chars 32167 - 32592 [Definition~extendable_functor_...] 0.007 secs (0.007u,0.s)
Chars 32593 - 32599 [Proof.] 0. secs (0.u,0.s)
Chars 8071 - 8082 [(intros~q~E).] 40.189 secs (0.001u,0.041s)
Chars 8083 - 8140 [(pose~proof~(antisymmetry~le~_...] 0.013 secs (0.012u,0.001s)
Chars 8141 - 8209 [(destruct~(total_abs_either~q)...] 0.012 secs (0.01u,0.002s)
Chars 8210 - 8211 [-] 0. secs (0.u,0.s)
Chars 8212 - 8220 [trivial.] 0.001 secs (0.001u,0.s)
Chars 8221 - 8222 [-] 0. secs (0.u,0.s)
Chars 8223 - 8245 [(apply~(injective~(-))).] 0.011 secs (0.01u,0.001s)
Chars 8246 - 8263 [(rewrite~negate_0).] 0.006 secs (0.004u,0.001s)
Chars 8264 - 8272 [trivial.] 0.001 secs (0.001u,0.s)
Chars 8071 - 8082 [(intros~q~E).] 0. secs (0.u,0.s)
Chars 8083 - 8140 [(pose~proof~(antisymmetry~le~_...] 0. secs (0.u,0.s)
Chars 8141 - 8209 [(destruct~(total_abs_either~q)...] 0.002 secs (0.002u,0.s)
Chars 8212 - 8220 [trivial.] 0. secs (0.u,0.s)
Chars 8223 - 8245 [(apply~(injective~(-))).] 0. secs (0.u,0.s)
Chars 8246 - 8263 [(rewrite~negate_0).] 0. secs (0.u,0.s)
Chars 8264 - 8272 [trivial.] 0. secs (0.u,0.s)
Chars 8273 - 8277 [Qed.] 0.002 secs (0.002u,0.s)
Chars 8279 - 8335 [Lemma~Qabs_0_or_pos~:~forall~q...] 0.002 secs (0.002u,0.s)
Chars 8336 - 8342 [Proof.] 0. secs (0.u,0.s)
Chars 15754 - 15790 [refine~(_~@~fcard_sigma~(hfibe...] 40.194 secs (0.003u,0.034s)
Chars 15793 - 15847 [refine~(fcard_equiv'~(equiv_fi...] 0.002 secs (0.002u,0.s)
Chars 15754 - 15790 [refine~(_~@~fcard_sigma~(hfibe...] 0. secs (0.u,0.s)
Chars 15793 - 15847 [refine~(fcard_equiv'~(equiv_fi...] 0. secs (0.u,0.s)
Chars 15848 - 15856 [Defined.] 0.002 secs (0.002u,0.s)
Chars 15930 - 16024 [Definition~finite_image~{X}~{Y...] 0.001 secs (0.u,0.s)
Chars 16025 - 16031 [Proof.] 0. secs (0.u,0.s)
Chars 16034 - 16042 [exact~_.] 0.314 secs (0.053u,0.046s)
Chars 16034 - 16042 [exact~_.] 0. secs (0.u,0.s)
Chars 16043 - 16051 [Defined.] 0.001 secs (0.001u,0.s)
Chars 16320 - 16421 [Definition~finmult~`{Funext}~{...] 0.029 secs (0.027u,0.001s)
Chars 16423 - 16581 [Definition~fcard_forall~`{Fune...] 0.019 secs (0.015u,0.004s)
Chars 16582 - 16588 [Proof.] 0. secs (0.u,0.s)
Chars 32602 - 32680 [(revert~C~ek~eh;~simple_induct...] 40.171 secs (0.011u,0.032s)
Chars 32683 - 32684 [-] 0. secs (0.u,0.s)
Chars 32685 - 32714 [(apply~extension_functor_coeq).] 0.004 secs (0.003u,0.s)
Chars 32719 - 32720 [+] 0. secs (0.u,0.s)
Chars 32721 - 32752 [exact~(fst~ek,~fun~_~_~=>~tt).] 0.003 secs (0.003u,0.s)
Chars 32757 - 32758 [+] 0. secs (0.u,0.s)
Chars 32759 - 32809 [exact~(fun~u~v~=>~(fst~(eh~u~v...] 0.005 secs (0.005u,0.s)
Chars 32812 - 32813 [-] 0. secs (0.u,0.s)
Chars 32814 - 32835 [(intros~u~v;~apply~IH).] 0.004 secs (0.003u,0.001s)
Chars 32840 - 32841 [+] 0. secs (0.u,0.s)
Chars 32842 - 32879 [exact~(snd~ek~(u~o~coeq)~(v~o~...] 0.005 secs (0.004u,0.s)
Chars 32884 - 32885 [+] 0. secs (0.u,0.s)
Chars 32886 - 32935 [exact~(snd~(eh~(u~o~coeq~o~g')...] 0.01 secs (0.008u,0.001s)
Chars 32602 - 32680 [(revert~C~ek~eh;~simple_induct...] 0.008 secs (0.007u,0.s)
Chars 32685 - 32714 [(apply~extension_functor_coeq).] 0.001 secs (0.001u,0.s)
Chars 32721 - 32752 [exact~(fst~ek,~fun~_~_~=>~tt).] 0.001 secs (0.001u,0.s)
Chars 32759 - 32809 [exact~(fun~u~v~=>~(fst~(eh~u~v...] 0.001 secs (0.001u,0.s)
Chars 32814 - 32835 [(intros~u~v;~apply~IH).] 0.003 secs (0.003u,0.s)
Chars 32842 - 32879 [exact~(snd~ek~(u~o~coeq)~(v~o~...] 0.001 secs (0.u,0.s)
Chars 32886 - 32935 [exact~(snd~(eh~(u~o~coeq~o~g')...] 0.002 secs (0.002u,0.s)
Chars 32936 - 32944 [Defined.] 0.008 secs (0.006u,0.001s)
Chars 32946 - 33432 [Definition~ooextendable_functo...] 0.015 secs (0.01u,0.004s)
Chars 33569 - 33931 [Definition~extendable_functor_...] 0.012 secs (0.011u,0.001s)
Chars 33932 - 33938 [Proof.] 0. secs (0.u,0.s)
Chars 8343 - 8352 [(intros~q).] 40.184 secs (0.001u,0.042s)
Chars 8353 - 8392 [(destruct~(le_or_lt~(abs~q)~0)...] 0.014 secs (0.01u,0.003s)
Chars 8393 - 8394 [-] 0. secs (0.u,0.s)
Chars 8395 - 8400 [left.] 0.001 secs (0.001u,0.s)
Chars 8401 - 8421 [(apply~Qabs_nonpos_0).] 0.001 secs (0.001u,0.s)
Chars 8422 - 8430 [trivial.] 0.001 secs (0.001u,0.s)
Chars 8431 - 8432 [-] 0. secs (0.u,0.s)
Chars 8433 - 8439 [right.] 0.001 secs (0.u,0.s)
Chars 8440 - 8448 [trivial.] 0.001 secs (0.001u,0.s)
Chars 8343 - 8352 [(intros~q).] 0. secs (0.u,0.s)
Chars 8353 - 8392 [(destruct~(le_or_lt~(abs~q)~0)...] 0. secs (0.u,0.s)
Chars 8395 - 8400 [left.] 0. secs (0.u,0.s)
Chars 8401 - 8421 [(apply~Qabs_nonpos_0).] 0. secs (0.u,0.s)
Chars 8422 - 8430 [trivial.] 0. secs (0.u,0.s)
Chars 8433 - 8439 [right.] 0. secs (0.u,0.s)
Chars 8440 - 8448 [trivial.] 0. secs (0.u,0.s)
Chars 8449 - 8453 [Qed.] 0.001 secs (0.u,0.s)
Chars 8455 - 8515 [Lemma~Qabs_of_nonneg@{}~:~fora...] 0.001 secs (0.001u,0.s)
Chars 8516 - 8522 [Proof.] 0. secs (0.u,0.s)
Chars 16591 - 16623 [(set~(f~:=~fun~x~=>~fcard~(Y~x...] 40.189 secs (0.002u,0.035s)
Chars 16626 - 16698 [(set~(g~:=~fun~x~=>~merely_equ...] 0.002 secs (0.002u,0.s)
Chars 16701 - 16739 [(apply~finite_choice~in~g;~[~~...] 0.012 secs (0.009u,0.001s)
Chars 16742 - 16760 [strip_truncations.] 0.074 secs (0.063u,0.011s)
Chars 16763 - 16778 [(unfold~finmult).] 0. secs (0.u,0.s)
Chars 16781 - 16845 [refine~(fcard_equiv'~(equiv_fu...] 0.002 secs (0.002u,0.s)
Chars 16591 - 16623 [(set~(f~:=~fun~x~=>~fcard~(Y~x...] 0. secs (0.u,0.s)
Chars 16626 - 16698 [(set~(g~:=~fun~x~=>~merely_equ...] 0. secs (0.u,0.s)
Chars 16701 - 16739 [(apply~finite_choice~in~g;~[~~...] 0.001 secs (0.001u,0.s)
Chars 16742 - 16760 [strip_truncations.] 0. secs (0.u,0.s)
Chars 16763 - 16778 [(unfold~finmult).] 0. secs (0.u,0.s)
Chars 16781 - 16845 [refine~(fcard_equiv'~(equiv_fu...] 0. secs (0.u,0.s)
Chars 16846 - 16854 [Defined.] 0.004 secs (0.004u,0.s)
Chars 16942 - 17040 [Definition~finmult_const~`{Fun...] 0.002 secs (0.001u,0.001s)
Chars 17041 - 17047 [Proof.] 0. secs (0.u,0.s)
Chars 33941 - 33971 [(apply~extendable_functor_coeq).] 40.158 secs (0.002u,0.03s)
Chars 33974 - 33987 [1:~assumption.] 0.001 secs (0.001u,0.s)
Chars 33990 - 34005 [exact~(snd~eh).] 0.002 secs (0.002u,0.s)
Chars 33941 - 33971 [(apply~extendable_functor_coeq).] 0.001 secs (0.001u,0.s)
Chars 33974 - 33987 [1:~assumption.] 0.001 secs (0.001u,0.s)
Chars 33990 - 34005 [exact~(snd~eh).] 0.001 secs (0.001u,0.s)
Chars 34006 - 34014 [Defined.] 0.002 secs (0.002u,0.s)
Chars 34016 - 34425 [Definition~ooextendable_functo...] 0.015 secs (0.014u,0.s)
Chars 8523 - 8551 [(intro;~apply~(abs_sig~_).2).] 40.2 secs (0.004u,0.043s)
Chars 8523 - 8551 [(intro;~apply~(abs_sig~_).2).] 0.001 secs (0.001u,0.s)
Chars 8552 - 8556 [Qed.] 0. secs (0.u,0.s)
Chars 8558 - 8617 [Lemma~Qabs_of_nonpos~:~forall~...] 0.002 secs (0.002u,0.s)
Chars 8618 - 8624 [Proof.] 0. secs (0.u,0.s)
Chars 8625 - 8653 [(intro;~apply~(abs_sig~_).2).] 0.16 secs (0.005u,0.042s)
Chars 8625 - 8653 [(intro;~apply~(abs_sig~_).2).] 0.001 secs (0.001u,0.s)
Chars 8654 - 8658 [Qed.] 0. secs (0.u,0.s)
Chars 8660 - 8708 [Lemma~Qabs_le_raw@{}~:~forall~...] 0.001 secs (0.u,0.001s)
Chars 8709 - 8715 [Proof.] 0. secs (0.u,0.s)
Chars 17050 - 17081 [refine~(fcard_arrow~X~(Fin~n)).] 40.244 secs (0.048u,0.046s)
Chars 17050 - 17081 [refine~(fcard_arrow~X~(Fin~n)).] 0. secs (0.u,0.s)
Chars 17082 - 17090 [Defined.] 0.003 secs (0.003u,0.s)
Chars 17207 - 17366 [#[global]~Instance~finite_deta...] 0.001 secs (0.001u,0.s)
Chars 17367 - 17373 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 8716 - 8776 [(intros~x;~destruct~(total_abs...] 40.206 secs (0.009u,0.042s)
Chars 8777 - 8778 [-] 0. secs (0.u,0.s)
Chars 8779 - 8802 [(rewrite~E2;~reflexivity).] 0.016 secs (0.011u,0.005s)
Chars 8803 - 8804 [-] 0. secs (0.u,0.s)
Chars 8805 - 8832 [(transitivity~(0~:~Q);~trivial).] 0.064 secs (0.053u,0.01s)
Chars 8835 - 8846 [(rewrite~E2).] 0.001 secs (0.001u,0.s)
Chars 8847 - 8872 [(apply~flip_nonpos_negate).] 0.032 secs (0.023u,0.008s)
Chars 8873 - 8881 [trivial.] 0.001 secs (0.001u,0.s)
Chars 8716 - 8776 [(intros~x;~destruct~(total_abs...] 0.001 secs (0.001u,0.s)
Chars 8779 - 8802 [(rewrite~E2;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 8805 - 8832 [(transitivity~(0~:~Q);~trivial).] 0.002 secs (0.002u,0.s)
Chars 8835 - 8846 [(rewrite~E2).] 0. secs (0.u,0.s)
Chars 8847 - 8872 [(apply~flip_nonpos_negate).] 0. secs (0.u,0.s)
Chars 8873 - 8881 [trivial.] 0. secs (0.u,0.s)
Chars 8882 - 8886 [Qed.] 0.002 secs (0.002u,0.s)
Chars 8888 - 8940 [Lemma~Qabs_neg@{}~:~forall~x~:...] 0.002 secs (0.002u,0.s)
Chars 8941 - 8947 [Proof.] 0. secs (0.u,0.s)
Chars 17376 - 17384 [exact~_.] 40.192 secs (0.014u,0.034s)
Chars 17376 - 17384 [exact~_.] 0. secs (0.u,0.s)
Chars 17385 - 17393 [Defined.] 0.001 secs (0.001u,0.s)
Chars 17554 - 17695 [Definition~detachable_image_fi...] 0.001 secs (0.001u,0.s)
Chars 17696 - 17702 [Proof.] 0. secs (0.u,0.s)
Chars 17705 - 17714 [(intros~y).] 1.623 secs (0.u,0.033s)
Chars 17717 - 17762 [(assert~(ff~:~Finite~(hfiber~f...] 0.034 secs (0.031u,0.002s)
Chars 17765 - 17789 [(destruct~ff~as~[[|~n]~e]).] 0.001 secs (0.u,0.001s)
Chars 17792 - 17793 [-] 0. secs (0.u,0.s)
Chars 17794 - 17842 [(right;~intros~u;~strip_trunca...] 0.123 secs (0.102u,0.02s)
Chars 17845 - 17846 [-] 0. secs (0.u,0.s)
Chars 17847 - 17894 [(left;~strip_truncations;~exac...] 0.102 secs (0.092u,0.01s)
Chars 17705 - 17714 [(intros~y).] 0. secs (0.u,0.s)
Chars 17717 - 17762 [(assert~(ff~:~Finite~(hfiber~f...] 0. secs (0.u,0.s)
Chars 17765 - 17789 [(destruct~ff~as~[[|~n]~e]).] 0. secs (0.u,0.s)
Chars 17794 - 17842 [(right;~intros~u;~strip_trunca...] 0.001 secs (0.001u,0.s)
Chars 17847 - 17894 [(left;~strip_truncations;~exac...] 0.001 secs (0.001u,0.s)
Chars 17895 - 17903 [Defined.] 0.003 secs (0.003u,0.s)
Chars 17905 - 18080 [Definition~detachable_finite_s...] 0.001 secs (0.001u,0.s)
Chars 18081 - 18087 [Proof.] 0. secs (0.u,0.s)
Chars 8948 - 8957 [(intros~x).] 40.186 secs (0.001u,0.042s)
Chars 8958 - 9009 [(destruct~(total_abs_either~x)...] 0.009 secs (0.008u,0.s)
Chars 9010 - 9011 [-] 0. secs (0.u,0.s)
Chars 9012 - 9023 [(rewrite~E2).] 0.002 secs (0.002u,0.s)
Chars 9024 - 9071 [(path_via~(-~-~x);~[~~|~rewrit...] 0.021 secs (0.02u,0.s)
Chars 9074 - 9100 [(apply~(abs_sig~(-~x)).2).] 0.004 secs (0.003u,0.s)
Chars 9101 - 9134 [(apply~flip_nonneg_negate;~tri...] 0.017 secs (0.014u,0.002s)
Chars 9135 - 9136 [-] 0. secs (0.u,0.s)
Chars 9137 - 9148 [(rewrite~E2).] 0.002 secs (0.002u,0.s)
Chars 9149 - 9175 [(apply~(abs_sig~(-~x)).2).] 0.003 secs (0.002u,0.s)
Chars 9176 - 9209 [(apply~flip_nonpos_negate;~tri...] 0.019 secs (0.018u,0.001s)
Chars 8948 - 8957 [(intros~x).] 0. secs (0.u,0.s)
Chars 8958 - 9009 [(destruct~(total_abs_either~x)...] 0. secs (0.u,0.s)
Chars 9012 - 9023 [(rewrite~E2).] 0. secs (0.u,0.s)
Chars 9024 - 9071 [(path_via~(-~-~x);~[~~|~rewrit...] 0.002 secs (0.002u,0.s)
Chars 9074 - 9100 [(apply~(abs_sig~(-~x)).2).] 0. secs (0.u,0.s)
Chars 9101 - 9134 [(apply~flip_nonneg_negate;~tri...] 0.001 secs (0.001u,0.s)
Chars 9137 - 9148 [(rewrite~E2).] 0.001 secs (0.001u,0.s)
Chars 9149 - 9175 [(apply~(abs_sig~(-~x)).2).] 0. secs (0.u,0.s)
Chars 9176 - 9209 [(apply~flip_nonpos_negate;~tri...] 0.001 secs (0.001u,0.s)
Chars 9210 - 9214 [Qed.] 0.003 secs (0.002u,0.s)
Chars 9216 - 9267 [Lemma~Qabs_le_neg_raw~:~forall...] 0.001 secs (0.u,0.001s)
Chars 9268 - 9274 [Proof.] 0. secs (0.u,0.s)
Chars 18090 - 18099 [(intros~x).] 40.176 secs (0.u,0.035s)
Chars 18102 - 18157 [refine~(decidable_equiv~_~(hfi...] 0.185 secs (0.154u,0.029s)
Chars 18220 - 18275 [(refine~(detachable_image_fini...] 0.007 secs (0.005u,0.002s)
Chars 18278 - 18279 [-] 0. secs (0.u,0.s)
Chars 18280 - 18309 [(apply~(mapinO_pr1~(Tr~(-~1)))).] 0.016 secs (0.013u,0.002s)
Chars 18090 - 18099 [(intros~x).] 0. secs (0.u,0.s)
Chars 18102 - 18157 [refine~(decidable_equiv~_~(hfi...] 0. secs (0.u,0.s)
Chars 18220 - 18275 [(refine~(detachable_image_fini...] 0. secs (0.u,0.s)
Chars 18280 - 18309 [(apply~(mapinO_pr1~(Tr~(-~1)))).] 0. secs (0.u,0.s)
Chars 18345 - 18353 [Defined.] 0.001 secs (0.001u,0.s)
Chars 18461 - 18488 [Section~DecidableQuotients.] 0. secs (0.u,0.s)
Chars 18491 - 18689 [Context~`{Univalence}~{X}~`{Fi...] 0.001 secs (0.001u,0.s)
Chars 18693 - 18747 [#[global]Instance~finite_quoti...] 0. secs (0.u,0.s)
Chars 18750 - 18756 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 9275 - 9284 [(intros~x).] 40.187 secs (0.001u,0.042s)
Chars 9285 - 9304 [(rewrite~<-~Qabs_neg).] 0.001 secs (0.001u,0.s)
Chars 9305 - 9323 [(apply~Qabs_le_raw).] 0.001 secs (0.001u,0.s)
Chars 9275 - 9284 [(intros~x).] 0. secs (0.u,0.s)
Chars 9285 - 9304 [(rewrite~<-~Qabs_neg).] 0. secs (0.u,0.s)
Chars 9305 - 9323 [(apply~Qabs_le_raw).] 0. secs (0.u,0.s)
Chars 9324 - 9328 [Qed.] 0. secs (0.u,0.s)
Chars 9330 - 9403 [Lemma~Q_abs_le_pr@{}~:~forall~...] 0.002 secs (0.002u,0.s)
Chars 9404 - 9410 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 18761 - 18794 [(pose~proof~(merely_equiv_fin~...] 40.138 secs (0.u,0.036s)
Chars 18799 - 18817 [strip_truncations.] 0.08 secs (0.073u,0.007s)
Chars 18822 - 18859 [(pose~(R'~:=~fun~x~=>~fun~y~=>...] 0.005 secs (0.004u,0.001s)
Chars 18864 - 18906 [(assert~(is_mere_relation~_~R'...] 0.006 secs (0.005u,0.001s)
Chars 18911 - 18977 [(assert~(Reflexive~R')~by~(int...] 0.001 secs (0.001u,0.s)
Chars 18982 - 19047 [(assert~(Symmetric~R')~by~(int...] 0.001 secs (0.001u,0.s)
Chars 19052 - 19124 [(assert~(Transitive~R')~by~(in...] 0.001 secs (0.001u,0.s)
Chars 19129 - 19218 [(assert~(R'd~:~forall~x~y,~Dec...] 0.001 secs (0.001u,0.s)
Chars 19223 - 19288 [srefine~(finite_equiv'~_~(equi...] 0.021 secs (0.014u,0.006s)
Chars 19293 - 19319 [1:~by~try~(intros;~split).] 0.002 secs (0.002u,0.s)
Chars 19324 - 19346 [(clearbody~R';~clear~e).] 0.001 secs (0.u,0.s)
Chars 19351 - 19443 [(generalize~dependent~(fcard~X...] 0.004 secs (0.004u,0.s)
Chars 19448 - 19449 [-] 0. secs (0.u,0.s)
Chars 19450 - 19485 [refine~(finite_equiv~Empty~_^-...] 0.004 secs (0.004u,0.s)
Chars 19492 - 19561 [refine~(Quotient_rec~R'~_~Empt...] 0.004 secs (0.004u,0.s)
Chars 19566 - 19567 [-] 0. secs (0.u,0.s)
Chars 19568 - 19605 [(pose~(R''~:=~fun~x~=>~fun~y~=...] 0.005 secs (0.005u,0.s)
Chars 19612 - 19655 [(assert~(is_mere_relation~_~R'...] 0.008 secs (0.007u,0.s)
Chars 19662 - 19730 [(assert~(Reflexive~R'')~by~(in...] 0.002 secs (0.001u,0.001s)
Chars 19737 - 19804 [(assert~(Symmetric~R'')~by~(in...] 0.002 secs (0.002u,0.s)
Chars 19811 - 19885 [(assert~(Transitive~R'')~by~(i...] 0.002 secs (0.001u,0.s)
Chars 19892 - 19972 [(assert~(forall~x~y,~Decidable...] 0.002 secs (0.002u,0.s)
Chars 19979 - 20087 [(pose~proof~((fun~x~y~=>~idmap...] 0.002 secs (0.002u,0.s)
Chars 20094 - 20160 [(destruct~(dec~(merely~{x~:~Fi...] 0.043 secs (0.039u,0.003s)
Chars 20167 - 20168 [{] 0. secs (0.u,0.s)
Chars 20169 - 20187 [strip_truncations.] 0.266 secs (0.257u,0.008s)
Chars 20196 - 20216 [(destruct~p~as~[x~r]).] 0.001 secs (0.001u,0.s)
Chars 20225 - 20267 [refine~(finite_equiv'~(Quotien...] 0.02 secs (0.02u,0.s)
Chars 20276 - 20341 [refine~(Build_Equiv~_~_~(Quoti...] 0.024 secs (0.024u,0.s)
Chars 20350 - 20373 [(apply~isequiv_surj_emb).] 0.001 secs (0.001u,0.s)
Chars 20382 - 20383 [-] 0. secs (0.u,0.s)
Chars 20384 - 20408 [(apply~BuildIsSurjection).] 0.001 secs (0.001u,0.s)
Chars 20419 - 20454 [refine~(Quotient_ind_hprop~R'~...] 0.009 secs (0.009u,0.s)
Chars 20465 - 20489 [(intros~[y|~[]];~apply~tr).] 0.006 secs (0.006u,0.s)
Chars 20500 - 20501 [+] 0. secs (0.u,0.s)
Chars 20502 - 20539 [(exists~(class_of~R''~y);~refl...] 0.003 secs (0.003u,0.s)
Chars 20550 - 20551 [+] 0. secs (0.u,0.s)
Chars 20552 - 20583 [(exists~(class_of~R''~x);~simpl).] 0.003 secs (0.003u,0.s)
Chars 20596 - 20611 [(apply~qglue,~r).] 0.002 secs (0.002u,0.s)
Chars 20620 - 20621 [-] 0. secs (0.u,0.s)
Chars 20622 - 20661 [(apply~isembedding_isinj_hset;...] 0.006 secs (0.005u,0.s)
Chars 20672 - 20718 [(refine~(Quotient_ind_hprop~R'...] 0.025 secs (0.025u,0.s)
Chars 20729 - 20785 [(revert~u;~refine~(Quotient_in...] 0.027 secs (0.027u,0.s)
Chars 20796 - 20812 [(simpl;~intros~q).] 0.003 secs (0.003u,0.s)
Chars 20823 - 20847 [(apply~qglue;~unfold~R'').] 0.003 secs (0.003u,0.s)
Chars 20858 - 20910 [exact~(related_quotient_paths~...] 0.004 secs (0.004u,0.s)
Chars 20911 - 20912 [}] 0. secs (0.u,0.s)
Chars 20919 - 20920 [{] 0. secs (0.u,0.s)
Chars 20921 - 20970 [refine~(finite_equiv'~(Quotien...] 0.021 secs (0.021u,0.s)
Chars 20979 - 21189 [refine~~(Build_Equiv~_~_~~~~~(...] 0.018 secs (0.018u,0.s)
Chars 21198 - 21221 [(apply~isequiv_surj_emb).] 0.002 secs (0.002u,0.s)
Chars 21230 - 21231 [-] 0. secs (0.u,0.s)
Chars 21232 - 21256 [(apply~BuildIsSurjection).] 0.002 secs (0.001u,0.s)
Chars 21267 - 21302 [refine~(Quotient_ind_hprop~R'~...] 0.01 secs (0.01u,0.s)
Chars 21313 - 21337 [(intros~[y|~[]];~apply~tr).] 0.008 secs (0.008u,0.s)
Chars 21348 - 21349 [+] 0. secs (0.u,0.s)
Chars 21350 - 21393 [(exists~(inl~(class_of~R''~y))...] 0.004 secs (0.004u,0.s)
Chars 21404 - 21405 [+] 0. secs (0.u,0.s)
Chars 21406 - 21435 [(exists~(inr~tt);~reflexivity).] 0.004 secs (0.004u,0.s)
Chars 21444 - 21445 [-] 0. secs (0.u,0.s)
Chars 21446 - 21485 [(apply~isembedding_isinj_hset;...] 0.004 secs (0.004u,0.s)
Chars 21496 - 21519 [refine~(sum_ind~_~_~_).] 0.002 secs (0.002u,0.s)
Chars 21530 - 21531 [+] 0. secs (0.u,0.s)
Chars 21532 - 21578 [(refine~(Quotient_ind_hprop~R'...] 0.051 secs (0.051u,0.s)
Chars 21591 - 21624 [(revert~u;~refine~(sum_ind~_~_...] 0.004 secs (0.004u,0.s)
Chars 21637 - 21638 [*] 0. secs (0.u,0.s)
Chars 21639 - 21685 [(refine~(Quotient_ind_hprop~R'...] 0.056 secs (0.056u,0.s)
Chars 21700 - 21716 [(simpl;~intros~q).] 0.003 secs (0.003u,0.s)
Chars 21731 - 21759 [(apply~ap,~qglue;~unfold~R'').] 0.004 secs (0.004u,0.s)
Chars 21774 - 21826 [exact~(related_quotient_paths~...] 0.004 secs (0.004u,0.s)
Chars 21839 - 21840 [*] 0. secs (0.u,0.s)
Chars 21841 - 21858 [(intros~[];~simpl).] 0.006 secs (0.006u,0.s)
Chars 21873 - 21882 [(intros~q).] 0.001 secs (0.001u,0.s)
Chars 21897 - 21944 [(apply~related_quotient_paths~...] 0.01 secs (0.01u,0.s)
Chars 21959 - 21979 [(apply~symmetry~in~q).] 0.002 secs (0.002u,0.s)
Chars 21994 - 22017 [(elim~(np~(tr~(v;~q)))).] 0.003 secs (0.003u,0.s)
Chars 22028 - 22029 [+] 0. secs (0.u,0.s)
Chars 22030 - 22047 [(intros~[];~simpl).] 0.006 secs (0.006u,0.s)
Chars 22060 - 22088 [(destruct~u~as~[u|~[]];~simpl).] 0.009 secs (0.009u,0.s)
Chars 22101 - 22102 [*] 0. secs (0.u,0.s)
Chars 22103 - 22166 [(revert~u;~refine~(Quotient_in...] 0.054 secs (0.053u,0.s)
Chars 22181 - 22190 [(intros~q).] 0.001 secs (0.001u,0.s)
Chars 22205 - 22252 [(apply~related_quotient_paths~...] 0.01 secs (0.01u,0.s)
Chars 22267 - 22288 [(elim~(np~(tr~(u;~q)))).] 0.003 secs (0.003u,0.s)
Chars 22301 - 22302 [*] 0. secs (0.u,0.s)
Chars 22303 - 22323 [(intros;~reflexivity).] 0.003 secs (0.003u,0.s)
Chars 22324 - 22325 [}] 0. secs (0.u,0.s)
Chars 18761 - 18794 [(pose~proof~(merely_equiv_fin~...] 0. secs (0.u,0.s)
Chars 18799 - 18817 [strip_truncations.] 0. secs (0.u,0.s)
Chars 18822 - 18859 [(pose~(R'~:=~fun~x~=>~fun~y~=>...] 0. secs (0.u,0.s)
Chars 18864 - 18906 [(assert~(is_mere_relation~_~R'...] 0. secs (0.u,0.s)
Chars 18911 - 18977 [(assert~(Reflexive~R')~by~(int...] 0. secs (0.u,0.s)
Chars 18982 - 19047 [(assert~(Symmetric~R')~by~(int...] 0. secs (0.u,0.s)
Chars 19052 - 19124 [(assert~(Transitive~R')~by~(in...] 0. secs (0.u,0.s)
Chars 19129 - 19218 [(assert~(R'd~:~forall~x~y,~Dec...] 0. secs (0.u,0.s)
Chars 19223 - 19288 [srefine~(finite_equiv'~_~(equi...] 0. secs (0.u,0.s)
Chars 19293 - 19319 [1:~by~try~(intros;~split).] 0. secs (0.u,0.s)
Chars 19324 - 19346 [(clearbody~R';~clear~e).] 0. secs (0.u,0.s)
Chars 19351 - 19443 [(generalize~dependent~(fcard~X...] 0.001 secs (0.001u,0.s)
Chars 19450 - 19485 [refine~(finite_equiv~Empty~_^-...] 0. secs (0.u,0.s)
Chars 19492 - 19561 [refine~(Quotient_rec~R'~_~Empt...] 0. secs (0.u,0.s)
Chars 19568 - 19605 [(pose~(R''~:=~fun~x~=>~fun~y~=...] 0. secs (0.u,0.s)
Chars 19612 - 19655 [(assert~(is_mere_relation~_~R'...] 0. secs (0.u,0.s)
Chars 19662 - 19730 [(assert~(Reflexive~R'')~by~(in...] 0. secs (0.u,0.s)
Chars 19737 - 19804 [(assert~(Symmetric~R'')~by~(in...] 0. secs (0.u,0.s)
Chars 19811 - 19885 [(assert~(Transitive~R'')~by~(i...] 0. secs (0.u,0.s)
Chars 19892 - 19972 [(assert~(forall~x~y,~Decidable...] 0. secs (0.u,0.s)
Chars 19979 - 20087 [(pose~proof~((fun~x~y~=>~idmap...] 0. secs (0.u,0.s)
Chars 20094 - 20160 [(destruct~(dec~(merely~{x~:~Fi...] 0. secs (0.u,0.s)
Chars 20169 - 20187 [strip_truncations.] 0.001 secs (0.001u,0.s)
Chars 20196 - 20216 [(destruct~p~as~[x~r]).] 0. secs (0.u,0.s)
Chars 20225 - 20267 [refine~(finite_equiv'~(Quotien...] 0. secs (0.u,0.s)
Chars 20276 - 20341 [refine~(Build_Equiv~_~_~(Quoti...] 0. secs (0.u,0.s)
Chars 20350 - 20373 [(apply~isequiv_surj_emb).] 0.001 secs (0.001u,0.s)
Chars 20384 - 20408 [(apply~BuildIsSurjection).] 0.001 secs (0.001u,0.s)
Chars 20419 - 20454 [refine~(Quotient_ind_hprop~R'~...] 0.001 secs (0.001u,0.s)
Chars 20465 - 20489 [(intros~[y|~[]];~apply~tr).] 0.003 secs (0.003u,0.s)
Chars 20502 - 20539 [(exists~(class_of~R''~y);~refl...] 0.002 secs (0.002u,0.s)
Chars 20552 - 20583 [(exists~(class_of~R''~x);~simpl).] 0.002 secs (0.002u,0.s)
Chars 20596 - 20611 [(apply~qglue,~r).] 0.001 secs (0.001u,0.s)
Chars 20622 - 20661 [(apply~isembedding_isinj_hset;...] 0.002 secs (0.002u,0.s)
Chars 20672 - 20718 [(refine~(Quotient_ind_hprop~R'...] 0.002 secs (0.002u,0.s)
Chars 20729 - 20785 [(revert~u;~refine~(Quotient_in...] 0.003 secs (0.003u,0.s)
Chars 20796 - 20812 [(simpl;~intros~q).] 0.002 secs (0.002u,0.s)
Chars 20823 - 20847 [(apply~qglue;~unfold~R'').] 0.002 secs (0.002u,0.s)
Chars 20858 - 20910 [exact~(related_quotient_paths~...] 0.001 secs (0.001u,0.s)
Chars 20921 - 20970 [refine~(finite_equiv'~(Quotien...] 0.001 secs (0.001u,0.s)
Chars 20979 - 21189 [refine~~(Build_Equiv~_~_~~~~~(...] 0.001 secs (0.001u,0.s)
Chars 21198 - 21221 [(apply~isequiv_surj_emb).] 0.001 secs (0.001u,0.s)
Chars 21232 - 21256 [(apply~BuildIsSurjection).] 0.001 secs (0.001u,0.s)
Chars 21267 - 21302 [refine~(Quotient_ind_hprop~R'~...] 0.013 secs (0.011u,0.002s)
Chars 21313 - 21337 [(intros~[y|~[]];~apply~tr).] 0.004 secs (0.004u,0.s)
Chars 21350 - 21393 [(exists~(inl~(class_of~R''~y))...] 0.002 secs (0.002u,0.s)
Chars 21406 - 21435 [(exists~(inr~tt);~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 21446 - 21485 [(apply~isembedding_isinj_hset;...] 0.002 secs (0.002u,0.s)
Chars 21496 - 21519 [refine~(sum_ind~_~_~_).] 0.001 secs (0.001u,0.s)
Chars 21532 - 21578 [(refine~(Quotient_ind_hprop~R'...] 0.003 secs (0.003u,0.s)
Chars 21591 - 21624 [(revert~u;~refine~(sum_ind~_~_...] 0.003 secs (0.003u,0.s)
Chars 21639 - 21685 [(refine~(Quotient_ind_hprop~R'...] 0.003 secs (0.003u,0.s)
Chars 21700 - 21716 [(simpl;~intros~q).] 0.002 secs (0.002u,0.s)
Chars 21731 - 21759 [(apply~ap,~qglue;~unfold~R'').] 0.002 secs (0.002u,0.s)
Chars 21774 - 21826 [exact~(related_quotient_paths~...] 0.001 secs (0.001u,0.s)
Chars 21841 - 21858 [(intros~[];~simpl).] 0.003 secs (0.002u,0.s)
Chars 21873 - 21882 [(intros~q).] 0.001 secs (0.001u,0.s)
Chars 21897 - 21944 [(apply~related_quotient_paths~...] 0.005 secs (0.005u,0.s)
Chars 21959 - 21979 [(apply~symmetry~in~q).] 0.001 secs (0.001u,0.s)
Chars 21994 - 22017 [(elim~(np~(tr~(v;~q)))).] 0.001 secs (0.001u,0.s)
Chars 22030 - 22047 [(intros~[];~simpl).] 0.003 secs (0.003u,0.s)
Chars 22060 - 22088 [(destruct~u~as~[u|~[]];~simpl).] 0.004 secs (0.004u,0.s)
Chars 22103 - 22166 [(revert~u;~refine~(Quotient_in...] 0.005 secs (0.005u,0.s)
Chars 22181 - 22190 [(intros~q).] 0.001 secs (0.001u,0.s)
Chars 22205 - 22252 [(apply~related_quotient_paths~...] 0.005 secs (0.005u,0.s)
Chars 22267 - 22288 [(elim~(np~(tr~(u;~q)))).] 0.001 secs (0.001u,0.s)
Chars 22303 - 22323 [(intros;~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 22328 - 22336 [Defined.] 0.056 secs (0.055u,0.001s)
Chars 22443 - 22541 [Definition~fcard_quotient~:~~~...] 0.084 secs (0.084u,0.s)
Chars 22544 - 22550 [Proof.] 0. secs (0.u,0.s)
Chars 9411 - 9428 [(intros~x~y;~split).] 40.161 secs (0.002u,0.042s)
Chars 9429 - 9430 [-] 0. secs (0.u,0.s)
Chars 9431 - 9440 [(intros~E).] 0.001 secs (0.001u,0.s)
Chars 9441 - 9447 [split.] 0.001 secs (0.001u,0.s)
Chars 9450 - 9451 [+] 0. secs (0.u,0.s)
Chars 9452 - 9473 [(apply~flip_le_negate).] 0.016 secs (0.012u,0.003s)
Chars 9474 - 9493 [(rewrite~involutive).] 0.009 secs (0.008u,0.s)
Chars 9494 - 9523 [(transitivity~(abs~x);~trivial).] 0.072 secs (0.057u,0.015s)
Chars 9528 - 9550 [(apply~Qabs_le_neg_raw).] 0.001 secs (0.u,0.s)
Chars 9553 - 9554 [+] 0. secs (0.u,0.s)
Chars 9555 - 9584 [(transitivity~(abs~x);~trivial).] 0.059 secs (0.05u,0.009s)
Chars 9589 - 9607 [(apply~Qabs_le_raw).] 0.001 secs (0.001u,0.s)
Chars 9608 - 9609 [-] 0. secs (0.u,0.s)
Chars 9610 - 9625 [(intros~[E1~E2]).] 0.001 secs (0.001u,0.s)
Chars 9628 - 9690 [(destruct~(total_abs_either~x)...] 0.011 secs (0.01u,0.s)
Chars 9693 - 9694 [+] 0. secs (0.u,0.s)
Chars 9695 - 9703 [trivial.] 0.001 secs (0.001u,0.s)
Chars 9706 - 9707 [+] 0. secs (0.u,0.s)
Chars 9708 - 9756 [(apply~flip_le_negate;~rewrite...] 0.03 secs (0.026u,0.003s)
Chars 9411 - 9428 [(intros~x~y;~split).] 0.001 secs (0.001u,0.s)
Chars 9431 - 9440 [(intros~E).] 0. secs (0.u,0.s)
Chars 9441 - 9447 [split.] 0. secs (0.u,0.s)
Chars 9452 - 9473 [(apply~flip_le_negate).] 0. secs (0.u,0.s)
Chars 9474 - 9493 [(rewrite~involutive).] 0. secs (0.u,0.s)
Chars 9494 - 9523 [(transitivity~(abs~x);~trivial).] 0.002 secs (0.002u,0.s)
Chars 9528 - 9550 [(apply~Qabs_le_neg_raw).] 0. secs (0.u,0.s)
Chars 9555 - 9584 [(transitivity~(abs~x);~trivial).] 0.002 secs (0.001u,0.s)
Chars 9589 - 9607 [(apply~Qabs_le_raw).] 0. secs (0.u,0.s)
Chars 9610 - 9625 [(intros~[E1~E2]).] 0. secs (0.u,0.s)
Chars 9628 - 9690 [(destruct~(total_abs_either~x)...] 0.002 secs (0.002u,0.s)
Chars 9695 - 9703 [trivial.] 0. secs (0.u,0.s)
Chars 9708 - 9756 [(apply~flip_le_negate;~rewrite...] 0.002 secs (0.002u,0.s)
Chars 9757 - 9761 [Qed.] 0.004 secs (0.003u,0.s)
Chars 9763 - 9822 [Lemma~Qabs_is_join@{}~:~forall...] 0.001 secs (0.001u,0.s)
Chars 9823 - 9829 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 22555 - 22594 [refine~(fcard_domain~(class_of...] 40.172 secs (0.005u,0.027s)
Chars 22599 - 22640 [(apply~ap,~path_arrow;~intros~...] 0.006 secs (0.005u,0.s)
Chars 22645 - 22696 [(refine~(Quotient_ind_hprop~_~...] 0.023 secs (0.019u,0.003s)
Chars 22701 - 22735 [(apply~fcard_equiv';~unfold~hf...] 0.002 secs (0.002u,0.s)
Chars 22740 - 22791 [(refine~(equiv_functor_sigma_i...] 0.002 secs (0.002u,0.s)
Chars 22796 - 22805 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 22810 - 22844 [refine~(path_quotient~R~y~x~oE...] 0.002 secs (0.002u,0.s)
Chars 22849 - 22887 [(apply~equiv_iff_hprop;~apply~...] 0.003 secs (0.003u,0.s)
Chars 22555 - 22594 [refine~(fcard_domain~(class_of...] 0. secs (0.u,0.s)
Chars 22599 - 22640 [(apply~ap,~path_arrow;~intros~...] 0.002 secs (0.002u,0.s)
Chars 22645 - 22696 [(refine~(Quotient_ind_hprop~_~...] 0.002 secs (0.002u,0.s)
Chars 22701 - 22735 [(apply~fcard_equiv';~unfold~hf...] 0.022 secs (0.012u,0.009s)
Chars 22740 - 22791 [(refine~(equiv_functor_sigma_i...] 0.001 secs (0.001u,0.s)
Chars 22796 - 22805 [symmetry.] 0. secs (0.u,0.s)
Chars 22810 - 22844 [refine~(path_quotient~R~y~x~oE...] 0. secs (0.u,0.s)
Chars 22849 - 22887 [(apply~equiv_iff_hprop;~apply~...] 0.001 secs (0.001u,0.s)
Chars 22890 - 22898 [Defined.] 0.008 secs (0.008u,0.s)
Chars 22900 - 22923 [End~DecidableQuotients.] 0.346 secs (0.322u,0.022s)
Chars 23038 - 23177 [Definition~leq_inj_finite~`{Fu...] 0.001 secs (0.001u,0.s)
Chars 23178 - 23184 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 9830 - 9839 [(intros~q).] 40.181 secs (0.001u,0.042s)
Chars 9840 - 9849 [symmetry.] 0.002 secs (0.001u,0.s)
Chars 9850 - 9912 [(destruct~(total_abs_either~q)...] 0.011 secs (0.011u,0.s)
Chars 9913 - 9914 [-] 0. secs (0.u,0.s)
Chars 9915 - 9928 [(apply~join_r).] 0.003 secs (0.003u,0.s)
Chars 9929 - 9956 [(transitivity~(0~:~Q);~trivial).] 0.072 secs (0.057u,0.014s)
Chars 9959 - 9992 [(apply~flip_nonneg_negate;~tri...] 0.019 secs (0.014u,0.005s)
Chars 9993 - 9994 [-] 0. secs (0.u,0.s)
Chars 9995 - 10008 [(apply~join_l).] 0.003 secs (0.002u,0.s)
Chars 10009 - 10036 [(transitivity~(0~:~Q);~trivial).] 0.063 secs (0.052u,0.011s)
Chars 10039 - 10072 [(apply~flip_nonpos_negate;~tri...] 0.018 secs (0.017u,0.s)
Chars 9830 - 9839 [(intros~q).] 0. secs (0.u,0.s)
Chars 9840 - 9849 [symmetry.] 0. secs (0.u,0.s)
Chars 9850 - 9912 [(destruct~(total_abs_either~q)...] 0.002 secs (0.002u,0.s)
Chars 9915 - 9928 [(apply~join_r).] 0. secs (0.u,0.s)
Chars 9929 - 9956 [(transitivity~(0~:~Q);~trivial).] 0.002 secs (0.002u,0.s)
Chars 9959 - 9992 [(apply~flip_nonneg_negate;~tri...] 0.001 secs (0.u,0.s)
Chars 9995 - 10008 [(apply~join_l).] 0. secs (0.u,0.s)
Chars 10009 - 10036 [(transitivity~(0~:~Q);~trivial).] 0.002 secs (0.u,0.001s)
Chars 10039 - 10072 [(apply~flip_nonpos_negate;~tri...] 0.001 secs (0.001u,0.s)
Chars 10073 - 10077 [Qed.] 0.003 secs (0.002u,0.s)
Chars 10079 - 10147 [Lemma~Qlt_join~:~forall~a~b~c~...] 0.001 secs (0.001u,0.s)
Chars 10148 - 10154 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutMore readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector 0)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
More readable: initial segment:
(register_vector n)
With remainder:
[]%list
Chars 23187 - 23225 [(assert~(MapIn~(Tr~(-~1))~f)~b...] 40.187 secs (0.002u,0.036s)
Chars 23226 - 23234 [clear~i.] 0. secs (0.u,0.s)
Chars 23237 - 23265 [(destruct~fX~as~[n~e];~simpl).] 0.001 secs (0.u,0.s)
Chars 23268 - 23297 [(destruct~fY~as~[m~e'];~simpl).] 0.001 secs (0.001u,0.s)
Chars 23300 - 23318 [strip_truncations.] 0.129 secs (0.11u,0.018s)
Chars 23321 - 23347 [(pose~(g~:=~e'~o~f~o~e^-1)).] 0.005 secs (0.005u,0.s)
Chars 23350 - 23400 [(assert~(MapIn~(Tr~(-~1))~g)~b...] 0.135 secs (0.119u,0.015s)
Chars 23403 - 23415 [clearbody~g.] 0. secs (0.u,0.s)
Chars 23416 - 23427 [clear~e~e'.] 0. secs (0.u,0.s)
Chars 23428 - 23451 [generalize~dependent~m.] 0. secs (0.u,0.s)
Chars 23454 - 23478 [(induction~n~as~[|~n~IHn]).] 0.001 secs (0.u,0.s)
Chars 23481 - 23492 [1:~exact~_.] 0.002 secs (0.001u,0.s)
Chars 23495 - 23508 [(intros~m~g~?).] 0. secs (0.u,0.s)
Chars 23511 - 23568 [(assert~(i~:~isinj~g)~by~(appl...] 0.003 secs (0.003u,0.s)
Chars 23571 - 23590 [(destruct~m~as~[|~m]).] 0.002 secs (0.002u,0.s)
Chars 23593 - 23594 [{] 0. secs (0.u,0.s)
Chars 23595 - 23613 [(elim~(g~(inr~tt))).] 0.002 secs (0.002u,0.s)
Chars 23614 - 23615 [}] 0. secs (0.u,0.s)
Chars 23618 - 23678 [(pose~(h~:=~(fin_transpose_las...] 0.013 secs (0.011u,0.002s)
Chars 23681 - 23731 [(assert~(MapIn~(Tr~(-~1))~h)~b...] 0.117 secs (0.104u,0.012s)
Chars 23734 - 23783 [(assert~(Ha~:~forall~a~:~Fin~n...] 0.002 secs (0.002u,0.s)
Chars 23786 - 23787 [{] 0. secs (0.u,0.s)
Chars 23788 - 23797 [(intros~a).] 0.001 secs (0.001u,0.s)
Chars 23802 - 23834 [remember~(g~(inl~a))~as~b~eqn:~p.] 0.003 secs (0.003u,0.s)
Chars 23839 - 23860 [(destruct~b~as~[b|~[]]).] 0.003 secs (0.003u,0.s)
Chars 23865 - 23866 [-] 0. secs (0.u,0.s)
Chars 23867 - 23906 [(assert~(q~:~g~(inl~a)~<>~g~(i...] 0.003 secs (0.003u,0.s)
Chars 23913 - 23914 [{] 0. secs (0.u,0.s)
Chars 23915 - 23924 [(intros~r).] 0.001 secs (0.001u,0.s)
Chars 23925 - 23958 [exact~(inl_ne_inr~_~_~(i~_~_~r)).] 0.002 secs (0.002u,0.s)
Chars 23959 - 23960 [}] 0. secs (0.u,0.s)
Chars 23967 - 24008 [(rewrite~p~in~q;~apply~symmetr...] 0.004 secs (0.004u,0.s)
Chars 24015 - 24046 [(assert~(r~:~h~(inl~a)~=~inl~b)).] 0.003 secs (0.003u,0.s)
Chars 24053 - 24054 [{] 0. secs (0.u,0.s)
Chars 24055 - 24095 [(unfold~h;~apply~moveR_equiv_V...] 0.007 secs (0.007u,0.s)
Chars 24104 - 24166 [refine~(fin_transpose_last_wit...] 0.003 secs (0.003u,0.s)
Chars 24167 - 24168 [}] 0. secs (0.u,0.s)
Chars 24175 - 24195 [(rewrite~r;~exact~tt).] 0.004 secs (0.004u,0.s)
Chars 24200 - 24201 [-] 0. secs (0.u,0.s)
Chars 24202 - 24238 [(assert~(q~:~h~(inl~a)~=~g~(in...] 0.003 secs (0.003u,0.s)
Chars 24245 - 24246 [{] 0. secs (0.u,0.s)
Chars 24247 - 24287 [(unfold~h;~apply~moveR_equiv_V...] 0.007 secs (0.007u,0.s)
Chars 24296 - 24348 [(refine~(_~@~p^);~apply~fin_tr...] 0.004 secs (0.004u,0.s)
Chars 24349 - 24350 [}] 0. secs (0.u,0.s)
Chars 24357 - 24367 [(rewrite~q).] 0.002 secs (0.002u,0.s)
Chars 24374 - 24440 [(destruct~(is_inl_or_is_inr~(g...] 0.007 secs (0.007u,0.s)
Chars 24447 - 24476 [(pose~proof~(inr_un_inr~_~r)~a...] 0.002 secs (0.002u,0.s)
Chars 24483 - 24541 [(revert~s;~generalize~(un_inr~...] 0.008 secs (0.008u,0.s)
Chars 24548 - 24586 [(elim~(inl_ne_inr~_~_~(i~_~_~(...] 0.004 secs (0.004u,0.s)
Chars 24587 - 24588 [}] 0. secs (0.u,0.s)
Chars 24591 - 24639 [(assert~(Hb~:~forall~b~:~Unit,...] 0.002 secs (0.002u,0.s)
Chars 24642 - 24643 [{] 0. secs (0.u,0.s)
Chars 24644 - 24654 [(intros~[]).] 0.001 secs (0.001u,0.s)
Chars 24659 - 24692 [(assert~(q~:~h~(inr~tt)~=~inr~...] 0.003 secs (0.003u,0.s)
Chars 24697 - 24698 [{] 0. secs (0.u,0.s)
Chars 24699 - 24739 [(unfold~h;~apply~moveR_equiv_V...] 0.007 secs (0.007u,0.s)
Chars 24746 - 24781 [(apply~fin_transpose_last_with...] 0.002 secs (0.002u,0.s)
Chars 24782 - 24783 [}] 0. secs (0.u,0.s)
Chars 24788 - 24808 [(rewrite~q;~exact~tt).] 0.004 secs (0.004u,0.s)
Chars 24809 - 24810 [}] 0. secs (0.u,0.s)
Chars 24813 - 24828 [(apply~leq_S_n').] 0.001 secs (0.001u,0.s)
Chars 24831 - 24924 [exact~~(IHn~m~(unfunctor_sum_l...] 0.005 secs (0.005u,0.s)
Chars 23187 - 23225 [(assert~(MapIn~(Tr~(-~1))~f)~b...] 0. secs (0.u,0.s)
Chars 23226 - 23234 [clear~i.] 0. secs (0.u,0.s)
Chars 23237 - 23265 [(destruct~fX~as~[n~e];~simpl).] 0. secs (0.u,0.s)
Chars 23268 - 23297 [(destruct~fY~as~[m~e'];~simpl).] 0. secs (0.u,0.s)
Chars 23300 - 23318 [strip_truncations.] 0. secs (0.u,0.s)
Chars 23321 - 23347 [(pose~(g~:=~e'~o~f~o~e^-1)).] 0. secs (0.u,0.s)
Chars 23350 - 23400 [(assert~(MapIn~(Tr~(-~1))~g)~b...] 0. secs (0.u,0.s)
Chars 23403 - 23415 [clearbody~g.] 0. secs (0.u,0.s)
Chars 23416 - 23427 [clear~e~e'.] 0. secs (0.u,0.s)
Chars 23428 - 23451 [generalize~dependent~m.] 0. secs (0.u,0.s)
Chars 23454 - 23478 [(induction~n~as~[|~n~IHn]).] 0. secs (0.u,0.s)
Chars 23481 - 23492 [1:~exact~_.] 0. secs (0.u,0.s)
Chars 23495 - 23508 [(intros~m~g~?).] 0. secs (0.u,0.s)
Chars 23511 - 23568 [(assert~(i~:~isinj~g)~by~(appl...] 0. secs (0.u,0.s)
Chars 23571 - 23590 [(destruct~m~as~[|~m]).] 0. secs (0.u,0.s)
Chars 23595 - 23613 [(elim~(g~(inr~tt))).] 0. secs (0.u,0.s)
Chars 23618 - 23678 [(pose~(h~:=~(fin_transpose_las...] 0. secs (0.u,0.s)
Chars 23681 - 23731 [(assert~(MapIn~(Tr~(-~1))~h)~b...] 0. secs (0.u,0.s)
Chars 23734 - 23783 [(assert~(Ha~:~forall~a~:~Fin~n...] 0. secs (0.u,0.s)
Chars 23788 - 23797 [(intros~a).] 0.001 secs (0.001u,0.s)
Chars 23802 - 23834 [remember~(g~(inl~a))~as~b~eqn:~p.] 0.001 secs (0.001u,0.s)
Chars 23839 - 23860 [(destruct~b~as~[b|~[]]).] 0.001 secs (0.001u,0.s)
Chars 23867 - 23906 [(assert~(q~:~g~(inl~a)~<>~g~(i...] 0.001 secs (0.001u,0.s)
Chars 23915 - 23924 [(intros~r).] 0.001 secs (0.001u,0.s)
Chars 23925 - 23958 [exact~(inl_ne_inr~_~_~(i~_~_~r)).] 0.001 secs (0.001u,0.s)
Chars 23967 - 24008 [(rewrite~p~in~q;~apply~symmetr...] 0.002 secs (0.002u,0.s)
Chars 24015 - 24046 [(assert~(r~:~h~(inl~a)~=~inl~b)).] 0.001 secs (0.001u,0.s)
Chars 24055 - 24095 [(unfold~h;~apply~moveR_equiv_V...] 0.004 secs (0.004u,0.s)
Chars 24104 - 24166 [refine~(fin_transpose_last_wit...] 0.001 secs (0.001u,0.s)
Chars 24175 - 24195 [(rewrite~r;~exact~tt).] 0.002 secs (0.002u,0.s)
Chars 24202 - 24238 [(assert~(q~:~h~(inl~a)~=~g~(in...] 0.001 secs (0.001u,0.s)
Chars 24247 - 24287 [(unfold~h;~apply~moveR_equiv_V...] 0.004 secs (0.003u,0.s)
Chars 24296 - 24348 [(refine~(_~@~p^);~apply~fin_tr...] 0.002 secs (0.002u,0.s)
Chars 24357 - 24367 [(rewrite~q).] 0.001 secs (0.001u,0.s)
Chars 24374 - 24440 [(destruct~(is_inl_or_is_inr~(g...] 0.002 secs (0.002u,0.s)
Chars 24447 - 24476 [(pose~proof~(inr_un_inr~_~r)~a...] 0.001 secs (0.001u,0.s)
Chars 24483 - 24541 [(revert~s;~generalize~(un_inr~...] 0.005 secs (0.005u,0.s)
Chars 24548 - 24586 [(elim~(inl_ne_inr~_~_~(i~_~_~(...] 0.001 secs (0.001u,0.s)
Chars 24591 - 24639 [(assert~(Hb~:~forall~b~:~Unit,...] 0.001 secs (0.001u,0.s)
Chars 24644 - 24654 [(intros~[]).] 0.001 secs (0.001u,0.s)
Chars 24659 - 24692 [(assert~(q~:~h~(inr~tt)~=~inr~...] 0.001 secs (0.001u,0.s)
Chars 24699 - 24739 [(unfold~h;~apply~moveR_equiv_V...] 0.003 secs (0.003u,0.s)
Chars 24746 - 24781 [(apply~fin_transpose_last_with...] 0.001 secs (0.001u,0.s)
Chars 24788 - 24808 [(rewrite~q;~exact~tt).] 0.002 secs (0.002u,0.s)
Chars 24813 - 24828 [(apply~leq_S_n').] 0.001 secs (0.u,0.s)
Chars 24831 - 24924 [exact~~(IHn~m~(unfunctor_sum_l...] 0.001 secs (0.001u,0.s)
Chars 24925 - 24929 [Qed.] 0.033 secs (0.032u,0.s)
Chars 25031 - 25051 [Section~Enumeration.] 0. secs (0.u,0.s)
Chars 25054 - 25113 [Context~`{Funext}~{X}~`{Finite...] 0. secs (0.u,0.s)
Chars 25117 - 25179 [Let~er~(n~:~nat)~:~Fin~n~->~X~...] 0. secs (0.u,0.s)
Chars 25183 - 25299 [Lemma~finite_enumeration_stage...] 0. secs (0.u,0.s)
Chars 25302 - 25308 [Proof.] 0. secs (0.u,0.s)
Chars 10155 - 10174 [(intros~a~b~c~E1~E2).] 40.194 secs (0.001u,0.043s)
Chars 10175 - 10261 [(destruct~(total~le~a~b)~as~[E...] 0.02 secs (0.018u,0.001s)
Chars 10155 - 10174 [(intros~a~b~c~E1~E2).] 0. secs (0.u,0.s)
Chars 10175 - 10261 [(destruct~(total~le~a~b)~as~[E...] 0.003 secs (0.003u,0.s)
Chars 10262 - 10266 [Qed.] 0.001 secs (0.001u,0.s)
Chars 10268 - 10342 [Lemma~Q_average_between@{}~:~f...] 0.006 secs (0.006u,0.s)
Chars 10343 - 10349 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 25313 - 25341 [(induction~n~as~[|~n~[IH|~IH]]).] 40.184 secs (0.003u,0.035s)
Chars 25346 - 25347 [-] 0. secs (0.u,0.s)
Chars 25348 - 25353 [left.] 0.001 secs (0.001u,0.s)
Chars 25354 - 25363 [(intros~x).] 0. secs (0.u,0.s)
Chars 25370 - 25413 [(apply~hprop_inhabited_contr;~...] 0.002 secs (0.001u,0.001s)
Chars 25418 - 25419 [-] 0. secs (0.u,0.s)
Chars 25420 - 25503 [(destruct~(detachable_image_fi...] 0.008 secs (0.007u,0.001s)
Chars 25510 - 25511 [+] 0. secs (0.u,0.s)
Chars 25512 - 25518 [right.] 0.001 secs (0.001u,0.s)
Chars 25527 - 25548 [exists~(nat_fin~n~k).] 0.001 secs (0.001u,0.s)
Chars 25557 - 25584 [exists~(nat_fin_compl~n~k).] 0.001 secs (0.001u,0.s)
Chars 25593 - 25621 [(rewrite~nat_fin_compl_compl).] 0.002 secs (0.002u,0.s)
Chars 25630 - 25638 [exact~p.] 0.001 secs (0.001u,0.s)
Chars 25645 - 25646 [+] 0. secs (0.u,0.s)
Chars 25647 - 25652 [left.] 0.001 secs (0.001u,0.s)
Chars 25653 - 25662 [(intros~x).] 0.001 secs (0.001u,0.s)
Chars 25671 - 25691 [(apply~hprop_allpath).] 0.001 secs (0.001u,0.s)
Chars 25700 - 25711 [(intros~k~l).] 0.001 secs (0.u,0.001s)
Chars 25720 - 25743 [(apply~path_sigma_hprop).] 0.044 secs (0.035u,0.008s)
Chars 25752 - 25801 [(destruct~k~as~[[k|~[]]~p],~l~...] 0.015 secs (0.015u,0.s)
Chars 25810 - 25811 [*] 0. secs (0.u,0.s)
Chars 25812 - 25840 [(apply~isinj_embedding~in~IH).] 0.001 secs (0.001u,0.s)
Chars 25851 - 25860 [(apply~ap).] 0.001 secs (0.u,0.s)
Chars 25871 - 25880 [(apply~IH).] 0.001 secs (0.001u,0.s)
Chars 25891 - 25909 [(unfold~er~in~p,~q).] 0.001 secs (0.001u,0.s)
Chars 25910 - 25924 [(simpl~in~p,~q).] 0.001 secs (0.001u,0.s)
Chars 25935 - 25950 [exact~(p~@~q^).] 0.001 secs (0.001u,0.s)
Chars 25959 - 25960 [*] 0. secs (0.u,0.s)
Chars 25961 - 25987 [refine~(Empty_rec~(ne~_)).] 0.001 secs (0.001u,0.s)
Chars 25998 - 26007 [exists~k.] 0.001 secs (0.001u,0.s)
Chars 26018 - 26033 [exact~(p~@~q^).] 0.002 secs (0.002u,0.s)
Chars 26042 - 26043 [*] 0. secs (0.u,0.s)
Chars 26044 - 26070 [refine~(Empty_rec~(ne~_)).] 0.001 secs (0.001u,0.s)
Chars 26081 - 26090 [exists~l.] 0.001 secs (0.001u,0.s)
Chars 26101 - 26116 [exact~(q~@~p^).] 0.002 secs (0.002u,0.s)
Chars 26125 - 26126 [*] 0. secs (0.u,0.s)
Chars 26127 - 26139 [reflexivity.] 0.001 secs (0.u,0.s)
Chars 26144 - 26145 [-] 0. secs (0.u,0.s)
Chars 26146 - 26162 [(right;~exact~IH).] 0.002 secs (0.002u,0.s)
Chars 25313 - 25341 [(induction~n~as~[|~n~[IH|~IH]]).] 0. secs (0.u,0.s)
Chars 25348 - 25353 [left.] 0. secs (0.u,0.s)
Chars 25354 - 25363 [(intros~x).] 0. secs (0.u,0.s)
Chars 25370 - 25413 [(apply~hprop_inhabited_contr;~...] 0. secs (0.u,0.s)
Chars 25420 - 25503 [(destruct~(detachable_image_fi...] 0. secs (0.u,0.s)
Chars 25512 - 25518 [right.] 0. secs (0.u,0.s)
Chars 25527 - 25548 [exists~(nat_fin~n~k).] 0. secs (0.u,0.s)
Chars 25557 - 25584 [exists~(nat_fin_compl~n~k).] 0. secs (0.u,0.s)
Chars 25593 - 25621 [(rewrite~nat_fin_compl_compl).] 0. secs (0.u,0.s)
Chars 25630 - 25638 [exact~p.] 0. secs (0.u,0.s)
Chars 25647 - 25652 [left.] 0. secs (0.u,0.s)
Chars 25653 - 25662 [(intros~x).] 0. secs (0.u,0.s)
Chars 25671 - 25691 [(apply~hprop_allpath).] 0. secs (0.u,0.s)
Chars 25700 - 25711 [(intros~k~l).] 0. secs (0.u,0.s)
Chars 25720 - 25743 [(apply~path_sigma_hprop).] 0. secs (0.u,0.s)
Chars 25752 - 25801 [(destruct~k~as~[[k|~[]]~p],~l~...] 0.004 secs (0.004u,0.s)
Chars 25812 - 25840 [(apply~isinj_embedding~in~IH).] 0. secs (0.u,0.s)
Chars 25851 - 25860 [(apply~ap).] 0. secs (0.u,0.s)
Chars 25871 - 25880 [(apply~IH).] 0. secs (0.u,0.s)
Chars 25891 - 25909 [(unfold~er~in~p,~q).] 0. secs (0.u,0.s)
Chars 25910 - 25924 [(simpl~in~p,~q).] 0. secs (0.u,0.s)
Chars 25935 - 25950 [exact~(p~@~q^).] 0. secs (0.u,0.s)
Chars 25961 - 25987 [refine~(Empty_rec~(ne~_)).] 0. secs (0.u,0.s)
Chars 25998 - 26007 [exists~k.] 0. secs (0.u,0.s)
Chars 26018 - 26033 [exact~(p~@~q^).] 0. secs (0.u,0.s)
Chars 26044 - 26070 [refine~(Empty_rec~(ne~_)).] 0. secs (0.u,0.s)
Chars 26081 - 26090 [exists~l.] 0. secs (0.u,0.s)
Chars 26101 - 26116 [exact~(q~@~p^).] 0. secs (0.u,0.s)
Chars 26127 - 26139 [reflexivity.] 0. secs (0.u,0.s)
Chars 26146 - 26162 [(right;~exact~IH).] 0.001 secs (0.001u,0.s)
Chars 26165 - 26173 [Defined.] 0.01 secs (0.008u,0.002s)
Chars 26177 - 26265 [Definition~finite_enumeration_...] 0. secs (0.u,0.s)
Chars 26268 - 26274 [Proof.] 0. secs (0.u,0.s)
Chars 10350 - 10363 [(intros~q~r~E).] 40.191 secs (0.002u,0.042s)
Chars 10364 - 10370 [split.] 0.001 secs (0.001u,0.s)
Chars 10371 - 10372 [-] 0. secs (0.u,0.s)
Chars 10373 - 10394 [(apply~flip_pos_minus).] 0.028 secs (0.025u,0.002s)
Chars 10397 - 10467 [(assert~(Hrw~:~(q~+~r)~/~2~-~q...] 0.013 secs (0.013u,0.s)
Chars 10470 - 10471 [{] 0. secs (0.u,0.s)
Chars 10472 - 10507 [(path_via~((q~+~r)~/~2~-~2~/~2...] 0.04 secs (0.033u,0.006s)
Chars 10512 - 10513 [{] 0. secs (0.u,0.s)
Chars 10514 - 10559 [(rewrite~dec_recip_inverse;~[~...] 0.033 secs (0.025u,0.007s)
Chars 10566 - 10591 [(rewrite~mult_1_l;~trivial).] 0.016 secs (0.013u,0.002s)
Chars 10596 - 10597 [}] 0. secs (0.u,0.s)
Chars 10602 - 10646 [(ring_tac.ring_with_integers~(...] 0.277 secs (0.232u,0.042s)
Chars 10649 - 10650 [}] 0. secs (0.u,0.s)
Chars 10653 - 10686 [(apply~pos_mult_compat;~[~~|~a...] 0.025 secs (0.025u,0.s)
Chars 10689 - 10693 [(red).] 0. secs (0.u,0.s)
Chars 10694 - 10727 [(apply~(snd~(flip_pos_minus~_~...] 0.01 secs (0.009u,0.s)
Chars 10728 - 10736 [trivial.] 0.001 secs (0.001u,0.s)
Chars 10737 - 10738 [-] 0. secs (0.u,0.s)
Chars 10739 - 10760 [(apply~flip_pos_minus).] 0.01 secs (0.01u,0.s)
Chars 10763 - 10833 [(assert~(Hrw~:~r~-~(q~+~r)~/~2...] 0.009 secs (0.009u,0.s)
Chars 10836 - 10837 [{] 0. secs (0.u,0.s)
Chars 10838 - 10873 [(path_via~(2~/~2~*~r~-~(q~+~r)...] 0.014 secs (0.013u,0.s)
Chars 10878 - 10879 [{] 0. secs (0.u,0.s)
Chars 10880 - 10925 [(rewrite~dec_recip_inverse;~[~...] 0.028 secs (0.023u,0.004s)
Chars 10932 - 10957 [(rewrite~mult_1_l;~trivial).] 0.01 secs (0.01u,0.s)
Chars 10962 - 10963 [}] 0. secs (0.u,0.s)
Chars 10968 - 11012 [(ring_tac.ring_with_integers~(...] 0.273 secs (0.23u,0.039s)
Chars 11015 - 11016 [}] 0. secs (0.u,0.s)
Chars 11019 - 11052 [(apply~pos_mult_compat;~[~~|~a...] 0.018 secs (0.018u,0.s)
Chars 11055 - 11059 [(red).] 0. secs (0.u,0.s)
Chars 11060 - 11093 [(apply~(snd~(flip_pos_minus~_~...] 0.007 secs (0.007u,0.s)
Chars 11094 - 11102 [trivial.] 0. secs (0.u,0.s)
Chars 10350 - 10363 [(intros~q~r~E).] 0. secs (0.u,0.s)
Chars 10364 - 10370 [split.] 0. secs (0.u,0.s)
Chars 10373 - 10394 [(apply~flip_pos_minus).] 0. secs (0.u,0.s)
Chars 10397 - 10467 [(assert~(Hrw~:~(q~+~r)~/~2~-~q...] 0.001 secs (0.001u,0.s)
Chars 10472 - 10507 [(path_via~((q~+~r)~/~2~-~2~/~2...] 0. secs (0.u,0.s)
Chars 10514 - 10559 [(rewrite~dec_recip_inverse;~[~...] 0. secs (0.u,0.s)
Chars 10566 - 10591 [(rewrite~mult_1_l;~trivial).] 0.001 secs (0.001u,0.s)
Chars 10602 - 10646 [(ring_tac.ring_with_integers~(...] 0. secs (0.u,0.s)
Chars 10653 - 10686 [(apply~pos_mult_compat;~[~~|~a...] 0. secs (0.u,0.s)
Chars 10689 - 10693 [(red).] 0. secs (0.u,0.s)
Chars 10694 - 10727 [(apply~(snd~(flip_pos_minus~_~...] 0. secs (0.u,0.s)
Chars 10728 - 10736 [trivial.] 0. secs (0.u,0.s)
Chars 10739 - 10760 [(apply~flip_pos_minus).] 0. secs (0.u,0.s)
Chars 10763 - 10833 [(assert~(Hrw~:~r~-~(q~+~r)~/~2...] 0.001 secs (0.001u,0.s)
Chars 10838 - 10873 [(path_via~(2~/~2~*~r~-~(q~+~r)...] 0. secs (0.u,0.s)
Chars 10880 - 10925 [(rewrite~dec_recip_inverse;~[~...] 0. secs (0.u,0.s)
Chars 10932 - 10957 [(rewrite~mult_1_l;~trivial).] 0.001 secs (0.001u,0.s)
Chars 10968 - 11012 [(ring_tac.ring_with_integers~(...] 0. secs (0.u,0.s)
Chars 11019 - 11052 [(apply~pos_mult_compat;~[~~|~a...] 0. secs (0.u,0.s)
Chars 11055 - 11059 [(red).] 0. secs (0.u,0.s)
Chars 11060 - 11093 [(apply~(snd~(flip_pos_minus~_~...] 0. secs (0.u,0.s)
Chars 11094 - 11102 [trivial.] 0. secs (0.u,0.s)
Chars 11103 - 11107 [Qed.] 0.079 secs (0.079u,0.s)
Chars 11109 - 11181 [Lemma~path_avg_split_diff_l~(q...] 0.002 secs (0.002u,0.s)
Chars 11182 - 11188 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
Chars 26279 - 26337 [(destruct~(finite_enumeration_...] 40.179 secs (0.003u,0.036s)
Chars 26342 - 26343 [-] 0. secs (0.u,0.s)
Chars 26344 - 26405 [(pose~proof~(leq_inj_finite~(e...] 0.004 secs (0.002u,0.001s)
Chars 26412 - 26434 [(elim~(not_lt_n_n~_~q)).] 0.001 secs (0.001u,0.s)
Chars 26439 - 26440 [-] 0. secs (0.u,0.s)
Chars 26441 - 26452 [assumption.] 0. secs (0.u,0.s)
Chars 26279 - 26337 [(destruct~(finite_enumeration_...] 0. secs (0.u,0.s)
Chars 26344 - 26405 [(pose~proof~(leq_inj_finite~(e...] 0.001 secs (0.001u,0.s)
Chars 26412 - 26434 [(elim~(not_lt_n_n~_~q)).] 0. secs (0.u,0.s)
Chars 26441 - 26452 [assumption.] 0. secs (0.u,0.s)
Chars 26455 - 26463 [Defined.] 0.001 secs (0.001u,0.s)
Chars 26465 - 26481 [End~Enumeration.] 0.041 secs (0.04u,0.s)
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
Chars 11191 - 11206 [(pattern~q~at~1).] 40.138 secs (0.001u,0.033s)
Chars 11209 - 11233 [(rewrite~<-~(mult_1_r~q)).] 0.007 secs (0.007u,0.s)
Chars 11236 - 11257 [(pattern~(1~:~Q)~at~1).] 0.002 secs (0.002u,0.s)
Chars 11260 - 11312 [(rewrite~<-~(dec_recip_inverse...] 0.041 secs (0.038u,0.002s)
Chars 11315 - 11348 [(rewrite~(associativity~q~2~(/...] 0.034 secs (0.03u,0.003s)
Chars 11351 - 11394 [(rewrite~<-~(distribute_r~(q~*...] 0.017 secs (0.015u,0.001s)
Chars 11397 - 11426 [(rewrite~(distribute_l~q~1~1)).] 0.013 secs (0.013u,0.s)
Chars 11429 - 11450 [(rewrite~(mult_1_r~q)).] 0.007 secs (0.007u,0.s)
Chars 11453 - 11489 [(rewrite~(commutativity~(q~+~q...] 0.045 secs (0.034u,0.01s)
Chars 11492 - 11532 [(rewrite~<-~(associativity~r~(...] 0.047 secs (0.039u,0.007s)
Chars 11535 - 11568 [(rewrite~(associativity~(-~q)~...] 0.056 secs (0.045u,0.01s)
Chars 11571 - 11597 [(rewrite~(plus_negate_l~q)).] 0.006 secs (0.004u,0.002s)
Chars 11600 - 11621 [(rewrite~(plus_0_l~q)).] 0.007 secs (0.007u,0.s)
Chars 11624 - 11636 [reflexivity.] 0.001 secs (0.u,0.s)
Chars 11191 - 11206 [(pattern~q~at~1).] 0.001 secs (0.001u,0.s)
Chars 11209 - 11233 [(rewrite~<-~(mult_1_r~q)).] 0.001 secs (0.001u,0.s)
Chars 11236 - 11257 [(pattern~(1~:~Q)~at~1).] 0.001 secs (0.001u,0.s)
Chars 11260 - 11312 [(rewrite~<-~(dec_recip_inverse...] 0.001 secs (0.001u,0.s)
Chars 11315 - 11348 [(rewrite~(associativity~q~2~(/...] 0.001 secs (0.001u,0.s)
Chars 11351 - 11394 [(rewrite~<-~(distribute_r~(q~*...] 0.001 secs (0.001u,0.s)
Chars 11397 - 11426 [(rewrite~(distribute_l~q~1~1)).] 0.001 secs (0.001u,0.s)
Chars 11429 - 11450 [(rewrite~(mult_1_r~q)).] 0.001 secs (0.001u,0.s)
Chars 11453 - 11489 [(rewrite~(commutativity~(q~+~q...] 0. secs (0.u,0.s)
Chars 11492 - 11532 [(rewrite~<-~(associativity~r~(...] 0. secs (0.u,0.s)
Chars 11535 - 11568 [(rewrite~(associativity~(-~q)~...] 0. secs (0.u,0.s)
Chars 11571 - 11597 [(rewrite~(plus_negate_l~q)).] 0. secs (0.u,0.s)
Chars 11600 - 11621 [(rewrite~(plus_0_l~q)).] 0. secs (0.u,0.s)
Chars 11624 - 11636 [reflexivity.] 0. secs (0.u,0.s)
Chars 11637 - 11641 [Qed.] 0.007 secs (0.007u,0.s)
Chars 11643 - 11715 [Lemma~path_avg_split_diff_r~(q...] 0.005 secs (0.004u,0.s)
Chars 11716 - 11722 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
More readable: initial segment:
(nat_rec (fun _ : nat => (nat * nat)%type) (0, 0)
   (fun (_ : nat) (pat : nat * nat) =>
    let (x, y) := pat in match x with
                         | 0 => (S y, 0)
                         | S x0 => (x0, S y)
                         end))
With remainder:
[Ast.tRel 0]
"Did not find an instance for "
(extracted rc_cons)
"open obligation cnstr_reccode5_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
destruct  p0  in  x
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
destruct  p0  in  x
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
destruct  p0  in  x
Chars 11725 - 11740 [(pattern~r~at~1).] 40.204 secs (0.002u,0.04s)
Chars 11743 - 11767 [(rewrite~<-~(mult_1_r~r)).] 0.008 secs (0.006u,0.002s)
Chars 11770 - 11791 [(pattern~(1~:~Q)~at~1).] 0.002 secs (0.002u,0.s)
Chars 11794 - 11846 [(rewrite~<-~(dec_recip_inverse...] 0.033 secs (0.03u,0.002s)
Chars 11849 - 11882 [(rewrite~(associativity~r~2~(/...] 0.033 secs (0.028u,0.005s)
Chars 11885 - 11913 [(rewrite~negate_mult_distr_l).] 0.008 secs (0.007u,0.s)
Chars 11916 - 11962 [(rewrite~<-~(distribute_r~(r~*...] 0.019 secs (0.018u,0.s)
Chars 11965 - 11994 [(rewrite~(distribute_l~r~1~1)).] 0.014 secs (0.011u,0.002s)
Chars 11997 - 12018 [(rewrite~(mult_1_r~r)).] 0.008 secs (0.008u,0.s)
Chars 12021 - 12060 [(rewrite~(commutativity~(r~+~r...] 0.059 secs (0.052u,0.006s)
Chars 12063 - 12088 [(rewrite~<-~negate_swap_r).] 0.007 secs (0.006u,0.001s)
Chars 12091 - 12131 [(rewrite~<-~(associativity~q~(...] 0.053 secs (0.044u,0.009s)
Chars 12134 - 12167 [(rewrite~(associativity~(-~r)~...] 0.049 secs (0.036u,0.012s)
Chars 12170 - 12196 [(rewrite~(plus_negate_l~r)).] 0.006 secs (0.006u,0.s)
Chars 12199 - 12220 [(rewrite~(plus_0_l~r)).] 0.007 secs (0.006u,0.s)
Chars 12223 - 12247 [(rewrite~(plus_comm~q~r)).] 0.007 secs (0.005u,0.002s)
Chars 12250 - 12262 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 11725 - 11740 [(pattern~r~at~1).] 0.001 secs (0.001u,0.s)
Chars 11743 - 11767 [(rewrite~<-~(mult_1_r~r)).] 0.001 secs (0.001u,0.s)
Chars 11770 - 11791 [(pattern~(1~:~Q)~at~1).] 0.001 secs (0.001u,0.s)
Chars 11794 - 11846 [(rewrite~<-~(dec_recip_inverse...] 0.001 secs (0.001u,0.s)
Chars 11849 - 11882 [(rewrite~(associativity~r~2~(/...] 0.001 secs (0.001u,0.s)
Chars 11885 - 11913 [(rewrite~negate_mult_distr_l).] 0.001 secs (0.u,0.s)
Chars 11916 - 11962 [(rewrite~<-~(distribute_r~(r~*...] 0.001 secs (0.001u,0.s)
Chars 11965 - 11994 [(rewrite~(distribute_l~r~1~1)).] 0.001 secs (0.001u,0.s)
Chars 11997 - 12018 [(rewrite~(mult_1_r~r)).] 0.001 secs (0.001u,0.s)
Chars 12021 - 12060 [(rewrite~(commutativity~(r~+~r...] 0.001 secs (0.001u,0.s)
Chars 12063 - 12088 [(rewrite~<-~negate_swap_r).] 0. secs (0.u,0.s)
Chars 12091 - 12131 [(rewrite~<-~(associativity~q~(...] 0. secs (0.u,0.s)
Chars 12134 - 12167 [(rewrite~(associativity~(-~r)~...] 0. secs (0.u,0.s)
Chars 12170 - 12196 [(rewrite~(plus_negate_l~r)).] 0. secs (0.u,0.s)
Chars 12199 - 12220 [(rewrite~(plus_0_l~r)).] 0. secs (0.u,0.s)
Chars 12223 - 12247 [(rewrite~(plus_comm~q~r)).] 0. secs (0.u,0.s)
Chars 12250 - 12262 [reflexivity.] 0. secs (0.u,0.s)
Chars 12263 - 12267 [Qed.] 0.021 secs (0.016u,0.004s)
Chars 12269 - 12385 [Lemma~pos_gt_both~:~~~forall~a...] 0.007 secs (0.006u,0.s)
Chars 12386 - 12392 [Proof.] 0. secs (0.u,0.s)
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
destruct  p0  in  x
destruct  p0  in  x
destruct  p0  in  x
destruct  p0  in  x
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
find_witness Control.TimeoutMore readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
Chars 12393 - 12515 [(assert~~~(Haux~:~~~~forall~a~...] 40.219 secs (0.009u,0.048s)
Chars 12516 - 12517 [{] 0. secs (0.u,0.s)
Chars 12518 - 12539 [(intros~a~b~E~e~E1~E2).] 0.001 secs (0.001u,0.s)
Chars 12542 - 12619 [(pose~proof~(Q_average_between...] 0.005 secs (0.003u,0.001s)
Chars 12622 - 12679 [exists~(mkQpos~_~(le_lt_trans~...] 0.019 secs (0.015u,0.004s)
Chars 12682 - 12707 [(unfold~cast~at~1~4;~simpl).] 0.007 secs (0.006u,0.s)
Chars 12710 - 12736 [exists~(Qpos_diff~_~_~E4).] 0.004 secs (0.003u,0.001s)
Chars 12739 - 12752 [(repeat~split).] 0.004 secs (0.004u,0.s)
Chars 12755 - 12756 [-] 0. secs (0.u,0.s)
Chars 12757 - 12790 [(apply~le_lt_trans~with~b;~tri...] 0.019 secs (0.014u,0.004s)
Chars 12795 - 12837 [(apply~le_lt_trans~with~(join~...] 0.021 secs (0.019u,0.001s)
Chars 12842 - 12858 [(apply~join_ub_l).] 0.004 secs (0.004u,0.s)
Chars 12861 - 12862 [-] 0. secs (0.u,0.s)
Chars 12863 - 12905 [(apply~le_lt_trans~with~(join~...] 0.02 secs (0.018u,0.002s)
Chars 12906 - 12922 [(apply~join_ub_l).] 0.004 secs (0.004u,0.s)
Chars 12925 - 12926 [-] 0. secs (0.u,0.s)
Chars 12927 - 12940 [(apply~pos_eq).] 0.003 secs (0.003u,0.s)
Chars 12941 - 12964 [(unfold~cast~at~2;~simpl).] 0.005 secs (0.004u,0.s)
Chars 12965 - 12988 [(unfold~cast~at~2;~simpl).] 0.005 secs (0.005u,0.s)
Chars 12993 - 13016 [(unfold~cast~at~3;~simpl).] 0.004 secs (0.004u,0.s)
Chars 13021 - 13074 [(abstract~ring_tac.ring_with_i...] 0.415 secs (0.371u,0.042s)
Chars 13075 - 13076 [}] 0. secs (0.u,0.s)
Chars 13077 - 13096 [(intros~a~b~e~E1~E2).] 0.001 secs (0.001u,0.s)
Chars 13097 - 13135 [(destruct~(total~le~a~b)~as~[E...] 0.026 secs (0.026u,0.s)
Chars 13136 - 13193 [(destruct~(Haux~_~_~E~e)~as~[d...] 0.012 secs (0.012u,0.s)
Chars 13194 - 13200 [eauto.] 0.02 secs (0.017u,0.002s)
Chars 12393 - 12515 [(assert~~~(Haux~:~~~~forall~a~...] 0.001 secs (0.001u,0.s)
Chars 12518 - 12539 [(intros~a~b~E~e~E1~E2).] 0.001 secs (0.001u,0.s)
Chars 12542 - 12619 [(pose~proof~(Q_average_between...] 0.001 secs (0.001u,0.s)
Chars 12622 - 12679 [exists~(mkQpos~_~(le_lt_trans~...] 0.001 secs (0.001u,0.s)
Chars 12682 - 12707 [(unfold~cast~at~1~4;~simpl).] 0.005 secs (0.005u,0.s)
Chars 12710 - 12736 [exists~(Qpos_diff~_~_~E4).] 0.002 secs (0.002u,0.s)
Chars 12739 - 12752 [(repeat~split).] 0.002 secs (0.002u,0.s)
Chars 12757 - 12790 [(apply~le_lt_trans~with~b;~tri...] 0.003 secs (0.003u,0.s)
Chars 12795 - 12837 [(apply~le_lt_trans~with~(join~...] 0.003 secs (0.003u,0.s)
Chars 12842 - 12858 [(apply~join_ub_l).] 0.001 secs (0.001u,0.s)
Chars 12863 - 12905 [(apply~le_lt_trans~with~(join~...] 0.003 secs (0.003u,0.s)
Chars 12906 - 12922 [(apply~join_ub_l).] 0.001 secs (0.001u,0.s)
Chars 12927 - 12940 [(apply~pos_eq).] 0.002 secs (0.002u,0.s)
Chars 12941 - 12964 [(unfold~cast~at~2;~simpl).] 0.004 secs (0.004u,0.s)
Chars 12965 - 12988 [(unfold~cast~at~2;~simpl).] 0.004 secs (0.004u,0.s)
Chars 12993 - 13016 [(unfold~cast~at~3;~simpl).] 0.003 secs (0.003u,0.s)
Chars 13021 - 13074 [(abstract~ring_tac.ring_with_i...] 0.025 secs (0.025u,0.s)
Chars 13077 - 13096 [(intros~a~b~e~E1~E2).] 0.023 secs (0.022u,0.s)
Chars 13097 - 13135 [(destruct~(total~le~a~b)~as~[E...] 0.027 secs (0.027u,0.s)
Chars 13136 - 13193 [(destruct~(Haux~_~_~E~e)~as~[d...] 0.029 secs (0.029u,0.s)
Chars 13194 - 13200 [eauto.] 0.023 secs (0.023u,0.s)
Chars 13201 - 13205 [Qed.] 0.066 secs (0.066u,0.s)
Chars 13207 - 13258 [Lemma~two_fourth_is_one_half@{...] 0.005 secs (0.005u,0.s)
Chars 13259 - 13265 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
More readable: initial segment:
cons
With remainder:
[Ast.tRel 0;
 Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list")
         0) 0 []) [Ast.tVar "X"]]
find_witness Control.TimeoutMore readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Chars 13266 - 13322 [(assert~(Hrw~:~4~=~2~*~2~:>~Q)...] 40.36 secs (0.131u,0.07s)
Chars 13323 - 13336 [(apply~pos_eq).] 0.001 secs (0.001u,0.s)
Chars 13337 - 13364 [(repeat~(unfold~cast;~simpl)).] 0.003 secs (0.003u,0.s)
Chars 13365 - 13387 [(rewrite~Hrw;~clear~Hrw).] 0.003 secs (0.002u,0.s)
Chars 13388 - 13412 [(rewrite~dec_recip_distr).] 0.055 secs (0.05u,0.004s)
Chars 13413 - 13432 [(rewrite~mult_assoc).] 0.012 secs (0.008u,0.003s)
Chars 13433 - 13478 [(rewrite~dec_recip_inverse;~[~...] 0.044 secs (0.038u,0.005s)
Chars 13479 - 13491 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 13492 - 13501 [Unshelve.] 0. secs (0.u,0.s)
Chars 13502 - 13521 [exact~(fun~_~=>~1).] 0.001 secs (0.001u,0.s)
Chars 13266 - 13322 [(assert~(Hrw~:~4~=~2~*~2~:>~Q)...] 0.001 secs (0.001u,0.s)
Chars 13323 - 13336 [(apply~pos_eq).] 0.001 secs (0.001u,0.s)
Chars 13337 - 13364 [(repeat~(unfold~cast;~simpl)).] 0.001 secs (0.u,0.s)
Chars 13365 - 13387 [(rewrite~Hrw;~clear~Hrw).] 0.002 secs (0.001u,0.s)
Chars 13388 - 13412 [(rewrite~dec_recip_distr).] 0. secs (0.u,0.s)
Chars 13413 - 13432 [(rewrite~mult_assoc).] 0. secs (0.u,0.s)
Chars 13433 - 13478 [(rewrite~dec_recip_inverse;~[~...] 0.001 secs (0.001u,0.s)
Chars 13479 - 13491 [reflexivity.] 0. secs (0.u,0.s)
Chars 13502 - 13521 [exact~(fun~_~=>~1).] 0. secs (0.u,0.s)
Chars 13535 - 13539 [Qed.] 0.038 secs (0.035u,0.002s)
Chars 13541 - 13608 [Lemma~Q_triangle_le~:~forall~q...] 0.003 secs (0.002u,0.s)
Chars 13609 - 13615 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Chars 13616 - 13623 [(intros).] 40.19 secs (0.001u,0.043s)
Chars 13624 - 13655 [(rewrite~(Qabs_is_join~(q~+~r))).] 0.002 secs (0.002u,0.s)
Chars 13656 - 13670 [(apply~join_le).] 0.003 secs (0.002u,0.s)
Chars 13671 - 13672 [-] 0. secs (0.u,0.s)
Chars 13673 - 13699 [(rewrite~negate_plus_distr).] 0.006 secs (0.004u,0.001s)
Chars 13702 - 13745 [(apply~plus_le_compat;~apply~Q...] 0.018 secs (0.015u,0.002s)
Chars 13746 - 13747 [-] 0. secs (0.u,0.s)
Chars 13748 - 13787 [(apply~plus_le_compat;~apply~Q...] 0.018 secs (0.013u,0.004s)
Chars 13616 - 13623 [(intros).] 0. secs (0.u,0.s)
Chars 13624 - 13655 [(rewrite~(Qabs_is_join~(q~+~r))).] 0. secs (0.u,0.s)
Chars 13656 - 13670 [(apply~join_le).] 0. secs (0.u,0.s)
Chars 13673 - 13699 [(rewrite~negate_plus_distr).] 0. secs (0.u,0.s)
Chars 13702 - 13745 [(apply~plus_le_compat;~apply~Q...] 0.002 secs (0.001u,0.s)
Chars 13748 - 13787 [(apply~plus_le_compat;~apply~Q...] 0.002 secs (0.002u,0.s)
Chars 13788 - 13792 [Qed.] 0.002 secs (0.001u,0.s)
Chars 13794 - 13869 [Lemma~Qabs_triangle_alt_aux~:~...] 0.004 secs (0.002u,0.002s)
Chars 13870 - 13876 [Proof.] 0. secs (0.u,0.s)
Chars 13877 - 13888 [(intros~q~r).] 40.2 secs (0.002u,0.042s)
Chars 13889 - 13926 [(apply~(order_reflecting~(+abs...] 0.02 secs (0.019u,0.001s)
Chars 13927 - 14044 [(assert~(Hrw~:~abs~q~-~abs~r~+...] 0.199 secs (0.171u,0.028s)
Chars 14045 - 14082 [(etransitivity;~[~~|~apply~Q_t...] 0.06 secs (0.049u,0.01s)
Chars 14083 - 14184 [(assert~(Hrw~:~q~-~r~+~r~=~q)~...] 0.175 secs (0.155u,0.02s)
Chars 14185 - 14197 [reflexivity.] 0.01 secs (0.01u,0.s)
Chars 13877 - 13888 [(intros~q~r).] 0. secs (0.u,0.s)
Chars 13889 - 13926 [(apply~(order_reflecting~(+abs...] 0. secs (0.u,0.s)
Chars 13927 - 14044 [(assert~(Hrw~:~abs~q~-~abs~r~+...] 0.003 secs (0.003u,0.s)
Chars 14045 - 14082 [(etransitivity;~[~~|~apply~Q_t...] 0.001 secs (0.001u,0.s)
Chars 14083 - 14184 [(assert~(Hrw~:~q~-~r~+~r~=~q)~...] 0.002 secs (0.002u,0.s)
Chars 14185 - 14197 [reflexivity.] 0. secs (0.u,0.s)
Chars 14198 - 14202 [Qed.] 0.038 secs (0.035u,0.002s)
Chars 14204 - 14281 [Lemma~Qabs_triangle_alt~:~fora...] 0.003 secs (0.003u,0.s)
Chars 14282 - 14288 [Proof.] 0. secs (0.u,0.s)
could not simplify some occuring term, shelved instead
find_witness Control.TimeoutMore readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
Chars 14289 - 14300 [(intros~q~r).] 40.196 secs (0.001u,0.043s)
Chars 14301 - 14340 [(rewrite~(Qabs_is_join~(abs~q~...] 0.005 secs (0.004u,0.s)
Chars 14341 - 14355 [(apply~join_le).] 0.003 secs (0.002u,0.s)
Chars 14356 - 14357 [-] 0. secs (0.u,0.s)
Chars 14358 - 14404 [(rewrite~<-~(Qabs_neg~(q~-~r))...] 0.016 secs (0.013u,0.002s)
Chars 14407 - 14435 [(apply~Qabs_triangle_alt_aux).] 0.001 secs (0.001u,0.s)
Chars 14436 - 14437 [-] 0. secs (0.u,0.s)
Chars 14438 - 14466 [(apply~Qabs_triangle_alt_aux).] 0.001 secs (0.001u,0.s)
Chars 14289 - 14300 [(intros~q~r).] 0. secs (0.u,0.s)
Chars 14301 - 14340 [(rewrite~(Qabs_is_join~(abs~q~...] 0. secs (0.u,0.s)
Chars 14341 - 14355 [(apply~join_le).] 0.001 secs (0.u,0.001s)
Chars 14358 - 14404 [(rewrite~<-~(Qabs_neg~(q~-~r))...] 0. secs (0.u,0.s)
Chars 14407 - 14435 [(apply~Qabs_triangle_alt_aux).] 0. secs (0.u,0.s)
Chars 14438 - 14466 [(apply~Qabs_triangle_alt_aux).] 0. secs (0.u,0.s)
Chars 14467 - 14471 [Qed.] 0.002 secs (0.002u,0.s)
Chars 14473 - 14537 [Lemma~Q_dense@{}~:~forall~q~r~...] 0.001 secs (0.u,0.s)
Chars 14538 - 14544 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
Some
With remainder:
[Ast.tApp
   (Ast.tConstruct
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod")
         0) 0 []) [Ast.tVar "X"; Ast.tVar "Y"; Ast.tRel 1; Ast.tRel 0]]
find_witness Control.Timeoutfind_witness Control.TimeoutChars 14545 - 14597 [(intros~q~r~E;~econstructor;~a...] 40.187 secs (0.003u,0.046s)
Chars 14545 - 14597 [(intros~q~r~E;~econstructor;~a...] 0.002 secs (0.002u,0.s)
Chars 14598 - 14602 [Qed.] 0. secs (0.u,0.s)
Chars 14604 - 14671 [Lemma~Qabs_neg_flip@{}~:~foral...] 0.003 secs (0.003u,0.s)
Chars 14672 - 14678 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfun (args : \<< A, word, word \>>) (tr' : Semantics.trace) 
  (mem' : mem) (locals' : locals) =>
tr' = tr /\
locals' =
#{ "v" => P2.car (P2.cdr args); "ptr" => ptr; "y" => P2.cdr (P2.cdr args) }# /\
(rp ptr (P2.car args) ⋆ R) mem'
     : \<< A, word, word \>> -> Semantics.trace -> mem -> locals -> Prop
Chars 14679 - 14690 [(intros~a~b).] 18.712 secs (0.u,0.045s)
Chars 14691 - 14710 [(rewrite~<-~Qabs_neg).] 0.002 secs (0.u,0.001s)
Chars 14711 - 14735 [(rewrite~<-~negate_swap_r).] 0.006 secs (0.005u,0.001s)
Chars 14736 - 14744 [trivial.] 0.002 secs (0.002u,0.s)
Chars 14679 - 14690 [(intros~a~b).] 0.001 secs (0.001u,0.s)
Chars 14691 - 14710 [(rewrite~<-~Qabs_neg).] 0. secs (0.u,0.s)
Chars 14711 - 14735 [(rewrite~<-~negate_swap_r).] 0. secs (0.u,0.s)
Chars 14736 - 14744 [trivial.] 0. secs (0.u,0.s)
Chars 14745 - 14749 [Qed.] 0.001 secs (0.001u,0.s)
Chars 14751 - 14923 [Definition~pos_of_Q~:~Q~->~Q+~...] 0.04 secs (0.038u,0.001s)
Chars 14925 - 15016 [Lemma~Q_abs_plus_1_bounds@{}~:...] 0.002 secs (0.002u,0.s)
Chars 15017 - 15023 [Proof.] 0. secs (0.u,0.s)
Chars 15024 - 15031 [(intros).] 40.208 secs (0.u,0.045s)
Chars 15032 - 15077 [(change~(-~(abs~q~+~1)~≤~q~≤~a...] 0.006 secs (0.005u,0.s)
Chars 15078 - 15084 [split.] 0.001 secs (0.001u,0.s)
Chars 15085 - 15086 [-] 0. secs (0.u,0.s)
Chars 15087 - 15108 [(apply~flip_le_negate).] 0.016 secs (0.013u,0.002s)
Chars 15109 - 15128 [(rewrite~involutive).] 0.009 secs (0.007u,0.001s)
Chars 15131 - 15152 [transitivity~(abs~q).] 0.059 secs (0.049u,0.009s)
Chars 15155 - 15156 [+] 0. secs (0.u,0.s)
Chars 15157 - 15179 [(apply~Qabs_le_neg_raw).] 0.001 secs (0.001u,0.s)
Chars 15182 - 15183 [+] 0. secs (0.u,0.s)
Chars 15184 - 15214 [(apply~nonneg_plus_le_compat_r).] 0.016 secs (0.015u,0.s)
Chars 15215 - 15231 [solve_propholds.] 0.012 secs (0.011u,0.s)
Chars 15232 - 15233 [-] 0. secs (0.u,0.s)
Chars 15234 - 15255 [transitivity~(abs~q).] 0.055 secs (0.05u,0.004s)
Chars 15258 - 15259 [+] 0. secs (0.u,0.s)
Chars 15260 - 15278 [(apply~Qabs_le_raw).] 0.001 secs (0.u,0.s)
Chars 15281 - 15282 [+] 0. secs (0.u,0.s)
Chars 15283 - 15313 [(apply~nonneg_plus_le_compat_r).] 0.016 secs (0.013u,0.002s)
Chars 15314 - 15330 [solve_propholds.] 0.012 secs (0.012u,0.s)
Chars 15024 - 15031 [(intros).] 0. secs (0.u,0.s)
Chars 15032 - 15077 [(change~(-~(abs~q~+~1)~≤~q~≤~a...] 0. secs (0.u,0.s)
Chars 15078 - 15084 [split.] 0.001 secs (0.u,0.s)
Chars 15087 - 15108 [(apply~flip_le_negate).] 0. secs (0.u,0.s)
Chars 15109 - 15128 [(rewrite~involutive).] 0. secs (0.u,0.s)
Chars 15131 - 15152 [transitivity~(abs~q).] 0. secs (0.u,0.s)
Chars 15157 - 15179 [(apply~Qabs_le_neg_raw).] 0. secs (0.u,0.s)
Chars 15184 - 15214 [(apply~nonneg_plus_le_compat_r).] 0. secs (0.u,0.s)
Chars 15215 - 15231 [solve_propholds.] 0. secs (0.u,0.s)
Chars 15234 - 15255 [transitivity~(abs~q).] 0. secs (0.u,0.s)
Chars 15260 - 15278 [(apply~Qabs_le_raw).] 0. secs (0.u,0.s)
Chars 15283 - 15313 [(apply~nonneg_plus_le_compat_r).] 0. secs (0.u,0.s)
Chars 15314 - 15330 [solve_propholds.] 0. secs (0.u,0.s)
Chars 15331 - 15335 [Qed.] 0.003 secs (0.003u,0.s)
Chars 15337 - 15402 [Lemma~Qabs_mult@{}~:~forall~a~...] 0.003 secs (0.003u,0.s)
Chars 15403 - 15409 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
simplified dependent [if true]
e : (x <? n1)  = true
if (x <? n1)
then (fun E0 : (x <? n1) = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : (x <? n1) = false =>
 BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 (ltN_plus_lemma1 e) E0)))
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
Chars 15410 - 15421 [(intros~a~b).] 40.197 secs (0.001u,0.042s)
Chars 15422 - 15579 [(destruct~(total_abs_either~a)...] 0.06 secs (0.052u,0.007s)
Chars 15580 - 15581 [-] 0. secs (0.u,0.s)
Chars 15582 - 15608 [(apply~(abs_sig~(a~*~b)).2).] 0.003 secs (0.003u,0.s)
Chars 15609 - 15642 [(apply~nonneg_mult_compat;~tri...] 0.017 secs (0.013u,0.003s)
Chars 15643 - 15644 [-] 0. secs (0.u,0.s)
Chars 15645 - 15675 [(rewrite~<-~negate_mult_distr_r).] 0.007 secs (0.006u,0.001s)
Chars 15678 - 15704 [(apply~(abs_sig~(a~*~b)).2).] 0.005 secs (0.005u,0.s)
Chars 15705 - 15738 [(apply~nonneg_nonpos_mult;~tri...] 0.022 secs (0.017u,0.005s)
Chars 15739 - 15740 [-] 0. secs (0.u,0.s)
Chars 15741 - 15771 [(rewrite~<-~negate_mult_distr_l).] 0.007 secs (0.006u,0.s)
Chars 15774 - 15800 [(apply~(abs_sig~(a~*~b)).2).] 0.004 secs (0.004u,0.s)
Chars 15801 - 15834 [(apply~nonpos_nonneg_mult;~tri...] 0.022 secs (0.018u,0.004s)
Chars 15835 - 15836 [-] 0. secs (0.u,0.s)
Chars 15837 - 15864 [(rewrite~negate_mult_negate).] 0.007 secs (0.005u,0.002s)
Chars 15865 - 15891 [(apply~(abs_sig~(a~*~b)).2).] 0.003 secs (0.003u,0.s)
Chars 15894 - 15920 [(apply~nonpos_mult;~trivial).] 0.023 secs (0.019u,0.003s)
Chars 15410 - 15421 [(intros~a~b).] 0. secs (0.u,0.s)
Chars 15422 - 15579 [(destruct~(total_abs_either~a)...] 0.015 secs (0.015u,0.s)
Chars 15582 - 15608 [(apply~(abs_sig~(a~*~b)).2).] 0.001 secs (0.001u,0.s)
Chars 15609 - 15642 [(apply~nonneg_mult_compat;~tri...] 0.002 secs (0.002u,0.s)
Chars 15645 - 15675 [(rewrite~<-~negate_mult_distr_r).] 0.001 secs (0.001u,0.s)
Chars 15678 - 15704 [(apply~(abs_sig~(a~*~b)).2).] 0.001 secs (0.001u,0.s)
Chars 15705 - 15738 [(apply~nonneg_nonpos_mult;~tri...] 0.002 secs (0.002u,0.s)
Chars 15741 - 15771 [(rewrite~<-~negate_mult_distr_l).] 0.001 secs (0.001u,0.s)
Chars 15774 - 15800 [(apply~(abs_sig~(a~*~b)).2).] 0.001 secs (0.001u,0.s)
Chars 15801 - 15834 [(apply~nonpos_nonneg_mult;~tri...] 0.002 secs (0.001u,0.001s)
Chars 15837 - 15864 [(rewrite~negate_mult_negate).] 0.001 secs (0.001u,0.s)
Chars 15865 - 15891 [(apply~(abs_sig~(a~*~b)).2).] 0.001 secs (0.001u,0.s)
Chars 15894 - 15920 [(apply~nonpos_mult;~trivial).] 0.002 secs (0.001u,0.s)
Chars 15921 - 15925 [Qed.] 0.007 secs (0.004u,0.002s)
Chars 15927 - 15978 [Lemma~Qpos_neg_le@{}~:~forall~...] 0.002 secs (0.001u,0.s)
Chars 15979 - 15985 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
Chars 15986 - 16032 [(intros~a;~apply~between_nonne...] 20.981 secs (0.023u,0.047s)
Chars 15986 - 16032 [(intros~a;~apply~between_nonne...] 0.002 secs (0.001u,0.001s)
Chars 16033 - 16037 [Qed.] 0. secs (0.u,0.s)
Chars 16039 - 16096 [Definition~Qpos_upper~(e~:~Q+)...] 0.001 secs (0.u,0.001s)
Chars 16098 - 16149 [Definition~Qpos_upper_inject~e...] 0. secs (0.u,0.s)
Chars 16150 - 16156 [Proof.] 0. secs (0.u,0.s)
Chars 16157 - 16166 [(intros~x).] 0.96 secs (0.u,0.045s)
Chars 16167 - 16189 [exists~(join~x~('~e)).] 0.002 secs (0.u,0.001s)
Chars 16190 - 16206 [(apply~join_ub_r).] 0.003 secs (0.003u,0.s)
Chars 16157 - 16166 [(intros~x).] 0. secs (0.u,0.s)
Chars 16167 - 16189 [exists~(join~x~('~e)).] 0. secs (0.u,0.s)
Chars 16190 - 16206 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 16207 - 16215 [Defined.] 0. secs (0.u,0.s)
Chars 16217 - 16278 [#[global]Instance~QLe_dec~:~(f...] 0. secs (0.u,0.s)
Chars 16279 - 16285 [Proof.] 0. secs (0.u,0.s)
rewrite if_dtt
if (n1 + x <? n1)
then (fun E0 : (n1 + x <? n1) = true => AA (ltN_of_nat (n1 + x) n1 E0))
else
(fun E0 : (n1 + x <? n1) = false =>
 BB (ltN_of_nat (n1 + x - n1) n2 (ltN_split_lemma1 (plus_ltN_lemma1 e) E0)))
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeoutfind_witness Control.TimeoutChars 16286 - 16321 [(intros~q~r;~destruct~(le_or_l...] 40.225 secs (0.021u,0.048s)
Chars 16322 - 16323 [-] 0. secs (0.u,0.s)
Chars 16324 - 16337 [(left;~trivial).] 0.002 secs (0.001u,0.s)
Chars 16338 - 16339 [-] 0. secs (0.u,0.s)
Chars 16340 - 16355 [(right;~intros~?).] 0.002 secs (0.002u,0.s)
Chars 16356 - 16383 [(apply~(irreflexivity~lt~q)).] 0.013 secs (0.011u,0.002s)
Chars 16386 - 16419 [(apply~le_lt_trans~with~r;~tri...] 0.012 secs (0.011u,0.s)
Chars 16286 - 16321 [(intros~q~r;~destruct~(le_or_l...] 0.001 secs (0.001u,0.s)
Chars 16324 - 16337 [(left;~trivial).] 0.001 secs (0.001u,0.s)
Chars 16340 - 16355 [(right;~intros~?).] 0.001 secs (0.001u,0.s)
Chars 16356 - 16383 [(apply~(irreflexivity~lt~q)).] 0. secs (0.u,0.s)
Chars 16386 - 16419 [(apply~le_lt_trans~with~r;~tri...] 0.001 secs (0.u,0.s)
Chars 16420 - 16424 [Qed.] 0.001 secs (0.001u,0.s)
Chars 16426 - 16486 [#[global]Instance~QLt_dec~:~(f...] 0. secs (0.u,0.s)
Chars 16487 - 16493 [Proof.] 0. secs (0.u,0.s)
Chars 16494 - 16529 [(intros~q~r;~destruct~(le_or_l...] 4.846 secs (0.009u,0.047s)
Chars 16530 - 16531 [-] 0. secs (0.u,0.s)
Chars 16532 - 16547 [(right;~intros~?).] 0.002 secs (0.002u,0.s)
Chars 16548 - 16575 [(apply~(irreflexivity~lt~q)).] 0.013 secs (0.011u,0.001s)
Chars 16578 - 16611 [(apply~lt_le_trans~with~r;~tri...] 0.013 secs (0.011u,0.001s)
Chars 16612 - 16613 [-] 0. secs (0.u,0.s)
Chars 16614 - 16627 [(left;~trivial).] 0.002 secs (0.002u,0.s)
Chars 16494 - 16529 [(intros~q~r;~destruct~(le_or_l...] 0.001 secs (0.001u,0.s)
Chars 16532 - 16547 [(right;~intros~?).] 0.001 secs (0.u,0.s)
Chars 16548 - 16575 [(apply~(irreflexivity~lt~q)).] 0. secs (0.u,0.s)
Chars 16578 - 16611 [(apply~lt_le_trans~with~r;~tri...] 0.001 secs (0.001u,0.s)
Chars 16614 - 16627 [(left;~trivial).] 0.001 secs (0.u,0.s)
Chars 16628 - 16632 [Qed.] 0.001 secs (0.001u,0.s)
Chars 16634 - 16653 [Section~enumerable.] 0. secs (0.u,0.s)
Chars 16654 - 16678 [Context~`{Enumerable~Q}.] 0. secs (0.u,0.s)
Chars 16680 - 16719 [Definition~Qpos_enumerator~:~n...] 0. secs (0.u,0.s)
Chars 16720 - 16726 [Proof.] 0. secs (0.u,0.s)
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_flatTM)
"open obligation cnstr_flatTM0_term for it. You might want to register a instance before and rerun this."
Chars 16727 - 16736 [(intros~n).] 0.476 secs (0.u,0.045s)
Chars 16737 - 16785 [(destruct~(le_or_lt~(enumerato...] 0.012 secs (0.011u,0.001s)
Chars 16786 - 16787 [-] 0. secs (0.u,0.s)
Chars 16788 - 16796 [exact~1.] 0.001 secs (0.001u,0.s)
Chars 16797 - 16798 [-] 0. secs (0.u,0.s)
Chars 16799 - 16831 [(exists~(enumerator~Q~n);~triv...] 0.002 secs (0.002u,0.s)
Chars 16727 - 16736 [(intros~n).] 0. secs (0.u,0.s)
Chars 16737 - 16785 [(destruct~(le_or_lt~(enumerato...] 0. secs (0.u,0.s)
Chars 16788 - 16796 [exact~1.] 0. secs (0.u,0.s)
Chars 16799 - 16831 [(exists~(enumerator~Q~n);~triv...] 0.001 secs (0.001u,0.s)
Chars 16832 - 16840 [Defined.] 0. secs (0.u,0.s)
Chars 16842 - 16922 [Lemma~Qpos_is_enumerator~:~IsC...] 0. secs (0.u,0.s)
Chars 16923 - 16929 [Proof.] 0. secs (0.u,0.s)
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
find_witness Control.TimeoutMore readable: initial segment:
@nil
With remainder:
[Ast.tRel 1]
Chars 16930 - 16954 [(apply~BuildIsSurjection).] 40.207 secs (0.001u,0.047s)
Chars 16955 - 16969 [(unfold~hfiber).] 0. secs (0.u,0.s)
Chars 16970 - 17030 [(intros~e;~generalize~(@center...] 0.003 secs (0.002u,0.s)
Chars 17031 - 17051 [(apply~(Trunc_ind~_)).] 0.039 secs (0.036u,0.002s)
Chars 17052 - 17065 [(intros~[n~E]).] 0.001 secs (0.001u,0.s)
Chars 17066 - 17084 [(apply~tr;~exists~n).] 0.003 secs (0.003u,0.s)
Chars 17085 - 17108 [(unfold~Qpos_enumerator).] 0.001 secs (0.001u,0.s)
Chars 17109 - 17159 [(destruct~(le_or_lt~(enumerato...] 0.008 secs (0.007u,0.s)
Chars 17160 - 17161 [-] 0. secs (0.u,0.s)
Chars 17162 - 17192 [(destruct~(irreflexivity~lt~0)).] 0.015 secs (0.012u,0.002s)
Chars 17193 - 17241 [(apply~lt_le_trans~with~(enume...] 0.014 secs (0.013u,0.s)
Chars 17244 - 17270 [(rewrite~E;~solve_propholds).] 0.003 secs (0.002u,0.001s)
Chars 17271 - 17272 [-] 0. secs (0.u,0.s)
Chars 17273 - 17288 [(apply~pos_eq,~E).] 0.001 secs (0.001u,0.s)
Chars 16930 - 16954 [(apply~BuildIsSurjection).] 0. secs (0.u,0.s)
Chars 16955 - 16969 [(unfold~hfiber).] 0. secs (0.u,0.s)
Chars 16970 - 17030 [(intros~e;~generalize~(@center...] 0.001 secs (0.001u,0.s)
Chars 17031 - 17051 [(apply~(Trunc_ind~_)).] 0. secs (0.u,0.s)
Chars 17052 - 17065 [(intros~[n~E]).] 0. secs (0.u,0.s)
Chars 17066 - 17084 [(apply~tr;~exists~n).] 0.001 secs (0.001u,0.s)
Chars 17085 - 17108 [(unfold~Qpos_enumerator).] 0. secs (0.u,0.s)
Chars 17109 - 17159 [(destruct~(le_or_lt~(enumerato...] 0.001 secs (0.001u,0.s)
Chars 17162 - 17192 [(destruct~(irreflexivity~lt~0)).] 0. secs (0.u,0.s)
Chars 17193 - 17241 [(apply~lt_le_trans~with~(enume...] 0.002 secs (0.002u,0.s)
Chars 17244 - 17270 [(rewrite~E;~solve_propholds).] 0.001 secs (0.001u,0.s)
Chars 17273 - 17288 [(apply~pos_eq,~E).] 0. secs (0.u,0.s)
Chars 17289 - 17293 [Qed.] 0.003 secs (0.003u,0.s)
Chars 17295 - 17359 [#[global]Instance~Qpos_enumera...] 0. secs (0.u,0.s)
Chars 17360 - 17366 [Proof.] 0. secs (0.u,0.s)
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
More readable: initial segment:
decode_prod
With remainder:
[]
"Did not find an instance for "
(extracted decode)
"open obligation var_decode_term for it. You might want to register a instance before and rerun this."
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
More readable: initial segment:
decode_prod
With remainder:
[]
"Did not find an instance for "
(extracted decode)
"open obligation var_decode_term for it. You might want to register a instance before and rerun this."
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
find_witness Control.TimeoutMore readable: initial segment:
decode_prod
With remainder:
[]
"Did not find an instance for "
(extracted decode)
"open obligation var_decode_term for it. You might want to register a instance before and rerun this."
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
"Did not find an instance for "
(extracted decode)
"open obligation var_decode_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
decode_prod
With remainder:
[]
"Did not find an instance for "
(extracted decode)
"open obligation var_decode_term for it. You might want to register a instance before and rerun this."
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
find_witness Control.TimeoutMore readable: initial segment:
decode_prod
With remainder:
[]
"Did not find an instance for "
(extracted decode)
"open obligation var_decode_term for it. You might want to register a instance before and rerun this."
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
find_witness Control.TimeoutMore readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
"Did not find an instance for "
(extracted decode)
"open obligation var_decode_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
decode_prod
With remainder:
[]
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
More readable: initial segment:
decode_prod
With remainder:
[]
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
"Did not find an instance for "
(extracted decode)
"open obligation var_decode_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
decode_prod
With remainder:
[]
"Did not find an instance for "
(extracted decode)
"open obligation var_decode_term for it. You might want to register a instance before and rerun this."
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
recRel_prettify_arith_step
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
recRel_prettify_arith_step
More readable: initial segment:
decode_prod
With remainder:
[]
More readable: initial segment:
decode_prod
With remainder:
[]
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Chars 17369 - 17392 [exists~Qpos_enumerator.] 40.184 secs (0.u,0.045s)
Chars 17395 - 17481 [(first~~[~exact~Qpos_is_enumer...] 0.001 secs (0.001u,0.s)
Chars 17369 - 17392 [exists~Qpos_enumerator.] 0. secs (0.u,0.s)
Chars 17395 - 17481 [(first~~[~exact~Qpos_is_enumer...] 0. secs (0.u,0.s)
Chars 17482 - 17486 [Qed.] 0. secs (0.u,0.s)
Chars 17488 - 17503 [End~enumerable.] 0.032 secs (0.024u,0.006s)
find_witness Control.TimeoutChars 17505 - 17518 [End~contents.] 0.71 secs (0.65u,0.058s)
Chars 17520 - 17543 [Arguments~Qpos~Q~{_~_}.] 0. secs (0.u,0.s)
More readable: initial segment:
decode_prod
With remainder:
[]
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
recRel_prettify_arith_step
rewrite if_dtt
if (x0 <? n)
then
(fun E0 : (x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) x0 E0))
else
(fun E0 : (x0 <? n) = false =>
 BB (exist (fun k : nat => (k <? 0) = true) (x0 - n) (ltN_split_lemma1 e E0)))
destruct  (Nat.add_0_r n)  in  x
recRel_prettify_arith_step
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
More readable: initial segment:
decode_sum
With remainder:
[]
More readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
find_witness Control.Timeoutrewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
More readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
More readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
recRel_prettify_arith_step
More readable: initial segment:
decode_sum
With remainder:
[]
More readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if match n1 with
   | 0 => false
   | S m' => x <=? m'
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = false => BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 e E0)))
recRel_prettify_arith_step
More readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
More readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
More readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
More readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if match n1 with
   | 0 => false
   | S m' => x <=? m'
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = false => BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 e E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
More readable: initial segment:
decode_sum
With remainder:
[]
More readable: initial segment:
decode_sum
With remainder:
[]
find_witness Control.TimeoutMore readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if match n1 with
   | 0 => false
   | S m' => x <=? m'
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = false => BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 e E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
"Did not find an instance for "
(extracted encodable_move_enc)
"open obligation encodable_move_enc_term for it. You might want to register a instance before and rerun this."
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
"Did not find an instance for "
(extracted encodable_move_enc)
"open obligation encodable_move_enc_term for it. You might want to register a instance before and rerun this."
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if match n1 with
   | 0 => false
   | S m' => x <=? m'
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = false => BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 e E0)))
More readable: initial segment:
decode_sum
With remainder:
[]
More readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
More readable: initial segment:
decode_sum
With remainder:
[]
recRel_prettify_arith_step
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if match n1 with
   | 0 => false
   | S m' => x <=? m'
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = false => BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 e E0)))
More readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
More readable: initial segment:
decode_sum
With remainder:
[]
More readable: initial segment:
decode_sum
With remainder:
[]
More readable: initial segment:
decode_sum
With remainder:
[]
More readable: initial segment:
decode_sum
With remainder:
[]
rewrite if_dtt
if match n1 with
   | 0 => false
   | S m' => x <=? m'
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = false => BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 e E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
     = ret 2.8754776337791554e-14%float
     : E FF
     = ret 1.1539903023827236e-05%float
     : E FF
     = ret
         {|
           approx.pol :=
             [[[109.9761759193364; 109.9761759193364]];
              [[91.024979933356605; 91.024979933356605]];
              [[-0.013094741799676513; -0.013094741799676513]];
              [[0.0068657782589525594; 0.0068657782589525594]];
              [[-0.0036010109553458848; -0.0036010109553458848]];
              [[0.0018905493185753925; 0.0018905493185753925]];
              [[-0.00099590478953359707; -0.00099590478953359707]];
              [[0.00053090310183563356; 0.00053090310183563356]];
              [[-0.00029486341253459614; -0.00029486341253459614]];
              [[0.011210177712916903; 0.011210177712916903]];
              [[0.026815037081536274; 0.026815037081536274]]];
           approx.rem := [[-0.074844644956674256; 0.074844644956674242]];
           approx.cont := true
         |}
     : Static.sval (chebyshev_model_ops (fromZ 18) (fromZ 200)) FUN
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
     = ret (Specific_ops.Float 5567862537815687%Z (-58)%Z)
     : E FF
Finished transaction in 0.95 secs (0.891u,0.057s) (successful)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
find_witness Control.Timeout     = ret (Specific_ops.Float 5567862537815687%Z (-57)%Z)
     : E FF
Finished transaction in 0.828 secs (0.824u,0.002s) (successful)
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
     = ret
         {|
           approx.pol :=
             [[[Specific_ops.Float 720357451616277761%Z (-58)%Z;
              Specific_ops.Float 720357451616277761%Z (-58)%Z]];
              [[Specific_ops.Float 1094558786233859380%Z (-58)%Z;
              Specific_ops.Float 1094558786233859380%Z (-58)%Z]];
              [[Specific_ops.Float 977308976456680341%Z (-59)%Z;
              Specific_ops.Float 977308976456680341%Z (-59)%Z]];
              [[Specific_ops.Float 911430244636437681%Z (-61)%Z;
              Specific_ops.Float 911430244636437681%Z (-61)%Z]];
              [[Specific_ops.Float (-875073714472971280)%Z (-63)%Z;
              Specific_ops.Float (-875073714472971280)%Z (-63)%Z]];
              [[Specific_ops.Float (-749224186984049261)%Z (-62)%Z;
              Specific_ops.Float (-749224186984049261)%Z (-62)%Z]];
              [[Specific_ops.Float (-922337203685477604)%Z (-63)%Z;
              Specific_ops.Float (-922337203685477604)%Z (-63)%Z]];
              [[Specific_ops.Float (-692452066805713429)%Z (-64)%Z;
              Specific_ops.Float (-692452066805713429)%Z (-64)%Z]];
              [[Specific_ops.Float (-756215827400101205)%Z (-67)%Z;
              Specific_ops.Float (-756215827400101205)%Z (-67)%Z]];
              [[Specific_ops.Float 698045379138553685%Z (-67)%Z;
              Specific_ops.Float 698045379138553685%Z (-67)%Z]];
              [[Specific_ops.Float 684621429539735211%Z (-67)%Z;
              Specific_ops.Float 684621429539735211%Z (-67)%Z]];
              [[Specific_ops.Float 733842578068733952%Z (-68)%Z;
              Specific_ops.Float 733842578068733952%Z (-68)%Z]];
              [[Specific_ops.Float 894929973254551552%Z (-69)%Z;
              Specific_ops.Float 894929973254551552%Z (-69)%Z]]];
           approx.rem :=
             [[Specific_ops.Float (-929534692799689239)%Z (-69)%Z;
             Specific_ops.Float 929534692799689239%Z (-69)%Z]];
           approx.cont := true
         |}
     : Static.sval chebyshev11_model_ops FUN
Finished transaction in 1.192 secs (1.189u,0.001s) (successful)
recRel_prettify_arith_step
     = ret
         {|
           approx.pol :=
             [[[Specific_ops.Float 720357451616277761%Z (-57)%Z;
              Specific_ops.Float 720357451616277761%Z (-57)%Z]];
              [[Specific_ops.Float 1094558786233859380%Z (-57)%Z;
              Specific_ops.Float 1094558786233859380%Z (-57)%Z]];
              [[Specific_ops.Float 977308976456680341%Z (-58)%Z;
              Specific_ops.Float 977308976456680341%Z (-58)%Z]];
              [[Specific_ops.Float 911430244636437681%Z (-60)%Z;
              Specific_ops.Float 911430244636437681%Z (-60)%Z]];
              [[Specific_ops.Float (-875073714472971280)%Z (-62)%Z;
              Specific_ops.Float (-875073714472971280)%Z (-62)%Z]];
              [[Specific_ops.Float (-749224186984049261)%Z (-61)%Z;
              Specific_ops.Float (-749224186984049261)%Z (-61)%Z]];
              [[Specific_ops.Float (-922337203685477604)%Z (-62)%Z;
              Specific_ops.Float (-922337203685477604)%Z (-62)%Z]];
              [[Specific_ops.Float (-692452066805713429)%Z (-63)%Z;
              Specific_ops.Float (-692452066805713429)%Z (-63)%Z]];
              [[Specific_ops.Float (-756215827400101205)%Z (-66)%Z;
              Specific_ops.Float (-756215827400101205)%Z (-66)%Z]];
              [[Specific_ops.Float 698045379138553685%Z (-66)%Z;
              Specific_ops.Float 698045379138553685%Z (-66)%Z]];
              [[Specific_ops.Float 684621429539735211%Z (-66)%Z;
              Specific_ops.Float 684621429539735211%Z (-66)%Z]];
              [[Specific_ops.Float 733842578068733952%Z (-67)%Z;
              Specific_ops.Float 733842578068733952%Z (-67)%Z]];
              [[Specific_ops.Float 894929973254551552%Z (-68)%Z;
              Specific_ops.Float 894929973254551552%Z (-68)%Z]]];
           approx.rem :=
             [[Specific_ops.Float (-929534692799689239)%Z (-68)%Z;
             Specific_ops.Float 929534692799689239%Z (-68)%Z]];
           approx.cont := true
         |}
     : Static.sval chebyshev11_model_ops FUN
Finished transaction in 1.221 secs (1.203u,0.016s) (successful)
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if true]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if false]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
find_witness Control.TimeoutCrunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
specialized IHeP using (eq_refl e )
specialized IHeP2 using (eq_refl e0 )
specialized IHeP1 using (eq_refl e )
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
"Did not find an instance for "
(extracted encodable_flatTM_enc)
"open obligation encodable_flatTM_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_flatTM_enc)
"open obligation encodable_flatTM_enc_term for it. You might want to register a instance before and rerun this."
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (I 1 = list2D_to_matrix [[C1]])
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (I 1 = list2D_to_matrix [[C1]])
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching:
((fun x z : nat => Σ (fun y : nat => ⟨ 0 ∣ x y * ∣ 0 ⟩ y z) 2) = I 1)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩)
"Did not find an instance for "
(extracted encodable_flatTM_enc)
"open obligation encodable_flatTM_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_flatTM_enc)
"open obligation encodable_flatTM_enc_term for it. You might want to register a instance before and rerun this."
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × (/ √ IZR (Z.succ (Z.succ 0)) .* ∣0⟩))
Crunching: (pad start dim A x e1 = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching: (pad start dim A Hx y = 0)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (Cmod2 Hx = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (Cmod2 Hx = 0)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩)
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching:
(hadamard x 0%nat * (/ √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩) 0%nat 0%nat +
 hadamard x 1%nat * (/ √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩) 1%nat 0%nat =
 ∣ 0 ⟩ x 0%nat)
Crunching:
(hadamard x 0%nat * (/ √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩) 0%nat y +
 hadamard x 1%nat * (/ √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩) 1%nat y = 
 ∣ 0 ⟩ x y)
Crunching: False
Crunching: (Cmod2 Hx = 0)
Crunching: (n < 0 -> √ (n + l) <= √ n + √ l)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩)
Crunching: (n < 0 -> √ (n + l) <= √ n + √ l)
Crunching:
(forall x : nat -> nat,
 (forall x0 : nat,
  x0 < H3 -> b x0 < H3 /\ x x0 < H3 /\ x (b x0) = x0 /\ b (x x0) = x0) ->
 permutation H3 (a ∘ b)%prg)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
find_witness Control.TimeoutCrunching:
(forall x : nat -> nat,
 (forall x0 : nat,
  x0 < H3 -> b x0 < H3 /\ x x0 < H3 /\ x (b x0) = x0 /\ b (x x0) = x0) ->
 permutation H3 (a ∘ b)%prg)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (permutation k H5 -> permutation k (kM ∘ H5)%prg)
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching: (a - b - n = 0)
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (pad 0 x (I 2) = I (2 ^ x))
Crunching: (1 = 0)
Crunching:
((forall r1 r2 : R, r1 < r2 -> ~ r2 < r1) ->
 (forall r1 r2 : R, r1 < r2 \/ r1 > r2 -> r1 <> r2) ->
 forall p q : positive,
 Z.abs_N (Z.rem (Z.pos p) (Z.pos q)) = (N.pos p mod N.pos q)%N)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (∣1⟩ = basis_vector 2 1)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (pad 0 x (I 2) = I (2 ^ x))
Crunching:
((0 >= 2 ^ alpha)%nat \/ (0 >= 2 ^ alpha)%nat ->
 pad 0 alpha (I 2) 0%nat 0%nat = 0)
Crunching: (n - (n - z) - z = 0)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.001s) (failure)
Crunching: (n - c - H = 0)
Crunching: (1 = 0)
Crunching: (1 = 0)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching: (1 = 0)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching: (1 = 0)
Crunching: (x < S n -> f x = n -> permutation n (fswap f x n))
Crunching: (WF_Matrix (pad 0 1 (I 2)))
Crunching: (WF_Matrix (pad 0 1 (I 2)))
Crunching:
((if 0 + 1 <=? alpha
  then I (2 ^ 0) ⊗ I 2 ⊗ I (2 ^ (alpha - (0 + 1)))
  else Zero) = I (2 ^ alpha))
clear  H0  :  (False -> cB (map (rec a1)) a1 = Lt)
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching:
(permutation (b 0)
   (fun i : nat => if i =? 0 then b (b 0) else if i =? b 0 then b 0 else b i))
Crunching:
(permutation (b 0)
   (fun i : nat => if i =? 0 then b (b 0) else if i =? b 0 then b 0 else b i))
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
find_witness Control.TimeoutCrunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching: (f ⨂ hadamard × Hx = f ⨂ n)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (x < S n -> f x = n -> permutation n (fswap f x n))
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (X ⨂ hadamard × X ⨂ ∣0⟩ = ?y)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
find_witness Control.TimeoutCrunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pad_u n v le x y = 0)
Crunching: False
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
Crunching:
((forall (x : R) (n : nat), cos_approx x n = cos_approx (- x) n) -> False)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching:
((Hfalse < 2)%nat -> (H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
Crunching: (0 < cos (7 / 8))
Crunching: (0 < cos (7 / 8))
Crunching: (0 < cos (7 / 8))
Crunching:
((forall z : R, cond_positivity z = false <-> z < 0) ->
 (hn0 < 1)%nat -> (σx × ∣ 0 ⟩) h hn0 = ∣ 1 ⟩ h hn0)
Crunching: (0 < cos (7 / 8))
Crunching: (pad_u n v le V0 H11 = 0)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) i j = ∣ 1 ⟩ i j)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: (x0 = a x0)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: (pad_u n v le V0 H11 = 0)
Crunching: ((σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching: ((p < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
Crunching:
((Hfalse < 2)%nat -> (H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
Crunching:
(forall y0 : nat,
 (y >= 2 ^ 0)%nat \/ (y0 >= 2 ^ 0)%nat -> pad_u 0 v le y y0 = 0)
Crunching: ((H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching:
((forall z : R, cond_positivity z = false <-> z < 0) ->
 (hn0 < 1)%nat -> (σx × ∣ 0 ⟩) h hn0 = ∣ 1 ⟩ h hn0)
Crunching: (((R0 < R0)%R -> False) -> S ?x@{n:=0} <= 0)
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching:
((Hfalse < 2)%nat -> (H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(forall y : nat,
 (0 >= 2 ^ l)%nat \/ (y >= 2 ^ l)%nat -> pad_ctrl l IN f z1 0%nat y = 0)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching:
((forall z : R, cond_positivity z = false <-> z < 0) ->
 (hn0 < 1)%nat -> (σx × ∣ 0 ⟩) h hn0 = ∣ 1 ⟩ h hn0)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) i j = ∣ 1 ⟩ i j)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: ((LE < 2)%nat -> (x < 1)%nat -> (σx × ∣ 0 ⟩) LE x = ∣ 1 ⟩ LE x)
Crunching: ((eps < 1)%nat -> (σx × ∣ 0 ⟩) LE eps = ∣ 1 ⟩ LE eps)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) i j = ∣ 1 ⟩ i j)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching: (0 < 1 -> σx × ∣ 0 ⟩ = ∣ 1 ⟩)
Crunching: (m >= n \/ Hm >= n -> perm_mat n p m Hm = 0%R)
Crunching: ((σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching: ((σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((p < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching: (R_dist (?Un H4) (a + n)%G < contra)
Crunching: ((Hi < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse Hi = ∣ 1 ⟩ Hfalse Hi)
find_witness Control.TimeoutCrunching: (x >= a \/ y >= a -> perm_mat a b x y = 0%R)
Crunching: (list2D_to_matrix [[e]; [e0]] = σy × ∣ 0 ⟩)
Crunching: (m >= n -> perm_mat n p m Hm = 0%R)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (0 = cv - n - m)
Crunching: (cv - n - m = 0)
Crunching: (0 = cv - n - m)
Crunching: (cv - n - m = 0)
Crunching:
(forall y : nat,
 (r >= 2 ^ start)%nat \/ (y >= 2 ^ start)%nat -> pad_ctrl start b p q r y = 0)
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
Crunching: ((σy × ∣ 0 ⟩) n H = 0)
Crunching:
(- 0 <
 big_sum (fun i : nat => match i with
                         | 0%nat => x
                         | S m => nth m y 0
                         end) (length y) +
 match length y with
 | 0%nat => x
 | S m => nth m y 0
 end)
Crunching: (m >= n \/ Hm >= n -> perm_mat n p m Hm = 0%R)
Crunching: (list2D_to_matrix [[e]; [e0]] = σy × ∣ 0 ⟩)
Crunching:
(- 0 <= big_sum (fun i : nat => nth i (x :: y) 0) (length (x :: y)))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (forall m n : nat, WF_Matrix (pad_swap Hfalse m n))
out of reach
Tactic call ran for 0.005 secs (0.001u,0.003s) (failure)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (pad_swap m x n x0 0%nat = 0)
could not simplify some occuring term, shelved instead
Crunching: (forall m n : nat, WF_Matrix (pad_swap Hfalse m n))
More readable: initial segment:
[]
With remainder:
[]
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
More readable: initial segment:
[]
With remainder:
[]
Crunching: (1%R = 1%R -> 1%R = 1%R -> perm_mat n m 0 H4 = 0%R)
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
out of reach
Tactic call ran for 0.024 secs (0.012u,0.011s) (failure)
Crunching: ((σy × ∣ 0 ⟩) 0%nat 0%nat = 0)
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
could not simplify some occuring term, shelved instead
Crunching: ((σy × ∣ 0 ⟩) 0%nat 0%nat = 0)
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
Crunching: ((σy × ∣ 0 ⟩) 0%nat 0%nat = 0)
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> WF_Unitary (perm_mat n p))
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> WF_Unitary (perm_mat n p))
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Crunching: ((σy × ∣ 0 ⟩) 0%nat 0%nat = 0)
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> WF_Unitary (perm_mat n p))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
More readable: initial segment:
[]
With remainder:
[]
Crunching: (~ (forall r : R, (sample r0 r <= length r0)%nat))
More readable: initial segment:
[]
With remainder:
[]
Crunching: ((r0 < 1)%nat -> (σz × ∣ 0 ⟩) r r0 = ∣ 0 ⟩ r r0)
More readable: initial segment:
[]
With remainder:
[]
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
Crunching:
(forall j : nat,
 (H0 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H0 j = ∣ 0 ⟩ H0 j)
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(forall j : nat,
 (s2 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) s2 j = ∣ 0 ⟩ s2 j)
More readable: initial segment:
[]
With remainder:
[]
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Crunching: (up (INR n) = Z.succ (Z.of_nat n) -> WF_Unitary (perm_mat n p))
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
Crunching:
(forall j : nat,
 (H1 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H1 j = ∣ 0 ⟩ H1 j)
More readable: initial segment:
[]
With remainder:
[]
Crunching: ((r0 < 1)%nat -> (σz × ∣ 0 ⟩) r r0 = ∣ 0 ⟩ r r0)
Crunching:
(forall j : nat,
 (H0 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H0 j = ∣ 0 ⟩ H0 j)
Crunching: (forall m n : nat, WF_Matrix (pad_swap Hfalse m n))
find_witness Control.TimeoutCrunching: (sample a EQ <= length a)%nat
Crunching:
(forall j : nat,
 (s2 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) s2 j = ∣ 0 ⟩ s2 j)
Crunching: (~ (forall r : R, (sample r0 r <= length r0)%nat))
Crunching: (1 <= 4)
Crunching: (cos_in 0 (cos 0) -> WF_Unitary Ha -> WF_Unitary (pad n m Ha))
Crunching: (WF_Unitary (pad n m Ha))
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
Crunching:
((N3 + Hb <= H10)%nat -> WF_Unitary H -> WF_Unitary (pad N3 H10 H))
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching: (WF_Unitary (pad HQ0 (HQ0 + l) HQP))
Crunching:
((l1' < 2)%nat ->
 (e < 1)%nat ->
 0 + σz l1' 0%nat * match e with
                    | 0%nat => C1
                    | S _ => 0
                    end + σz l1' 1%nat * match e with
                                         | 0%nat | _ => 0
                                         end = ∣0⟩ l1' e)
Crunching:
((l1' < 2)%nat ->
 (e < 1)%nat ->
 0 + σz l1' 0%nat * match e with
                    | 0%nat => C1
                    | S _ => 0
                    end + σz l1' 1%nat * match e with
                                         | 0%nat | _ => 0
                                         end = ∣0⟩ l1' e)
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
Crunching:
((l1' < 2)%nat ->
 (e < 1)%nat ->
 0 + σz l1' 0%nat * match e with
                    | 0%nat => C1
                    | S _ => 0
                    end + σz l1' 1%nat * match e with
                                         | 0%nat | _ => 0
                                         end = ∣0⟩ l1' e)
Crunching: (perm_mat Hn H s2 n = 0%R)
Crunching: (perm_mat Hn H s2 n = 0%R)
Crunching: (perm_mat Hn H s2 n = 0%R)
Crunching: (perm_mat Hn H s2 n = 0%R)
Crunching: (perm_mat Hn H s2 n = 0%R)
Crunching: (perm_mat Hn H s2 n = 0%R)
Crunching:
(forall j : nat,
 (H17 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H17 j = ∣ 0 ⟩ H17 j)
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> WF_Unitary (perm_mat n p))
Crunching:
((H17 < 2)%nat -> (He < 1)%nat -> (σz × ∣ 0 ⟩) H17 He = ∣ 0 ⟩ H17 He)
Crunching: (cos_in 0 (cos 0) -> WF_Unitary Ha -> WF_Unitary (pad n m Ha))
Crunching: (WF_Unitary (pad n m Ha))
Crunching:
((x < 2)%nat ->
 (n < 1)%nat -> Σ (fun y : nat => σz x y * ∣ 0 ⟩ y n) 2 = ∣ 0 ⟩ x n)
Crunching: ((x < 2)%nat -> (n < 1)%nat -> (σz × ∣ 0 ⟩) x n = ∣ 0 ⟩ x n)
Crunching:
((x < 2)%nat -> (0 < 1)%nat -> (σz × ∣ 0 ⟩) x 0%nat = ∣ 0 ⟩ x 0%nat)
Crunching:
(forall j : nat,
 (H1 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H1 j = ∣ 0 ⟩ H1 j)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Crunching: (WF_Unitary (pad esp contra Ha))
Crunching: ((m < 1)%nat -> (σz × ∣ 0 ⟩) H1 m = ∣ 0 ⟩ H1 m)
Crunching: (S (sample l' alp_f1d) <= length l')%nat
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (pad N1 HN1 H a y = 0)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((- b + 0)%R = (- b)%R ->
 (0 + - b)%R = (- b)%R -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 g)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ g)%prg)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (perm_mat 0 (EQ ∘ psi1)%prg = list2D_to_matrix [])
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (perm_mat 0 (EQ ∘ psi1)%prg = list2D_to_matrix [])
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Crunching: (S (sample l' alp_f1d) <= length l')%nat
Crunching:
((N3 + Hb <= H10)%nat -> WF_Unitary H -> WF_Unitary (pad N3 H10 H))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (0 <= E1 < sum_over_list [] -> (0 < 0)%nat)
Crunching: (perm_mat Hyp n × perm_mat Hyp H = perm_mat Hyp (n ∘ H)%prg)
Crunching: (perm_mat Hyp n × perm_mat Hyp H = perm_mat Hyp (n ∘ H)%prg)
rewrite if_dtt
if (pA a)
then (fun E : pA a = true => p (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(n = 0 ->
 forall g : nat -> nat,
 permutation 0 g -> perm_mat 0 m × perm_mat 0 g = perm_mat 0 (m ∘ g)%prg)
Crunching:
(0%nat <> 2%nat ->
 WF_Matrix (pad_u m Hm a) /\ (pad_u m Hm a) † × pad_u m Hm a = I (2 ^ m))
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => IZR (Z.succ (-1))
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => IZR (Z.succ (-1))
             end
  | S (S _) => IZR (Z.succ (-1))
  end) × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((- b + 0)%R = (- b)%R ->
 (0 + - b)%R = (- b)%R -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift e2 × ∣ b ⟩)
Crunching: (forall b : bool, phase_shift e2 × ∣ b ⟩ = Cexp (b * e2) .* ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift e2 × ∣ b ⟩)
Crunching:
((phase_shift m × ∣ ϕ ⟩) 0%nat 0%nat = (Cexp (ϕ * m) .* ∣ ϕ ⟩) 0%nat 0%nat)
Crunching:
((phase_shift m × ∣ contra ⟩) 0%nat 0%nat =
 (Cexp (contra * m) .* ∣ contra ⟩) 0%nat 0%nat)
Crunching:
((phase_shift m × ∣ a ⟩) 0%nat 0%nat = (Cexp (a * m) .* ∣ a ⟩) 0%nat 0%nat)
Crunching: (ConstructiveCauchyReals.CRealLtProp (Rrepr 0) (Rrepr 0))
Crunching: False
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => IZR (Z.succ (-1))
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => IZR (Z.succ (-1))
             end
  | S (S _) => IZR (Z.succ (-1))
  end) × ∣ b ⟩)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 g)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ g)%prg)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (perm_mat 0 (EQ ∘ psi1)%prg = list2D_to_matrix [])
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Tactic call ran for 0.01 secs (0.009u,0.001s) (success)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (perm_mat 0 (EQ ∘ psi1)%prg = list2D_to_matrix [])
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((- b + 0)%R = (- b)%R ->
 (0 + - b)%R = (- b)%R -> Cexp (b * θ) .* ∣ b ⟩ = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((- b + 0)%R = (- b)%R ->
 (0 + - b)%R = (- b)%R -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((- b + √ 0)%R = (- b)%R ->
 (√ 0 + - b)%R = (- b)%R -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0 => 0
    | S n' => (big_sum G H f n' + f n')%G
    end) C C_is_monoid
   (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp n y0 y)%C) Hyp =
 perm_mat Hyp (m ∘ n)%prg x y)
Crunching: (S (sample l' alp_f1d) <= length l')%nat
Crunching: (S (sample l' alp_f1d) <= length l')%nat
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp =
 perm_mat Hyp (m ∘ ϕ)%prg x y)
Crunching:
(perm_mat Hyp (m ∘ ϕ)%prg x y =
 Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp)
Crunching:
(Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp =
 perm_mat Hyp (m ∘ ϕ)%prg x y)
Tactic call ran for 0.01 secs (0.009u,0.001s) (success)
Crunching:
(perm_mat Hyp (m ∘ ϕ)%prg x y =
 Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp)
Crunching:
(Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp =
 perm_mat Hyp (m ∘ ϕ)%prg x y)
Crunching:
(perm_mat Hyp (m ∘ ϕ)%prg x y =
 Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp)
Crunching: (m < n)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = phase_shift op × ∣ n ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift e2 × ∣ b ⟩)
Crunching: (forall b : bool, phase_shift e2 × ∣ b ⟩ = Cexp (b * e2) .* ∣ b ⟩)
Crunching: (forall x y : R, Rabs x < Rabs y -> y > 0 -> x < y)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift e2 × ∣ b ⟩)
Crunching: (0 < 0)%nat
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
Crunching:
((phase_shift m × ∣ ϕ ⟩) 0%nat 0%nat = (Cexp (ϕ * m) .* ∣ ϕ ⟩) 0%nat 0%nat)
Crunching:
((phase_shift m × ∣ contra ⟩) 0%nat 0%nat =
 (Cexp (contra * m) .* ∣ contra ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift m × ∣ contra ⟩)
find_witness Control.TimeoutCrunching:
((phase_shift m × ∣ a ⟩) 0%nat 0%nat = (Cexp (a * m) .* ∣ a ⟩) 0%nat 0%nat)
Crunching:
(forall y : nat, (EQ >= 1)%nat \/ (y >= 1)%nat -> pad_u 0 Hm Hn EQ y = 0)
Crunching: (WF_Unitary Hn -> WF_Unitary (pad_u 0 Hm Hn))
Crunching: (0 <= E1 < sum_over_list [] -> (0 < 0)%nat)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => IZR (Z.succ (-1))
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => IZR (Z.succ (-1))
             end
  | S (S _) => IZR (Z.succ (-1))
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => IZR (Z.succ (-1))
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => IZR (Z.succ (-1))
             end
  | S (S _) => IZR (Z.succ (-1))
  end) × ∣ b ⟩)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
Crunching: (sum_over_list [a] <= X -> sample [a] X = length [a])
Crunching: (perm_mat L R = I L)
Crunching: (perm_mat m Streicher_K = I m)
Crunching:
((hadamard × ∣ b ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ b .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching:
(0%nat <> 2%nat ->
 WF_Matrix (pad_u m Hm a) /\ (pad_u m Hm a) † × pad_u m Hm a = I (2 ^ m))
Crunching:
(fst ((hadamard × ∣ p ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ p .* ∣ 1 ⟩)) x y))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ p ⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ n ⟩)
Crunching:
((hadamard × ∣ b ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ b .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching:
(fst ((hadamard × ∣ b ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ b .* ∣ 1 ⟩)) x y))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ b ⟩)
Crunching: (1 < 0)
Crunching: (H <= (H10 + Hb) / 2 <= nna)
find_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutsimplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
find_witness Control.TimeoutCrunching:
(fst ((hadamard × ∣ p ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ p .* ∣ 1 ⟩)) x y))
Crunching:
(WF_Matrix u ->
 (u) † × u = I 2 ->
 PI / 4 < PI / 2 -> ~ (dim < 0 + (1 + (1 - 0 - 1) + 1))%nat)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
simplified dependent [if false]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
Finished transaction in 126.783 secs (122.048u,3.399s) (successful)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ p ⟩)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz = 0)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ p ⟩)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz = 0)
Crunching: (perm_mat L R = I L)
Crunching:
(0 =
 (u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz)
find_witness Control.TimeoutCrunching:
(0 = (u ⊗ I (2 ^ (m - 0)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (m - 0)) ⊗ ∣0⟩⟨0∣) z intz)
Crunching:
(0 =
 (u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz = 0)
Crunching:
((u ⊗ I (2 ^ (m - 0)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (m - 0)) ⊗ ∣0⟩⟨0∣) z intz = 0)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz = 0)
Crunching:
(forall x : nat,
 (hadamard × ∣ p ⟩) x = (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ p .* ∣ 1 ⟩)) x)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   a Hab = 0)
Crunching:
((u ⊗ I (2 ^ (m - 0)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (m - 0)) ⊗ ∣0⟩⟨0∣) a Hab = 0)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   a H5 = 0)
Crunching:
((u ⊗ I (2 ^ (m - 0)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (m - 0)) ⊗ ∣0⟩⟨0∣) a H5 = 0)
Crunching: (perm_mat m Streicher_K = I m)
Crunching: (H4 > 0 -> a < H4)
rewrite if_dtt
if (proj1_sig x =? proj1_sig k)
then (fun _ : (proj1_sig x =? proj1_sig k) = true => AA tt)
else
(fun E0 : (proj1_sig x =? proj1_sig k) = false =>
 BB
   ((if proj1_sig x <? proj1_sig k as b1
      return ((proj1_sig x <? proj1_sig k) = b1 -> ltN n)
     then
      fun E1 : (proj1_sig x <? proj1_sig k) = true =>
      ltN_of_nat (proj1_sig x) n (ltN_pop_lemma1 n k x E1)
     else
      fun E1 : (proj1_sig x <? proj1_sig k) = false =>
      ltN_of_nat (Init.Nat.pred (proj1_sig x)) n (ltN_pop_lemma2 n k x E1 E0))
      eq_refl))
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.TimeoutCrunching: (perm_mat m Streicher_K = I m)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ n ⟩)
Crunching:
((hadamard × ∣ z_ne_0 ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ z_ne_0 .* ∣ 1 ⟩)) 0%nat 0%nat)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
((hadamard × ∣ b ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ b .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching: (perm_mat 0 f = I 0)
Crunching:
(fst ((hadamard × ∣ b ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ b .* ∣ 1 ⟩)) x y))
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ b ⟩)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching:
((forall r1 r2 : R, r1 > 0 -> r2 > 0 -> r1 * r2 > 0) ->
 hadamard × ∣ b ⟩ =
 (fun x y : nat => / √ 2 * (∣ 0 ⟩ x y + (-1) ^ b * ∣ 1 ⟩ x y)))
Crunching: (I 0 = perm_mat 0 f)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ b ⟩)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching:
(pad 0 dim (u ⊗ I (2 ^ (m - 0)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (m - 0)) ⊗ ∣0⟩⟨0∣)
   Hs abs = 0)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (1 < 0)
Crunching: (1 < 0)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Proving is_simple_correct0...
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.007 secs (0.006u,0.001s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 2.648 secs (2.555u,0.09s) (success)
Proving invert_bind_args_raw_to_typed...
Crunching: (permutation (2 ^ H12) (qubit_perm_to_nat_perm H12 a))
Tactic call ran for 1.056 secs (1.036u,0.013s) (success)
Proving fold_invert_bind_args...
find_witness Control.TimeoutCrunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Tactic call ran for 0.944 secs (0.93u,0.012s) (success)
Proving split_ident_to_ident...
find_witness Control.TimeoutTactic call ran for 0.108 secs (0.087u,0.02s) (success)
Proving eq_indep_types_of_eq_types...
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (permutation (2 ^ H) (qubit_perm_to_nat_perm H a))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
find_witness Control.TimeoutCrunching: (permutation (2 ^ H12) (qubit_perm_to_nat_perm H12 a))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Tactic call ran for 2.445 secs (2.373u,0.061s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.TimeoutCrunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.TimeoutTactic call ran for 3.979 secs (3.934u,0.032s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: (permutation (2 ^ H) (qubit_perm_to_nat_perm H a))
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (∣1⟩ = basis_vector 2 1)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (∣1⟩ = basis_vector 2 1)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (permutation (2 ^ H12) (qubit_perm_to_nat_perm H12 a))
Crunching: ((-1) ^ (2 * n + 1) = -1)
find_witness Control.TimeoutCrunching: (permutation (2 ^ H12) (qubit_perm_to_nat_perm H12 f))
Crunching: (permutation (2 ^ H12) (qubit_perm_to_nat_perm H12 f))
Crunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
find_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
find_witness Control.TimeoutCrunching: False
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(permutation H10 p -> permutation (2 ^ H10) (qubit_perm_to_nat_perm H10 p))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Crunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutsimplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => F (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
find_witness Control.TimeoutCrunching: (WF_Unitary (pad_swap dim m n))
Crunching:
(forall x : R,
 sin_in 0² x ->
 forall x0 y : nat,
 (x0 < 2)%nat -> (y < 2)%nat -> cnot × ∣ x0, y ⟩ = ∣ x0, (x0 + y) mod 2 ⟩)
rewrite if_dtt
if (pA a1)
then (fun E : pA a1 = true => F (exist (fun a0 : A => pA a0 = true) a1 E))
else (fun _ : pA a1 = false => false)
Crunching:
(ln 1 <= r -> r < sum_over_list l1 -> sample (l1 ++ []) r = sample l1 r)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.TimeoutCrunching: positive
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat))
Crunching:
((fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat) =
 cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ q, q' ⟩)
Crunching: (WF_Unitary (pad_swap dim m n))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutsimplified dependent [if true] in H0
Ha' : (pA a')  = true
if (pA a')
then (fun E : pA a' = true => F (exist (fun a0 : A => pA a0 = true) a' E))
else (fun _ : pA a' = false => false)
Crunching: (0%nat <> 0%nat)
find_witness Control.TimeoutCrunching: (0%nat <> 0%nat)
Crunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(Forall (fun x : R => 0 <= x) [] ->
 Forall (fun x : R => 0 <= x) x ->
 sum_over_list [] <= l ->
 sample ([] ++ x) l = (length [] + sample x (l + - sum_over_list []))%nat)
find_witness Control.TimeoutCrunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Finished transaction in 14.888 secs (14.532u,0.232s) (successful)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
find_witness Control.TimeoutCrunching:
(permutation q Hqgt0 ->
 perm_to_matrix q Hqgt0 × f_to_vec q H =
 f_to_vec q (fun x : nat => H (Hqgt0 x)))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
find_witness Control.Timeout(forall y2 : nat,
 LE = y2 ->
 Morphisms.respectful eq
   (Morphisms.respectful eq (Morphisms.respectful eq eq))
   (Language.Compilers.expr.Interp
      (@IdentifiersBasicGENERATED.Compilers.ident_interp)
      reified_carry_mul_gen x7 x8 x9 LM1 LE) (carry_mulmod y y0 y1 P2 y2))
Crunching: ((PI / 4 < PI / 2)%R -> forall y : nat, f lm = f y -> lm = y)
Crunching:
((forall m : nat, (m < H7)%nat -> WF_Unitary (pad_swap (S n) 0 n)) ->
 WF_Unitary (pad_swap (S n) 0 n))
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: positive
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: positive
out of reach
Tactic call ran for 0.007 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching: (WF_Unitary (pad_swap dim m n))
out of reach
Tactic call ran for 0.006 secs (0.003u,0.002s) (failure)
find_witness Control.TimeoutCrunching: (∣ 0, 0 ⟩ r s = 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (∣ 0, 0 ⟩ r s = 0)
Crunching:
(sample (A ++ []) x0 = (length A + sample [] (x0 - sum_over_list A))%nat)
Crunching: (0%nat <> 0%nat)
Crunching: (0%nat <> 0%nat)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (perm_to_matrix q1 q2 x y * f_to_vec q1 f y z)%C)
    (2 ^ q1)) = f_to_vec q1 (fun x : nat => f (q2 x)))
Crunching: ((e2 >= 2 * 2)%nat \/ (H2 >= 1 * 1)%nat -> ∣ 0, 0 ⟩ e2 H2 = 0)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
((fun x z : nat =>
  Σ
    (fun y : nat =>
     (perm_to_matrix q1 q2 x y *
      basis_vector (2 ^ q1) (funbool_to_nat q1 f) y z)%C) 
    (2 ^ q1)) = f_to_vec q1 (fun x : nat => f (q2 x)))
Crunching: (0%nat <> 0%nat)
Crunching:
((fun x z : nat =>
  Σ
    (fun y : nat =>
     (perm_to_matrix q1 q2 x y *
      basis_vector (2 ^ q1) (funbool_to_nat q1 f) y z)%C) 
    (2 ^ q1)) = f_to_vec q1 (fun x : nat => f (q2 x)))
Crunching:
(Forall (fun x : R => 0 <= x) A ->
 Forall (fun x : R => 0 <= x) a ->
 sum_over_list A <= q ->
 sample (A ++ a) q = (length A + sample a (q - sum_over_list A))%nat)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Crunching:
(sample (n ++ IH) a = (length n + sample IH (a - sum_over_list n))%nat)
Crunching:
(sample (n ++ IH) a = (length n + sample IH (a - sum_over_list n))%nat)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.03 secs (0.03u,0.s) (failure)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Crunching:
(sample (f ++ []) l = (length f + sample [] (l - sum_over_list f))%nat)
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.076 secs (0.067u,0.008s) (success)
Tactic call ran for 0.014 secs (0.014u,0.s) (success)
Tactic call ran for 0.087 secs (0.087u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Reifying...
Assembling rewrite_head_no_dtree...
Compiling decision tree...
Splitting rewrite rules...
Reducing rewrite_head_no_dtree...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.048 secs (0.048u,0.s) (success)
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
Proving Rewriter_Wf...
Tactic call ran for 0.02 secs (0.02u,0.s) (success)
Tactic call ran for 0.093 secs (0.09u,0.s) (success)
Tactic call ran for 0.027 secs (0.027u,0.s) (success)
Proving Rewriter_Interp...
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Tactic call ran for 0.406 secs (0.401u,0.004s) (success)
Tactic call ran for 0.005 secs (0.004u,0.s) (success)
find_witness Control.TimeoutCrunching:
(permutation q Hqgt0 ->
 perm_to_matrix q Hqgt0 × f_to_vec q H =
 f_to_vec q (fun x : nat => H (Hqgt0 x)))
Assembling verified rewriter...
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Proving Rewriter_Wf...
Refining with verified rewriter...
Tactic call ran for 0.017 secs (0.017u,0.s) (success)
Tactic call ran for 0.05 secs (0.05u,0.s) (success)
Proving Rewriter_Interp...
Crunching:
(permutation q Hqgt0 ->
 perm_to_matrix q Hqgt0 × f_to_vec q l1 =
 f_to_vec q (fun x : nat => l1 (Hqgt0 x)))
Tactic call ran for 0.35 secs (0.345u,0.004s) (success)
Tactic call ran for 0.001 secs (0.u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Crunching: (pad_u Hpr H' A × pad_u Hpr x B = pad_u Hpr x B × pad_u Hpr H' A)
Crunching: False
find_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: False
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (∣1⟩ = basis_vector 2 1)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (pad_u Hpr H' A × pad_u Hpr x B = pad_u Hpr x B × pad_u Hpr H' A)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.003 secs (0.002u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (WF_Unitary (perm_to_matrix x xint))
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.TimeoutCrunching: (a <= sample (repeat 0%R a ++ b) r)%nat
find_witness Control.TimeoutCrunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
Crunching: (n <= sample (repeat 0%R n ++ n_lb) i)%nat
Crunching: (WF_Unitary (perm_to_matrix x xint))
Crunching: (WF_Unitary (perm_to_matrix x xint))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (WF_Unitary (perm_to_matrix x xint))
out of reach
Tactic call ran for 0.004 secs (0.003u,0.001s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
Crunching: (a <= sample (repeat 0%R a ++ b) r)%nat
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(0 <= H ->
 (2 * Nat.div2 x + Nat.b2n (Nat.odd x) <= sample (repeat 0%R x ++ y) H)%nat)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (perm_to_matrix 0 p) † × perm_to_matrix 0 p)
Crunching: (list2D_to_matrix [[(perm_to_matrix 0 p 0 0) ^*]] = I 1)
find_witness Control.TimeoutFinished transaction in 43.645 secs (3.078u,0.189s) (successful)
Crunching:
(list2D_to_matrix [[e]] = (perm_to_matrix 0 p) † × perm_to_matrix 0 p)
Crunching: (list2D_to_matrix [[(perm_to_matrix 0 p 0 0) ^*]] = I 1)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 0.251 secs (0.245u,0.004s) (successful)
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Crunching: (n <= sample (repeat 0%R n ++ n_lb) i)%nat
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Finished transaction in 2.489 secs (2.462u,0.015s) (successful)
Crunching: (WF_Unitary (perm_to_matrix x xint))
Crunching: (forall a b : R, 0 <= a <= b -> b * a + a * b <= a * a + b * b)
Crunching: (WF_Unitary (perm_to_matrix x xint))
Crunching: (WF_Unitary (perm_to_matrix x xint))
find_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (WF_Unitary (perm_to_matrix x xint))
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
find_witness Control.TimeoutCrunching:
(WF_Matrix (perm_to_matrix 0 Hn) /\
 (perm_to_matrix 0 Hn) † × perm_to_matrix 0 Hn = I 1)
find_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
find_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (0 < r -> (a <= sample (repeat 0%R a ++ b) r)%nat)
Crunching: (PI_2_3_7_tg (S n) < PI_2_3_7_tg n)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
Crunching: (a <= sample (repeat 0%R a ++ b) r)%nat
Crunching: (∣1⟩ = basis_vector 2 1)
find_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
find_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
find_witness Control.Timeoutfind_witness Control.Timeoutrewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(0 <= H ->
 (2 * Nat.div2 x + Nat.b2n (Nat.odd x) <= sample (repeat 0%R x ++ y) H)%nat)
Crunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
find_witness Control.TimeoutCrunching:
(0 <= H ->
 (2 * Nat.div2 x + Nat.b2n (Nat.odd x) <= sample (repeat 0%R x ++ y) H)%nat)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
find_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching:
(pad_u 0 R S × pad_ctrl 0 R' HRR' S' = pad_ctrl 0 R' HRR' S' × pad_u 0 R S)
Crunching:
(pad_u 0 R S × pad_ctrl 0 R' HRR' S' = pad_ctrl 0 R' HRR' S' × pad_u 0 R S)
find_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching:
(pad_u 0 R S × pad_ctrl 0 R' HRR' S' = pad_ctrl 0 R' HRR' S' × pad_u 0 R S)
Crunching:
(pad_u 0 R S × pad_ctrl 0 R' HRR' S' = pad_ctrl 0 R' HRR' S' × pad_u 0 R S)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching:
(permutation x q ->
 (qubit_perm_to_nat_perm x q ∘ qubit_perm_to_nat_perm x r)%prg =
 qubit_perm_to_nat_perm x (r ∘ q)%prg)
Crunching: (H0 <= sample (repeat 0%R H0 ++ []) f)%nat
Crunching: (H0 <= sample (repeat 0%R H0 ++ []) f)%nat
find_witness Control.TimeoutCrunching:
(pad_u n m H × pad_ctrl n p Hn H8 = pad_ctrl n p Hn H8 × pad_u n m H)
Crunching:
(permutation x q ->
 (qubit_perm_to_nat_perm x q ∘ qubit_perm_to_nat_perm x r)%prg =
 qubit_perm_to_nat_perm x (r ∘ q)%prg)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
Crunching:
(pr_outcome_sum [l1] f = (l1 + pr_outcome_sum [] (fun y : nat => f (S y)))%R)
find_witness Control.TimeoutCrunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
Crunching:
(pad_u Hq Hr H × pad_ctrl Hq H2 x B = pad_ctrl Hq H2 x B × pad_u Hq Hr H)
Crunching:
(pr_outcome_sum (x :: n) Hapart =
 (if Hapart 0%nat
  then (x + pr_outcome_sum n (fun y : nat => Hapart (S y)))%R
  else pr_outcome_sum n (fun y : nat => Hapart (S y))))
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
Crunching:
(forall A B : Square 2,
 Hr <> H14 ->
 Hr <> EQ ->
 WF_Matrix A ->
 WF_Matrix B ->
 pad_u Hq Hr A × pad_ctrl Hq H14 EQ B = pad_ctrl Hq H14 EQ B × pad_u Hq Hr A)
Crunching:
(permutation x q ->
 (qubit_perm_to_nat_perm x q ∘ qubit_perm_to_nat_perm x r)%prg =
 qubit_perm_to_nat_perm x (r ∘ q)%prg)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
((if Hr + 1 <=? Hq then I (2 ^ Hr) ⊗ IH ⊗ I (2 ^ (Hq - (Hr + 1))) else Zero)
 × pad_ctrl Hq H14 n B =
 pad_ctrl Hq H14 n B
 × (if Hr + 1 <=? Hq then I (2 ^ Hr) ⊗ IH ⊗ I (2 ^ (Hq - (Hr + 1))) else Zero))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching:
((1 + 0)%R = 1 ->
 (0 + 1)%R = 1 ->
 Hr <> H14 ->
 Hr <> n ->
 WF_Matrix IH ->
 WF_Matrix H5 ->
 pad_u Hq Hr IH × pad_ctrl Hq H14 n H5 =
 pad_ctrl Hq H14 n H5 × pad_u Hq Hr IH)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
Crunching:
((if Hr + 1 <=? Hq then I (2 ^ Hr) ⊗ IH ⊗ I (2 ^ (Hq - (Hr + 1))) else Zero)
 × pad_ctrl Hq n Hn B =
 pad_ctrl Hq n Hn B
 × (if Hr + 1 <=? Hq then I (2 ^ Hr) ⊗ IH ⊗ I (2 ^ (Hq - (Hr + 1))) else Zero))
Crunching: (~ 1 < 0)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
find_witness Control.TimeoutCrunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
Reifying...
Crunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
find_witness Control.TimeoutCrunching:
(forall x0 : nat,
 (x0 < 2 ^ a)%nat ->
 pad_u a b Ha x x0 * pad_ctrl a c Hc Hb x0 y =
 pad_ctrl a c Hc Hb x x0 * pad_u a b Ha x0 y)
find_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
Crunching:
(permutation q p0 ->
 (qubit_perm_to_nat_perm q p0 ∘ qubit_perm_to_nat_perm q l)%prg =
 qubit_perm_to_nat_perm q (l ∘ p0)%prg)
find_witness Control.TimeoutCrunching:
(forall x0 : nat,
 (x0 < 2 ^ a)%nat ->
 pad_u a b Ha x x0 * pad_ctrl a c Hc Hb x0 y =
 pad_ctrl a c Hc Hb x x0 * pad_u a b Ha x0 y)
Crunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
find_witness Control.TimeoutCrunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.001u,0.004s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Finished transaction in 45.689 secs (5.174u,0.178s) (successful)
Crunching:
(pad_u n 0 A × pad_ctrl n n0 o B = pad_ctrl n n0 o B × pad_u n 0 A)
Crunching:
(H * m + m * H < m * m + H * H \/ (H * m + m * H)%R = (m * m + H * H)%R)
Finished transaction in 0.34 secs (0.335u,0.003s) (successful)
Crunching:
(pr_outcome_sum [l1] f = (l1 + pr_outcome_sum [] (fun y : nat => f (S y)))%R)
Crunching: (0 < 2)
Finished transaction in 3.6 secs (3.586u,0.01s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(pr_outcome_sum [x] Hapart =
 (if Hapart 0%nat
  then (x + pr_outcome_sum [] (fun y : nat => Hapart (S y)))%R
  else pr_outcome_sum [] (fun y : nat => Hapart (S y))))
Crunching:
(pr_outcome_sum (x :: n) Hapart =
 (if Hapart 0%nat
  then (x + pr_outcome_sum n (fun y : nat => Hapart (S y)))%R
  else pr_outcome_sum n (fun y : nat => Hapart (S y))))
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
(pr_outcome_sum (s2 :: H1) H2 =
 (if H2 0%nat
  then (s2 + pr_outcome_sum H1 (fun y : nat => H2 (S y)))%R
  else pr_outcome_sum H1 (fun y : nat => H2 (S y))))
Crunching:
(forall f : nat -> bool,
 pr_outcome_sum (k :: c) f =
 (if f 0%nat
  then (k + pr_outcome_sum c (fun y : nat => f (S y)))%R
  else pr_outcome_sum c (fun y : nat => f (S y))))
Crunching: ((0 + 1)%R = 1 -> 1 < 0)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.005 secs (0.004u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
Finished transaction in 38.165 secs (37.536u,0.422s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(pr_outcome_sum (H6 ++ l2) l =
 (pr_outcome_sum H6 l +
  pr_outcome_sum l2 (fun x : nat => l (length H6 + x)%nat))%R)
Compiling decision tree...
Splitting rewrite rules...
find_witness Control.TimeoutCrunching: (Rmax y r < z <-> y < z /\ r < z)
Crunching:
(pr_outcome_sum (H6 ++ l2) l =
 (pr_outcome_sum H6 l +
  pr_outcome_sum l2 (fun x : nat => l (length H6 + x)%nat))%R)
Crunching:
(forall g : nat -> nat,
 permutation 0 Hlen' ->
 permutation 0 g ->
 perm_to_matrix 0 Hlen' × perm_to_matrix 0 g =
 perm_to_matrix 0 (g ∘ Hlen')%prg)
find_witness Control.TimeoutCrunching:
(pr_outcome_sum (H6 ++ l2) l =
 (pr_outcome_sum H6 l +
  pr_outcome_sum l2 (fun x : nat => l (length H6 + x)%nat))%R)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(pr_outcome_sum (H6 ++ l2) l =
 (pr_outcome_sum H6 l +
  pr_outcome_sum l2 (fun x : nat => l (length H6 + x)%nat))%R)
find_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall a b : R, 0 <= a <= b -> b * a + a * b <= a * a + b * b)
find_witness Control.TimeoutAssembling rewrite_head...
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Reducing rewrite_head...
find_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.TimeoutCrunching:
(forall f : nat -> bool,
 pr_outcome_sum (H6 ++ H5) f =
 (pr_outcome_sum H6 f +
  pr_outcome_sum H5 (fun x : nat => f (length H6 + x)%nat))%R)
find_witness Control.TimeoutCrunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
Tactic call ran for 0.622 secs (0.607u,0.014s) (success)
rewrite if_dtt
if
match q with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := a in a) m'
end
then
(fun
   E0 : match q with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := a in a) m'
        end = true =>
 AA
   (exist
      (fun k : nat =>
       match q with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) (let (a, _) := a in a) E0))
else
(fun
   E0 : match q with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := a in a) m'
        end = false =>
 BB
   (exist (fun _ : nat => false = true)
      ((fix sub (n m : nat) {struct n} : nat :=
          match n with
          | 0 => n
          | S k => match m with
                   | 0 => n
                   | S l => sub k l
                   end
          end) (let (a, _) := a in a) q)
      (ltN_split_lemma1
         (let
            (a, b) as e
             return
               (match
                  (fix add (n m : nat) {struct n} : nat :=
                     match n with
                     | 0 => m
                     | S p => S (add p m)
                     end) q 0
                with
                | 0 => false
                | S m' =>
                    (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m'0 => leb n' m'0
                           end
                       end) (let (a, _) := e in a) m'
                end = true) := a in
          b) E0)))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.TimeoutCrunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
Crunching:
(forall (l1 l2 : list R) (f : nat -> bool),
 pr_outcome_sum (l1 ++ l2) f =
 (pr_outcome_sum l1 f +
  pr_outcome_sum l2 (fun x : nat => f (length l1 + x)%nat))%R)
find_witness Control.TimeoutFinished transaction in 47.781 secs (7.216u,0.258s) (successful)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
Crunching:
(forall (l2 : list R) (f : nat -> bool),
 pr_outcome_sum (r :: r0 ++ l2) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum l2 (fun x : nat => f (S (length r0 + x))))%R)
find_witness Control.TimeoutCrunching:
(forall f : nat -> bool,
 pr_outcome_sum (r :: r0 ++ Hxy) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum Hxy (fun x : nat => f (S (length r0 + x))))%R)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
Tactic call ran for 3.635 secs (3.545u,0.086s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.212 secs (0.212u,0.s) (success)
Finished failing transaction in 20.331 secs (-60.09u,-1.195s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutAssembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
find_witness Control.TimeoutFinished transaction in 0.498 secs (0.474u,0.023s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (forall x : nat, (cnot × ∣ 1, 1 ⟩) x = ∣ 1, 0 ⟩ x)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(pr_outcome_sum (H6 ++ l2) l =
 (pr_outcome_sum H6 l +
  pr_outcome_sum l2 (fun x : nat => l (length H6 + x)%nat))%R)
find_witness Control.TimeoutCrunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
Proving Rewriter_Wf...
find_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.891 secs (0.854u,0.035s) (success)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(Σ (fun y0 : nat => (perm_to_matrix m n x y0 * perm_to_matrix m o y0 y)%C)
   (2 ^ m) = perm_to_matrix m (fun x : nat => o (n x)) x y)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
Crunching: (x <= y -> x < z)
Crunching: (x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Finished transaction in 5.063 secs (5.044u,0.009s) (successful)
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
find_witness Control.TimeoutCrunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching: (swap × ∣ H5, H'1 ⟩ = ∣ H'1, H5 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching: (x <= y -> x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x < z)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x <= y -> x < z)
Crunching: (x < z)
find_witness Control.TimeoutCrunching:
(forall x y : nat,
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
rewrite if_dtt
if
match q with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := a in a) m'
end
then
(fun
   E0 : match q with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := a in a) m'
        end = true =>
 AA
   (exist
      (fun k : nat =>
       match q with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) (let (a, _) := a in a) E0))
else
(fun
   E0 : match q with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := a in a) m'
        end = false =>
 BB
   (exist (fun _ : nat => false = true)
      ((fix sub (n m : nat) {struct n} : nat :=
          match n with
          | 0 => n
          | S k => match m with
                   | 0 => n
                   | S l => sub k l
                   end
          end) (let (a, _) := a in a) q)
      (ltN_split_lemma1
         (let
            (a, b) as e
             return
               (match
                  (fix add (n m : nat) {struct n} : nat :=
                     match n with
                     | 0 => m
                     | S p => S (add p m)
                     end) q 0
                with
                | 0 => false
                | S m' =>
                    (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m'0 => leb n' m'0
                           end
                       end) (let (a, _) := e in a) m'
                end = true) := a in
          b) E0)))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
Crunching: (x <= y -> x < z)
Crunching: (x < z)
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching: (x <= y -> x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching: (x < z)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = swap × ∣ H5, m ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (swap × ∣ H5, H'1 ⟩ = ∣ H'1, H5 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (swap × ∣ H5, h ⟩ = ∣ h, H5 ⟩)
Crunching: (x <= y -> x < z)
Crunching: (x < z)
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = perm_to_matrix 0 Hlen' × perm_to_matrix 0 g)
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 g 0 0]] =
 perm_to_matrix 0 (g ∘ Hlen')%prg)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(forall x y : nat,
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
find_witness Control.TimeoutCrunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(permutation Hnm HF ->
 perm_to_matrix Hnm Hpq × perm_to_matrix Hnm HF =
 perm_to_matrix Hnm (HF ∘ Hpq)%prg)
find_witness Control.TimeoutTactic call ran for 10.854 secs (10.668u,0.158s) (success)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(PI / 4 < PI / 2 ->
 {l : R | derivable_pt_abs (fun x : R => (sin x / cos x)%R) x l})
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x <= y -> x < z)
find_witness Control.TimeoutCrunching: (x < z)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching: (x <= y -> x < z)
Crunching: (x < z)
find_witness Control.TimeoutCrunching: (x <= y -> x < z)
Crunching: (x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutout of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(PI / 4 < PI / 2 ->
 {l : R | derivable_pt_abs (fun x : R => (sin x / cos x)%R) x l})
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
Crunching: (x <= y -> x < z)
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x < z)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(swap
 × (fun x y : nat =>
    ∣ Hocc ⟩ (x / 2)%nat (y / 1)%nat * ∣ H7 ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ H7 ⟩ (x / 2)%nat (y / 1)%nat * ∣ Hocc ⟩ (x mod 2)%nat (y mod 1)%nat))
find_witness Control.TimeoutCrunching: (x <= y -> x < z)
Crunching: (x < z)
out of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (swap × ∣ ρ, mixed ⟩ = ∣ mixed, ρ ⟩)
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
find_witness Control.TimeoutCrunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutout of reach
Tactic call ran for 0.01 secs (0.009u,0.001s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = swap × ∣ H5, m ⟩)
find_witness Control.TimeoutCrunching: (swap × ∣ H5, H'1 ⟩ = ∣ H'1, H5 ⟩)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.013 secs (0.012u,0.s) (failure)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
Crunching:
(Σ (fun y : nat => (perm_to_matrix m n 0 y * perm_to_matrix m o y 0)%C)
   (2 ^ m) = perm_to_matrix m (fun x : nat => o (n x)) 0 0)
Crunching: (swap × ∣ H5, H'1 ⟩ = ∣ H'1, H5 ⟩)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(Σ (fun y : nat => (perm_to_matrix m n 0 y * perm_to_matrix m o y 0)%C)
   (2 ^ m) = perm_to_matrix m (fun x : nat => o (n x)) 0 0)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (x <= y -> x < z)
Crunching: (x < z)
Crunching: (swap × ∣ H5, q' ⟩ = ∣ q', H5 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (swap × ∣ H5, h ⟩ = ∣ h, H5 ⟩)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (x <= y -> x < z)
Crunching: (x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching: (x <= y -> x < z)
Crunching: (x < z)
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching: (swap × ∣ x0, H7 ⟩ = ∣ H7, x0 ⟩)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
Crunching: (x <= y -> x < z)
Crunching: (swap × ∣ Hlt, le_mn2 ⟩ = ∣ le_mn2, Hlt ⟩)
find_witness Control.TimeoutCrunching: (x < z)
Finished transaction in 43.934 secs (3.628u,0.175s) (successful)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x <= y -> x < z)
find_witness Control.TimeoutCrunching: (x < z)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x <= y -> x < z)
Crunching: (x < z)
Proving Rewriter_Interp...
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(forall x y : nat,
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
find_witness Control.TimeoutCrunching:
(pad_ctrl a H2 n A × pad_ctrl a o p B = pad_ctrl a o p B × pad_ctrl a H2 n A)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Finished transaction in 0.245 secs (0.245u,0.s) (successful)
Crunching:
(pad_ctrl a o p B × pad_ctrl a H2 n A = pad_ctrl a H2 n A × pad_ctrl a o p B)
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutCrunching:
((a >= 4)%nat \/ (n >= 1)%nat ->
 Σ
   (fun y : nat =>
    swap a y *
    (∣ k ⟩ (fst (Nat.divmod y 1 0 1)) (fst (Nat.divmod n 0 0 0)) *
     ∣ s1 ⟩
       match snd (Nat.divmod y 1 0 1) with
       | 0%nat => 1%nat
       | S _ => 0%nat
       end 0%nat)) 4 = 0)
out of reach
Tactic call ran for 0.014 secs (0.014u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutFalse
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutout of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Finished transaction in 2.741 secs (2.723u,0.01s) (successful)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(perm_to_matrix n f =
 (fun x y : nat => if (x =? y) && (x <? 2 ^ n) then C1 else 0%R))
Crunching: (x < z)
Crunching: (x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (x < z)
Crunching:
((if m <? H1
  then
   if m + S (H1 - m - 1 + 1) <=? a
   then
    I (2 ^ m)
    ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (H1 - m - 1)) ⊗ A
       .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (H1 - m - 1)) ⊗ I 2)
    ⊗ I (2 ^ (a - (m + S (H1 - m - 1 + 1))))
   else Zero
  else
   if H1 <? m
   then
    if H1 + S (m - H1 - 1 + 1) <=? a
    then
     I (2 ^ H1)
     ⊗ (A ⊗ I (2 ^ (m - H1 - 1)) ⊗ ∣1⟩⟨1∣
        .+ I 2 ⊗ I (2 ^ (m - H1 - 1)) ⊗ ∣0⟩⟨0∣)
     ⊗ I (2 ^ (a - (H1 + S (m - H1 - 1 + 1))))
    else Zero
   else Zero)
 × (if H2 <? p
    then
     if H2 + S (p - H2 - 1 + 1) <=? a
     then
      I (2 ^ H2)
      ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (p - H2 - 1)) ⊗ B
         .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (p - H2 - 1)) ⊗ I 2)
      ⊗ I (2 ^ (a - (H2 + S (p - H2 - 1 + 1))))
     else Zero
    else
     if p <? H2
     then
      if p + S (H2 - p - 1 + 1) <=? a
      then
       I (2 ^ p)
       ⊗ (B ⊗ I (2 ^ (H2 - p - 1)) ⊗ ∣1⟩⟨1∣
          .+ I 2 ⊗ I (2 ^ (H2 - p - 1)) ⊗ ∣0⟩⟨0∣)
       ⊗ I (2 ^ (a - (p + S (H2 - p - 1 + 1))))
      else Zero
     else Zero) =
 (if H2 <? p
  then
   if H2 + S (p - H2 - 1 + 1) <=? a
   then
    I (2 ^ H2)
    ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (p - H2 - 1)) ⊗ B
       .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (p - H2 - 1)) ⊗ I 2)
    ⊗ I (2 ^ (a - (H2 + S (p - H2 - 1 + 1))))
   else Zero
  else
   if p <? H2
   then
    if p + S (H2 - p - 1 + 1) <=? a
    then
     I (2 ^ p)
     ⊗ (B ⊗ I (2 ^ (H2 - p - 1)) ⊗ ∣1⟩⟨1∣
        .+ I 2 ⊗ I (2 ^ (H2 - p - 1)) ⊗ ∣0⟩⟨0∣)
     ⊗ I (2 ^ (a - (p + S (H2 - p - 1 + 1))))
    else Zero
   else Zero)
 × (if m <? H1
    then
     if m + S (H1 - m - 1 + 1) <=? a
     then
      I (2 ^ m)
      ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (H1 - m - 1)) ⊗ A
         .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (H1 - m - 1)) ⊗ I 2)
      ⊗ I (2 ^ (a - (m + S (H1 - m - 1 + 1))))
     else Zero
    else
     if H1 <? m
     then
      if H1 + S (m - H1 - 1 + 1) <=? a
      then
       I (2 ^ H1)
       ⊗ (A ⊗ I (2 ^ (m - H1 - 1)) ⊗ ∣1⟩⟨1∣
          .+ I 2 ⊗ I (2 ^ (m - H1 - 1)) ⊗ ∣0⟩⟨0∣)
       ⊗ I (2 ^ (a - (H1 + S (m - H1 - 1 + 1))))
      else Zero
     else Zero))
Crunching:
(swap
 × (fun x y0 : nat =>
    ∣ l ⟩ (x / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x mod 2)%nat (y0 mod 1)%nat) =
 (fun x y0 : nat =>
  ∣ y ⟩ (x / 2)%nat (y0 / 1)%nat * ∣ l ⟩ (x mod 2)%nat (y0 mod 1)%nat))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (x < z)
Crunching: (x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Crunching: (forall x : nat, perm_to_matrix 0 f x = I 1 x)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
find_witness Control.TimeoutMore readable: initial segment:
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
out of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(perm_to_matrix n f =
 (fun x y : nat => if (x =? y) && (x <? 2 ^ n) then C1 else 0%R))
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
     = (exist (fun k : nat => (k <? 6) = true) 0 eq_refl,
        (exist (fun k : nat => (k <? 5) = true) 0 eq_refl,
         (exist (fun k : nat => (k <? 4) = true) 0 eq_refl,
          (exist (fun k : nat => (k <? 3) = true) 0 eq_refl,
           (exist (fun k : nat => (k <? 2) = true) 0 eq_refl,
            (exist (fun k : nat => (k <? 1) = true) 0 eq_refl, tt))))))
     : decr_list (fun n : nat => ltN (S n)) 6
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (∣0⟩ = basis_vector 2 0)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 13.534 secs (13.392u,0.1s) (success)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Finished transaction in 48.491 secs (7.939u,0.239s) (successful)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (∣0⟩ = basis_vector 2 0)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Finished transaction in 0.542 secs (0.54u,0.002s) (successful)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.011 secs (0.01u,0.s) (failure)
Crunching: (forall x : nat, perm_to_matrix 0 f x = I 1 x)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (forall x : nat, perm_to_matrix 0 f x = I 1 x)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((fun n : nat => forall x : nat, perm_to_matrix n f x = I (S n) x) 0)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall x : nat, perm_to_matrix 0 f x = I 1 x)
Crunching: (perm_to_matrix 0 f a = I 1 a)
Crunching: (0 = (pr_outcome_sum (repeat 0 n) f + 0)%R)
Crunching: (forall x : nat, perm_to_matrix 0 f x = I 1 x)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall x : nat, I 1 x = perm_to_matrix 0 f x)
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 5.253 secs (5.238u,0.01s) (successful)
out of reach
Tactic call ran for 0.013 secs (0.012u,0.s) (failure)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
find_witness Control.TimeoutFinished transaction in 40.897 secs (0.344u,0.159s) (successful)
Finished transaction in 0.023 secs (0.023u,0.s) (successful)
Finished transaction in 0.16 secs (0.159u,0.001s) (successful)
Crunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Tactic call ran for 12.11 secs (11.917u,0.149s) (success)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
find_witness Control.TimeoutCrunching: (a < 0 -> √ (a + b) < √ a + √ b \/ √ (a + b) = (√ a + √ b)%R)
find_witness Control.Timeoutfind_witness Control.Timeoutrewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
find_witness Control.Timeoutfind_witness Control.Timeoutrewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
find_witness Control.TimeoutCrunching: (a < 0 -> √ (a + b) < √ a + √ b \/ √ (a + b) = (√ a + √ b)%R)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.011 secs (0.01u,0.001s) (success)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
find_witness Control.TimeoutTactic call ran for 0.006 secs (0.006u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
find_witness Control.TimeoutTactic call ran for 0.006 secs (0.006u,0.s) (success)
find_witness Control.TimeoutMore readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
find_witness Control.Timeoutfind_witness Control.Timeoutrewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Assembling verified rewriter...
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.047 secs (0.047u,0.s) (failure)
find_witness Control.TimeoutRefining with verified rewriter...
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
find_witness Control.TimeoutMore readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
find_witness Control.TimeoutCrunching: (0 < / 2 -> NZ < 0 -> √ (NZ + EQ) <= √ NZ + √ EQ)
find_witness Control.Timeoutrewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
out of reach
Tactic call ran for 0.049 secs (0.049u,0.s) (failure)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
False
Tactic call ran for 0.006 secs (0.005u,0.s) (success)
Finished transaction in 42.624 secs (2.215u,0.179s) (successful)
Finished transaction in 0.167 secs (0.166u,0.s) (successful)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
out of reach
Tactic call ran for 0.046 secs (0.046u,0.s) (failure)
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
Crunching:
(forall (n : nat) (p : nat -> nat) (x y : nat),
 2 ^ n <= x \/ 2 ^ n <= y -> perm_to_matrix n p x y = 0%R)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Finished transaction in 1.79 secs (1.781u,0.004s) (successful)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Crunching: (~ y <= z * / x)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching:
(pr_outcome_sum (f :: len) n =
 ((if n 0%nat then f else - 0) + pr_outcome_sum len (fun i : nat => n (S i)))%R)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
rewrite if_dtt
if (proj1_sig x <? x0)
then
(fun E : (proj1_sig x <? x0) = true =>
 ltN_pop (exist (fun k : nat => (k <? 1) = true) x0 e)
   (ltN_of_nat (proj1_sig x) 1
      (ltN_intro_lemma1 0 (exist (fun k : nat => (k <? 1) = true) x0 e) x E)))
else
(fun E : (proj1_sig x <? x0) = false =>
 ltN_pop (exist (fun k : nat => (k <? 1) = true) x0 e)
   (ltN_of_nat (S (proj1_sig x)) 1
      (ltN_intro_lemma2 0 (exist (fun k : nat => (k <? 1) = true) x0 e) x E)))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
out of reach
Tactic call ran for 0.05 secs (0.048u,0.001s) (failure)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (Heqn * / EQ < H)
Crunching: (Heqn * / EQ < H)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (√ (a + b) < √ a + √ b \/ √ (a + b) = (√ a + √ b)%R)
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (a < 0 -> √ (a + b) < √ a + √ b \/ √ (a + b) = (√ a + √ b)%R)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (x <= y -> √ x + √ y >= √ (x + y))
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
rewrite if_dtt
if (proj1_sig x <? x0)
then
(fun E : (proj1_sig x <? x0) = true =>
 ltN_pop (exist (fun k : nat => (k <? 1) = true) x0 e)
   (ltN_of_nat (proj1_sig x) 1
      (ltN_intro_lemma1 0 (exist (fun k : nat => (k <? 1) = true) x0 e) x E)))
else
(fun E : (proj1_sig x <? x0) = false =>
 ltN_pop (exist (fun k : nat => (k <? 1) = true) x0 e)
   (ltN_of_nat (S (proj1_sig x)) 1
      (ltN_intro_lemma2 0 (exist (fun k : nat => (k <? 1) = true) x0 e) x E)))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Finished transaction in 42.647 secs (2.145u,0.176s) (successful)
Finished transaction in 0.166 secs (0.165u,0.001s) (successful)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
(false = true)
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Crunching:
((1 + 0)%R = 1 -> (0 + 1)%R = 1 -> pr_outcome_sum f g = pr_outcome_sum f H)
Finished transaction in 41.293 secs (0.693u,0.169s) (successful)
Finished transaction in 0.048 secs (0.048u,0.s) (successful)
Finished transaction in 1.444 secs (1.439u,0.004s) (successful)
Finished transaction in 0.351 secs (0.35u,0.001s) (successful)
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching: (0 < 1 -> pr_outcome_sum derv start = pr_outcome_sum derv b)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching: (0 < 1 -> pr_outcome_sum derv start = pr_outcome_sum derv b)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching:
(forall (n : nat) (p : nat -> nat) (x y : nat),
 x >= 2 ^ n \/ y >= 2 ^ n -> perm_to_matrix n p x y = 0%R)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (R0 < R0 -> - Ci .* σx × (σy × (σz × ∣ 1 ⟩)) = ∣ 1 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
(S (0 + 1) ^ 0 <= E \/ S (0 + 1) ^ 0 <= p -> perm_to_matrix 0 H E p = 0%R)
Crunching:
(forall y : nat, 2 ^ 0 <= E \/ 2 ^ 0 <= y -> perm_to_matrix 0 H E y = 0%R)
Crunching:
(forall y : nat, 2 ^ 0 <= E \/ 2 ^ 0 <= y -> perm_to_matrix 0 H E y = 0%R)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching:
(forall y : nat, 2 ^ 0 <= E \/ 2 ^ 0 <= y -> perm_to_matrix 0 H E y = 0%R)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
out of reach
Tactic call ran for 0.032 secs (0.01u,0.022s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (R0 < R0 -> - Ci .* σx × (σy × (σz × ∣ 1 ⟩)) = ∣ 1 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(forall (n : nat) (p : nat -> nat) (x y : nat),
 2 ^ n <= x \/ 2 ^ n <= y -> perm_to_matrix n p x y = 0%R)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Case compile_stmt_correct/SInteract
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Case compile_stmt_correct/SCall
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (pr_outcome_sum l f1 = pr_outcome_sum l f2)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
(false = true)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣1⟩)
Case compile_stmt_correct/SLoad
Crunching:
((1 + 0)%R = 1 -> (0 + 1)%R = 1 -> pr_outcome_sum f g = pr_outcome_sum f H)
Crunching: (pr_outcome_sum l f1 = pr_outcome_sum l f2)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Finished transaction in 42.929 secs (2.395u,0.181s) (successful)
Case compile_stmt_correct/SStore
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Finished transaction in 0.186 secs (0.185u,0.s) (successful)
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Tactic call ran for 0.004 secs (0.002u,0.001s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Finished transaction in 1.773 secs (1.761u,0.007s) (successful)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (pr_outcome_sum derv f1 = pr_outcome_sum derv c)
Crunching: (pr_outcome_sum derv H = pr_outcome_sum derv f2)
find_witness Control.TimeoutCrunching: (0 < 1 -> pr_outcome_sum derv start = pr_outcome_sum derv b)
Case compile_stmt_correct/SInlinetable
Crunching: (pr_outcome_sum derv b = pr_outcome_sum derv start)
Crunching: (pr_outcome_sum derv start = pr_outcome_sum derv b)
Crunching: (pr_outcome_sum derv start = pr_outcome_sum derv b)
Crunching: (0 < 1 -> pr_outcome_sum derv start = pr_outcome_sum derv b)
Crunching: (0 < 0)
Crunching: (pr_outcome_sum derv b = pr_outcome_sum derv start)
Crunching: (pr_outcome_sum derv start = pr_outcome_sum derv b)
Crunching: (pr_outcome_sum derv start = pr_outcome_sum derv b)
Crunching: (0 < 1 -> pr_outcome_sum derv start = pr_outcome_sum derv b)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching:
(ConstructiveCauchyReals.CRealEq (Rrepr (pr_outcome_sum n m)) (Rrepr 0))
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
             match a with
             | (a'~1)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 1%N
                           | N.pos p => N.pos p~1
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end)
             | (a'~0)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 0%N
                           | N.pos p => N.pos p~0
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end)
             | 1%positive =>
                 match b with
                 | 1%N => (1%N, 0%N)
                 | _ => (0%N, 1%N)
                 end
             end) p (N.pos Hab) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq Hab m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' Hab
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
         match a with
         | (a'~1)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end)
         | (a'~0)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end)
         | 1%positive =>
             match b with
             | 1%N => (1%N, 0%N)
             | _ => (0%N, 1%N)
             end
         end) p (N.pos Hab) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq Hab m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' Hab
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
             match a with
             | (a'~1)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 1%N
                           | N.pos p => N.pos p~1
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end)
             | (a'~0)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 0%N
                           | N.pos p => N.pos p~0
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end)
             | 1%positive =>
                 match b with
                 | 1%N => (1%N, 0%N)
                 | _ => (0%N, 1%N)
                 end
             end) p (N.pos Hab) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq Hab m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' Hab
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
         match a with
         | (a'~1)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end)
         | (a'~0)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end)
         | 1%positive =>
             match b with
             | 1%N => (1%N, 0%N)
             | _ => (0%N, 1%N)
             end
         end) p (N.pos Hab) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq Hab m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' Hab
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
Finished transaction in 42.42 secs (1.952u,0.163s) (successful)
Finished transaction in 0.154 secs (0.154u,0.s) (successful)
Crunching:
(Z.abs_N (Z.rem (Z.pos A) (Z.pos eq_dec)) = (N.pos A mod N.pos eq_dec)%N)
Crunching: (update n m Hb m = Hb)
Finished transaction in 1.32 secs (1.316u,0.003s) (successful)
Tactic call ran for 0.008 secs (0.006u,0.002s) (success)
Crunching:
((fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x : nat =>
    if n x
    then
     (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
        match x0 with
        | 0%nat => match x1 with
                   | [] => x2
                   | x3 :: _ => x3
                   end
        | S x3 => match x1 with
                  | [] => x2
                  | _ :: x5 => Ffix x3 x5 x2
                  end
        end) x a R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end) a) = R0)
Crunching: (update f f' k f' = k)
Crunching:
((fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x : nat =>
    if n x
    then
     (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
        match x0 with
        | 0%nat => match x1 with
                   | [] => x2
                   | x3 :: _ => x3
                   end
        | S x3 => match x1 with
                  | [] => x2
                  | _ :: x5 => Ffix x3 x5 x2
                  end
        end) x a R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end) a) = R0)
Crunching:
((fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x : nat =>
    if n x
    then
     (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
        match x0 with
        | 0%nat => match x1 with
                   | [] => x2
                   | x3 :: _ => x3
                   end
        | S x3 => match x1 with
                  | [] => x2
                  | _ :: x5 => Ffix x3 x5 x2
                  end
        end) x a R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end) a) = R0)
Crunching:
(R0 =
 (fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x : nat =>
    if n x
    then
     (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
        match x0 with
        | 0%nat => match x1 with
                   | [] => x2
                   | x3 :: _ => x3
                   end
        | S x3 => match x1 with
                  | [] => x2
                  | _ :: x5 => Ffix x3 x5 x2
                  end
        end) x a R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end) a))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
((fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x : nat =>
    if IN x
    then
     (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
        match x0 with
        | 0%nat => match x1 with
                   | [] => x2
                   | x3 :: _ => x3
                   end
        | S x3 => match x1 with
                  | [] => x2
                  | _ :: x5 => Ffix x3 x5 x2
                  end
        end) x l R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end) l) = R0)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
find_witness Control.TimeoutCrunching:
((forall i : nat, (i < length (H1 :: H2))%nat -> abs i = false) ->
 pr_outcome_sum (H1 :: H2) abs = 0)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching: (pr_outcome_sum (H :: x) Hxy = 0)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
(ConstructiveCauchyReals.CRealEq (Rrepr (pr_outcome_sum n m)) (Rrepr 0))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Case compile_stmt_correct/SStackalloc
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          let (q, r) :=
            (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
               match a with
               | (a'~1)%positive =>
                   let (q, r) := pos_div_eucl a' b in
                   if
                    match
                      match b with
                      | 0%N =>
                          match
                            match r with
                            | 0%N => 1%N
                            | N.pos p => N.pos p~1
                            end
                          with
                          | 0%N => Eq
                          | N.pos _ => Lt
                          end
                      | N.pos n' =>
                          match
                            match r with
                            | 0%N => 1%N
                            | N.pos p => N.pos p~1
                            end
                          with
                          | 0%N => Gt
                          | N.pos m' =>
                              (fix compare_cont
                                 (r0 : comparison) 
                                 (x y : positive) {struct y} : comparison :=
                                 match x with
                                 | (p~1)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont r0 p q0
                                     | (q0~0)%positive =>
                                         compare_cont Gt p q0
                                     | 1%positive => Gt
                                     end
                                 | (p~0)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont Lt p q0
                                     | (q0~0)%positive =>
                                         compare_cont r0 p q0
                                     | 1%positive => Gt
                                     end
                                 | 1%positive =>
                                     match y with
                                     | 1%positive => r0
                                     | _ => Lt
                                     end
                                 end) Eq n' m'
                          end
                      end
                    with
                    | Gt => false
                    | _ => true
                    end
                   then
                    (match q with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end,
                     match
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                     with
                     | 0%N => 0%N
                     | N.pos n' =>
                         match b with
                         | 0%N =>
                             match r with
                             | 0%N => 1%N
                             | N.pos p => N.pos p~1
                             end
                         | N.pos m' =>
                             match
                               (fix sub_mask (x y : positive) {struct y} :
                                    Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive => Pos.IsPos p~0
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | 1%positive =>
                                      match y with
                                      | 1%positive => Pos.IsNul
                                      | _ => Pos.IsNeg
                                      end
                                  end
                                with sub_mask_carry
                                  (x y : positive) {struct y} : Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          match p with
                                          | (p0~1)%positive =>
                                              Pos.IsPos p0~0~0
                                          | (p0~0)%positive =>
                                              Pos.IsPos ((... ...) p0)~0
                                          | 1%positive => Pos.IsNul
                                          end
                                      end
                                  | 1%positive => Pos.IsNeg
                                  end
                                for
                                sub_mask) n' m'
                             with
                             | Pos.IsPos p => N.pos p
                             | _ => 0%N
                             end
                         end
                     end)
                   else
                    (match q with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end,
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end)
               | (a'~0)%positive =>
                   let (q, r) := pos_div_eucl a' b in
                   if
                    match
                      match b with
                      | 0%N =>
                          match
                            match r with
                            | 0%N => 0%N
                            | N.pos p => N.pos p~0
                            end
                          with
                          | 0%N => Eq
                          | N.pos _ => Lt
                          end
                      | N.pos n' =>
                          match
                            match r with
                            | 0%N => 0%N
                            | N.pos p => N.pos p~0
                            end
                          with
                          | 0%N => Gt
                          | N.pos m' =>
                              (fix compare_cont
                                 (r0 : comparison) 
                                 (x y : positive) {struct y} : comparison :=
                                 match x with
                                 | (p~1)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont r0 p q0
                                     | (q0~0)%positive =>
                                         compare_cont Gt p q0
                                     | 1%positive => Gt
                                     end
                                 | (p~0)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont Lt p q0
                                     | (q0~0)%positive =>
                                         compare_cont r0 p q0
                                     | 1%positive => Gt
                                     end
                                 | 1%positive =>
                                     match y with
                                     | 1%positive => r0
                                     | _ => Lt
                                     end
                                 end) Eq n' m'
                          end
                      end
                    with
                    | Gt => false
                    | _ => true
                    end
                   then
                    (match q with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end,
                     match
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                     with
                     | 0%N => 0%N
                     | N.pos n' =>
                         match b with
                         | 0%N =>
                             match r with
                             | 0%N => 0%N
                             | N.pos p => N.pos p~0
                             end
                         | N.pos m' =>
                             match
                               (fix sub_mask (x y : positive) {struct y} :
                                    Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive => Pos.IsPos p~0
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | 1%positive =>
                                      match y with
                                      | 1%positive => Pos.IsNul
                                      | _ => Pos.IsNeg
                                      end
                                  end
                                with sub_mask_carry
                                  (x y : positive) {struct y} : Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          match p with
                                          | (p0~1)%positive =>
                                              Pos.IsPos p0~0~0
                                          | (p0~0)%positive =>
                                              Pos.IsPos ((... ...) p0)~0
                                          | 1%positive => Pos.IsNul
                                          end
                                      end
                                  | 1%positive => Pos.IsNeg
                                  end
                                for
                                sub_mask) n' m'
                             with
                             | Pos.IsPos p => N.pos p
                             | _ => 0%N
                             end
                         end
                     end)
                   else
                    (match q with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end,
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end)
               | 1%positive =>
                   match b with
                   | 1%N => (1%N, 0%N)
                   | _ => (0%N, 1%N)
                   end
               end) p (N.pos HA) in
          if
           match
             match match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end with
             | 0%N => Gt
             | N.pos m' =>
                 (fix compare_cont
                    (r0 : comparison) (x y : positive) {struct y} :
                      comparison :=
                    match x with
                    | (p~1)%positive =>
                        match y with
                        | (q0~1)%positive => compare_cont r0 p q0
                        | (q0~0)%positive => compare_cont Gt p q0
                        | 1%positive => Gt
                        end
                    | (p~0)%positive =>
                        match y with
                        | (q0~1)%positive => compare_cont Lt p q0
                        | (q0~0)%positive => compare_cont r0 p q0
                        | 1%positive => Gt
                        end
                    | 1%positive =>
                        match y with
                        | 1%positive => r0
                        | _ => Lt
                        end
                    end) Eq HA m'
             end
           with
           | Gt => false
           | _ => true
           end
          then
           (match q with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end,
            match match r with
                  | 0%N => 1%N
                  | N.pos p => N.pos p~1
                  end with
            | 0%N => 0%N
            | N.pos n' =>
                match
                  (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                     match x with
                     | (p~1)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive => Pos.IsPos p~0
                         end
                     | (p~0)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p0~1)%positive => (p0~0~1)%positive
                                   | (p0~0)%positive =>
                                       ((pred_double p0)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p)
                         end
                     | 1%positive =>
                         match y with
                         | 1%positive => Pos.IsNul
                         | _ => Pos.IsNeg
                         end
                     end
                   with sub_mask_carry (x y : positive) {struct y} :
                       Pos.mask :=
                     match x with
                     | (p~1)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p0~1)%positive => (p0~0~1)%positive
                                   | (p0~0)%positive =>
                                       ((pred_double p0)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p)
                         end
                     | (p~0)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             match p with
                             | (p0~1)%positive => Pos.IsPos p0~0~0
                             | (p0~0)%positive =>
                                 Pos.IsPos
                                   ((fix pred_double 
                                     (x0 : positive) : positive :=
                                       match x0 with
                                       | (p1~1)%positive => (p1~0~1)%positive
                                       | (p1~0)%positive =>
                                           ((pred_double p1)~1)%positive
                                       | 1%positive => 1%positive
                                       end) p0)~0
                             | 1%positive => Pos.IsNul
                             end
                         end
                     | 1%positive => Pos.IsNeg
                     end
                   for
                   sub_mask) n' HA
                with
                | Pos.IsPos p => N.pos p
                | _ => 0%N
                end
            end)
          else
           (match q with
            | 0%N => 0%N
            | N.pos p => N.pos p~0
            end, match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq HA m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' HA
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      let (q, r) :=
        (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
           match a with
           | (a'~1)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 1%N
                         | N.pos p => N.pos p~1
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                                | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end)
           | (a'~0)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 0%N
                         | N.pos p => N.pos p~0
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                                | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end)
           | 1%positive =>
               match b with
               | 1%N => (1%N, 0%N)
               | _ => (0%N, 1%N)
               end
           end) p (N.pos HA) in
      if
       match
         match match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end with
         | 0%N => Gt
         | N.pos m' =>
             (fix compare_cont
                (r0 : comparison) (x y : positive) {struct y} : comparison :=
                match x with
                | (p~1)%positive =>
                    match y with
                    | (q0~1)%positive => compare_cont r0 p q0
                    | (q0~0)%positive => compare_cont Gt p q0
                    | 1%positive => Gt
                    end
                | (p~0)%positive =>
                    match y with
                    | (q0~1)%positive => compare_cont Lt p q0
                    | (q0~0)%positive => compare_cont r0 p q0
                    | 1%positive => Gt
                    end
                | 1%positive => match y with
                                | 1%positive => r0
                                | _ => Lt
                                end
                end) Eq HA m'
         end
       with
       | Gt => false
       | _ => true
       end
      then
       (match q with
        | 0%N => 1%N
        | N.pos p => N.pos p~1
        end,
        match match r with
              | 0%N => 1%N
              | N.pos p => N.pos p~1
              end with
        | 0%N => 0%N
        | N.pos n' =>
            match
              (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive => Pos.IsPos p~0
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         Pos.IsPos
                           ((fix pred_double (x0 : positive) : positive :=
                               match x0 with
                               | (p0~1)%positive => (p0~0~1)%positive
                               | (p0~0)%positive =>
                                   ((pred_double p0)~1)%positive
                               | 1%positive => 1%positive
                               end) p)
                     end
                 | 1%positive =>
                     match y with
                     | 1%positive => Pos.IsNul
                     | _ => Pos.IsNeg
                     end
                 end
               with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         Pos.IsPos
                           ((fix pred_double (x0 : positive) : positive :=
                               match x0 with
                               | (p0~1)%positive => (p0~0~1)%positive
                               | (p0~0)%positive =>
                                   ((pred_double p0)~1)%positive
                               | 1%positive => 1%positive
                               end) p)
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         match p with
                         | (p0~1)%positive => Pos.IsPos p0~0~0
                         | (p0~0)%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p1~1)%positive => (p1~0~1)%positive
                                   | (p1~0)%positive =>
                                       ((pred_double p1)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p0)~0
                         | 1%positive => Pos.IsNul
                         end
                     end
                 | 1%positive => Pos.IsNeg
                 end
               for
               sub_mask) n' HA
            with
            | Pos.IsPos p => N.pos p
            | _ => 0%N
            end
        end)
      else
       (match q with
        | 0%N => 0%N
        | N.pos p => N.pos p~0
        end, match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq HA m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' HA
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          let (q, r) :=
            (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
               match a with
               | (a'~1)%positive =>
                   let (q, r) := pos_div_eucl a' b in
                   if
                    match
                      match b with
                      | 0%N =>
                          match
                            match r with
                            | 0%N => 1%N
                            | N.pos p => N.pos p~1
                            end
                          with
                          | 0%N => Eq
                          | N.pos _ => Lt
                          end
                      | N.pos n' =>
                          match
                            match r with
                            | 0%N => 1%N
                            | N.pos p => N.pos p~1
                            end
                          with
                          | 0%N => Gt
                          | N.pos m' =>
                              (fix compare_cont
                                 (r0 : comparison) 
                                 (x y : positive) {struct y} : comparison :=
                                 match x with
                                 | (p~1)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont r0 p q0
                                     | (q0~0)%positive =>
                                         compare_cont Gt p q0
                                     | 1%positive => Gt
                                     end
                                 | (p~0)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont Lt p q0
                                     | (q0~0)%positive =>
                                         compare_cont r0 p q0
                                     | 1%positive => Gt
                                     end
                                 | 1%positive =>
                                     match y with
                                     | 1%positive => r0
                                     | _ => Lt
                                     end
                                 end) Eq n' m'
                          end
                      end
                    with
                    | Gt => false
                    | _ => true
                    end
                   then
                    (match q with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end,
                     match
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                     with
                     | 0%N => 0%N
                     | N.pos n' =>
                         match b with
                         | 0%N =>
                             match r with
                             | 0%N => 1%N
                             | N.pos p => N.pos p~1
                             end
                         | N.pos m' =>
                             match
                               (fix sub_mask (x y : positive) {struct y} :
                                    Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive => Pos.IsPos p~0
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | 1%positive =>
                                      match y with
                                      | 1%positive => Pos.IsNul
                                      | _ => Pos.IsNeg
                                      end
                                  end
                                with sub_mask_carry
                                  (x y : positive) {struct y} : Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          match p with
                                          | (p0~1)%positive =>
                                              Pos.IsPos p0~0~0
                                          | (p0~0)%positive =>
                                              Pos.IsPos ((... ...) p0)~0
                                          | 1%positive => Pos.IsNul
                                          end
                                      end
                                  | 1%positive => Pos.IsNeg
                                  end
                                for
                                sub_mask) n' m'
                             with
                             | Pos.IsPos p => N.pos p
                             | _ => 0%N
                             end
                         end
                     end)
                   else
                    (match q with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end,
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end)
               | (a'~0)%positive =>
                   let (q, r) := pos_div_eucl a' b in
                   if
                    match
                      match b with
                      | 0%N =>
                          match
                            match r with
                            | 0%N => 0%N
                            | N.pos p => N.pos p~0
                            end
                          with
                          | 0%N => Eq
                          | N.pos _ => Lt
                          end
                      | N.pos n' =>
                          match
                            match r with
                            | 0%N => 0%N
                            | N.pos p => N.pos p~0
                            end
                          with
                          | 0%N => Gt
                          | N.pos m' =>
                              (fix compare_cont
                                 (r0 : comparison) 
                                 (x y : positive) {struct y} : comparison :=
                                 match x with
                                 | (p~1)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont r0 p q0
                                     | (q0~0)%positive =>
                                         compare_cont Gt p q0
                                     | 1%positive => Gt
                                     end
                                 | (p~0)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont Lt p q0
                                     | (q0~0)%positive =>
                                         compare_cont r0 p q0
                                     | 1%positive => Gt
                                     end
                                 | 1%positive =>
                                     match y with
                                     | 1%positive => r0
                                     | _ => Lt
                                     end
                                 end) Eq n' m'
                          end
                      end
                    with
                    | Gt => false
                    | _ => true
                    end
                   then
                    (match q with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end,
                     match
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                     with
                     | 0%N => 0%N
                     | N.pos n' =>
                         match b with
                         | 0%N =>
                             match r with
                             | 0%N => 0%N
                             | N.pos p => N.pos p~0
                             end
                         | N.pos m' =>
                             match
                               (fix sub_mask (x y : positive) {struct y} :
                                    Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive => Pos.IsPos p~0
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | 1%positive =>
                                      match y with
                                      | 1%positive => Pos.IsNul
                                      | _ => Pos.IsNeg
                                      end
                                  end
                                with sub_mask_carry
                                  (x y : positive) {struct y} : Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          match p with
                                          | (p0~1)%positive =>
                                              Pos.IsPos p0~0~0
                                          | (p0~0)%positive =>
                                              Pos.IsPos ((... ...) p0)~0
                                          | 1%positive => Pos.IsNul
                                          end
                                      end
                                  | 1%positive => Pos.IsNeg
                                  end
                                for
                                sub_mask) n' m'
                             with
                             | Pos.IsPos p => N.pos p
                             | _ => 0%N
                             end
                         end
                     end)
                   else
                    (match q with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end,
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end)
               | 1%positive =>
                   match b with
                   | 1%N => (1%N, 0%N)
                   | _ => (0%N, 1%N)
                   end
               end) p (N.pos HA) in
          if
           match
             match match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end with
             | 0%N => Gt
             | N.pos m' =>
                 (fix compare_cont
                    (r0 : comparison) (x y : positive) {struct y} :
                      comparison :=
                    match x with
                    | (p~1)%positive =>
                        match y with
                        | (q0~1)%positive => compare_cont r0 p q0
                        | (q0~0)%positive => compare_cont Gt p q0
                        | 1%positive => Gt
                        end
                    | (p~0)%positive =>
                        match y with
                        | (q0~1)%positive => compare_cont Lt p q0
                        | (q0~0)%positive => compare_cont r0 p q0
                        | 1%positive => Gt
                        end
                    | 1%positive =>
                        match y with
                        | 1%positive => r0
                        | _ => Lt
                        end
                    end) Eq HA m'
             end
           with
           | Gt => false
           | _ => true
           end
          then
           (match q with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end,
            match match r with
                  | 0%N => 1%N
                  | N.pos p => N.pos p~1
                  end with
            | 0%N => 0%N
            | N.pos n' =>
                match
                  (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                     match x with
                     | (p~1)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive => Pos.IsPos p~0
                         end
                     | (p~0)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p0~1)%positive => (p0~0~1)%positive
                                   | (p0~0)%positive =>
                                       ((pred_double p0)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p)
                         end
                     | 1%positive =>
                         match y with
                         | 1%positive => Pos.IsNul
                         | _ => Pos.IsNeg
                         end
                     end
                   with sub_mask_carry (x y : positive) {struct y} :
                       Pos.mask :=
                     match x with
                     | (p~1)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p0~1)%positive => (p0~0~1)%positive
                                   | (p0~0)%positive =>
                                       ((pred_double p0)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p)
                         end
                     | (p~0)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             match p with
                             | (p0~1)%positive => Pos.IsPos p0~0~0
                             | (p0~0)%positive =>
                                 Pos.IsPos
                                   ((fix pred_double 
                                     (x0 : positive) : positive :=
                                       match x0 with
                                       | (p1~1)%positive => (p1~0~1)%positive
                                       | (p1~0)%positive =>
                                           ((pred_double p1)~1)%positive
                                       | 1%positive => 1%positive
                                       end) p0)~0
                             | 1%positive => Pos.IsNul
                             end
                         end
                     | 1%positive => Pos.IsNeg
                     end
                   for
                   sub_mask) n' HA
                with
                | Pos.IsPos p => N.pos p
                | _ => 0%N
                end
            end)
          else
           (match q with
            | 0%N => 0%N
            | N.pos p => N.pos p~0
            end, match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq HA m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' HA
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      let (q, r) :=
        (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
           match a with
           | (a'~1)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 1%N
                         | N.pos p => N.pos p~1
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                                | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end)
           | (a'~0)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 0%N
                         | N.pos p => N.pos p~0
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                                | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end)
           | 1%positive =>
               match b with
               | 1%N => (1%N, 0%N)
               | _ => (0%N, 1%N)
               end
           end) p (N.pos HA) in
      if
       match
         match match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end with
         | 0%N => Gt
         | N.pos m' =>
             (fix compare_cont
                (r0 : comparison) (x y : positive) {struct y} : comparison :=
                match x with
                | (p~1)%positive =>
                    match y with
                    | (q0~1)%positive => compare_cont r0 p q0
                    | (q0~0)%positive => compare_cont Gt p q0
                    | 1%positive => Gt
                    end
                | (p~0)%positive =>
                    match y with
                    | (q0~1)%positive => compare_cont Lt p q0
                    | (q0~0)%positive => compare_cont r0 p q0
                    | 1%positive => Gt
                    end
                | 1%positive => match y with
                                | 1%positive => r0
                                | _ => Lt
                                end
                end) Eq HA m'
         end
       with
       | Gt => false
       | _ => true
       end
      then
       (match q with
        | 0%N => 1%N
        | N.pos p => N.pos p~1
        end,
        match match r with
              | 0%N => 1%N
              | N.pos p => N.pos p~1
              end with
        | 0%N => 0%N
        | N.pos n' =>
            match
              (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive => Pos.IsPos p~0
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         Pos.IsPos
                           ((fix pred_double (x0 : positive) : positive :=
                               match x0 with
                               | (p0~1)%positive => (p0~0~1)%positive
                               | (p0~0)%positive =>
                                   ((pred_double p0)~1)%positive
                               | 1%positive => 1%positive
                               end) p)
                     end
                 | 1%positive =>
                     match y with
                     | 1%positive => Pos.IsNul
                     | _ => Pos.IsNeg
                     end
                 end
               with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         Pos.IsPos
                           ((fix pred_double (x0 : positive) : positive :=
                               match x0 with
                               | (p0~1)%positive => (p0~0~1)%positive
                               | (p0~0)%positive =>
                                   ((pred_double p0)~1)%positive
                               | 1%positive => 1%positive
                               end) p)
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         match p with
                         | (p0~1)%positive => Pos.IsPos p0~0~0
                         | (p0~0)%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p1~1)%positive => (p1~0~1)%positive
                                   | (p1~0)%positive =>
                                       ((pred_double p1)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p0)~0
                         | 1%positive => Pos.IsNul
                         end
                     end
                 | 1%positive => Pos.IsNeg
                 end
               for
               sub_mask) n' HA
            with
            | Pos.IsPos p => N.pos p
            | _ => 0%N
            end
        end)
      else
       (match q with
        | 0%N => 0%N
        | N.pos p => N.pos p~0
        end, match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq HA m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' HA
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching: (update n m Hb m = Hb)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
             match a with
             | (a'~1)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 1%N
                           | N.pos p => N.pos p~1
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end)
             | (a'~0)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 0%N
                           | N.pos p => N.pos p~0
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end)
             | 1%positive =>
                 match b with
                 | 1%N => (1%N, 0%N)
                 | _ => (0%N, 1%N)
                 end
             end) p (N.pos Hab) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq Hab m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' Hab
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
         match a with
         | (a'~1)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end)
         | (a'~0)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end)
         | 1%positive =>
             match b with
             | 1%N => (1%N, 0%N)
             | _ => (0%N, 1%N)
             end
         end) p (N.pos Hab) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq Hab m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' Hab
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
             match a with
             | (a'~1)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 1%N
                           | N.pos p => N.pos p~1
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end)
             | (a'~0)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 0%N
                           | N.pos p => N.pos p~0
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end)
             | 1%positive =>
                 match b with
                 | 1%N => (1%N, 0%N)
                 | _ => (0%N, 1%N)
                 end
             end) p (N.pos Hab) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq Hab m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' Hab
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
         match a with
         | (a'~1)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end)
         | (a'~0)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end)
         | 1%positive =>
             match b with
             | 1%N => (1%N, 0%N)
             | _ => (0%N, 1%N)
             end
         end) p (N.pos Hab) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq Hab m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' Hab
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
(forall x y lb ub : nat,
 lb <= x <= ub /\ lb <= y <= ub -> lb <= (x + y) / 2 <= ub)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Finished transaction in 41.562 secs (0.996u,0.164s) (successful)
Finished transaction in 0.076 secs (0.074u,0.s) (successful)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Finished transaction in 0.691 secs (0.684u,0.003s) (successful)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching: (update f f' k f' = k)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
             match a with
             | (a'~1)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 1%N
                           | N.pos p => N.pos p~1
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end)
             | (a'~0)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 0%N
                           | N.pos p => N.pos p~0
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end)
             | 1%positive =>
                 match b with
                 | 1%N => (1%N, 0%N)
                 | _ => (0%N, 1%N)
                 end
             end) p (N.pos Hab) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq Hab m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' Hab
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
         match a with
         | (a'~1)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end)
         | (a'~0)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end)
         | 1%positive =>
             match b with
             | 1%N => (1%N, 0%N)
             | _ => (0%N, 1%N)
             end
         end) p (N.pos Hab) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq Hab m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' Hab
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
             match a with
             | (a'~1)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 1%N
                           | N.pos p => N.pos p~1
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end)
             | (a'~0)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 0%N
                           | N.pos p => N.pos p~0
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end)
             | 1%positive =>
                 match b with
                 | 1%N => (1%N, 0%N)
                 | _ => (0%N, 1%N)
                 end
             end) p (N.pos Hab) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq Hab m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' Hab
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
         match a with
         | (a'~1)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end)
         | (a'~0)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end)
         | 1%positive =>
             match b with
             | 1%N => (1%N, 0%N)
             | _ => (0%N, 1%N)
             end
         end) p (N.pos Hab) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq Hab m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' Hab
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
find_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundMore readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
find_witness Control.TimeoutMore readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
find_witness Control.Timeoutfind_witness Control.TimeoutCase compile_stmt_correct/SLit
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
find_witness Control.TimeoutFinished transaction in 42.608 secs (2.12u,0.192s) (successful)
Finished transaction in 0.172 secs (0.171u,0.001s) (successful)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Case compile_stmt_correct/SOp
find_witness Control.TimeoutMore readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Finished transaction in 1.303 secs (1.298u,0.004s) (successful)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching: (forall b : x, EQ <> Ha -> update x' EQ b Ha = x' Ha)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching: (EQ <> q -> update x' EQ Hnd q = x' q)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
(map.only_differ locals1 vset locals2 ->
 Lift1Prop.iff1 (rep.equiv x (rep.rtype_of_ltype varnames) s locals1)
   (rep.equiv x (rep.rtype_of_ltype varnames) s locals2))
Crunching: Z
Crunching: (update x' Temp a a0 = x' a0)
Crunching: (n <> 0 -> update m n h 0 = m 0)
Crunching: (forall b : x, EQ <> Ha -> update x' EQ b Ha = x' Ha)
Reifying...
Crunching:
((forall (l1 lf1 : list R) (a b c : R) (f : R -> R),
  adapted_couple f a b l1 lf1 ->
  a <= c <= b -> {l : list R & {l0 : list R & adapted_couple f c b l l0}}) ->
 (pr_outcome_sum l (fun y : nat => f (S y)) + a)%R = sum_over_list (a :: l))
Finished transaction in 41.924 secs (1.413u,0.155s) (successful)
Finished transaction in 0.114 secs (0.113u,0.001s) (successful)
Finished transaction in 1.032 secs (1.027u,0.003s) (successful)
Crunching:
((forall (l1 lf1 : list R) (a b c : R) (f : R -> R),
  adapted_couple f a b l1 lf1 ->
  a <= c <= b -> {l : list R & {l0 : list R & adapted_couple f c b l l0}}) ->
 (a + pr_outcome_sum l (fun y : nat => f (S y)))%R = sum_over_list (a :: l))
Crunching: (EQ <> q -> update x' EQ Hnd q = x' q)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall d1 d2 : R,
 d1 > R0 ->
 d2 > R0 ->
 (if Rcase_abs (l - P) then (- (l - P))%R else (l - P)%R) < Rmin d1 d2 ->
 P - d1 <= l <= P + d2)
Crunching:
(forall d1 d2 : R,
 d1 > R0 ->
 d2 > R0 ->
 (if Rcase_abs (l - P) then (- (l - P))%R else (l - P)%R) < Rmin d1 d2 ->
 P - d1 <= l <= P + d2)
Crunching:
(forall d1 d2 : R,
 d1 > R0 ->
 d2 > R0 ->
 (if Rcase_abs (l - P) then (- (l - P))%R else (l - P)%R) < Rmin d1 d2 ->
 P - d1 <= l <= P + d2)
find_witness Control.TimeoutCrunching:
(forall d1 d2 : R,
 d1 > R0 ->
 d2 > R0 ->
 (if Rcase_abs (l - P) then (- (l - P))%R else (l - P)%R) < Rmin d1 d2 ->
 P - d1 <= l <= P + d2)
Crunching: (R - n <= L <= R + d2)
Crunching: (R - n <= L <= R + d2)
Crunching: (R - n <= L <= R + d2)
Crunching:
(PI / 4 < PI / 2 ->
 (forall x l1 l2 : R,
  derivable_pt_lim (id + fct_cte (PI / 2)) x l1 ->
  derivable_pt_lim sin ((id + fct_cte (PI / 2))%F x) l2 ->
  derivable_pt_lim (comp sin (id + fct_cte (PI / 2))) x (l2 * l1)%R) ->
 x - H <= y <= x + l)
Finished transaction in 42.53 secs (2.071u,0.174s) (successful)
Finished transaction in 0.177 secs (0.175u,0.001s) (successful)
FlattenExpr: Entering slow lemmas section
Crunching: (x - H <= y <= x + LE)
Finished transaction in 1.361 secs (1.355u,0.003s) (successful)
find_witness Control.TimeoutTactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching: (r - Hy <= y <= r + HnotA)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching: (r - Hy <= y <= r + HnotA)
Crunching: (r - Hy <= y <= r + HnotA)
Crunching: (Rabs (y - r) < Rmin Hy HnotA -> r - Hy <= y <= r + HnotA)
Crunching: (Rabs (y - r) < Rmin Hy del -> r - Hy <= y <= r + del)
Crunching: (Rabs (y - r) < Rmin Hy del -> r - Hy <= y <= r + del)
Crunching: (Rabs (y - r) < Rmin Hy del -> r - Hy <= y <= r + del)
Crunching: (update e2 z1 z2 = e2)
Crunching: (Rabs (y - r) < Rmin Hy del -> r - Hy <= y <= r + del)
Crunching: (update e2 z1 z2 = e2)
Case compile_stmt_correct/SSet
Compiling decision tree...
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Splitting rewrite rules...
Tactic call ran for 0.014 secs (0.013u,0.001s) (success)
Crunching: (r - a <= x <= r + b)
Case compile_stmt_correct/SIf/Then
Crunching:
(m > 0 -> H2 > 0 -> Rabs (x - r) < Rmin m H2 -> r - m <= x <= r + H2)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.01 secs (0.01u,0.s) (success)
find_witness Control.TimeoutCrunching: (Rabs (a - l) < Rmin b H0 -> l - b <= a <= l + H0)
Crunching: (l - b <= a <= l + n)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Case compile_stmt_correct/SIf/Else
Finished transaction in 42.087 secs (1.566u,0.168s) (successful)
find_witness Control.TimeoutFinished transaction in 0.118 secs (0.116u,0.002s) (successful)
find_witness Control.TimeoutFinished transaction in 0.972 secs (0.968u,0.004s) (successful)
Tactic call ran for 0.012 secs (0.011u,0.s) (success)
find_witness Control.TimeoutCase compile_stmt_correct/SLoop
find_witness Control.TimeoutTactic call ran for 0.01 secs (0.01u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(forall (e : list Symbolic.expr) (v1 v2 : list Z),
 Forall2 (eval G1 d1) e v1 -> Forall2 (eval G2 d2) e v2 -> v1 = v2)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
find_witness Control.TimeoutCrunching:
(exp (pr_outcome_sum l H2) <
 exp (pr_outcome_sum l (fun rnd : nat => H2 rnd || f2 rnd)))
Assembling rewrite_head...
find_witness Control.Timeoutfind_witness Control.TimeoutReducing rewrite_head...
find_witness Control.TimeoutCrunching: (update (update m 0 H) 0 a = update m 0 a)
find_witness Control.TimeoutCrunching: False
find_witness Control.TimeoutCrunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: False
Crunching: (update (update m 0 H) 0 a = update m 0 a)
find_witness Control.TimeoutCrunching: False
Finished transaction in 42.562 secs (2.054u,0.175s) (successful)
Tactic call ran for 4.009 secs (3.975u,0.029s) (success)
find_witness Control.TimeoutFinished transaction in 0.169 secs (0.166u,0.002s) (successful)
Crunching: False
Crunching: False
Finished transaction in 1.434 secs (1.422u,0.01s) (successful)
find_witness Control.TimeoutCrunching: False
find_witness Control.TimeoutCrunching: False
find_witness Control.TimeoutCrunching: False
find_witness Control.Timeout(forall (e : list Symbolic.expr) (v1 v2 : list Z),
 Forall2 (eval G1 d1) e v1 -> Forall2 (eval G2 d2) e v2 -> v1 = v2)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
Crunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
Crunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching:
((forall x : nat, p x = true -> Heq x = true) ->
 pr_outcome_sum l p <= pr_outcome_sum l Heq * 1)
Crunching:
(nat ->
 (fun j : nat =>
  if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) j 0
  then H'2
  else
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) j 0
   then H
   else m j) =
 (fun j : nat =>
  if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) j 0
  then H'2
  else m j))
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: False
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching:
(nat ->
 (fun j : nat =>
  if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) j 0
  then H'2
  else
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) j 0
   then H
   else m j) =
 (fun j : nat =>
  if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) j 0
  then H'2
  else m j))
Finished transaction in 43.275 secs (2.721u,0.17s) (successful)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: False
find_witness Control.TimeoutCrunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
find_witness Control.TimeoutCrunching:
(nat ->
 (fun j : nat =>
  if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) j 0
  then H'2
  else
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) j 0
   then H
   else m j) =
 (fun j : nat =>
  if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) j 0
  then H'2
  else m j))
bad
find_witness Control.TimeoutFinished transaction in 0.215 secs (0.212u,0.003s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 2.103 secs (2.095u,0.003s) (successful)
find_witness Control.TimeoutCrunching:
((forall x : nat, p x = true -> Heq x = true) ->
 pr_outcome_sum l p <= pr_outcome_sum l Heq * 1)
find_witness Control.TimeoutFinished transaction in 32.738 secs (0.09u,0.132s) (successful)
Finished transaction in 0.007 secs (0.006u,0.s) (successful)
Finished transaction in 0.036 secs (0.028u,0.007s) (successful)
find_witness Control.TimeoutCrunching:
(P <> n -> update (update ep P a) n b = update (update ep n b) P a)
find_witness Control.TimeoutCrunching:
(P <> n -> update (update ep P a) n b = update (update ep n b) P a)
Crunching:
(P <> n -> update (update ep P a) n b = update (update ep n b) P a)
Crunching:
((forall x : nat, p x = true -> Heq x = true) ->
 pr_outcome_sum l p <= pr_outcome_sum l Heq * 1)
Crunching:
(forall b b' : eps,
 P <> n -> update (update ep P b) n b' = update (update ep n b') P b)
Crunching:
(forall b b' : eps,
 P <> n -> update (update ep P b) n b' = update (update ep n b') P b)
Crunching:
(forall b b' : eps,
 P <> n -> update (update ep P b) n b' = update (update ep n b') P b)
Crunching:
(forall b b' : eps,
 P <> n -> update (update ep P b) n b' = update (update ep n b') P b)
Crunching:
(forall b b' : eps,
 P <> n -> update (update ep P b) n b' = update (update ep n b') P b)
Crunching:
(forall (i j : nat) (b b' : eps),
 i <> j -> update (update ep i b) j b' = update (update ep j b') i b)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update (update r fv lm) k H = update (update r k H) fv lm)
Crunching:
(forall b b' : eps,
 P <> 0 -> update (update ep P b) 0 b' = update (update ep 0 b') P b)
Case compile_stmt_correct/SSeq
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (update (update ep P Hxij') 0 z = update (update ep 0 z) P Hxij')
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Finished transaction in 35.038 secs (34.819u,0.178s) (successful)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.001s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (0 <= r1 <= r2 -> r2 * r1 + r1 * r2 <= r1 * r1 + r2 * r2)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (0 <= pr_outcome_sum n HP)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Case compile_stmt_correct/SSkip
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: (0 < 0)%R
Finished transaction in 43.693 secs (3.131u,0.183s) (successful)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (0 < 0)%nat
Finished transaction in 40.898 secs (0.432u,0.177s) (successful)
Finished transaction in 0.033 secs (0.032u,0.s) (successful)
Finished transaction in 0.231 secs (0.23u,0.s) (successful)
Crunching: Type
Finished transaction in 0.273 secs (0.255u,0.017s) (successful)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (0 <= pr_outcome_sum n a)
Crunching: (0 <= pr_outcome_sum n HP)
Crunching: (shift f 0 = f)
find_witness Control.TimeoutFinished transaction in 2.699 secs (2.66u,0.029s) (successful)
Crunching: (0 < 0)%R
Crunching: (0 <= pr_outcome_sum n HP)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(0 <= 0 + big_sum (fun i : nat => if f i then nth i [] 0 else 0) (length []))
Crunching: (0 <= 0 + pr_outcome_sum [] f)
Crunching:
(0 <= 0 + big_sum (fun i : nat => if f i then nth i [] 0 else 0) (length []))
Crunching: (0 <= 0 + pr_outcome_sum [] f)
Crunching:
(0 <= 0 + big_sum (fun i : nat => if f i then nth i [] 0 else 0) (length []))
Crunching: (0 <= 0 + pr_outcome_sum [] f)
Crunching: (∣0⟩ = basis_vector 2 0)
Finished transaction in 29.079 secs (28.857u,0.189s) (successful)
Crunching: (shift f 0 = f)
Crunching: (0 < 0)%nat
find_witness Control.TimeoutCrunching: (0 < 0)%R
Crunching: Type
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutFlattenExpr: flattenExpr_correct_aux done
find_witness Control.TimeoutCrunching:
(interval_sum q x n Hqltx ->
 interval_sum (fun x : R => q (x + - s)%R) (x + s) (n + s) Hqltx)
Crunching: (forall j : nat, shift (shift y j) H = shift y (H + j))
Crunching: (shift (shift n b) a = shift n (a + b))
find_witness Control.TimeoutCrunching: (forall j : nat, shift (shift y j) H = shift y (H + j))
find_witness Control.TimeoutCrunching: (shift (shift n b) a = shift n (a + b))
Finished transaction in 0.389 secs (0.386u,0.003s) (successful)
find_witness Control.TimeoutFinished transaction in 0.45 secs (0.446u,0.004s) (successful)
Crunching: (shift (shift eps0_pos z') 0 = shift eps0_pos z')
Finished transaction in 40.943 secs (0.472u,0.193s) (successful)
Finished transaction in 0.036 secs (0.036u,0.s) (successful)
Finished transaction in 0.226 secs (0.226u,0.s) (successful)
find_witness Control.TimeoutCrunching:
(forall rl rr r1 r2 : R,
 rl <= r1 <= r2 /\ r2 <= rr ->
 (forall r : R, r1 < r < r2 -> del1 r) ->
 (forall r : R, rl < r < r1 -> ~ del1 r) ->
 (forall r : R, r2 < r < rr -> ~ del1 r) ->
 interval_sum (fun x : R => del1 (x - Na)%R) (rl + Na) (rr + Na) (r2 - r1))
find_witness Control.TimeoutCrunching:
(interval_sum (fun x : R => del1 (x + - N1)%R) (H + N1) (Hp + N1) w)
Crunching: (forall j : nat, shift (shift y j) H = shift y (H + j))
Crunching: (shift (shift n b) a = shift n (a + b))
find_witness Control.TimeoutCrunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift eps0_pos m = eps0_pos)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (S m < n \/ S m = n -> False)
Finished transaction in 44.078 secs (3.489u,0.181s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 0.236 secs (0.235u,0.s) (successful)
Crunching: (shift eps0_pos j = eps0_pos)
find_witness Control.TimeoutCrunching: (shift (shift eps0_pos z') 0 = shift eps0_pos z')
find_witness Control.TimeoutCrunching: (shift (shift eps0_pos z') 0 = shift eps0_pos z')
Finished transaction in 2.499 secs (2.467u,0.026s) (successful)
find_witness Control.TimeoutCrunching:
(interval_sum q x n Hqltx ->
 interval_sum (fun x : R => q (x + - s)%R) (x + s) (n + s) Hqltx)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (m < p - 0 -> 0 + m < p)
Crunching: (forall j : nat, shift (shift y j) H = shift y (H + j))
Finished transaction in 43.295 secs (3.015u,0.132s) (successful)
Crunching: (shift (shift y H0) H = shift y (H + H0))
Crunching: (shift (shift n b) a = shift n (a + b))
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift f (i + j) x = shift (shift f j) i x)
Crunching: (shift f (i + j) x = shift (shift f j) i x)
Crunching: (forall j : nat, shift (shift H15 j) p = shift H15 (p + j))
Crunching: (shift eps0_pos m = eps0_pos)
Crunching: (shift eps0_pos m = eps0_pos)
Crunching: (shift eps0_pos m = eps0_pos)
Crunching: (shift eps0_pos m = eps0_pos)
Crunching: (shift eps0_pos m = eps0_pos)
Crunching: (S m < n \/ S m = n -> False)
Crunching: (S m < n \/ S m = n -> False)
Crunching:
(forall rr r : R,
 interval_sum H7 H rr r ->
 (forall x : R, (H < x \/ H = x) /\ x < rr -> H7 x <-> Ha x) ->
 interval_sum Ha H rr r)
Crunching:
(forall (P2 : R -> Prop) (rl rr r : R),
 interval_sum Hcontra rl rr r ->
 (forall x : R, (rl < x \/ rl = x) /\ x < rr -> Hcontra x <-> P2 x) ->
 interval_sum P2 rl rr r)
find_witness Control.TimeoutFinished transaction in 40.806 secs (0.05u,0.228s) (successful)
Finished transaction in 0.003 secs (0.002u,0.s) (successful)
Finished transaction in 0.018 secs (0.017u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall x y : nat, fswap abs x y x = abs y)
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
 proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1))
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) = true =>
 ltN_intro
   (ltN_intro (exist (fun k : nat => (k <? 2) = true) H0 H1)
      (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
   (ltN_of_nat
      (Init.Nat.pred
         (proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1))) 1
      (ltN_comm_intro_lemma1 (exist (fun k : nat => (k <? 1) = true) IH1 IH2)
         (exist (fun k : nat => (k <? 2) = true) H0 H1) E)))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) = false =>
 ltN_intro
   (ltN_intro (exist (fun k : nat => (k <? 2) = true) H0 H1)
      (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) 1
      (ltN_comm_intro_lemma2 (exist (fun k : nat => (k <? 1) = true) IH1 IH2)
         (exist (fun k : nat => (k <? 2) = true) H0 H1) E)))
string
rewrite if_dtt
if
match H0 with
| 0 => false
| S x =>
    (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
       match x0 with
       | 0 => true
       | S x2 => match x1 with
                 | 0 => false
                 | S x3 => Ffix x2 x3
                 end
       end) IH1 x
end
then
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = true =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
          eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) match H0 with
               | 0 => H0
               | S x1 => x1
               end x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) match H0 with
                  | 0 => H0
                  | S x1 => x1
                  end x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) match H0 with
                              | 0 => H0
                              | S x => x
                              end
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S match H0 with
                                 | 0 => H0
                                 | S x => x
                                 end)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1))
   eq_refl)
else
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = false =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
          eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) H0 x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) H0 x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) H0
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S H0)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1))
   eq_refl)
find_witness Control.TimeoutCrunching: (forall x y : nat, fswap abs x y x = abs y)
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
 proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1))
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) = true =>
 ltN_intro
   (ltN_intro (exist (fun k : nat => (k <? 2) = true) H0 H1)
      (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
   (ltN_of_nat
      (Init.Nat.pred
         (proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1))) 1
      (ltN_comm_intro_lemma1 (exist (fun k : nat => (k <? 1) = true) IH1 IH2)
         (exist (fun k : nat => (k <? 2) = true) H0 H1) E)))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) = false =>
 ltN_intro
   (ltN_intro (exist (fun k : nat => (k <? 2) = true) H0 H1)
      (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) 1
      (ltN_comm_intro_lemma2 (exist (fun k : nat => (k <? 1) = true) IH1 IH2)
         (exist (fun k : nat => (k <? 2) = true) H0 H1) E)))
Crunching: (n < n)
Finished transaction in 48.129 secs (7.562u,0.257s) (successful)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Finished transaction in 0.545 secs (0.535u,0.008s) (successful)
find_witness Control.TimeoutCrunching:
(forall rr r : R,
 interval_sum H7 H rr r ->
 (forall x : R, (H < x \/ H = x) /\ x < rr -> H7 x <-> Ha x) ->
 interval_sum Ha H rr r)
Crunching:
((forall x : R, (b < x \/ b = x) /\ x < Hb -> Hcontra x <-> H0 x) ->
 interval_sum H0 b Hb IH)
Finished transaction in 4.528 secs (4.506u,0.017s) (successful)
rewrite if_dtt
if
match H0 with
| 0 => false
| S x =>
    (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
       match x0 with
       | 0 => true
       | S x2 => match x1 with
                 | 0 => false
                 | S x3 => Ffix x2 x3
                 end
       end) IH1 x
end
then
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = true =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
          eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) match H0 with
               | 0 => H0
               | S x1 => x1
               end x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) match H0 with
                  | 0 => H0
                  | S x1 => x1
                  end x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) match H0 with
                              | 0 => H0
                              | S x => x
                              end
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S match H0 with
                                 | 0 => H0
                                 | S x => x
                                 end)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1))
   eq_refl)
else
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = false =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
          eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) H0 x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) H0 x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) H0
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S H0)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1))
   eq_refl)
rewrite if_dtt
if
match H0 with
| 0 => false
| S x =>
    (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
       match x0 with
       | 0 => true
       | S x2 => match x1 with
                 | 0 => false
                 | S x3 => Ffix x2 x3
                 end
       end) IH1 x
end
then
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = true =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <=? S n) = true) H0 x)
               (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <=? S n) = true) H0 x)
               (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)) eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) match H0 with
               | 0 => H0
               | S x1 => x1
               end x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <=? S n) = true) H0 x)
                  (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <=? S n) = true) H0 x)
                  (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) match H0 with
                  | 0 => H0
                  | S x1 => x1
                  end x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) match H0 with
                              | 0 => H0
                              | S x => x
                              end
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <=? n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <=? n) = true) IH1 IH2)
              (exist (fun k : nat => (k <=? S n) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S match H0 with
                                 | 0 => H0
                                 | S x => x
                                 end)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <=? n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <=? n) = true) IH1 IH2)
              (exist (fun k : nat => (k <=? S n) = true) H0 x) x0)) x1))
   eq_refl)
else
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = false =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <=? S n) = true) H0 x)
               (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <=? S n) = true) H0 x)
               (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)) eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) H0 x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <=? S n) = true) H0 x)
                  (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <=? S n) = true) H0 x)
                  (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) H0 x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) H0
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <=? n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <=? n) = true) IH1 IH2)
              (exist (fun k : nat => (k <=? S n) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S H0)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <=? n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <=? n) = true) IH1 IH2)
              (exist (fun k : nat => (k <=? S n) = true) H0 x) x0)) x1))
   eq_refl)
Finished transaction in 43.138 secs (2.63u,0.196s) (successful)
rewrite if_dtt
if
match H0 with
| 0 => false
| S x =>
    (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
       match x0 with
       | 0 => true
       | S x2 => match x1 with
                 | 0 => false
                 | S x3 => Ffix x2 x3
                 end
       end) IH1 x
end
Finished transaction in 0.193 secs (0.188u,0.003s) (successful)
then
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = true =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
          eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) match H0 with
               | 0 => H0
               | S x1 => x1
               end x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) match H0 with
                  | 0 => H0
                  | S x1 => x1
                  end x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) match H0 with
                              | 0 => H0
                              | S x => x
                              end
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S match H0 with
                                 | 0 => H0
                                 | S x => x
                                 end)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1))
   eq_refl)
else
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = false =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
          eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) H0 x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) H0 x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) H0
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S H0)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1))
   eq_refl)
rewrite if_dtt
if
match H0 with
| 0 => false
| S x =>
    (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
       match x0 with
       | 0 => true
       | S x2 => match x1 with
                 | 0 => false
                 | S x3 => Ffix x2 x3
                 end
       end) IH1 x
end
then
(fun
   x : match H0 with
       | 0 => false
       | S x =>
           (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
              match x0 with
              | 0 => true
              | S x2 => match x1 with
                        | 0 => false
                        | S x3 => Ffix x2 x3
                        end
              end) IH1 x
       end = true =>
 (if
   match
     (let (x0, _) :=
        (if
          match H0 with
          | 0 => false
          | S x0 =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x0
          end as c
          return
            (match H0 with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x0
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x0 : match H0 with
                 | 0 => false
                 | S x0 =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x0
                 end = true =>
          exist
            (fun x1 : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x1 (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0)
         else
          fun
            x0 : match H0 with
                 | 0 => false
                 | S x0 =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x0
                 end = false =>
          exist
            (fun x1 : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x1 (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0))
          eq_refl in
      x0)
   with
   | 0 => false
   | S x0 =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) match H0 with
               | 0 => H0
               | S x1 => x1
               end x0
   end as c
   return
     (match
        (let (x0, _) :=
           (if
             match H0 with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x0
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x0 =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x0
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x0 : match H0 with
                    | 0 => false
                    | S x0 =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x0
                    end = true =>
             exist
               (fun x1 : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x1 (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0)
            else
             fun
               x0 : match H0 with
                    | 0 => false
                    | S x0 =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x0
                    end = false =>
             exist
               (fun x1 : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x1 (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0))
             eq_refl in
         x0)
      with
      | 0 => false
      | S x0 =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) match H0 with
                  | 0 => H0
                  | S x1 => x1
                  end x0
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x0 : match
            (let (x0, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x0 =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x0
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x0 =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x0
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x0 : match H0 with
                        | 0 => false
                        | S x0 =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x0
                        end = true =>
                 exist
                   (fun x1 : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x1 (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0)
                else
                 fun
                   x0 : match H0 with
                        | 0 => false
                        | S x0 =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x0
                        end = false =>
                 exist
                   (fun x1 : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x1 (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0))
                 eq_refl in
             x0)
          with
          | 0 => false
          | S x0 =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x0
          end = true =>
   exist
     (fun x1 : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x1 (S n) = true) match H0 with
                               | 0 => H0
                               | S x1 => x1
                               end
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x1 =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x1
           end as c
           return
             (match H0 with
              | 0 => false
              | S x1 =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x1
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x1 : match H0 with
                  | 0 => false
                  | S x1 =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x1
                  end = true =>
           exist
             (fun x2 : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x2 (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
          else
           fun
             x1 : match H0 with
                  | 0 => false
                  | S x1 =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x1
                  end = false =>
           exist
             (fun x2 : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x2 (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match H0 with
           | 0 => H0
           | S x1 => x1
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 pol) x)) x0)
  else
   fun
     x0 : match
            (let (x0, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x0 =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x0
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x0 =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x0
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x0 : match H0 with
                        | 0 => false
                        | S x0 =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x0
                        end = true =>
                 exist
                   (fun x1 : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x1 (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0)
                else
                 fun
                   x0 : match H0 with
                        | 0 => false
                        | S x0 =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x0
                        end = false =>
                 exist
                   (fun x1 : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x1 (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0))
                 eq_refl in
             x0)
          with
          | 0 => false
          | S x0 =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x0
          end = false =>
   exist
     (fun x1 : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x1 (S n) = true) (S match H0 with
                                  | 0 => H0
                                  | S x1 => x1
                                  end)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x1 =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x1
           end as c
           return
             (match H0 with
              | 0 => false
              | S x1 =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x1
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x1 : match H0 with
                  | 0 => false
                  | S x1 =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x1
                  end = true =>
           exist
             (fun x2 : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x2 (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
          else
           fun
             x1 : match H0 with
                  | 0 => false
                  | S x1 =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x1
                  end = false =>
           exist
             (fun x2 : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x2 (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match H0 with
           | 0 => H0
           | S x1 => x1
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 pol) x)) x0))
   eq_refl)
else
(fun
   x : match H0 with
       | 0 => false
       | S x =>
           (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
              match x0 with
              | 0 => true
              | S x2 => match x1 with
                        | 0 => false
                        | S x3 => Ffix x2 x3
                        end
              end) IH1 x
       end = false =>
 (if
   match
     (let (x0, _) :=
        (if
          match H0 with
          | 0 => false
          | S x0 =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x0
          end as c
          return
            (match H0 with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x0
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x0 : match H0 with
                 | 0 => false
                 | S x0 =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x0
                 end = true =>
          exist
            (fun x1 : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x1 (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0)
         else
          fun
            x0 : match H0 with
                 | 0 => false
                 | S x0 =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x0
                 end = false =>
          exist
            (fun x1 : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x1 (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0))
          eq_refl in
      x0)
   with
   | 0 => false
   | S x0 =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) H0 x0
   end as c
   return
     (match
        (let (x0, _) :=
           (if
             match H0 with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x0
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x0 =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x0
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x0 : match H0 with
                    | 0 => false
                    | S x0 =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x0
                    end = true =>
             exist
               (fun x1 : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x1 (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0)
            else
             fun
               x0 : match H0 with
                    | 0 => false
                    | S x0 =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x0
                    end = false =>
             exist
               (fun x1 : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x1 (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0))
             eq_refl in
         x0)
      with
      | 0 => false
      | S x0 =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) H0 x0
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x0 : match
            (let (x0, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x0 =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x0
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x0 =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x0
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x0 : match H0 with
                        | 0 => false
                        | S x0 =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x0
                        end = true =>
                 exist
                   (fun x1 : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x1 (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0)
                else
                 fun
                   x0 : match H0 with
                        | 0 => false
                        | S x0 =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x0
                        end = false =>
                 exist
                   (fun x1 : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x1 (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0))
                 eq_refl in
             x0)
          with
          | 0 => false
          | S x0 =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x0
          end = true =>
   exist
     (fun x1 : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x1 (S n) = true) H0
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x1 =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x1
           end as c
           return
             (match H0 with
              | 0 => false
              | S x1 =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x1
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x1 : match H0 with
                  | 0 => false
                  | S x1 =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x1
                  end = true =>
           exist
             (fun x2 : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x2 (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
          else
           fun
             x1 : match H0 with
                  | 0 => false
                  | S x1 =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x1
                  end = false =>
           exist
             (fun x2 : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x2 (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 pol) x)) x0)
  else
   fun
     x0 : match
            (let (x0, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x0 =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x0
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x0 =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x0
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x0 : match H0 with
                        | 0 => false
                        | S x0 =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x0
                        end = true =>
                 exist
                   (fun x1 : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x1 (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0)
                else
                 fun
                   x0 : match H0 with
                        | 0 => false
                        | S x0 =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x0
                        end = false =>
                 exist
                   (fun x1 : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x1 (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x0))
                 eq_refl in
             x0)
          with
          | 0 => false
          | S x0 =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x0
          end = false =>
   exist
     (fun x1 : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x1 (S n) = true) (S H0)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x1 =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x1
           end as c
           return
             (match H0 with
              | 0 => false
              | S x1 =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x1
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x1 : match H0 with
                  | 0 => false
                  | S x1 =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x1
                  end = true =>
           exist
             (fun x2 : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x2 (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
          else
           fun
             x1 : match H0 with
                  | 0 => false
                  | S x1 =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x1
                  end = false =>
           exist
             (fun x2 : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x2 (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 pol)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 pol) x)) x0))
   eq_refl)
rewrite if_dtt
if
match H0 with
| 0 => false
| S x =>
    (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
       match x0 with
       | 0 => true
       | S x2 => match x1 with
                 | 0 => false
                 | S x3 => Ffix x2 x3
                 end
       end) IH1 x
end
then
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = true =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
          eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) match H0 with
               | 0 => H0
               | S x1 => x1
               end x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) match H0 with
                  | 0 => H0
                  | S x1 => x1
                  end x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) match H0 with
                              | 0 => H0
                              | S x => x
                              end
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S match H0 with
                                 | 0 => H0
                                 | S x => x
                                 end)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1))
   eq_refl)
else
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = false =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
          eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) H0 x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) H0 x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) H0
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S H0)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) H0 x)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) H0 x) x0)) x1))
   eq_refl)
rewrite if_dtt
if
match H0 with
| 0 => false
| S x =>
    (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
       match x0 with
       | 0 => true
       | S x2 => match x1 with
                 | 0 => false
                 | S x3 => Ffix x2 x3
                 end
       end) IH1 x
end
then
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = true =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <=? S n) = true) H0 x)
               (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <=? S n) = true) H0 x)
               (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)) eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) match H0 with
               | 0 => H0
               | S x1 => x1
               end x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <=? S n) = true) H0 x)
                  (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <=? S n) = true) H0 x)
                  (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) match H0 with
                  | 0 => H0
                  | S x1 => x1
                  end x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) match H0 with
                              | 0 => H0
                              | S x => x
                              end
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <=? n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <=? n) = true) IH1 IH2)
              (exist (fun k : nat => (k <=? S n) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match H0 with
                      | 0 => H0
                      | S x1 => x1
                      end x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S match H0 with
                                 | 0 => H0
                                 | S x => x
                                 end)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <=? n) = true)
           match H0 with
           | 0 => H0
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <=? n) = true) IH1 IH2)
              (exist (fun k : nat => (k <=? S n) = true) H0 x) x0)) x1))
   eq_refl)
else
(fun
   x0 : match H0 with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = false =>
 (if
   match
     (let (x, _) :=
        (if
          match H0 with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x1 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x1 (S n) = true})
         then
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <=? S n) = true) H0 x)
               (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
         else
          fun
            x1 : match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                match x2 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <=? S n) = true) H0 x)
               (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)) eq_refl in
      x)
   with
   | 0 => false
   | S x =>
       (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
          match x1 with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) H0 x
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match H0 with
             | 0 => false
             | S x =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match H0 with
                | 0 => false
                | S x =>
                    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                       match x1 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x1 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x1 (S n) = true})
            then
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <=? S n) = true) H0 x)
                  (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
            else
             fun
               x1 : match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                   match x2 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <=? S n) = true) H0 x)
                  (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
             eq_refl in
         x)
      with
      | 0 => false
      | S x =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) H0 x
      end = c ->
      {x1 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 (S n) = true})
  then
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) H0
     (ltN_intro_lemma1 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <=? n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <=? n) = true) IH1 IH2)
              (exist (fun k : nat => (k <=? S n) = true) H0 x) x0)) x1)
  else
   fun
     x1 : match
            (let (x, _) :=
               (if
                 match H0 with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                        match x1 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match H0 with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                           match x1 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x1 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x1 (S n) = true})
                then
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1)
                else
                 fun
                   x1 : match H0 with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                               match x1 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                       match x2 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <=? S n) = true) H0 x)
                      (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x1))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x =>
              (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                 match x1 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) H0 x
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
         match x2 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S H0)
     (ltN_intro_lemma2 (S n)
        ((if
           match H0 with
           | 0 => false
           | S x =>
               (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match H0 with
              | 0 => false
              | S x =>
                  (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x2 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x2 (S n) = true})
          then
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2)
          else
           fun
             x2 : match H0 with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                 match x3 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <=? S n) = true) H0 x)
                (exist (fun k : nat => (k <=? n) = true) IH1 IH2) x2))
           eq_refl)
        (exist (fun k : nat => (k <=? n) = true) H0
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <=? n) = true) IH1 IH2)
              (exist (fun k : nat => (k <=? S n) = true) H0 x) x0)) x1))
   eq_refl)
Finished transaction in 1.567 secs (1.561u,0.001s) (successful)
Crunching:
(forall (P2 : R -> Prop) (rl rr r : R),
 interval_sum Hcontra rl rr r ->
 (forall x : R, (rl < x \/ rl = x) /\ x < rr -> Hcontra x <-> P2 x) ->
 interval_sum P2 rl rr r)
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_one_gen x x0
    x1 x2 x3 = onemod x x0 x1 x2 x3) /\ Wf.Compilers.expr.Wf reified_one_gen)
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_one_gen x x0
    x1 x2 x3 = onemod x x0 x1 x2 x3) /\ Wf.Compilers.expr.Wf reified_one_gen)
Crunching: (continue_in atan no_cond 1)
Crunching: (continue_in atan no_cond 1)
Crunching:
(interval_sum f l2 m Hin ->
 (forall x : R, l2 <= x < m -> f x <-> H2 x) -> interval_sum H2 l2 m Hin)
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_one_gen x x0
    x1 x2 x3 = onemod x x0 x1 x2 x3) /\ Wf.Compilers.expr.Wf reified_one_gen)
Crunching: (continue_in atan no_cond 1)
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_one_gen x x0
    x1 x2 x3 = onemod x x0 x1 x2 x3) /\ Wf.Compilers.expr.Wf reified_one_gen)
Crunching: (continue_in atan no_cond 1)
Crunching: (continue_in atan no_cond 1)
Crunching: (Morphisms.respectful ?R2 eq (fswap N0 H4 abs) N0)
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_one_gen x x0
    x1 x2 x3 = onemod x x0 x1 x2 x3) /\ Wf.Compilers.expr.Wf reified_one_gen)
Crunching: (rl <= r1 <= r2)
More readable: initial segment:
optBind
With remainder:
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
find_witness Control.TimeoutMore readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_one_gen x x0
    x1 x2 x3 = onemod x x0 x1 x2 x3) /\ Wf.Compilers.expr.Wf reified_one_gen)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
rewrite if_dtt
if
match x with
| 0 => false
| S x =>
    (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
       match x0 with
       | 0 => true
       | S x2 => match x1 with
                 | 0 => false
                 | S x3 => Ffix x2 x3
                 end
       end) IH1 x
end
then
(fun
   x1 : match x with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = true =>
 (if
   match
     (let (x, _) :=
        (if
          match x with
          | 0 => false
          | S x =>
              (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                 match x0 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match x with
             | 0 => false
             | S x =>
                 (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                    match x0 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x0 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x0 (S n) = true})
         then
          fun
            x2 : match x with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                        match x0 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                match x0 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) x x0)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
         else
          fun
            x2 : match x with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                        match x0 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                match x0 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) x x0)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
          eq_refl in
      x)
   with
   | 0 => false
   | S x0 =>
       (fix Ffix (x x2 : nat) {struct x} : bool :=
          match x with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) match x with
               | 0 => x
               | S x => x
               end x0
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match x with
             | 0 => false
             | S x =>
                 (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                    match x0 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match x with
                | 0 => false
                | S x =>
                    (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                       match x0 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x0 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x0 (S n) = true})
            then
             fun
               x2 : match x with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                           match x0 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                   match x0 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
            else
             fun
               x2 : match x with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                           match x0 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                   match x0 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
             eq_refl in
         x)
      with
      | 0 => false
      | S x0 =>
          (fix Ffix (x x2 : nat) {struct x} : bool :=
             match x with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) match x with
                  | 0 => x
                  | S x => x
                  end x0
      end = c ->
      {x0 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x0 (S n) = true})
  then
   fun
     x2 : match
            (let (x, _) :=
               (if
                 match x with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                        match x0 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match x with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                           match x0 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x0 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x0 (S n) = true})
                then
                 fun
                   x2 : match x with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                               match x0 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                       match x0 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
                else
                 fun
                   x2 : match x with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                               match x0 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                       match x0 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x0 =>
              (fix Ffix (x x2 : nat) {struct x} : bool :=
                 match x with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match x with
                      | 0 => x
                      | S x => x
                      end x0
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
         match x0 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) match x with
                              | 0 => x
                              | S x => x
                              end
     (ltN_intro_lemma1 (S n)
        ((if
           match x with
           | 0 => false
           | S x =>
               (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                  match x0 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match x with
              | 0 => false
              | S x =>
                  (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                     match x0 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x0 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x0 (S n) = true})
          then
           fun
             x3 : match x with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                         match x0 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x0 x4 : nat) {struct x0} : bool :=
                 match x0 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x3)
          else
           fun
             x3 : match x with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                         match x0 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x0 x4 : nat) {struct x0} : bool :=
                 match x0 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x3))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match x with
           | 0 => x
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) x x0) x1)) x2)
  else
   fun
     x2 : match
            (let (x, _) :=
               (if
                 match x with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                        match x0 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match x with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                           match x0 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x0 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x0 (S n) = true})
                then
                 fun
                   x2 : match x with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                               match x0 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                       match x0 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
                else
                 fun
                   x2 : match x with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                               match x0 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                       match x0 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x0 =>
              (fix Ffix (x x2 : nat) {struct x} : bool :=
                 match x with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) match x with
                      | 0 => x
                      | S x => x
                      end x0
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
         match x0 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S match x with
                                 | 0 => x
                                 | S x => x
                                 end)
     (ltN_intro_lemma2 (S n)
        ((if
           match x with
           | 0 => false
           | S x =>
               (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                  match x0 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match x with
              | 0 => false
              | S x =>
                  (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                     match x0 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x0 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x0 (S n) = true})
          then
           fun
             x3 : match x with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                         match x0 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x0 x4 : nat) {struct x0} : bool :=
                 match x0 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x3)
          else
           fun
             x3 : match x with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                         match x0 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x0 x4 : nat) {struct x0} : bool :=
                 match x0 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x3))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true)
           match x with
           | 0 => x
           | S x => x
           end
           (ltN_comm_intro_lemma1
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) x x0) x1)) x2))
   eq_refl)
else
(fun
   x1 : match x with
        | 0 => false
        | S x =>
            (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
               match x0 with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) IH1 x
        end = false =>
 (if
   match
     (let (x, _) :=
        (if
          match x with
          | 0 => false
          | S x =>
              (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                 match x0 with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) IH1 x
          end as c
          return
            (match x with
             | 0 => false
             | S x =>
                 (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                    match x0 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end = c ->
             {x0 : nat
             | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                  match x2 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) x0 (S n) = true})
         then
          fun
            x2 : match x with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                        match x0 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = true =>
          exist
            (fun x : nat =>
             (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                match x0 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) IH1
            (ltN_intro_lemma1 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) x x0)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
         else
          fun
            x2 : match x with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                        match x0 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end = false =>
          exist
            (fun x : nat =>
             (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                match x0 with
                | 0 => true
                | S x4 => match x3 with
                          | 0 => false
                          | S x5 => Ffix x4 x5
                          end
                end) x (S n) = true) (S IH1)
            (ltN_intro_lemma2 (S n)
               (exist (fun k : nat => (k <? S (S n)) = true) x x0)
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
          eq_refl in
      x)
   with
   | 0 => false
   | S x0 =>
       (fix Ffix (x x2 : nat) {struct x} : bool :=
          match x with
          | 0 => true
          | S x3 => match x2 with
                    | 0 => false
                    | S x4 => Ffix x3 x4
                    end
          end) x x0
   end as c
   return
     (match
        (let (x, _) :=
           (if
             match x with
             | 0 => false
             | S x =>
                 (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                    match x0 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) IH1 x
             end as c0
             return
               (match x with
                | 0 => false
                | S x =>
                    (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                       match x0 with
                       | 0 => true
                       | S x3 =>
                           match x2 with
                           | 0 => false
                           | S x4 => Ffix x3 x4
                           end
                       end) IH1 x
                end = c0 ->
                {x0 : nat
                | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                     match x2 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) x0 (S n) = true})
            then
             fun
               x2 : match x with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                           match x0 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = true =>
             exist
               (fun x : nat =>
                (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                   match x0 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) IH1
               (ltN_intro_lemma1 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
            else
             fun
               x2 : match x with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                           match x0 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = false =>
             exist
               (fun x : nat =>
                (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                   match x0 with
                   | 0 => true
                   | S x4 =>
                       match x3 with
                       | 0 => false
                       | S x5 => Ffix x4 x5
                       end
                   end) x (S n) = true) (S IH1)
               (ltN_intro_lemma2 (S n)
                  (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                  (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
             eq_refl in
         x)
      with
      | 0 => false
      | S x0 =>
          (fix Ffix (x x2 : nat) {struct x} : bool :=
             match x with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) x x0
      end = c ->
      {x0 : nat
      | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0 => true
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x0 (S n) = true})
  then
   fun
     x2 : match
            (let (x, _) :=
               (if
                 match x with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                        match x0 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match x with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                           match x0 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x0 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x0 (S n) = true})
                then
                 fun
                   x2 : match x with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                               match x0 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                       match x0 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
                else
                 fun
                   x2 : match x with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                               match x0 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                       match x0 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x0 =>
              (fix Ffix (x x2 : nat) {struct x} : bool :=
                 match x with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) x x0
          end = true =>
   exist
     (fun x : nat =>
      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
         match x0 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) x
     (ltN_intro_lemma1 (S n)
        ((if
           match x with
           | 0 => false
           | S x =>
               (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                  match x0 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match x with
              | 0 => false
              | S x =>
                  (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                     match x0 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x0 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x0 (S n) = true})
          then
           fun
             x3 : match x with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                         match x0 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x0 x4 : nat) {struct x0} : bool :=
                 match x0 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x3)
          else
           fun
             x3 : match x with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                         match x0 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x0 x4 : nat) {struct x0} : bool :=
                 match x0 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x3))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) x
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) x x0) x1)) x2)
  else
   fun
     x2 : match
            (let (x, _) :=
               (if
                 match x with
                 | 0 => false
                 | S x =>
                     (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                        match x0 with
                        | 0 => true
                        | S x3 =>
                            match x2 with
                            | 0 => false
                            | S x4 => Ffix x3 x4
                            end
                        end) IH1 x
                 end as c
                 return
                   (match x with
                    | 0 => false
                    | S x =>
                        (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                           match x0 with
                           | 0 => true
                           | S x3 =>
                               match x2 with
                               | 0 => false
                               | S x4 => Ffix x3 x4
                               end
                           end) IH1 x
                    end = c ->
                    {x0 : nat
                    | (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
                         match x2 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) x0 (S n) = true})
                then
                 fun
                   x2 : match x with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                               match x0 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = true =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                       match x0 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) IH1
                   (ltN_intro_lemma1 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2)
                else
                 fun
                   x2 : match x with
                        | 0 => false
                        | S x =>
                            (fix Ffix (x0 x2 : nat) {struct x0} : bool :=
                               match x0 with
                               | 0 => true
                               | S x3 =>
                                   match x2 with
                                   | 0 => false
                                   | S x4 => Ffix x3 x4
                                   end
                               end) IH1 x
                        end = false =>
                 exist
                   (fun x : nat =>
                    (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                       match x0 with
                       | 0 => true
                       | S x4 =>
                           match x3 with
                           | 0 => false
                           | S x5 => Ffix x4 x5
                           end
                       end) x (S n) = true) (S IH1)
                   (ltN_intro_lemma2 (S n)
                      (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                      (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x2))
                 eq_refl in
             x)
          with
          | 0 => false
          | S x0 =>
              (fix Ffix (x x2 : nat) {struct x} : bool :=
                 match x with
                 | 0 => true
                 | S x3 =>
                     match x2 with
                     | 0 => false
                     | S x4 => Ffix x3 x4
                     end
                 end) x x0
          end = false =>
   exist
     (fun x : nat =>
      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
         match x0 with
         | 0 => true
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) x (S n) = true) (S x)
     (ltN_intro_lemma2 (S n)
        ((if
           match x with
           | 0 => false
           | S x =>
               (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                  match x0 with
                  | 0 => true
                  | S x4 =>
                      match x3 with
                      | 0 => false
                      | S x5 => Ffix x4 x5
                      end
                  end) IH1 x
           end as c
           return
             (match x with
              | 0 => false
              | S x =>
                  (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                     match x0 with
                     | 0 => true
                     | S x4 =>
                         match x3 with
                         | 0 => false
                         | S x5 => Ffix x4 x5
                         end
                     end) IH1 x
              end = c ->
              {x0 : nat
              | (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                   match x3 with
                   | 0 => true
                   | S x5 =>
                       match x4 with
                       | 0 => false
                       | S x6 => Ffix x5 x6
                       end
                   end) x0 (S n) = true})
          then
           fun
             x3 : match x with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                         match x0 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = true =>
           exist
             (fun x : nat =>
              (fix Ffix (x0 x4 : nat) {struct x0} : bool :=
                 match x0 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) IH1
             (ltN_intro_lemma1 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x3)
          else
           fun
             x3 : match x with
                  | 0 => false
                  | S x =>
                      (fix Ffix (x0 x3 : nat) {struct x0} : bool :=
                         match x0 with
                         | 0 => true
                         | S x4 =>
                             match x3 with
                             | 0 => false
                             | S x5 => Ffix x4 x5
                             end
                         end) IH1 x
                  end = false =>
           exist
             (fun x : nat =>
              (fix Ffix (x0 x4 : nat) {struct x0} : bool :=
                 match x0 with
                 | 0 => true
                 | S x5 =>
                     match x4 with
                     | 0 => false
                     | S x6 => Ffix x5 x6
                     end
                 end) x (S n) = true) (S IH1)
             (ltN_intro_lemma2 (S n)
                (exist (fun k : nat => (k <? S (S n)) = true) x x0)
                (exist (fun k : nat => (k <? S n) = true) IH1 IH2) x3))
           eq_refl)
        (exist (fun k : nat => (k <? S n) = true) x
           (ltN_comm_intro_lemma2
              (exist (fun k : nat => (k <? S n) = true) IH1 IH2)
              (exist (fun k : nat => (k <? S (S n)) = true) x x0) x1)) x2))
   eq_refl)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
 proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1))
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) = true =>
 ltN_intro
   (ltN_intro (exist (fun k : nat => (k <? 2) = true) H0 H1)
      (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
   (ltN_of_nat
      (Init.Nat.pred
         (proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1))) 1
      (ltN_comm_intro_lemma1 (exist (fun k : nat => (k <? 1) = true) IH1 IH2)
         (exist (fun k : nat => (k <? 2) = true) H0 H1) E)))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) = false =>
 ltN_intro
   (ltN_intro (exist (fun k : nat => (k <? 2) = true) H0 H1)
      (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) 1
      (ltN_comm_intro_lemma2 (exist (fun k : nat => (k <? 1) = true) IH1 IH2)
         (exist (fun k : nat => (k <? 2) = true) H0 H1) E)))
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
 proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1))
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) = true =>
 ltN_intro
   (ltN_intro (exist (fun k : nat => (k <? 2) = true) H0 H1)
      (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
   (ltN_of_nat
      (Init.Nat.pred
         (proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1))) 1
      (ltN_comm_intro_lemma1 (exist (fun k : nat => (k <? 1) = true) IH1 IH2)
         (exist (fun k : nat => (k <? 2) = true) H0 H1) E)))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) = false =>
 ltN_intro
   (ltN_intro (exist (fun k : nat => (k <? 2) = true) H0 H1)
      (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? 2) = true) H0 H1)) 1
      (ltN_comm_intro_lemma2 (exist (fun k : nat => (k <? 1) = true) IH1 IH2)
         (exist (fun k : nat => (k <? 2) = true) H0 H1) E)))
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
string
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
string
string
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_one_gen x x0
    x1 x2 x3 = onemod x x0 x1 x2 x3) /\ Wf.Compilers.expr.Wf reified_one_gen)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching:
((forall (x : nat) (x0 : ?T) (x1 : ?T0) (x2 : nat) (x3 : ?T1),
  ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} <= ?m ->
  reflect (?m < ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}) (x2 <=? x) ->
  Init.Nat.max ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} ?m = ?m) ->
 fswap N0 H4 abs H4 = N0 abs)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching:
((forall (x : nat) (x0 : ?T) (x1 : ?T0) (x2 : nat) 
    (x3 : ?T1)
    (x4 : ?n0@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} <=
          ?n0@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}),
  reflect
    (?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3; H1:=x4} <
     ?m@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3; H1:=x4}) 
    (x2 <=? x) ->
  Init.Nat.max ?n0@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}
    ?n0@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} =
  ?n0@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}) -> fswap N0 H4 abs H4 = N0 abs)
Crunching: (∣1⟩ = basis_vector 2 1)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching:
((forall (x : nat) (x0 : ?T) (x1 : ?T0) (x2 : nat) (x3 : ?T1),
  ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} <= ?m ->
  reflect (?m < ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}) (x2 <=? x) ->
  Init.Nat.max ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} ?m = ?m) ->
 fswap N0 H4 abs H4 = N0 abs)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching:
((forall (x : nat) (x0 : ?T) (x1 : ?T0) (x2 : nat) (x3 : ?T1),
  ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} <= ?m ->
  reflect (?m < ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}) (x2 <=? x) ->
  Init.Nat.max ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} ?m = ?m) ->
 fswap N0 H4 abs H4 = N0 abs)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Finished transaction in 41.026 secs (0.172u,0.236s) (successful)
Finished transaction in 0.013 secs (0.012u,0.s) (successful)
Finished transaction in 0.102 secs (0.088u,0.013s) (successful)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (fswap n m y y = n m)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (forall x y : nat, fswap abs x y y = abs x)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (interval_sum H l' n (Hab * 1))
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: ((if y =? x then f y else f x) = f x)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (fswap N0 H4 y y = N0 H4)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (n m = fswap n m y y)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (fswap n m y y = n m)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
find_witness Control.TimeoutMore readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (∣1⟩ = basis_vector 2 1)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
FlattenExpr: flattenExprs_correct done
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.006 secs (0.004u,0.001s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_one_gen x x0
    x1 x2 x3 = onemod x x0 x1 x2 x3) /\ Wf.Compilers.expr.Wf reified_one_gen)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
(match ?m@{width:=32} with
 | Z.pos y' =>
     (fix compare_cont (r : comparison) (x y : positive) {struct y} :
          comparison :=
        match x with
        | (p~1)%positive =>
            match y with
            | (q~1)%positive => compare_cont r p q
            | (q~0)%positive => compare_cont Gt p q
            | 1%positive => Gt
            end
        | (p~0)%positive =>
            match y with
            | (q~1)%positive => compare_cont Lt p q
            | (q~0)%positive => compare_cont r p q
            | 1%positive => Gt
            end
        | 1%positive => match y with
                        | 1%positive => r
                        | _ => Lt
                        end
        end) Eq 8%positive y'
 | _ => Gt
 end = Gt -> False)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
find_witness Control.TimeoutMore readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
Finished transaction in 43.016 secs (2.408u,0.181s) (successful)
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (forall x y : nat, fswap abs x y y = abs x)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Finished transaction in 0.183 secs (0.18u,0.002s) (successful)
find_witness Control.TimeoutMore readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
find_witness Control.TimeoutMore readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
More readable: initial segment:
optBind
With remainder:
find_witness Control.Timeout[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Finished transaction in 1.516 secs (1.506u,0.007s) (successful)
Crunching: ((if H =? m then n H else if H =? H then n m else n H) = n m)
find_witness Control.TimeoutFinished transaction in 49.629 secs (9.001u,0.272s) (successful)
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_prime_gen x
    x0 x1 x2 x3 = primemod x x0 x1 x2 x3) /\
 Wf.Compilers.expr.Wf reified_prime_gen)
Finished transaction in 0.712 secs (0.663u,0.047s) (successful)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_prime_gen x
    x0 x1 x2 x3 = primemod x x0 x1 x2 x3) /\
 Wf.Compilers.expr.Wf reified_prime_gen)
find_witness Control.TimeoutCrunching: ((if 0 =? x then f 0 else if 0 =? 0 then f x else f 0) = f x)
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_prime_gen x
    x0 x1 x2 x3 = primemod x x0 x1 x2 x3) /\
 Wf.Compilers.expr.Wf reified_prime_gen)
find_witness Control.TimeoutFinished transaction in 5.262 secs (5.248u,0.008s) (successful)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
Finished transaction in 41.271 secs (0.336u,0.269s) (successful)
Finished transaction in 0.021 secs (0.021u,0.s) (successful)
(NoDup
   (flatten_argnames
      (snd (make_names inname_gen l1 t),
       snd (make_innames' (fst (make_names inname_gen l1 t)) t2))))
Finished transaction in 0.164 secs (0.161u,0.001s) (successful)
Crunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
find_witness Control.Timeout((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_prime_gen x
    x0 x1 x2 x3 = primemod x x0 x1 x2 x3) /\
 Wf.Compilers.expr.Wf reified_prime_gen)
False
Tactic call ran for 0.013 secs (0.013u,0.s) (success)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.001s) (failure)
Section Variables:
field_parameters
: FieldParameters
Section Variables:
word
: Interface.word width
width
: Z
field_parameters
: FieldParameters
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeout(NoDup
   (flatten_argnames
      (snd (make_names inname_gen l1 t),
       snd (make_innames' (fst (make_names inname_gen l1 t)) t2))))
Crunching:
(∣0⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
(NoDup
   (flatten_argnames
      (snd (make_names inname_gen l1 t),
       snd (make_innames' (fst (make_names inname_gen l1 t)) t2))))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
((forall (x x0 x1 : Z) (x2 : list (Z * Z)) (x3 : nat),
  Language.Compilers.expr.Interp
    (@IdentifiersBasicGENERATED.Compilers.ident_interp) reified_prime_gen x
    x0 x1 x2 x3 = primemod x x0 x1 x2 x3) /\
 Wf.Compilers.expr.Wf reified_prime_gen)
find_witness Control.TimeoutFinished transaction in 43.491 secs (2.964u,0.182s) (successful)
Finished transaction in 0.178 secs (0.177u,0.s) (successful)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Finished transaction in 1.612 secs (1.601u,0.007s) (successful)
Finished transaction in 0.397 secs (0.392u,0.003s) (successful)
Finished transaction in 0.03 secs (0.03u,0.s) (successful)
Finished transaction in 0.249 secs (0.247u,0.002s) (successful)
Finished transaction in 0.484 secs (0.479u,0.002s) (successful)
Finished transaction in 0.033 secs (0.033u,0.s) (successful)
Finished transaction in 0.229 secs (0.229u,0.s) (successful)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Finished transaction in 5.337 secs (5.298u,0.034s) (successful)
Finished transaction in 40.978 secs (0.162u,0.24s) (successful)
Finished transaction in 0.014 secs (0.014u,0.s) (successful)
Finished transaction in 0.117 secs (0.105u,0.011s) (successful)
Finished transaction in 0.32 secs (0.311u,0.007s) (successful)
Finished transaction in 3.166 secs (3.146u,0.015s) (successful)
Finished transaction in 48.185 secs (7.633u,0.249s) (successful)
Finished transaction in 0.644 secs (0.635u,0.007s) (successful)
Finished transaction in 2.499 secs (2.484u,0.012s) (successful)
Finished transaction in 0.189 secs (0.188u,0.s) (successful)
Finished transaction in 1.472 secs (1.463u,0.007s) (successful)
Finished transaction in 5.045 secs (5.022u,0.016s) (successful)
clear  H0a'  :  (False -> cmpA a a' <> Lt)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Compilation incomplete.
You may need to add new compilation lemmas using `Hint Extern 1 => simple eapply … : compiler` or to tell Rupicola about your custom bindings using `Hint Extern 2 (IsRupicolaBinding (xlet (A := ?A) ?vars _ _)) => exact (RupicolaBinding A vars) : typeclass_instances`.
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Finished transaction in 17.302 secs (17.077u,0.2s) (successful)
Finished transaction in 0.005 secs (0.005u,0.s) (successful)
Tactic call ran for 0.008 secs (0.007u,0.001s) (success)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 306.284 secs (301.93u,4.037s) (success)
Tactic call ran for 0.498 secs (0.494u,0.003s) (success)
Assembling rewrite_head_no_dtree...
Finished transaction in 40.943 secs (0.188u,0.243s) (successful)
Finished transaction in 0.014 secs (0.013u,0.001s) (successful)
Reducing rewrite_head_no_dtree...
Finished transaction in 0.127 secs (0.111u,0.014s) (successful)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Axioms:
ClassicalDedekindReals.sig_not_dec : forall P : Prop, {~ ~ P} + {~ P}
ClassicalDedekindReals.sig_forall_dec
  : forall P : nat -> Prop,
    (forall n : nat, {P n} + {~ P n}) ->
    {n : nat | ~ P n} + {forall n : nat, P n}
prop_ext : ClassicalFacts.prop_extensionality
lib.Axioms.proof_irr : ClassicalFacts.proof_irrelevance
Clight_core.inline_external_call_mem_events
  : forall (ef : external_function) (ge : Senv.t) 
      (vargs : list val) (m : mem) (t : Events.trace) 
      (vres : val) (m' : mem),
    ef_inline ef = true ->
    Events.external_call ef ge vargs m t vres m' ->
    {trace : list event_semantics.mem_event
    | event_semantics.ev_elim m trace m'}
Events.inline_assembly_sem : string -> signature -> Events.extcall_sem
functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Events.external_functions_sem : string -> signature -> Events.extcall_sem
Eqdep.Eq_rect_eq.eq_rect_eq
  : forall (U : Type) (p : U) (Q : U -> Type) (x : Q p) (h : p = p),
    x = eq_rect p Q x p h
Classical_Prop.classic : forall P : Prop, P \/ ~ P
Proving Rewriter_Wf...
Tactic call ran for 4.466 secs (4.442u,0.015s) (success)
Finished transaction in 30.652 secs (30.184u,0.464s) (successful)
Finished transaction in 0.004 secs (0.004u,0.s) (successful)
Finished transaction in 48.421 secs (7.806u,0.246s) (successful)
Finished transaction in 0.645 secs (0.635u,0.008s) (successful)
Finished transaction in 5.021 secs (5.004u,0.01s) (successful)
Tactic call ran for 14.966 secs (14.835u,0.105s) (success)
Finished transaction in 1.22 secs (1.154u,0.063s) (successful)
Tactic call ran for 0.004 secs (0.003u,0.001s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.015 secs (0.015u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.011 secs (0.011u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Finished transaction in 40.842 secs (0.02u,0.207s) (successful)
Finished transaction in 0.001 secs (0.001u,0.s) (successful)
Finished transaction in 0.008 secs (0.007u,0.s) (successful)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Tactic call ran for 13.707 secs (13.684u,0.021s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 9.002 secs (8.922u,0.078s) (success)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Assembling verified rewriter...
Finished transaction in 40.612 secs (0.091u,0.154s) (successful)
Finished transaction in 0.001 secs (0.001u,0.s) (successful)
Finished transaction in 0.033 secs (0.03u,0.002s) (successful)
Refining with verified rewriter...
Finished transaction in 11.861 secs (11.793u,0.067s) (successful)
build_inputs start
build_inputs end
build_merge_base_addresses start
build_merge_base_addresses end
Finished transaction in 9.315 secs (7.968u,0.217s) (successful)
build_merge_base_addresses start
Finished transaction in 0.626 secs (0.621u,0.004s) (successful)
build_merge_base_addresses end
build_merge_stack_placeholders start
Finished transaction in 4.724 secs (4.702u,0.014s) (successful)
build_merge_stack_placeholders end
get callee_saved_registers start
get callee_saved_registers end
Finished transaction in 41.301 secs (0.29u,0.248s) (successful)
Finished transaction in 0.017 secs (0.017u,0.s) (successful)
Finished transaction in 0.135 secs (0.133u,0.s) (successful)
get callee_saved_registers start
SymexLines start
SymexLines end
get callee_saved_registers start
get callee_saved_registers end
LoadArray start
LoadArray end
LoadOutputs start
Reifying...
Finished transaction in 21.347 secs (21.137u,0.206s) (successful)
Finished transaction in 0.008 secs (0.008u,0.s) (successful)
LoadOutputs end
LoadOutputs start
LoadOutputs end
Compiling decision tree...
Splitting rewrite rules...
Finished transaction in 2.61 secs (2.598u,0.011s) (successful)
Finished transaction in 0.004 secs (0.003u,0.001s) (successful)
Finished transaction in 3.554 secs (3.547u,0.006s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
Finished transaction in 40.984 secs (0.265u,0.253s) (successful)
Finished transaction in 0.019 secs (0.017u,0.002s) (successful)
Finished transaction in 0.134 secs (0.132u,0.001s) (successful)
Reifying...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Finished transaction in 17.674 secs (17.637u,0.035s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 4.93 secs (4.925u,0.s) (success)
FlattenExpr: flattenBooleanExpr_correct_aux done
Unrecognized (non-unfoldable) term: s'
expr.reify_in_context: Failure in reifying:
s'
expr.reify_in_context: Failure in reifying:
(2 ^ s')
expr.reify_in_context: Failure in reifying:
(x * y / 2 ^ s')
expr.reify_in_context: Failure in reifying:
((x * y) mod 2 ^ s', x * y / 2 ^ s')
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Reifying...
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Finished transaction in 3.952 secs (3.948u,0.003s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
bad
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
bad
Finished transaction in 8.792 secs (8.718u,0.072s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
(match
   match s' with
   | 0 => 1
   | Z.pos x =>
       (fix Ffix (x0 : Z) (x1 : positive) {struct x1} : Z :=
          match x1 with
          | (x2~1)%positive =>
              match Ffix (Ffix x0 x2) x2 with
              | 0 => 0
              | Z.pos x3 => Z.pos x3~0
              | Z.neg x3 => Z.neg x3~0
              end
          | (x2~0)%positive => Ffix (Ffix x0 x2) x2
          | 1%positive =>
              match x0 with
              | 0 => 0
              | Z.pos x2 => Z.pos x2~0
              | Z.neg x2 => Z.neg x2~0
              end
          end) 1 x
   | Z.neg _ => 0
   end
 with
 | 0 => Eq
 | Z.pos _ => Lt
 | Z.neg _ => Gt
 end = ?y)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
(Z.testbit (Interface.word.signed (Interface.word.of_Z k)) Hpr =
 Z.testbit (Interface.word.swrap k) Hpr)
(Z.testbit (Interface.word.signed (Interface.word.of_Z k)) Hpr =
 Z.testbit (Interface.word.swrap k) Hpr)
bad
Finished transaction in 6.85 secs (6.832u,0.017s) (successful)
Finished transaction in 0.004 secs (0.004u,0.s) (successful)
Compiling decision tree...
Splitting rewrite rules...
Finished transaction in 3.179 secs (3.174u,0.004s) (successful)
Finished transaction in 0.004 secs (0.004u,0.s) (successful)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H0 : True
H : ((0 ?= Z.of_nat n) = Gt)
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H3 ?H6)
============================
False
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H0 : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
False
Section Variables:
field_parameters
: FieldParameters
Section Variables:
word
: Interface.word width
width
: Z
field_parameters
: FieldParameters
Finished transaction in 4.115 secs (4.113u,0.002s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
bad
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
p : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
p : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
Hi : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H3 ?H6)
============================
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
p : (type -> Type)
n' : (type -> Type)
H : True
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H_1 : (type -> Type)
p : (type -> Type)
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H_1 : (type -> Type)
p : (type -> Type)
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
(wf [] (res H_1) (res p))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H0 : True
H : ((0 ?= Z.of_nat n) = Gt)
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H3 ?H6)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H0 : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
False
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H0 : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
False
Finished transaction in 8.526 secs (8.511u,0.014s) (successful)
Finished transaction in 0.003 secs (0.002u,0.s) (successful)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
(wf [] (res var1) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
p : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) =
   output_options : output_options_opt
   low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
p : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H3 ?H6)
============================
(wf [] (res H) (res p))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
p : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H3 ?H6)
============================
(wf [] (res H) (res p))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
p : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H3 ?H6)
============================
(wf [] (res H) (res p))
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
p : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H3 ?H6)
============================
(wf [] (res H) (res p))
Assembling rewrite_head...
Reducing rewrite_head...
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
k : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H3 ?H6)
============================
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
E : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
Compiling decision tree...
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
var2 : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H3 ?H6)
============================
(wf [] (res H) (res var2))
Splitting rewrite rules...
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
var2 : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H3 ?H6)
============================
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : (type -> Type)
Hi : (type -> Type)
H0 : True
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H2 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H3 H6)
Tactic call ran for 2.682 secs (2.65u,0.03s) (success)
Finished transaction in 7.157 secs (7.089u,0.058s) (successful)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
Type
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
Type
(interp256 cont
   {|
     CC.cc_c :=
       if in_dec CC.code_dec CC.C (writes_conditions i)
       then cc_spec CC.C (spec i (Tuple.map HF args) H)
       else CC.cc_c H;
     CC.cc_m :=
       if in_dec CC.code_dec CC.M (writes_conditions i)
       then cc_spec CC.M (spec i (Tuple.map HF args) H)
       else CC.cc_m H;
     CC.cc_l :=
       if in_dec CC.code_dec CC.L (writes_conditions i)
       then cc_spec CC.L (spec i (Tuple.map HF args) H)
       else CC.cc_l H;
     CC.cc_z :=
       if in_dec CC.code_dec CC.Z (writes_conditions i)
       then cc_spec CC.Z (spec i (Tuple.map HF args) H)
       else CC.cc_z H
   |}
   (fun r' : register =>
    if reg_eqb r' r
    then ?x
    else
     if reg_eqb r' rd
     then spec i (Tuple.map HF args) H mod wordmax
     else HF r') =
 interp256 cont
   (CC.update (writes_conditions i)
      (spec i
         (Tuple.map (fun r' : register => if reg_eqb r' r then Hn else HF r')
            args) H) cc_spec H)
   (fun n : register =>
    if reg_eqb n rd
    then
     spec i
       (Tuple.map (fun r' : register => if reg_eqb r' r then Hn else HF r')
          args) H mod wordmax
    else if reg_eqb n r then Hn else HF n))
Finished transaction in 7.338 secs (7.253u,0.075s) (successful)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
Type
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
Type
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
p : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
(wf [] (res p) (res var2))
Unrecognized (non-unfoldable) term: m
expr.reify_in_context: Failure in reifying:
m
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
p : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
(wf [] (res p) (res var2))
(Forall2 (eval_idx_or_list_idx G2 d2) G [] -> Forall2 eq xs [])
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
p : (type -> Type)
H3 : (type -> Type)
H : True
Hres :
(forall H1 H4 H2 H6 : Z,
 H1 = H2 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H4 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H6)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H4) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H6)
============================
(wf [] (res p) (res H3))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
find_witness Control.Timeoutres :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
p : (type -> Type)
n' : (type -> Type)
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
(wf [] (res p) (res n'))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
p : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
(wf [] (res p) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
Z
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
p : (type -> Type)
var2 : (type -> Type)
H : True
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
p : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
(wf [] (res p) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
p : (type -> Type)
k : (type -> Type)
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
(wf [] (res p) (res k))
Finished transaction in 7.964 secs (7.892u,0.059s) (successful)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H_1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
============================
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H_1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H3 H2 H5 : Z,
 H1 = H2 ->
 H3 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some r[0 ~> 2 ^ s' - 1]%zrange) H3 &&
  true) = true ->
 ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res H1 H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   H2 H5)
H1 :
(ZRange.type.base.option.is_bounded_by
   (Some r[0 ~> 2 ^ s' - 1]%zrange, Some r[0 ~> 2 ^ s' - 1]%zrange)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_mulx_gen @ (fun var : type -> Type => GallinaReify.base.reify s'))
   ?H2 ?H5)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : Z
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base
      (base.type.type_base Compilers.Z * base.type.type_base Compilers.Z)))
H_1 : (type -> Type)
var2 : (type -> Type)
H : True
Unrecognized (non-unfoldable) term: s'
expr.reify_in_context: Failure in reifying:
s'
expr.reify_in_context: Failure in reifying:
(2 ^ s')
expr.reify_in_context: Failure in reifying:
((c + x + y) / 2 ^ s')
expr.reify_in_context: Failure in reifying:
((c + x + y) mod 2 ^ s', (c + x + y) / 2 ^ s')
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 3.758 secs (3.736u,0.017s) (success)
Reifying...
Unrecognized (non-unfoldable) term: s'
expr.reify_in_context: Failure in reifying:
s'
expr.reify_in_context: Failure in reifying:
(2 ^ s')
expr.reify_in_context: Failure in reifying:
((H2 + x + y) / 2 ^ s')
expr.reify_in_context: Failure in reifying:
((H2 + x + y) mod 2 ^ s', (H2 + x + y) / 2 ^ s')
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Tactic call ran for 1.708 secs (1.689u,0.017s) (success)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Unrecognized (non-unfoldable) term: s'
expr.reify_in_context: Failure in reifying:
s'
expr.reify_in_context: Failure in reifying:
(2 ^ s')
expr.reify_in_context: Failure in reifying:
((H2 + x + y) / 2 ^ s')
expr.reify_in_context: Failure in reifying:
((H2 + x + y) mod 2 ^ s', (H2 + x + y) / 2 ^ s')
(forall x y : Z, x + y = y + x)
(forall x y : Z, x + y = y + x)
Unrecognized (non-unfoldable) term: s'
expr.reify_in_context: Failure in reifying:
s'
expr.reify_in_context: Failure in reifying:
(2 ^ s')
expr.reify_in_context: Failure in reifying:
((- b + x + - y) / 2 ^ s')
expr.reify_in_context: Failure in reifying:
(- ((- b + x + - y) / 2 ^ s'))
expr.reify_in_context: Failure in reifying:
((- b + x + - y) mod 2 ^ s', - ((- b + x + - y) / 2 ^ s'))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Finished transaction in 2.794 secs (2.785u,0.004s) (successful)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Unrecognized (non-unfoldable) term: s'
expr.reify_in_context: Failure in reifying:
s'
expr.reify_in_context: Failure in reifying:
(2 ^ s')
expr.reify_in_context: Failure in reifying:
((- b + x + - y) / 2 ^ s')
expr.reify_in_context: Failure in reifying:
(- ((- b + x + - y) / 2 ^ s'))
expr.reify_in_context: Failure in reifying:
((- b + x + - y) mod 2 ^ s', - ((- b + x + - y) / 2 ^ s'))
N : Z
R : Z
N' : Z
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values :=
[1; machine_wordsize / 2; machine_wordsize; 2 * machine_wordsize] : 
(list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
Hpq : Z
H3 : True
Hres :
(forall H0 H2 H1 H5 : Z,
 H0 = H1 ->
 H2 = H5 ->
 ZRange.type.base.option.is_bounded_by bound H0 &&
 (ZRange.type.base.option.is_bounded_by bound H2 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H0 H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H0 H2 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H1
   H5)
H0 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H0 ?H2) = true)
H1 :
(expr.Interp (@Compilers.ident_interp) res ?H0 ?H2 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) 
   ?H1 ?H5)
============================
((0 ?= Hpq) = Gt)
N : Z
R : Z
N' : Z
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values :=
[1; machine_wordsize / 2; machine_wordsize; 2 * machine_wordsize] : 
(list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H3 : True
Hres :
(forall H0 H2 H1 H5 : Z,
 H0 = H1 ->
 H2 = H5 ->
 ZRange.type.base.option.is_bounded_by bound H0 &&
 (ZRange.type.base.option.is_bounded_by bound H2 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H0 H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H0 H2 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H1
   H5)
H0 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H0 ?H2) = true)
H1 :
(expr.Interp (@Compilers.ident_interp) res ?H0 ?H2 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) 
   ?H1 ?H5)
============================
False
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Finished transaction in 0.256 secs (0.248u,0.007s) (successful)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(ctx (of_prefancy_scalar ###v) = Compilers.ident_interp idc)
(Compilers.ident_interp idc = ctx (of_prefancy_scalar ###v))
Unrecognized (non-unfoldable) term: s'
expr.reify_in_context: Failure in reifying:
s'
expr.reify_in_context: Failure in reifying:
(2 ^ s')
expr.reify_in_context: Failure in reifying:
((- b + x + - y) / 2 ^ s')
expr.reify_in_context: Failure in reifying:
(- ((- b + x + - y) / 2 ^ s'))
expr.reify_in_context: Failure in reifying:
((- b + x + - y) mod 2 ^ s', - ((- b + x + - y) / 2 ^ s'))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Finished transaction in 2.431 secs (2.421u,0.007s) (successful)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((evalf H4 * evalf H5) mod m)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
N : Z
R : Z
N' : Z
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values :=
[1; machine_wordsize / 2; machine_wordsize; 2 * machine_wordsize] : 
(list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
Hpq : Z
H3 : True
Hres :
(forall H0 H2 H1 H5 : Z,
 H0 = H1 ->
 H2 = H5 ->
 ZRange.type.base.option.is_bounded_by bound H0 &&
 (ZRange.type.base.option.is_bounded_by bound H2 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H0 H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H0 H2 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H1
   H5)
H0 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H0 ?H2) = true)
H1 :
(expr.Interp (@Compilers.ident_interp) res ?H0 ?H2 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) 
   ?H1 ?H5)
============================
((0 ?= Hpq) = Gt)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Unrecognized (non-unfoldable) term: s'
expr.reify_in_context: Failure in reifying:
s'
expr.reify_in_context: Failure in reifying:
(2 ^ s')
expr.reify_in_context: Failure in reifying:
((- b + x + - y) / 2 ^ s')
expr.reify_in_context: Failure in reifying:
(- ((- b + x + - y) / 2 ^ s'))
expr.reify_in_context: Failure in reifying:
((- b + x + - y) mod 2 ^ s', - ((- b + x + - y) / 2 ^ s'))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(forall x y : Z, x + y = y + x)
Unrecognized (non-unfoldable) term: s'
expr.reify_in_context: Failure in reifying:
s'
expr.reify_in_context: Failure in reifying:
(2 ^ s')
expr.reify_in_context: Failure in reifying:
((- b + x + - y) / 2 ^ s')
expr.reify_in_context: Failure in reifying:
(- ((- b + x + - y) / 2 ^ s'))
expr.reify_in_context: Failure in reifying:
((- b + x + - y) mod 2 ^ s', - ((- b + x + - y) / 2 ^ s'))
Finished transaction in 4.503 secs (4.48u,0.016s) (successful)
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
M : Z
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
mu := (2 ^ (2 * machine_wordsize) / M) : Z
muLow := (mu mod 2 ^ machine_wordsize) : Z
consts_list := [M; muLow] : (list Z)
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H8 : (type -> Type)
H : (1 < machine_wordsize)
H0 : (2 ^ (machine_wordsize - 1) <= M)
H5 : (M < 2 ^ machine_wordsize)
H1 : (muLow + 2 ^ machine_wordsize = (2 ^ 2) ^ machine_wordsize / M)
H2 : (2 ^ (machine_wordsize - 1) < M)
H4 : (M < 2 ^ machine_wordsize)
H3 :
(2 * ((2 ^ 2) ^ machine_wordsize mod M) <=
 2 ^ (machine_wordsize + 1) - (muLow + 2 ^ machine_wordsize))
var2 : (type -> Type)
Hres :
(forall H7 H10 H9 H12 : Z,
 H7 = H9 ->
 H10 = H12 ->
 ZRange.type.base.option.is_bounded_by bound H7 &&
 (ZRange.type.base.option.is_bounded_by bound H10 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H7 H10) = true /\
 expr.Interp (@Compilers.ident_interp) res H7 H10 =
 expr.Interp (@Compilers.ident_interp)
   (reified_barrett_red_gen @
    (fun var : type -> Type => GallinaReify.base.reify M) @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify 1%nat) @
    (fun var : type -> Type => GallinaReify.base.reify [muLow; 1]) @
    (fun var : type -> Type => GallinaReify.base.reify [M])) H9 H12)
H7 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H7 ?H10) = true)
H9 :
(expr.Interp (@Compilers.ident_interp) res ?H7 ?H10 =
 expr.Interp (@Compilers.ident_interp)
   (reified_barrett_red_gen @
    (fun var : type -> Type => GallinaReify.base.reify M) @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify 1%nat) @
    (fun var : type -> Type => GallinaReify.base.reify [muLow; 1]) @
    (fun var : type -> Type => GallinaReify.base.reify [M])) 
   ?H9 ?H12)
============================
(wf [] (res H8) (res var2))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Finished transaction in 0.337 secs (0.335u,0.001s) (successful)
(forall x y : Z, x + y = y + x)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Tactic call ran for 89.529 secs (87.368u,2.096s) (success)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Finished transaction in 3.353 secs (3.34u,0.008s) (successful)
Tactic call ran for 0.517 secs (0.506u,0.009s) (success)
Finished transaction in 25.436 secs (24.985u,0.338s) (successful)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(forall x y : Z, x + y = y + x)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((evalf k * evalf e) mod m)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Finished transaction in 3.136 secs (3.118u,0.013s) (successful)
Tactic call ran for 34.712 secs (33.826u,0.841s) (success)
Tactic call ran for 0.281 secs (0.28u,0.s) (success)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(forall x y : Z, x + y = y + x)
Finished transaction in 0.245 secs (0.245u,0.s) (successful)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((eval
    (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))
       (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))) 0 k *
  eval
    (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))
       (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))) 0 e) mod m)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((eval
    (weight
       (Z.log2_up (- Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n k *
  eval
    (weight
       (Z.log2_up (- Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n e) mod m)
(forall x y : Z, x + y = y + x)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Finished transaction in 2.542 secs (2.536u,0.003s) (successful)
Proving Rewriter_Wf...
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((eval
    (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))
       (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))) 0 k *
  eval
    (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))
       (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))) 0 e) mod m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((eval
    (weight
       (Z.log2_up (- Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n k *
  eval
    (weight
       (Z.log2_up (- Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n e) mod m)
Finished transaction in 1.995 secs (1.977u,0.014s) (successful)
Tactic call ran for 1.311 secs (1.309u,0.s) (success)
Finished transaction in 0.175 secs (0.175u,0.s) (successful)
Proving Rewriter_Wf...
Finished transaction in 1.704 secs (1.701u,0.s) (successful)
N : Z
R : Z
N' : Z
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
arg1 : Z
arg2 : Z
Harg12 : Z
H : True
H0 : (0 < Harg12)
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by bound H2 &&
 (ZRange.type.base.option.is_bounded_by bound H4 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H3
   H6)
H2 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) 
   ?H3 ?H6)
============================
((arg1 + arg2) * (arg1 ^ Harg12 + arg2 ^ Harg12) <=
 2 * (arg1 * arg1 ^ Harg12 + arg2 * arg2 ^ Harg12))
find_witness Control.TimeoutTactic call ran for 3.331 secs (3.25u,0.078s) (success)
Finished transaction in 2.089 secs (2.079u,0.007s) (successful)
Finished transaction in 63.858 secs (23.34u,0.254s) (successful)
N : Z
R : Z
N' : Z
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
arg1 : Z
arg2 : Z
Harg12 : Z
H : True
H0 : (0 < Harg12)
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by bound H2 &&
 (ZRange.type.base.option.is_bounded_by bound H4 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H3
   H6)
H2 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) 
   ?H3 ?H6)
============================
((arg1 + arg2) * (arg1 ^ Harg12 + arg2 ^ Harg12) <=
 2 * (arg1 * arg1 ^ Harg12 + arg2 * arg2 ^ Harg12))
Finished transaction in 0.183 secs (0.183u,0.s) (successful)
find_witness Control.TimeoutFinished transaction in 0.02 secs (0.019u,0.s) (successful)
N : Z
R : Z
N' : Z
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
arg1 : Z
arg2 : Z
Harg12 : Z
H : True
H0 : (0 < Harg12)
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by bound H2 &&
 (ZRange.type.base.option.is_bounded_by bound H4 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H3
   H6)
H2 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) 
   ?H3 ?H6)
============================
((arg1 + arg2) * (arg1 ^ Harg12 + arg2 ^ Harg12) <=
 2 * (arg1 * arg1 ^ Harg12 + arg2 * arg2 ^ Harg12))
N : Z
R : Z
N' : Z
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
arg1 : Z
arg2 : Z
Harg12 : Z
H : True
H0 : (0 < Harg12)
Hres :
(forall H2 H4 H3 H6 : Z,
 H2 = H3 ->
 H4 = H6 ->
 ZRange.type.base.option.is_bounded_by bound H2 &&
 (ZRange.type.base.option.is_bounded_by bound H4 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H2 H4) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H3
   H6)
H2 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H2 ?H4) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 ?H4 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) 
   ?H3 ?H6)
============================
((arg1 + arg2) * (arg1 ^ Harg12 + arg2 ^ Harg12) <=
 2 * (arg1 * arg1 ^ Harg12 + arg2 * arg2 ^ Harg12))
Finished transaction in 1.673 secs (1.667u,0.004s) (successful)
Tactic call ran for 7.059 secs (7.034u,0.017s) (success)
Finished transaction in 0.844 secs (0.841u,0.001s) (successful)
Finished transaction in 0.075 secs (0.075u,0.s) (successful)
Finished transaction in 0.634 secs (0.629u,0.003s) (successful)
Finished transaction in 1.237 secs (1.231u,0.003s) (successful)
Finished transaction in 0.112 secs (0.112u,0.s) (successful)
Finished transaction in 0.956 secs (0.951u,0.002s) (successful)
Reifying...
Tactic call ran for 174.399 secs (172.102u,2.153s) (success)
Finished transaction in 1.31 secs (1.305u,0.002s) (successful)
Finished transaction in 0.119 secs (0.118u,0.s) (successful)
Tactic call ran for 0.58 secs (0.58u,0.s) (success)
Proving Rewriter_Interp...
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
M : Z
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
Finished transaction in 0.914 secs (0.913u,0.s) (successful)
Finished transaction in 2.429 secs (2.418u,0.008s) (successful)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Finished transaction in 0.21 secs (0.206u,0.003s) (successful)
Tactic call ran for 5.191 secs (5.176u,0.008s) (success)
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
M : Z
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
mu := (2 ^ (2 * machine_wordsize) / M) : Z
muLow := (mu mod 2 ^ machine_wordsize) : Z
consts_list := [M; muLow] : (list Z)
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H5 : (type -> Type)
H : (1 < machine_wordsize)
H0 : (2 ^ (machine_wordsize - 1) <= M)
H6 : (M < 2 ^ machine_wordsize)
H1 : (muLow + 2 ^ machine_wordsize = (2 ^ 2) ^ machine_wordsize / M)
H2 : (2 ^ (machine_wordsize - 1) < M)
H4 : (M < 2 ^ machine_wordsize)
H3 :
(2 * ((2 ^ 2) ^ machine_wordsize mod M) <=
 2 ^ (machine_wordsize + 1) - (muLow + 2 ^ machine_wordsize))
var2 : (type -> Type)
Hres :
(forall H8 H10 H9 H12 : Z,
 H8 = H9 ->
 H10 = H12 ->
 ZRange.type.base.option.is_bounded_by bound H8 &&
 (ZRange.type.base.option.is_bounded_by bound H10 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H8 H10) = true /\
 expr.Interp (@Compilers.ident_interp) res H8 H10 =
 expr.Interp (@Compilers.ident_interp)
   (reified_barrett_red_gen @
    (fun var : type -> Type => GallinaReify.base.reify M) @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify 1%nat) @
    (fun var : type -> Type => GallinaReify.base.reify [muLow; 1]) @
    (fun var : type -> Type => GallinaReify.base.reify [M])) H9 H12)
H8 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H8 ?H10) = true)
H9 :
(expr.Interp (@Compilers.ident_interp) res ?H8 ?H10 =
 expr.Interp (@Compilers.ident_interp)
   (reified_barrett_red_gen @
    (fun var : type -> Type => GallinaReify.base.reify M) @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify 1%nat) @
    (fun var : type -> Type => GallinaReify.base.reify [muLow; 1]) @
    (fun var : type -> Type => GallinaReify.base.reify [M])) 
   ?H9 ?H12)
============================
(wf [] (res H5) (res var2))
Finished transaction in 15.126 secs (14.885u,0.218s) (successful)
Tactic call ran for 14.586 secs (14.55u,0.021s) (success)
Proving Rewriter_Wf...
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
Hl' : (type -> Type)
H : (0 <= N)
H9 : (N < R)
H0 : (0 <= N')
H8 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H6 : (2 <= machine_wordsize)
H7 : (2 ^ machine_wordsize = R)
var2 : (type -> Type)
Hres :
(forall H11 H13 H12 H15 : Z,
 H11 = H12 ->
 H13 = H15 ->
 ZRange.type.base.option.is_bounded_by bound H11 &&
 (ZRange.type.base.option.is_bounded_by bound H13 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H11 H13) = true /\
 expr.Interp (@Compilers.ident_interp) res H11 H13 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H12
   H15)
H11 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H11 ?H13) = true)
H12 :
(expr.Interp (@Compilers.ident_interp) res ?H11 ?H13 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H12 ?H15)
============================
(wf [] (res Hl') (res var2))
Finished transaction in 2.058 secs (2.047u,0.007s) (successful)
Tactic call ran for 2.141 secs (2.129u,0.008s) (success)
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
Hl' : (type -> Type)
H : (0 <= N)
H9 : (N < R)
H0 : (0 <= N')
H8 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H6 : (2 <= machine_wordsize)
H7 : (2 ^ machine_wordsize = R)
var2 : (type -> Type)
Hres :
(forall H11 H13 H12 H15 : Z,
 H11 = H12 ->
 H13 = H15 ->
 ZRange.type.base.option.is_bounded_by bound H11 &&
 (ZRange.type.base.option.is_bounded_by bound H13 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H11 H13) = true /\
 expr.Interp (@Compilers.ident_interp) res H11 H13 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H12
   H15)
H11 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H11 ?H13) = true)
H12 :
(expr.Interp (@Compilers.ident_interp) res ?H11 ?H13 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H12 ?H15)
============================
(wf [] (res Hl') (res var2))
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
Hl' : (type -> Type)
H : (0 <= N)
H9 : (N < R)
H0 : (0 <= N')
H8 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H6 : (2 <= machine_wordsize)
H7 : (2 ^ machine_wordsize = R)
var2 : (type -> Type)
Hres :
(forall H11 H13 H12 H15 : Z,
 H11 = H12 ->
 H13 = H15 ->
 ZRange.type.base.option.is_bounded_by bound H11 &&
 (ZRange.type.base.option.is_bounded_by bound H13 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H11 H13) = true /\
 expr.Interp (@Compilers.ident_interp) res H11 H13 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H12
   H15)
H11 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H11 ?H13) = true)
H12 :
(expr.Interp (@Compilers.ident_interp) res ?H11 ?H13 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H12 ?H15)
============================
(wf [] (res Hl') (res var2))
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
Hl' : (type -> Type)
H : (0 <= N)
H9 : (N < R)
H0 : (0 <= N')
H8 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H6 : (2 <= machine_wordsize)
H7 : (2 ^ machine_wordsize = R)
var2 : (type -> Type)
Hres :
(forall H11 H13 H12 H15 : Z,
 H11 = H12 ->
 H13 = H15 ->
 ZRange.type.base.option.is_bounded_by bound H11 &&
 (ZRange.type.base.option.is_bounded_by bound H13 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H11 H13) = true /\
 expr.Interp (@Compilers.ident_interp) res H11 H13 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H12
   H15)
H11 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H11 ?H13) = true)
H12 :
(expr.Interp (@Compilers.ident_interp) res ?H11 ?H13 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H12 ?H15)
============================
(wf [] (res Hl') (res var2))
Tactic call ran for 3.439 secs (3.433u,0.003s) (success)
Assembling verified rewriter...
Finished transaction in 2.927 secs (2.91u,0.012s) (successful)
Refining with verified rewriter...
Finished transaction in 0.245 secs (0.243u,0.001s) (successful)
Finished transaction in 2.584 secs (2.575u,0.006s) (successful)
Compiling decision tree...
Splitting rewrite rules...
Tactic call ran for 5.859 secs (5.827u,0.026s) (success)
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.466 secs (0.456u,0.008s) (success)
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
Finished transaction in 3.151 secs (3.079u,0.067s) (successful)
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H6 : (type -> Type)
H : (0 <= N)
H10 : (N < R)
H0 : (0 <= N')
H9 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H7 : (2 <= machine_wordsize)
H8 : (2 ^ machine_wordsize = R)
var2 : (type -> Type)
Hres :
(forall H12 H14 H13 H16 : Z,
 H12 = H13 ->
 H14 = H16 ->
 ZRange.type.base.option.is_bounded_by bound H12 &&
 (ZRange.type.base.option.is_bounded_by bound H14 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H12 H14) = true /\
 expr.Interp (@Compilers.ident_interp) res H12 H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H13
   H16)
H12 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H12 ?H14) = true)
H13 :
(expr.Interp (@Compilers.ident_interp) res ?H12 ?H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H13 ?H16)
============================
(wf [] (res H6) (res var2))
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H6 : (type -> Type)
H : (0 <= N)
H10 : (N < R)
H0 : (0 <= N')
H9 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H7 : (2 <= machine_wordsize)
H8 : (2 ^ machine_wordsize = R)
H11 : ((n + 1)%nat = S n)
var2 : (type -> Type)
Hres :
(forall H13 H15 H14 H17 : Z,
 H13 = H14 ->
 H15 = H17 ->
 ZRange.type.base.option.is_bounded_by bound H13 &&
 (ZRange.type.base.option.is_bounded_by bound H15 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H13 H15) = true /\
 expr.Interp (@Compilers.ident_interp) res H13 H15 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H14
   H17)
H13 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H13 ?H15) = true)
H14 :
(expr.Interp (@Compilers.ident_interp) res ?H13 ?H15 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H14 ?H17)
============================
(wf [] (res H6) (res var2))
Proving Rewriter_Interp...
Tactic call ran for 0.979 secs (0.955u,0.022s) (success)
Tactic call ran for 0.155 secs (0.154u,0.s) (success)
Finished transaction in 0.229 secs (0.229u,0.s) (successful)
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H6 : (type -> Type)
p : (0%nat = 0%nat)
H : (0 <= N)
H10 : (N < R)
H0 : (0 <= N')
H9 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H6 : (type -> Type)
p : (0%nat = 0%nat)
H : (0 <= N)
H10 : (N < R)
H0 : (0 <= N')
H9 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H7 : (2 <= machine_wordsize)
H8 : (2 ^ machine_wordsize = R)
Hres :
(forall H12 H14 H13 H16 : Z,
 H12 = H13 ->
 H14 = H16 ->
 ZRange.type.base.option.is_bounded_by bound H12 &&
 (ZRange.type.base.option.is_bounded_by bound H14 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H12 H14) = true /\
 expr.Interp (@Compilers.ident_interp) res H12 H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H13
   H16)
H12 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H12 ?H14) = true)
H13 :
(expr.Interp (@Compilers.ident_interp) res ?H12 ?H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H13 ?H16)
============================
False
Finished transaction in 15.391 secs (15.166u,0.203s) (successful)
Proving Rewriter_Wf...
Finished transaction in 2.24 secs (2.234u,0.004s) (successful)
Proving Rewriter_Interp...
Tactic call ran for 0.54 secs (0.529u,0.011s) (success)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((evalf cv * evalf cv) mod m)
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
Finished transaction in 315.918 secs (312.377u,2.852s) (successful)
Finished transaction in 0.008 secs (0.008u,0.s) (successful)
Finished transaction in 47.661 secs (6.567u,0.48s) (successful)
Finished transaction in 0.01 secs (0.01u,0.s) (successful)
Finished transaction in 2.243 secs (2.234u,0.005s) (successful)
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H6 : (type -> Type)
H : (0 <= N)
H10 : (N < R)
H0 : (0 <= N')
H9 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H7 : (2 <= machine_wordsize)
H8 : (2 ^ machine_wordsize = R)
var2 : (type -> Type)
Hres :
(forall H12 H14 H13 H16 : Z,
 H12 = H13 ->
 H14 = H16 ->
 ZRange.type.base.option.is_bounded_by bound H12 &&
 (ZRange.type.base.option.is_bounded_by bound H14 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H12 H14) = true /\
 expr.Interp (@Compilers.ident_interp) res H12 H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H13
   H16)
H12 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H12 ?H14) = true)
H13 :
(expr.Interp (@Compilers.ident_interp) res ?H12 ?H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H13 ?H16)
============================
(wf [] (res H6) (res var2))
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H6 : (type -> Type)
H : (0 <= N)
H10 : (N < R)
H0 : (0 <= N')
H9 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H7 : (2 <= machine_wordsize)
H8 : (2 ^ machine_wordsize = R)
H11 : ((n + 1)%nat = S n)
var2 : (type -> Type)
Hres :
(forall H13 H15 H14 H17 : Z,
 H13 = H14 ->
 H15 = H17 ->
 ZRange.type.base.option.is_bounded_by bound H13 &&
 (ZRange.type.base.option.is_bounded_by bound H15 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H13 H15) = true /\
 expr.Interp (@Compilers.ident_interp) res H13 H15 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H14
   H17)
H13 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H13 ?H15) = true)
H14 :
(expr.Interp (@Compilers.ident_interp) res ?H13 ?H15 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H14 ?H17)
============================
(wf [] (res H6) (res var2))
Finished transaction in 0.183 secs (0.181u,0.001s) (successful)
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
tight_upperbound_fraction : tight_upperbound_fraction_opt
n : nat
s : Z
c : (list (Z * Z))
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
n1 : positive
le_mn1 : positive
H0 : True
Finished transaction in 1.42 secs (1.416u,0.001s) (successful)
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H6 : (type -> Type)
p : (0%nat = 0%nat)
H : (0 <= N)
H10 : (N < R)
H0 : (0 <= N')
H9 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H7 : (2 <= machine_wordsize)
H8 : (2 ^ machine_wordsize = R)
Hres :
(forall H12 H14 H13 H16 : Z,
 H12 = H13 ->
 H14 = H16 ->
 ZRange.type.base.option.is_bounded_by bound H12 &&
 (ZRange.type.base.option.is_bounded_by bound H14 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H12 H14) = true /\
 expr.Interp (@Compilers.ident_interp) res H12 H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H13
   H16)
H12 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H12 ?H14) = true)
H13 :
(expr.Interp (@Compilers.ident_interp) res ?H12 ?H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H13 ?H16)
============================
False
Tactic call ran for 5.751 secs (5.662u,0.078s) (success)
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
Finished transaction in 2.178 secs (2.143u,0.031s) (successful)
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
Finished transaction in 0.174 secs (0.169u,0.005s) (successful)
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H6 : (type -> Type)
H : (0 <= N)
H10 : (N < R)
H0 : (0 <= N')
H9 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H7 : (2 <= machine_wordsize)
H8 : (2 ^ machine_wordsize = R)
var2 : (type -> Type)
Hres :
(forall H12 H14 H13 H16 : Z,
 H12 = H13 ->
 H14 = H16 ->
 ZRange.type.base.option.is_bounded_by bound H12 &&
 (ZRange.type.base.option.is_bounded_by bound H14 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H12 H14) = true /\
 expr.Interp (@Compilers.ident_interp) res H12 H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H13
   H16)
H12 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H12 ?H14) = true)
H13 :
(expr.Interp (@Compilers.ident_interp) res ?H12 ?H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H13 ?H16)
============================
(wf [] (res H6) (res var2))
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H6 : (type -> Type)
H : (0 <= N)
H10 : (N < R)
H0 : (0 <= N')
H9 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H7 : (2 <= machine_wordsize)
H8 : (2 ^ machine_wordsize = R)
H11 : ((n + 1)%nat = S n)
var2 : (type -> Type)
Hres :
(forall H13 H15 H14 H17 : Z,
 H13 = H14 ->
 H15 = H17 ->
 ZRange.type.base.option.is_bounded_by bound H13 &&
 (ZRange.type.base.option.is_bounded_by bound H15 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H13 H15) = true /\
 expr.Interp (@Compilers.ident_interp) res H13 H15 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H14
   H17)
H13 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H13 ?H15) = true)
H14 :
(expr.Interp (@Compilers.ident_interp) res ?H13 ?H15 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H14 ?H17)
============================
(wf [] (res H6) (res var2))
Tactic call ran for 7.32 secs (7.281u,0.03s) (success)
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
Finished transaction in 1.41 secs (1.405u,0.003s) (successful)
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
(map.undef_on m1 k2 -> map.undef_on m2 k2 -> map.only_differ m1 k1 m2)
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
(n = length (Partition.partition (UniformWeight.uweight width) n x))
Finished transaction in 8.666 secs (8.631u,0.018s) (successful)
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
(map.undef_on m1 k2 -> map.undef_on m2 k2 -> map.only_differ m1 k1 m2)
Finished transaction in 2.645 secs (2.638u,0.004s) (successful)
Finished transaction in 0.171 secs (0.171u,0.s) (successful)
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
tight_upperbound_fraction : tight_upperbound_fraction_opt
n : nat
s : Z
c : (list (Z * Z))
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : True
m0 : Z
H0 : (0 < m0)
Hres :
(forall H2 H3 : list Z,
 H2 = H3 ->
 ZRange.type.base.option.is_bounded_by
   (Some (UnsaturatedSolinasHeuristics.loose_bounds n s c)) H2 && true = true ->
 ZRange.type.base.option.is_bounded_by
   (Some (UnsaturatedSolinasHeuristics.tight_bounds n s c))
   (expr.Interp (@Compilers.ident_interp) res H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 =
 expr.Interp (@Compilers.ident_interp)
   (reified_carry_square_gen @
    (fun var : type -> Type => GallinaReify.base.reify (Qnum limbwidth)) @
    (fun var : type -> Type => GallinaReify.base.reify (QDen limbwidth)) @
    (fun var : type -> Type => GallinaReify.base.reify s) @
    (fun var : type -> Type => GallinaReify.base.reify c) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify idxs)) H3)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some (UnsaturatedSolinasHeuristics.tight_bounds n s c))
   (expr.Interp (@Compilers.ident_interp) res ?H2) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 =
 expr.Interp (@Compilers.ident_interp)
   (reified_carry_square_gen @
    (fun var : type -> Type => GallinaReify.base.reify (Qnum limbwidth)) @
    (fun var : type -> Type => GallinaReify.base.reify (QDen limbwidth)) @
    (fun var : type -> Type => GallinaReify.base.reify s) @
    (fun var : type -> Type => GallinaReify.base.reify c) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify idxs)) 
   ?H3)
============================
(Z.quot2 m0 = m0 ÷ 2)
output_language_api : ToString.OutputLanguageAPI
static : static_opt
internal_static : internal_static_opt
inline : inline_opt
inline_internal : inline_internal_opt
N : Z
R : Z
N' : Z
n : nat
machine_wordsize : machine_wordsize_opt
value_range := r[0 ~> 2 ^ machine_wordsize - 1]%zrange : zrange
flag_range := r[0 ~> 1]%zrange : zrange
bound := (Some value_range) : (option zrange)
consts_list := [N; N'] : (list Z)
R' := (Z.modinv R N) : Z
possible_values := possible_values_of_machine_wordsize : (list Z)
fancy_args :=
(Some
   {|
     Pipeline.invert_low :=
       fun log2wordsize : Z => invert_low log2wordsize consts_list;
     Pipeline.invert_high :=
       fun log2wordsize : Z => invert_high log2wordsize consts_list;
     Pipeline.value_range := value_range;
     Pipeline.flag_range := flag_range
   |}) : (option Pipeline.to_fancy_args)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H6 : (type -> Type)
H : (0 <= N)
H10 : (N < R)
H0 : (0 <= N')
H9 : (N' < R)
H1 : (N <> 0)
H2 : (R > 1)
H3 : (EquivModulo.Z.equiv_modulo R (N * N') (-1))
H4 : (EquivModulo.Z.equiv_modulo N (R * R') 1)
H5 : (n <> 0%nat)
H7 : (2 <= machine_wordsize)
H8 : (2 ^ machine_wordsize = R)
var2 : (type -> Type)
Hres :
(forall H12 H14 H13 H16 : Z,
 H12 = H13 ->
 H14 = H16 ->
 ZRange.type.base.option.is_bounded_by bound H12 &&
 (ZRange.type.base.option.is_bounded_by bound H14 && true) = true ->
 ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res H12 H14) = true /\
 expr.Interp (@Compilers.ident_interp) res H12 H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize)) H13
   H16)
H12 :
(ZRange.type.base.option.is_bounded_by bound
   (expr.Interp (@Compilers.ident_interp) res ?H12 ?H14) = true)
H13 :
(expr.Interp (@Compilers.ident_interp) res ?H12 ?H14 =
 expr.Interp (@Compilers.ident_interp)
   (reified_montred_gen @
    (fun var : type -> Type => GallinaReify.base.reify N) @
    (fun var : type -> Type => GallinaReify.base.reify R) @
    (fun var : type -> Type => GallinaReify.base.reify N') @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize))
   ?H13 ?H16)
============================
(wf [] (res H6) (res var2))
Proving Rewriter_Interp...
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify __.m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
__.m
expr.reify_in_context: Failure in reifying:
((evalf k * evalf k) mod __.m)
(map.undef_on m1 k2 -> map.undef_on m2 k2 -> map.only_differ m1 k1 m2)
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
Finished transaction in 1.497 secs (1.492u,0.002s) (successful)
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
(map.undef_on m1 k2 -> map.undef_on m2 k2 -> map.only_differ m1 k1 m2)
find_witness Control.TimeoutFinished transaction in 20.77 secs (20.619u,0.148s) (successful)
(n = length (Partition.partition (UniformWeight.uweight width) n x))
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
Tactic call ran for 8.126 secs (8.014u,0.104s) (success)
(map.undef_on m1 k2 -> map.undef_on m2 k2 -> map.only_differ m1 k1 m2)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
GT : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res GT) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
bad
(map.undef_on m1 k2 -> map.undef_on m2 k2 -> map.only_differ m1 k1 m2)
bad
Tactic call ran for 9.252 secs (9.155u,0.078s) (success)
bad
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
n : nat
LE : (0 <= Z.of_nat n)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(Wf res)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : nat
H0 : True
LE : (0 <= Z.of_nat H)
Hres :
(forall H2 H3 : Z,
 H2 = H3 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H2 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H3)
H2 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H2) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H3)
============================
(Wf res)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((evalf k * evalf k) mod m)
Assembling verified rewriter...
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
n : nat
n0 : nat
LE : (0 <= Z.of_nat n0)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(Wf res)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
n : nat
LE : (0 <= Z.of_nat n)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(Wf res)
Refining with verified rewriter...
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
Hb : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res Hb) (res var2))
(n = length (Partition.partition (UniformWeight.uweight width) n x))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
q : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res q) (res var2))
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
HF : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res HF) (res var2))
(varname_gen (length (Partition.partition (UniformWeight.uweight width) n H)) =
 varname_gen n)
(map.undef_on m1 k2 -> map.undef_on m2 k2 -> map.only_differ m1 k1 m2)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
Acc_0 : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res Acc_0) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
GT : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res GT) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
Tactic call ran for 28.982 secs (28.851u,0.103s) (success)
Tactic call ran for 6.394 secs (6.281u,0.101s) (success)
(n = length (Partition.partition (UniformWeight.uweight width) n x))
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
var1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
(0 <= a -> False)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
var1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
var1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
(map.undef_on m1 k2 -> map.undef_on m2 k2 -> map.only_differ m1 k1 m2)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
var1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
var1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
var1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((eval
    (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 s c))
       (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 s c))) 0 H *
  eval
    (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 s c))
       (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 s c))) 0 H) mod m)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
var1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
(map.undef_on m1 k2 -> map.undef_on m2 k2 -> map.only_differ m1 k1 m2)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
var1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
Assembling verified rewriter...
Refining with verified rewriter...
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
Tactic call ran for 0.009 secs (0.008u,0.001s) (success)
Finished transaction in 65.547 secs (64.486u,0.963s) (successful)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
Habsurd : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res Habsurd) (res var2))
find_witness Control.TimeoutFinished transaction in 0.002 secs (0.001u,0.001s) (successful)
Tactic call ran for 10.669 secs (10.554u,0.106s) (success)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H1 : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H2 H3 : Z,
 H2 = H3 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H2 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H3)
H2 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H2) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H3)
============================
(wf [] (res H1) (res var2))
(0 = 1)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H1 : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H2 H3 : Z,
 H2 = H3 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H2 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H3)
H2 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H2) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H3)
============================
(wf [] (res H1) (res var2))
bad
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
n : nat
LE : (0 <= Z.of_nat n)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(Wf res)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : nat
H0 : True
LE : (0 <= Z.of_nat H)
Hres :
(forall H2 H3 : Z,
 H2 = H3 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H2 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H3)
H2 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H2) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H3)
============================
(Wf res)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : nat
H0 : True
LE : (0 <= Z.of_nat H)
Hres :
(forall H2 H3 : Z,
 H2 = H3 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H2 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H3)
H2 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H2) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H3)
============================
(Wf res)
bad
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H0 : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf x) mod m)
bad
bad
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H0 : True
a : Z
b : Z
c : Z
H : (0 <= a <= b)
H1 : (0 < c)
Hres :
(forall H3 H4 : Z,
 H3 = H4 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H3 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H3 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H4)
H3 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H3) = true)
H4 :
(expr.Interp (@Compilers.ident_interp) res ?H3 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H4)
============================
((a + b) * (a ^ c + b ^ c) <= 2 * (a * a ^ c + b * b ^ c))
bad
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H0 : True
a : Z
b : Z
c : Z
H : (0 <= a <= b)
H1 : (0 < c)
Hres :
(forall H3 H4 : Z,
 H3 = H4 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H3 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H3 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H4)
H3 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H3) = true)
H4 :
(expr.Interp (@Compilers.ident_interp) res ?H3 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H4)
============================
((a + b) * (a ^ c + b ^ c) <= 2 * (a * a ^ c + b * b ^ c))
Reifying...
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
x : Z
y : Z
H0 : True
c : Z
H : (0 <= x <= y)
H1 : (0 < c)
Hres :
(forall H3 H4 : Z,
 H3 = H4 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H3 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H3 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H4)
H3 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H3) = true)
H4 :
(expr.Interp (@Compilers.ident_interp) res ?H3 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H4)
============================
((x + y) * (x ^ c + y ^ c) <= 2 * (x * x ^ c + y * y ^ c))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H0 : True
a : Z
b : Z
c : Z
H : (0 <= a <= b)
H1 : (0 < c)
Hres :
(forall H3 H4 : Z,
 H3 = H4 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H3 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H3 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H4)
H3 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H3) = true)
H4 :
(expr.Interp (@Compilers.ident_interp) res ?H3 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H4)
============================
((a + b) * (a ^ c + b ^ c) <= 2 * (a * a ^ c + b * b ^ c))
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf k) mod m)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
Acc_0 : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res Acc_0) (res var2))
Reifying...
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
GT : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res GT) (res var2))
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.205 secs (0.198u,0.005s) (success)
Tactic call ran for 0.074 secs (0.074u,0.s) (success)
Tactic call ran for 0.123 secs (0.121u,0.001s) (success)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
((0 ?= Z.of_nat n) = Lt)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf x) mod m)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
H : True
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf Hd) mod m)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Proving Rewriter_Wf...
Tactic call ran for 0.112 secs (0.109u,0.003s) (success)
Tactic call ran for 0.02 secs (0.02u,0.s) (success)
(map.undef_on m1 k2 -> map.undef_on m2 k2 -> map.only_differ m1 k1 m2)
Tactic call ran for 0.112 secs (0.111u,0.s) (success)
Tactic call ran for 0.096 secs (0.096u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Assembling verified rewriter...
Proving Rewriter_Wf...
Tactic call ran for 0.058 secs (0.058u,0.s) (success)
Tactic call ran for 1.23 secs (1.204u,0.022s) (success)
Finished transaction in 4.523 secs (4.477u,0.039s) (successful)
Refining with verified rewriter...
Tactic call ran for 0.941 secs (0.921u,0.018s) (success)
Proving Rewriter_Interp...
Proving Rewriter_Interp...
Finished transaction in 14.661 secs (14.551u,0.09s) (successful)
Finished transaction in 41.547 secs (0.661u,0.333s) (successful)
Finished transaction in 0.005 secs (0.003u,0.001s) (successful)
Tactic call ran for 1.306 secs (1.298u,0.006s) (success)
Tactic call ran for 2.011 secs (2.004u,0.002s) (success)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
var1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
((forall n : nat, nextn <= n -> ~ varname_set_base Hn (varname_gen n)) ->
 (fix cmd (c : cmd) :
      Semantics.trace ->
      map.rep ->
      map.rep -> (Semantics.trace -> map.rep -> map.rep -> Prop) -> Prop :=
    WeakestPrecondition.cmd_body (WeakestPrecondition.call functions) cmd c)
   (snd (load_all_lists nextn Hn (list_lengths_from_value args) Hm)) tr mem0
   locals0
   (fun (tr' : Semantics.trace) (mem' locals' : map.rep) =>
    tr = tr' /\
    mem0 = mem' /\
    map.only_differ locals0
      (used_varnames nextn
         (fst
            (fst (load_all_lists nextn Hn (list_lengths_from_value args) Hm))))
      locals' /\
    (forall n : nat,
     nextn +
     fst (fst (load_all_lists nextn Hn (list_lengths_from_value args) Hm)) <=
     n ->
     ~
     varname_set_base
       (snd (fst (load_all_lists nextn Hn (list_lengths_from_value args) Hm)))
       (varname_gen n)) /\
    locally_equivalent_base args
      (base_rtype_of_ltype
         (snd
            (fst (load_all_lists nextn Hn (list_lengths_from_value args) Hm))))
      locals'))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
var1 : (type -> Type)
var2 : (type -> Type)
H : True
out of reach
Tactic call ran for 0.004 secs (0.003u,0.001s) (failure)
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
Tactic call ran for 0.894 secs (0.887u,0.004s) (success)
Tactic call ran for 1.163 secs (1.15u,0.012s) (success)
Finished transaction in 40.942 secs (0.4u,0.156s) (successful)
Finished transaction in 0.029 secs (0.028u,0.s) (successful)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
s' : int.type
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.type_base Compilers.Z)))
var1 : (type -> Type)
var2 : (type -> Type)
H : True
Hres :
(forall H1 H2 : Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s')) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some (int.to_zrange s'))
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_value_barrier_gen ?H2)
============================
(wf [] (res var1) (res var2))
Finished transaction in 0.232 secs (0.228u,0.003s) (successful)
Assembling verified rewriter...
Refining with verified rewriter...
Assembling verified rewriter...
Refining with verified rewriter...
Unrecognized (non-constant-headed) term: (if
                                           Crypto.Util.Decidable.dec
                                             (cond = 0)
                                          then z
                                          else nz) (
expr.Not_headed_by_a_constant_under_binders
  (Constr.Unsafe.Case
     (<abstr>,
     constr:(fun _ : {cond = 0} + {cond <> 0} => Z),
     Constr.Unsafe.NoInvert,
     constr:(Crypto.Util.Decidable.dec (cond = 0)),
     [|
     constr:(fun _ : cond = 0 => z);
     constr:(fun _ : cond <> 0 => nz)
     |])))
expr.reify_in_context: Failure in reifying:
(if Crypto.Util.Decidable.dec (cond = 0) then z else nz)
Unrecognized (non-unfoldable) term: z
expr.reify_in_context: Failure in reifying:
z
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf k) mod m)
Finished transaction in 8.279 secs (8.19u,0.076s) (successful)
Unrecognized (non-constant-headed) term: (if
                                           Crypto.Util.Decidable.dec
                                             (cond = 0)
                                          then z
                                          else nz) (
expr.Not_headed_by_a_constant_under_binders
  (Constr.Unsafe.Case
     (<abstr>,
     constr:(fun _ : {cond = 0} + {cond <> 0} => Z),
     Constr.Unsafe.NoInvert,
     constr:(Crypto.Util.Decidable.dec (cond = 0)),
     [|
     constr:(fun _ : cond = 0 => z);
     constr:(fun _ : cond <> 0 => nz)
     |])))
expr.reify_in_context: Failure in reifying:
(if Crypto.Util.Decidable.dec (cond = 0) then z else nz)
Finished transaction in 7.054 secs (7.019u,0.023s) (successful)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
(∀ x y z : Z, y < z - x → x + y < z)
Finished transaction in 49.217 secs (8.592u,0.265s) (successful)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf k) mod m)
FlattenExpr: flattenStmt_correct_aux done
find_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf k) mod m)
Finished transaction in 0.575 secs (0.569u,0.005s) (successful)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Finished transaction in 72.905 secs (72.209u,0.616s) (successful)
Finished transaction in 6.036 secs (6.002u,0.024s) (successful)
bad
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf x) mod m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify __.m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
__.m
expr.reify_in_context: Failure in reifying:
((a * evalf x) mod __.m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify __.m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
__.m
expr.reify_in_context: Failure in reifying:
((a *
  eval
    (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 s c))
       (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 s c))) 0 x) mod __.m)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify __.m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
__.m
expr.reify_in_context: Failure in reifying:
((a *
  eval
    (weight
       (Z.log2_up (s - Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n x) mod __.m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify __.m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
__.m
expr.reify_in_context: Failure in reifying:
((a * evalf e) mod __.m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf x) mod m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf Hd) mod m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a *
  eval
    (weight
       (Z.log2_up (s - Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n Hd) mod m)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Finished transaction in 18.625 secs (18.45u,0.147s) (successful)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf x) mod m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((a * evalf Hd) mod m)
find_witness Control.Timeoutoutput_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
tight_upperbound_fraction : tight_upperbound_fraction_opt
n : nat
Finished transaction in 78.912 secs (78.516u,0.313s) (successful)
Finished transaction in 7.58 secs (7.522u,0.046s) (successful)
Finished transaction in 70.905 secs (69.837u,0.931s) (successful)
bad
bad
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(evalf q mod m)
Finished transaction in 5.145 secs (5.104u,0.033s) (successful)
Unrecognized (non-unfoldable) term: q
expr.reify_in_context: Failure in reifying:
q
expr.reify_in_context: Failure in reifying:
(evalf q)
expr.reify_in_context: Failure in reifying:
(Z.modulo (evalf q))
expr.reify_in_context: Failure in reifying:
(evalf q mod 0)
bad
bad
bad
bad
bad
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
tight_upperbound_fraction : tight_upperbound_fraction_opt
n : nat
s : Z
c : (list (Z * Z))
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (list Z)
H : True
H0 : (list_Z_bounded_by (UnsaturatedSolinasHeuristics.loose_bounds n s c) x)
bad
bad
bad
Finished transaction in 3.869 secs (3.839u,0.024s) (successful)
Finished transaction in 41.807 secs (0.956u,0.336s) (successful)
Finished transaction in 0.004 secs (0.003u,0.s) (successful)
bad
bad
bad
Finished transaction in 41.047 secs (0.464u,0.157s) (successful)
Finished transaction in 0.031 secs (0.031u,0.s) (successful)
Finished transaction in 0.202 secs (0.2u,0.s) (successful)
bad
bad
bad
bad
bad
Unrecognized (non-constant-headed) term: (if
                                           Crypto.Util.Decidable.dec
                                             (cond = 0)
                                          then z
                                          else nz) (
expr.Not_headed_by_a_constant_under_binders
  (Constr.Unsafe.Case
     (<abstr>,
     constr:(fun _ : {cond = 0} + {cond <> 0} => Z),
     Constr.Unsafe.NoInvert,
     constr:(Crypto.Util.Decidable.dec (cond = 0)),
     [|
     constr:(fun _ : cond = 0 => z);
     constr:(fun _ : cond <> 0 => nz)
     |])))
expr.reify_in_context: Failure in reifying:
(if Crypto.Util.Decidable.dec (cond = 0) then z else nz)
string
Finished transaction in 4.913 secs (4.877u,0.028s) (successful)
bad
bad
bad
bad
bad
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(evalf x mod m)
bad
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
Finished transaction in 19.28 secs (19.094u,0.161s) (successful)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(evalf q mod m)
Unrecognized (non-constant-headed) term: (if
                                           Crypto.Util.Decidable.dec
                                             (cond = 0)
                                          then z
                                          else nz) (
expr.Not_headed_by_a_constant_under_binders
  (Constr.Unsafe.Case
     (<abstr>,
     constr:(fun _ : {cond = 0} + {cond <> 0} => Z),
     Constr.Unsafe.NoInvert,
     constr:(Crypto.Util.Decidable.dec (cond = 0)),
     [|
     constr:(fun _ : cond = 0 => z);
     constr:(fun _ : cond <> 0 => nz)
     |])))
expr.reify_in_context: Failure in reifying:
(if Crypto.Util.Decidable.dec (cond = 0) then z else nz)
End of FlattenExpr.v
Unrecognized (non-unfoldable) term: q
expr.reify_in_context: Failure in reifying:
q
expr.reify_in_context: Failure in reifying:
(evalf q)
expr.reify_in_context: Failure in reifying:
(Z.modulo (evalf q))
expr.reify_in_context: Failure in reifying:
(evalf q mod 0)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(evalf q mod m)
out of reach
Tactic call ran for 0.008 secs (0.004u,0.003s) (failure)
Unrecognized (non-unfoldable) term: H0
expr.reify_in_context: Failure in reifying:
H0
expr.reify_in_context: Failure in reifying:
(from_montgomery_res H0)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res H0))
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res H3) *
 eval machine_wordsize (from_montgomery_res H0))
expr.reify_in_context: Failure in reifying:
(Z.modulo
   (eval machine_wordsize (from_montgomery_res H3) *
    eval machine_wordsize (from_montgomery_res H0)))
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
tight_upperbound_fraction : tight_upperbound_fraction_opt
n : nat
s : Z
c : (list (Z * Z))
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (list Z)
H : True
H0 : (list_Z_bounded_by (UnsaturatedSolinasHeuristics.loose_bounds n s c) x)
Unrecognized (non-unfoldable) term: i
expr.reify_in_context: Failure in reifying:
i
expr.reify_in_context: Failure in reifying:
(from_montgomery_res i)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res i))
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res Hq) *
 eval machine_wordsize (from_montgomery_res i))
expr.reify_in_context: Failure in reifying:
(Z.modulo
   (eval machine_wordsize (from_montgomery_res Hq) *
    eval machine_wordsize (from_montgomery_res i)))
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
tight_upperbound_fraction : tight_upperbound_fraction_opt
n : nat
s : Z
c : (list (Z * Z))
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (list Z)
H : True
H0 : (list_Z_bounded_by (UnsaturatedSolinasHeuristics.loose_bounds n s c) x)
Hres :
(forall H2 H3 : list Z,
 H2 = H3 ->
 ZRange.type.base.option.is_bounded_by
   (Some (UnsaturatedSolinasHeuristics.loose_bounds n s c)) H2 && true = true ->
 ZRange.type.base.option.is_bounded_by
   (Some (UnsaturatedSolinasHeuristics.tight_bounds n s c))
   (expr.Interp (@Compilers.ident_interp) res H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 =
 expr.Interp (@Compilers.ident_interp)
   (reified_carry_gen @
    (fun var : type -> Type => GallinaReify.base.reify (Qnum limbwidth)) @
    (fun var : type -> Type => GallinaReify.base.reify (QDen limbwidth)) @
    (fun var : type -> Type => GallinaReify.base.reify s) @
    (fun var : type -> Type => GallinaReify.base.reify c) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify idxs)) H3)
H2 :
(ZRange.type.base.option.is_bounded_by
   (Some (UnsaturatedSolinasHeuristics.tight_bounds n s c))
   (expr.Interp (@Compilers.ident_interp) res ?H2) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 =
 expr.Interp (@Compilers.ident_interp)
   (reified_carry_gen @
    (fun var : type -> Type => GallinaReify.base.reify (Qnum limbwidth)) @
    (fun var : type -> Type => GallinaReify.base.reify (QDen limbwidth)) @
    (fun var : type -> Type => GallinaReify.base.reify s) @
    (fun var : type -> Type => GallinaReify.base.reify c) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify idxs)) 
   ?H3)
============================
False
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(evalf x mod m)
Unrecognized (non-unfoldable) term: H'
expr.reify_in_context: Failure in reifying:
H'
expr.reify_in_context: Failure in reifying:
(from_montgomery_res H')
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res H'))
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res Hq) *
 eval machine_wordsize (from_montgomery_res H'))
expr.reify_in_context: Failure in reifying:
(Z.modulo
   (eval machine_wordsize (from_montgomery_res Hq) *
    eval machine_wordsize (from_montgomery_res H')))
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : True
x : Z
y : Z
z : Z
H0 : (- z <= y - x)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.075 secs (0.074u,0.001s) (success)
Tactic call ran for 0.015 secs (0.015u,0.s) (success)
Tactic call ran for 0.093 secs (0.092u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.026 secs (0.026u,0.s) (success)
Tactic call ran for 0.396 secs (0.394u,0.001s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.405 secs (0.399u,0.005s) (success)
Tactic call ran for 0.1 secs (0.1u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
(forall (wold_out : list Interface.word.rep) (t : Semantics.trace)
   (m0 : Interface.map.rep) (Rx Ry Rout : Interface.map.rep -> Prop),
 WordByWordMontgomery.WordByWordMontgomery.valid 64
   (WordByWordMontgomery.n m 64) m (List.map Interface.word.unsigned H) /\
 WordByWordMontgomery.WordByWordMontgomery.valid 64
   (WordByWordMontgomery.n m 64) m (List.map Interface.word.unsigned n) ->
 Separation.sep (Bignum.Bignum (WordByWordMontgomery.n m 64) y H) Rx m0 ->
 Separation.sep (Bignum.Bignum (WordByWordMontgomery.n m 64) nN n) Ry m0 ->
 Separation.sep (Bignum.Bignum (WordByWordMontgomery.n m 64) dy wold_out)
   Rout m0 ->
 WeakestPrecondition.call (mul :: nil) "p256_mul" t m0 
   (dy :: y :: nN :: nil)
   (fun (t' : Semantics.trace) (m' : Interface.map.rep)
      (rets : list Interface.word.rep) =>
    t = t' /\
    rets = nil /\
    (exists wout : list Interface.word.rep,
       Separation.sep
         (Separation.sep
            (Separation.emp
               (WordByWordMontgomery.WordByWordMontgomery.eval 64
                  (WordByWordMontgomery.WordByWordMontgomery.from_montgomerymod
                     64 (WordByWordMontgomery.n m 64) m
                     (WordByWordMontgomery.m' m 64)
                     (List.map Interface.word.unsigned wout)) mod m =
                (WordByWordMontgomery.WordByWordMontgomery.eval 64
                   (WordByWordMontgomery.WordByWordMontgomery.from_montgomerymod
                      64 (WordByWordMontgomery.n m 64) m
                      (WordByWordMontgomery.m' m 64)
                      (List.map Interface.word.unsigned H)) *
                 WordByWordMontgomery.WordByWordMontgomery.eval 64
                   (WordByWordMontgomery.WordByWordMontgomery.from_montgomerymod
                      64 (WordByWordMontgomery.n m 64) m
                      (WordByWordMontgomery.m' m 64)
                      (List.map Interface.word.unsigned n))) mod m /\
                WordByWordMontgomery.WordByWordMontgomery.valid 64
                  (WordByWordMontgomery.n m 64) m
                  (List.map Interface.word.unsigned wout)))
            (Bignum.Bignum (WordByWordMontgomery.n m 64) dy wout)) Rout m')))
Finished transaction in 42.934 secs (2.025u,0.347s) (successful)
Finished transaction in 0.004 secs (0.003u,0.s) (successful)
Unrecognized (non-unfoldable) term: b
expr.reify_in_context: Failure in reifying:
b
expr.reify_in_context: Failure in reifying:
(from_montgomery_res b)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res b))
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res H3) *
 eval machine_wordsize (from_montgomery_res b))
expr.reify_in_context: Failure in reifying:
(Z.modulo
   (eval machine_wordsize (from_montgomery_res H3) *
    eval machine_wordsize (from_montgomery_res b)))
Unrecognized (non-unfoldable) term: b
expr.reify_in_context: Failure in reifying:
b
expr.reify_in_context: Failure in reifying:
(from_montgomerymod machine_wordsize n 0 m' b)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomerymod machine_wordsize n 0 m' b))
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomerymod machine_wordsize n 0 m' H3) *
 eval machine_wordsize (from_montgomerymod machine_wordsize n 0 m' b))
expr.reify_in_context: Failure in reifying:
(Z.modulo
   (eval machine_wordsize (from_montgomerymod machine_wordsize n 0 m' H3) *
    eval machine_wordsize (from_montgomerymod machine_wordsize n 0 m' b)))
expr.reify_in_context: Failure in reifying:
((eval machine_wordsize (from_montgomerymod machine_wordsize n 0 m' H3) *
  eval machine_wordsize (from_montgomerymod machine_wordsize n 0 m' b)) mod 0)
Unrecognized (non-constant-headed) term: (if
                                           Crypto.Util.Decidable.dec
                                             (cond = 0)
                                          then x
                                          else y) (
expr.Not_headed_by_a_constant_under_binders
  (Constr.Unsafe.Case
     (<abstr>,
     constr:(fun _ : {cond = 0} + {cond <> 0} => list Z),
     Constr.Unsafe.NoInvert,
     constr:(Crypto.Util.Decidable.dec (cond = 0)),
     [|
     constr:(fun _ : cond = 0 => x);
     constr:(fun _ : cond <> 0 => y)
     |])))
expr.reify_in_context: Failure in reifying:
(if Crypto.Util.Decidable.dec (cond = 0) then x else y)
Reifying...
Finished transaction in 46.007 secs (5.34u,0.193s) (successful)
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.069 secs (0.067u,0.002s) (success)
Tactic call ran for 0.014 secs (0.014u,0.s) (success)
Tactic call ran for 0.102 secs (0.099u,0.002s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.021 secs (0.02u,0.s) (success)
Tactic call ran for 0.214 secs (0.21u,0.004s) (success)
Unrecognized (non-constant-headed) term: (if
                                           Crypto.Util.Decidable.dec (H = 0)
                                          then pol
                                          else y) (
expr.Not_headed_by_a_constant_under_binders
  (Constr.Unsafe.Case
     (<abstr>,
     constr:(fun _ : {H = 0} + {H <> 0} => list Z),
     Constr.Unsafe.NoInvert,
     constr:(Crypto.Util.Decidable.dec (H = 0)),
     [|
     constr:(fun _ : H = 0 => pol);
     constr:(fun _ : H <> 0 => y)
     |])))
expr.reify_in_context: Failure in reifying:
(if Crypto.Util.Decidable.dec (H = 0) then pol else y)
Proving Rewriter_Interp...
Finished transaction in 0.312 secs (0.307u,0.004s) (successful)
Tactic call ran for 0.33 secs (0.327u,0.003s) (success)
Tactic call ran for 0.062 secs (0.062u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Unrecognized (non-unfoldable) term: b
expr.reify_in_context: Failure in reifying:
b
expr.reify_in_context: Failure in reifying:
(from_montgomery_res b)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res b))
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res H3) *
 eval machine_wordsize (from_montgomery_res b))
expr.reify_in_context: Failure in reifying:
(Z.modulo
   (eval machine_wordsize (from_montgomery_res H3) *
    eval machine_wordsize (from_montgomery_res b)))
Unrecognized (non-unfoldable) term: b
expr.reify_in_context: Failure in reifying:
b
expr.reify_in_context: Failure in reifying:
(from_montgomerymod machine_wordsize 0 m m' b)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' b))
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' H3) *
 eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' b))
expr.reify_in_context: Failure in reifying:
(Z.modulo
   (eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' H3) *
    eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' b)))
Finished transaction in 3.133 secs (3.118u,0.011s) (successful)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.057 secs (0.053u,0.003s) (success)
Tactic call ran for 0.011 secs (0.01u,0.s) (success)
Tactic call ran for 0.11 secs (0.099u,0.01s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.017 secs (0.017u,0.s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.289 secs (0.289u,0.s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
find_witness Control.TimeoutTactic call ran for 0.015 secs (0.014u,0.s) (success)
Unrecognized (non-constant-headed) term: (if
                                           Crypto.Util.Decidable.dec (H' = 0)
                                          then []
                                          else H) (
expr.Not_headed_by_a_constant_under_binders
  (Constr.Unsafe.Case
     (<abstr>,
     constr:(fun _ : {H' = 0} + {H' = 0 -> False} => list Z),
     Constr.Unsafe.NoInvert,
     constr:(Crypto.Util.Decidable.dec (H' = 0)),
     [|
     constr:(fun _ : H' = 0 => []);
     constr:(fun _ : H' = 0 -> False => H)
     |])))
expr.reify_in_context: Failure in reifying:
(if Crypto.Util.Decidable.dec (H' = 0) then [] else H)
Tactic call ran for 0.015 secs (0.015u,0.s) (success)
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
tight_upperbound_fraction : tight_upperbound_fraction_opt
n : nat
s : Z
c : (list (Z * Z))
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H1 : True
m0 : Z
H : (0 < m0)
Unrecognized (non-constant-headed) term: (if
                                           Crypto.Util.Decidable.dec (H' = 0)
                                          then pf0
                                          else b) (
expr.Not_headed_by_a_constant_under_binders
  (Constr.Unsafe.Case
     (<abstr>,
     constr:(fun _ : {H' = 0} + {H' <> 0} => list Z),
     Constr.Unsafe.NoInvert,
     constr:(Crypto.Util.Decidable.dec (H' = 0)),
     [|
     constr:(fun _ : H' = 0 => pf0);
     constr:(fun _ : H' <> 0 => b)
     |])))
expr.reify_in_context: Failure in reifying:
(if Crypto.Util.Decidable.dec (H' = 0) then pf0 else b)
find_witness Fun.Finally_raised: Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((eval
    (weight
       (Z.log2_up (s - Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n N0 -
  eval
    (weight
       (Z.log2_up (s - Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n H1) mod m)
Finished transaction in 42.611 secs (1.72u,0.342s) (successful)
Finished transaction in 0.004 secs (0.004u,0.s) (successful)
Unrecognized (non-unfoldable) term: Rew
expr.reify_in_context: Failure in reifying:
Rew
expr.reify_in_context: Failure in reifying:
(from_montgomerymod machine_wordsize 0 m m' Rew)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' Rew))
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' Rew) *
 eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' Rew))
expr.reify_in_context: Failure in reifying:
(Z.modulo
   (eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' Rew) *
    eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' Rew)))
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
Rew : (list Z)
H : True
H0 : (0 < 2)
H1 : (WordByWordMontgomery.valid machine_wordsize 0 m Rew)
Hres :
(forall H3 H4 : list Z,
 H3 = H4 ->
 ZRange.type.base.option.is_bounded_by (Some montgomery_domain_bounds) H3 &&
 true = true ->
 ZRange.type.base.option.is_bounded_by (Some montgomery_domain_bounds)
   (expr.Interp (@Compilers.ident_interp) res H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_square_gen @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify m) @
    (fun var : type -> Type => GallinaReify.base.reify m')) H4)
H3 :
(ZRange.type.base.option.is_bounded_by (Some montgomery_domain_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H3) = true)
H4 :
(expr.Interp (@Compilers.ident_interp) res ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_square_gen @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify m) @
    (fun var : type -> Type => GallinaReify.base.reify m')) 
   ?H4)
============================
(0 = 0)
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
Rew : (list Z)
H : True
H0 : (0 < 2)
H1 : (WordByWordMontgomery.valid machine_wordsize 0 m Rew)
Hres :
(forall H3 H4 : list Z,
 H3 = H4 ->
 ZRange.type.base.option.is_bounded_by (Some montgomery_domain_bounds) H3 &&
 true = true ->
 ZRange.type.base.option.is_bounded_by (Some montgomery_domain_bounds)
   (expr.Interp (@Compilers.ident_interp) res H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_square_gen @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify m) @
    (fun var : type -> Type => GallinaReify.base.reify m')) H4)
H3 :
(ZRange.type.base.option.is_bounded_by (Some montgomery_domain_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H3) = true)
H4 :
(expr.Interp (@Compilers.ident_interp) res ?H3 =
 expr.Interp (@Compilers.ident_interp)
   (reified_square_gen @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify m) @
    (fun var : type -> Type => GallinaReify.base.reify m')) 
   ?H4)
============================
(0 = 0)
Finished transaction in 43.186 secs (2.576u,0.171s) (successful)
Finished transaction in 0.185 secs (0.176u,0.008s) (successful)
Unrecognized (non-unfoldable) term: H0
expr.reify_in_context: Failure in reifying:
H0
expr.reify_in_context: Failure in reifying:
(from_montgomerymod machine_wordsize 0 m m' H0)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' H0))
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' H0) *
 eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' H0))
expr.reify_in_context: Failure in reifying:
(Z.modulo
   (eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' H0) *
    eval machine_wordsize (from_montgomerymod machine_wordsize 0 m m' H0)))
Finished transaction in 1.455 secs (1.447u,0.005s) (successful)
find_witness Control.TimeoutAxioms:
ClassicalDedekindReals.sig_not_dec : forall P : Prop, {~ ~ P} + {~ P}
ClassicalDedekindReals.sig_forall_dec
  : forall P : nat -> Prop,
    (forall n : nat, {P n} + {~ P n}) ->
    {n : nat | ~ P n} + {forall n : nat, P n}
prop_ext : ClassicalFacts.prop_extensionality
lib.Axioms.proof_irr : ClassicalFacts.proof_irrelevance
Clight_core.inline_external_call_mem_events
  : forall (ef : external_function) (ge : Senv.t) 
      (vargs : list val) (m : mem) (t : Events.trace) 
      (vres : val) (m' : mem),
    ef_inline ef = true ->
    Events.external_call ef ge vargs m t vres m' ->
    {trace : list event_semantics.mem_event
    | event_semantics.ev_elim m trace m'}
Events.inline_assembly_sem : string -> signature -> Events.extcall_sem
functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Events.external_functions_sem : string -> signature -> Events.extcall_sem
Eqdep.Eq_rect_eq.eq_rect_eq
  : forall (U : Type) (p : U) (Q : U -> Type) (x : Q p) (h : p = p),
    x = eq_rect p Q x p h
Classical_Prop.classic : forall P : Prop, P \/ ~ P
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : True
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
False
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : True
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
False
Tactic call ran for 313.581 secs (308.697u,4.437s) (success)
Tactic call ran for 0.488 secs (0.486u,0.s) (success)
find_witness Control.TimeoutAssembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Finished transaction in 41.261 secs (0.427u,0.299s) (successful)
Finished transaction in 0.004 secs (0.003u,0.s) (successful)
Finished transaction in 17.623 secs (17.268u,0.31s) (successful)
Finished transaction in 0.005 secs (0.005u,0.s) (successful)
Tactic call ran for 4.586 secs (4.572u,0.006s) (success)
find_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(-
 eval
   (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 s c))
      (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 s c))) 0 H6 mod m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(-
 eval
   (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 s c))
      (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 s c))) 0 Hylty0 mod m)
((let
    (rep, get, _, _, _, _) as map
     return ((let (rep, _, _, _, _, _) := map in rep) -> key -> option value) :=
    map in
  get) map.empty Hu =
 (let
    (rep, get, _, _, _, _) as map
     return ((let (rep, _, _, _, _, _) := map in rep) -> key -> option value) :=
    map in
  get)
   (let
      (rep, _, empty, _, _, _) as map
       return (let (rep, _, _, _, _, _) := map in rep) := map in
    empty) Hu)
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 46.587 secs (6.083u,0.225s) (successful)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(- evalf H1 mod m)
Finished transaction in 0.388 secs (0.386u,0.002s) (successful)
Tactic call ran for 16.898 secs (16.622u,0.252s) (success)
Finished transaction in 3.679 secs (3.667u,0.004s) (successful)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(- evalf HP1 mod m)
find_witness Control.Timeoutfind_witness Control.TimeoutProving Rewriter_Interp...
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 41.454 secs (0.651u,0.319s) (successful)
Finished transaction in 0.009 secs (0.009u,0.s) (successful)
Finished transaction in 779.864 secs (770.852u,7.844s) (successful)
Finished transaction in 0.28 secs (0.278u,0.002s) (successful)
find_witness Control.Timeoutbad
(type.related_hetero abstraction_relation'
   (fill_in_bottom_for_arrows
      (f
         match t1 with
         | type.base _ => y
         | (_ -> _)%etype => partial.bottom abstract_domain' bottom'
         end)) (v z))
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((eval
    (weight
       (Z.log2_up (s - Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n x +
  eval
    (weight
       (Z.log2_up (s - Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n k) mod m)
find_witness Control.Timeoutbad
Tactic call ran for 22.261 secs (22.109u,0.12s) (success)
False
Finished transaction in 45.798 secs (5.227u,0.224s) (successful)
Unrecognized (non-unfoldable) term: a
expr.reify_in_context: Failure in reifying:
a
expr.reify_in_context: Failure in reifying:
(from_montgomery_res a)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res a))
expr.reify_in_context: Failure in reifying:
(- eval machine_wordsize (from_montgomery_res a))
expr.reify_in_context: Failure in reifying:
(Z.modulo (- eval machine_wordsize (from_montgomery_res a)))
Finished transaction in 0.392 secs (0.389u,0.003s) (successful)
False
Finished transaction in 3.759 secs (3.742u,0.011s) (successful)
Tactic call ran for 14.641 secs (14.453u,0.164s) (success)
Finished transaction in 42.985 secs (2.48u,0.172s) (successful)
Finished transaction in 0.206 secs (0.205u,0.001s) (successful)
False
Finished transaction in 1.979 secs (1.967u,0.011s) (successful)
bad
find_witness Control.TimeoutReifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.036 secs (0.036u,0.s) (success)
bad
Tactic call ran for 0.299 secs (0.296u,0.003s) (success)
Proving Rewriter_Interp...
find_witness Control.TimeoutTactic call ran for 0.569 secs (0.565u,0.003s) (success)
Tactic call ran for 0.129 secs (0.121u,0.008s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
find_witness Control.TimeoutAssembling verified rewriter...
Refining with verified rewriter...
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutUnrecognized (non-unfoldable) term: a
expr.reify_in_context: Failure in reifying:
a
expr.reify_in_context: Failure in reifying:
(from_montgomery_res a)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res a))
expr.reify_in_context: Failure in reifying:
(- eval machine_wordsize (from_montgomery_res a))
expr.reify_in_context: Failure in reifying:
(Z.modulo (- eval machine_wordsize (from_montgomery_res a)))
Unrecognized (non-unfoldable) term: m
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize (from_montgomery_res e) mod m)
expr.reify_in_context: Failure in reifying:
(- (eval machine_wordsize (from_montgomery_res e) mod m))
expr.reify_in_context: Failure in reifying:
(Z.modulo (- (eval machine_wordsize (from_montgomery_res e) mod m)))
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((eval
    (weight
       (Qnum
          (inject_Z
             match 1 ?= s - Associational.eval c with
             | Lt => Z.succ (Z.log2 (Z.pred (s - Associational.eval c)))
             | _ => 0
             end / inject_Z (Z.of_nat n)))
       (QDen
          (inject_Z
             match 1 ?= s - Associational.eval c with
             | Lt => Z.succ (Z.log2 (Z.pred (s - Associational.eval c)))
             | _ => 0
             end / inject_Z (Z.of_nat n)))) n HH -
  eval
    (weight
       (Qnum
          (inject_Z
             match 1 ?= s - Associational.eval c with
             | Lt => Z.succ (Z.log2 (Z.pred (s - Associational.eval c)))
             | _ => 0
             end / inject_Z (Z.of_nat n)))
       (QDen
          (inject_Z
             match 1 ?= s - Associational.eval c with
             | Lt => Z.succ (Z.log2 (Z.pred (s - Associational.eval c)))
             | _ => 0
             end / inject_Z (Z.of_nat n)))) n H) mod m)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutbad
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCompilation incomplete.
You may need to add new compilation lemmas using `Hint Extern 1 => simple eapply … : compiler` or to tell Rupicola about your custom bindings using `Hint Extern 2 (IsRupicolaBinding (xlet (A := ?A) ?vars _ _)) => exact (RupicolaBinding A vars) : typeclass_instances`.
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 74.913 secs (74.188u,0.628s) (successful)
find_witness Control.TimeoutUnrecognized (non-unfoldable) term: machine_wordsize
expr.reify_in_context: Failure in reifying:
machine_wordsize
expr.reify_in_context: Failure in reifying:
(inject_Z machine_wordsize)
expr.reify_in_context: Failure in reifying:
(inject_Z (Z.log2_up s) / inject_Z machine_wordsize)%Q
expr.reify_in_context: Failure in reifying:
(Qceiling (inject_Z (Z.log2_up s) / inject_Z machine_wordsize))
expr.reify_in_context: Failure in reifying:
(Z.to_nat (Qceiling (inject_Z (Z.log2_up s) / inject_Z machine_wordsize)))
Failed to reify n via unfolding to (Z.to_nat
                                      (Qceiling
                                         (inject_Z (Z.log2_up s) /
                                          inject_Z machine_wordsize)))
expr.reify_in_context: Failure in reifying:
n
expr.reify_in_context: Failure in reifying:
(Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(r' ^ Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize v * r' ^ Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(Z.modulo (eval machine_wordsize v * r' ^ Z.of_nat n))
Unrecognized (non-unfoldable) term: machine_wordsize
expr.reify_in_context: Failure in reifying:
machine_wordsize
expr.reify_in_context: Failure in reifying:
(inject_Z machine_wordsize)
expr.reify_in_context: Failure in reifying:
(inject_Z (Z.log2_up s) / inject_Z machine_wordsize)%Q
expr.reify_in_context: Failure in reifying:
(Qceiling (inject_Z (Z.log2_up s) / inject_Z machine_wordsize))
expr.reify_in_context: Failure in reifying:
(Z.to_nat (Qceiling (inject_Z (Z.log2_up s) / inject_Z machine_wordsize)))
Failed to reify n via unfolding to (Z.to_nat
                                      (Qceiling
                                         (inject_Z (Z.log2_up s) /
                                          inject_Z machine_wordsize)))
expr.reify_in_context: Failure in reifying:
n
expr.reify_in_context: Failure in reifying:
(Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(r' ^ Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize M * r' ^ Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(Z.modulo (eval machine_wordsize M * r' ^ Z.of_nat n))
Unrecognized (non-unfoldable) term: machine_wordsize
expr.reify_in_context: Failure in reifying:
machine_wordsize
expr.reify_in_context: Failure in reifying:
(inject_Z machine_wordsize)
expr.reify_in_context: Failure in reifying:
(inject_Z (Z.log2_up s) / inject_Z machine_wordsize)%Q
expr.reify_in_context: Failure in reifying:
(Qceiling (inject_Z (Z.log2_up s) / inject_Z machine_wordsize))
expr.reify_in_context: Failure in reifying:
(Z.to_nat (Qceiling (inject_Z (Z.log2_up s) / inject_Z machine_wordsize)))
Failed to reify n via unfolding to (Z.to_nat
                                      (Qceiling
                                         (inject_Z (Z.log2_up s) /
                                          inject_Z machine_wordsize)))
expr.reify_in_context: Failure in reifying:
n
expr.reify_in_context: Failure in reifying:
(Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(r' ^ Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize Hd1 * r' ^ Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(Z.modulo (eval machine_wordsize Hd1 * r' ^ Z.of_nat n))
Finished transaction in 0.656 secs (0.644u,0.011s) (successful)
Finished transaction in 0.149 secs (0.147u,0.001s) (successful)
Finished transaction in 53.366 secs (52.108u,1.188s) (successful)
Finished transaction in 0.007 secs (0.007u,0.s) (successful)
(match b0 with
 | Some r =>
     ZRange.is_bounded_by_bool x0 r =
     FoldBool.fold_andb_map
       (fun (r0 : option ZRange.zrange) (v'' : Z) =>
        match r0 with
        | Some r' =>
            fun v' : Z =>
            ((ZRange.lower r' <=? v')%Z && (v' <=? ZRange.upper r')%Z)%bool
        | None => fun _ : Z => true
        end v'') (b0 :: bs) (x0 :: xs)
 | None => True
 end /\ list_Z_bounded_by bs xs)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(- evalf x mod m)
Unrecognized (non-unfoldable) term: machine_wordsize
expr.reify_in_context: Failure in reifying:
machine_wordsize
expr.reify_in_context: Failure in reifying:
(inject_Z machine_wordsize)
expr.reify_in_context: Failure in reifying:
(inject_Z (Z.log2_up s) / inject_Z machine_wordsize)%Q
expr.reify_in_context: Failure in reifying:
(Qceiling (inject_Z (Z.log2_up s) / inject_Z machine_wordsize))
expr.reify_in_context: Failure in reifying:
(Z.to_nat (Qceiling (inject_Z (Z.log2_up s) / inject_Z machine_wordsize)))
Failed to reify n via unfolding to (Z.to_nat
                                      (Qceiling
                                         (inject_Z (Z.log2_up s) /
                                          inject_Z machine_wordsize)))
expr.reify_in_context: Failure in reifying:
n
expr.reify_in_context: Failure in reifying:
(Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(r' ^ Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(eval machine_wordsize a * r' ^ Z.of_nat n)
expr.reify_in_context: Failure in reifying:
(Z.modulo (eval machine_wordsize a * r' ^ Z.of_nat n))
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H0 : True
x : Z
y : Z
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some montgomery_domain_bounds) H1 &&
 true = true ->
 ZRange.type.base.option.is_bounded_by (Some non_montgomery_domain_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp)
   (reified_from_montgomery_gen @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify m) @
    (fun var : type -> Type => GallinaReify.base.reify m')) H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some non_montgomery_domain_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp)
   (reified_from_montgomery_gen @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify m) @
    (fun var : type -> Type => GallinaReify.base.reify m')) 
   ?H2)
============================
(x + y = y + x)
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
abs : Z
H0 : True
y : Z
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some montgomery_domain_bounds) H1 &&
 true = true ->
 ZRange.type.base.option.is_bounded_by (Some non_montgomery_domain_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp)
   (reified_from_montgomery_gen @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify m) @
    (fun var : type -> Type => GallinaReify.base.reify m')) H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some non_montgomery_domain_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp)
   (reified_from_montgomery_gen @
    (fun var : type -> Type => GallinaReify.base.reify machine_wordsize) @
    (fun var : type -> Type => GallinaReify.base.reify n) @
    (fun var : type -> Type => GallinaReify.base.reify m) @
    (fun var : type -> Type => GallinaReify.base.reify m')) 
   ?H2)
============================
(abs + y = y + abs)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(-
 eval
   (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth (0 + n) s c))
      (QDen (UnsaturatedSolinasHeuristics.limbwidth (0 + n) s c))) 
   (0 + n) x mod m)
find_witness Control.Timeoutfind_witness Control.Timeoutwidth : Z
n : nat
s : Z
c : (list (Z * Z))
Finished transaction in 74.254 secs (32.516u,1.083s) (successful)
Finished transaction in 0.015 secs (0.015u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutwidth : Z
n : nat
s : Z
c : (list (Z * Z))
find_witness Control.TimeoutFinished transaction in 26.932 secs (26.823u,0.079s) (successful)
Finished transaction in 0.089 secs (0.088u,0.s) (successful)
Finished transaction in 0.124 secs (0.121u,0.002s) (successful)
Finished transaction in 0.092 secs (0.092u,0.s) (successful)
find_witness Control.TimeoutFinished transaction in 42.586 secs (2.024u,0.233s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.TimeoutFinished transaction in 1.503 secs (1.494u,0.005s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.TimeoutFinished transaction in 1.501 secs (1.49u,0.009s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(- evalf x mod m)
Finished transaction in 2.961 secs (2.934u,0.021s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.Timeout(FoldBool.fold_andb_map
   (fun (r : option ZRange.zrange) (v'' : Z) =>
    match r with
    | Some r' =>
        fun v' : Z => (ZRange.lower r' <=? v') && (v' <=? ZRange.upper r')
    | None => fun _ : Z => true
    end v'') (max_bounds n0) (map word.unsigned x) = true)
find_witness Control.TimeoutFinished transaction in 4.229 secs (4.198u,0.025s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Unrecognized (non-unfoldable) term: Ha'
expr.reify_in_context: Failure in reifying:
Ha'
Finished transaction in 4.175 secs (4.134u,0.034s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 68.442 secs (68.157u,0.217s) (successful)
(FoldBool.fold_andb_map
   (fun (r : option ZRange.zrange) (v'' : Z) =>
    match r with
    | Some r' =>
        fun v' : Z => (ZRange.lower r' <=? v') && (v' <=? ZRange.upper r')
    | None => fun _ : Z => true
    end v'') (max_bounds n0) (map word.unsigned x) = true)
Finished transaction in 4.249 secs (4.199u,0.04s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.TimeoutFinished transaction in 5.583 secs (5.505u,0.068s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.Timeout(forall m : mem_state,
 (R_cell64 d a i ⋆ fr)%sep m ->
 exists bs : list Init.Byte.byte,
   load_bytes m (word.of_Z va) 8 = Some bs /\ eval d i (le_combine bs))
(1 <= 0)
Finished transaction in 5.656 secs (5.534u,0.112s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 2.917 secs (2.913u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 186.962 secs (143.83u,2.398s) (successful)
Finished transaction in 0.009 secs (0.009u,0.s) (successful)
find_witness Control.TimeoutUnrecognized (non-unfoldable) term: Ha'
expr.reify_in_context: Failure in reifying:
Ha'
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 44.831 secs (3.894u,0.372s) (successful)
Finished transaction in 0.007 secs (0.005u,0.001s) (successful)
(1 <= 0)
(expr.wf H e1 l1 ->
 (forall (t : type) (v1 : value_with_lets1 t) (v2 : value_with_lets2 t),
  In
    (existT
       (fun t0 : type => (value_with_lets1 t0 * value_with_lets2 t0)%type) t
       (v1, v2)) H ->
  UnderLets.wf
    (fun G' : list {t0 : type & (var1 t0 * var2 t0)%type} => wf_value G') G'
    v1 v2) ->
 UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => wf_value G') G'
   (interp1 annotate_with_state e1) (interp2 annotate_with_state l1))
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(eval (weight 8 1) n_bytes x mod m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(eval (weight 8 1) n_bytes x mod m)
(expr.wf H e1 l1 ->
 (forall (t : type) (v1 : value_with_lets1 t) (v2 : value_with_lets2 t),
  In
    (existT
       (fun t0 : type => (value_with_lets1 t0 * value_with_lets2 t0)%type) t
       (v1, v2)) H ->
  UnderLets.wf
    (fun G' : list {t0 : type & (var1 t0 * var2 t0)%type} => wf_value G') G'
    v1 v2) ->
 UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => wf_value G') G'
   (interp1 annotate_with_state e1) (interp2 annotate_with_state l1))
find_witness Control.TimeoutBuilding all_base...
Building all_idents...
Building ident_index...
find_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(eval (weight 8 1) n_bytes x mod m)
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
find_witness Control.TimeoutBuilding all_raw_idents...
output_options : output_options_opt
opts : AbstractInterpretation.Options
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.type_base Compilers.Z)))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
find_witness Control.TimeoutBuilding invert_bind_args_unknown...
Building all_pattern_idents...
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(eval (weight 8 1) n_bytes x mod m)
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(eval (weight 8 1) n_bytes RS' mod m)
Building to_type_split_types_subst_default_eq...
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(eval (weight 8 1) n_bytes pf0 mod m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(eval (weight 8 1) n_bytes pf0 mod m)
Building projT1_add_types_from_raw_sig_eq...
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(eval (weight 8 1) n_bytes pf0 mod m)
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding unify...
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutBuilding unify_unknown...
Building final ident package...
Finished transaction in 73.198 secs (32.254u,0.622s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeout(symex_expr (invert_expr.smart_App_curried e tt) EQ = symex_expr e EQ)
Finished transaction in 46.241 secs (5.295u,0.352s) (successful)
Finished transaction in 0.005 secs (0.005u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(Forall2
   (fun (idx0 : option idx) (v : Z) =>
    forall idx' : idx, idx0 = Some idx' -> eval_idx_Z G s idx' v)
   (List.map (get_reg s) (List.map reg_index regs))
   (List.map (Semantics.get_reg m) regs))
(Forall2
   (fun (idx0 : option idx) (v : Z) =>
    forall idx' : idx, idx0 = Some idx' -> eval_idx_Z G s idx' v)
   (List.map (get_reg s) (List.map reg_index regs))
   (List.map (Semantics.get_reg m) regs))
find_witness Control.TimeoutChars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 83 - 125 [Require~Import~Category.Core~F...] 0.026 secs (0.018u,0.007s)
Chars 126 - 173 [Require~Import~Category.Prod~F...] 1.83 secs (1.646u,0.179s)
Chars 174 - 216 [Require~Import~Category.Dual~F...] 0.053 secs (0.049u,0.003s)
Chars 217 - 274 [Require~Import~Functor.Composi...] 0. secs (0.u,0.s)
Chars 275 - 364 [Require~Import~InitialTerminal...] 0.021 secs (0.017u,0.004s)
Chars 365 - 401 [Require~Import~FunctorCategory...] 0.036 secs (0.034u,0.001s)
Chars 402 - 426 [Require~Import~Cat.Core.] 0.004 secs (0.004u,0.s)
Chars 427 - 456 [Require~Import~Functor.Paths.] 0. secs (0.u,0.s)
Chars 457 - 476 [Require~Comma.Core.] 0.036 secs (0.036u,0.s)
Chars 477 - 526 [#[local]Set~Warnings~Append~"-...] 0. secs (0.u,0.s)
Chars 679 - 697 [Import~Comma.Core.] 0. secs (0.u,0.s)
Chars 698 - 746 [#[local]Set~Warnings~Append~"n...] 0. secs (0.u,0.s)
Chars 747 - 801 [Require~Import~Comma.InducedFu...] 0.014 secs (0.013u,0.s)
Chars 802 - 882 [Require~ProductLaws~Exponentia...] 0.06 secs (0.059u,0.s)
Chars 883 - 949 [Require~Import~Types.Prod~Type...] 0.004 secs (0.002u,0.002s)
Chars 951 - 977 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 978 - 1001 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 1002 - 1030 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 1031 - 1055 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 1057 - 1089 [#[local]Open~Scope~category_sc...] 0. secs (0.u,0.s)
Chars 1271 - 1285 [Section~comma.] 0. secs (0.u,0.s)
Chars 1288 - 1316 [#[local]Open~Scope~type_scope.] 0. secs (0.u,0.s)
Chars 1319 - 1337 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 1341 - 1374 [Variable~(P~:~PreCategory~->~T...] 0. secs (0.u,0.s)
Chars 1377 - 1440 [Context~`{HF~:~forall~C~D,~P~C...] 0. secs (0.u,0.s)
Chars 1444 - 1488 [#[local]Notation~Cat~:=~(@sub_...] 0. secs (0.u,0.s)
Chars 1492 - 1522 [Variables~(A~B~C~:~PreCategory).] 0. secs (0.u,0.s)
Chars 1526 - 1553 [Hypothesis~(PAB~:~P~(A~*~B)).] 0. secs (0.u,0.s)
Chars 1556 - 1656 [Hypothesis~(P_comma~:~forall~(...] 0.001 secs (0.001u,0.s)
Chars 1660 - 1692 [#[local]Open~Scope~category_sc...] 0. secs (0.u,0.s)
Chars 1695 - 1727 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 1731 - 1870 [Definition~comma_category_proj...] 0.025 secs (0.022u,0.003s)
Chars 1873 - 1879 [Proof.] 0. secs (0.u,0.s)
Chars 1884 - 1953 [exists~(Datatypes.fst~ST~/~Dat...] 16.582 secs (0.014u,0.022s)
Chars 1958 - 2030 [exact~(comma_category_projecti...] 0.003 secs (0.001u,0.001s)
Chars 1884 - 1953 [exists~(Datatypes.fst~ST~/~Dat...] 0.001 secs (0.u,0.s)
Chars 1958 - 2030 [exact~(comma_category_projecti...] 0.001 secs (0.001u,0.s)
Chars 2033 - 2041 [Defined.] 0.002 secs (0.001u,0.s)
Chars 2045 - 2328 [Definition~comma_category_proj...] 0.009 secs (0.008u,0.s)
Chars 2331 - 2337 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 43 - 71 [Require~Import~Basics~Types.] 1.747 secs (1.556u,0.175s)
Chars 72 - 98 [Require~Import~HProp~HSet.] 0.047 secs (0.046u,0.s)
Chars 99 - 136 [Require~Import~Spaces.Pos~Spac...] 0.398 secs (0.391u,0.006s)
Chars 137 - 166 [Require~Import~Colimits.Coeq.] 0.672 secs (0.607u,0.064s)
Chars 167 - 214 [Require~Import~Modalities.Moda...] 6.935 secs (6.655u,0.273s)
Chars 215 - 244 [Require~Import~Cubical.DPath.] 0. secs (0.u,0.s)
Chars 285 - 313 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 315 - 351 [Generalizable~Variables~X~A~B~...] 0. secs (0.u,0.s)
Chars 824 - 873 [Definition~Circle~:=~@Coeq~Uni...] 0. secs (0.u,0.s)
Chars 902 - 938 [Definition~base~:~Circle~:=~co...] 0. secs (0.u,0.s)
Chars 971 - 1013 [Definition~loop~:~base~=~base~...] 0. secs (0.u,0.s)
Chars 1078 - 1100 [Module~CircleNotation.] 0. secs (0.u,0.s)
Chars 1103 - 1140 [Notation~S1~:=~Circle~(only~pa...] 0. secs (0.u,0.s)
Chars 1141 - 1160 [End~CircleNotation.] 0. secs (0.u,0.s)
Chars 1186 - 1292 [Definition~Circle_ind~(P~:~Cir...] 0. secs (0.u,0.s)
Chars 1293 - 1299 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.339 secs (0.255u,0.082s)
Chars 23 - 44 [Require~Import~Types.] 1.422 secs (1.31u,0.108s)
Chars 45 - 77 [Require~Import~Colimits.Pushout.] 2.719 secs (2.592u,0.12s)
Chars 78 - 114 [Require~Import~Colimits.SpanPu...] 0.008 secs (0.008u,0.s)
Chars 115 - 147 [Require~Import~HoTT.Truncations.] 4.87 secs (4.614u,0.243s)
Chars 148 - 177 [Require~Import~Homotopy.Join.] 0.141 secs (0.141u,0.s)
Chars 178 - 213 [Require~Import~Homotopy.Suspen...] 0. secs (0.u,0.s)
Chars 214 - 252 [Require~Import~Homotopy.Blaker...] 0.761 secs (0.747u,0.012s)
Chars 541 - 680 [#[global]~Instance~freudenthal...] 0.001 secs (0.001u,0.s)
Chars 681 - 687 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 2342 - 2346 [(hnf).] 40.124 secs (0.001u,0.024s)
Chars 2351 - 2603 [refine~~(CommaCategory.Build_m...] 0.009 secs (0.008u,0.s)
Chars 2608 - 2614 [(simpl).] 0.003 secs (0.003u,0.s)
Chars 2619 - 2652 [(destruct_head_hnf~Datatypes.p...] 0.017 secs (0.014u,0.003s)
Chars 2657 - 2670 [path_functor.] 0.012 secs (0.01u,0.001s)
Chars 2342 - 2346 [(hnf).] 0.001 secs (0.001u,0.s)
Chars 2351 - 2603 [refine~~(CommaCategory.Build_m...] 0.001 secs (0.001u,0.s)
Chars 2608 - 2614 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 2619 - 2652 [(destruct_head_hnf~Datatypes.p...] 0.001 secs (0.001u,0.s)
Chars 2657 - 2670 [path_functor.] 0.001 secs (0.001u,0.s)
Chars 2673 - 2681 [Defined.] 0.021 secs (0.019u,0.001s)
Chars 2685 - 3837 [#[local]~Ltac~~comma_laws_t~:=...] 0.001 secs (0.001u,0.s)
Chars 3841 - 3980 [Lemma~comma_category_projectio...] 0.003 secs (0.002u,0.s)
Chars 3983 - 3989 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 35 [Require~Import~HoTT.Types.Univ...] 0.988 secs (0.805u,0.18s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 44 - 88 [Require~Import~HoTT.Basics~HoT...] 1.733 secs (1.534u,0.195s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 28 [Require~Import~Basics~Types.] 1.751 secs (1.565u,0.181s)
Chars 89 - 127 [Require~Import~Constant~Factor...] 7.452 secs (7.067u,0.372s)
Chars 128 - 180 [Require~Import~Modalities.Moda...] 0.006 secs (0.006u,0.s)
Chars 36 - 128 [Require~Import~HoTT.Classes.or...] 10.84 secs (10.374u,0.436s)
Chars 129 - 330 [Require~Import~HoTT.Classes.in...] 0.037 secs (0.037u,0.s)
Chars 333 - 359 [Generalizable~Variable~N.] 0. secs (0.u,0.s)
Chars 361 - 378 [Section~contents.] 0. secs (0.u,0.s)
Chars 379 - 411 [Context~`{Funext}~`{Univalence}.] 0. secs (0.u,0.s)
Chars 412 - 434 [Context~`{Naturals~N}.] 0.001 secs (0.001u,0.s)
Chars 603 - 717 [Lemma~nat_distance_unique~{a~b...] 0.001 secs (0.001u,0.s)
Chars 718 - 724 [Proof.] 0. secs (0.u,0.s)
Chars 29 - 65 [Require~Import~Algebra.Groups....] 8.44 secs (8.052u,0.365s)
Chars 181 - 244 [Require~Import~ObjectClassifie...] 3.839 secs (3.748u,0.081s)
Chars 246 - 274 [#[local]Open~Scope~type_scope.] 0. secs (0.u,0.s)
Chars 275 - 303 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 454 - 522 [Definition~BAut~(X~:~Type@{u})...] 0. secs (0.u,0.s)
Chars 524 - 568 [Coercion~BAut_pr1~X~:~BAut~X~-...] 0. secs (0.u,0.s)
Chars 570 - 646 [#[global]~Instance~ispointed_b...] 0.001 secs (0.001u,0.s)
Chars 768 - 832 [Definition~pBAut~(X~:~Type)~:~...] 0. secs (0.u,0.s)
Chars 834 - 984 [Definition~path_baut~`{Univale...] 0.006 secs (0.006u,0.s)
Chars 66 - 106 [Require~Import~Algebra.Groups....] 0.248 secs (0.241u,0.005s)
Chars 986 - 1129 [Definition~ap_pr1_path_baut~`{...] 0.011 secs (0.011u,0.s)
Chars 1130 - 1136 [Proof.] 0. secs (0.u,0.s)
Chars 107 - 147 [Require~Import~Algebra.Groups....] 1.787 secs (1.732u,0.048s)
Chars 148 - 177 [Require~Import~Spaces.Finite.] 1.402 secs (1.368u,0.029s)
Chars 178 - 201 [Require~Import~WildCat.] 0.012 secs (0.011u,0.s)
Chars 204 - 230 [#[local]Open~Scope~mc_scope.] 0. secs (0.u,0.s)
Chars 231 - 262 [#[local]Open~Scope~mc_mult_scope.] 0. secs (0.u,0.s)
Chars 361 - 667 [Record~GroupPresentation~:={~~...] 0.003 secs (0.002u,0.s)
Chars 924 - 973 [Definition~group_gp~:~GroupPre...] 0. secs (0.u,0.s)
Chars 974 - 980 [Proof.] 0. secs (0.u,0.s)
Chars 1302 - 1376 [refine~(Coeq_ind~P~(fun~u~=>~t...] 40.169 secs (0.003u,0.031s)
Chars 1379 - 1398 [(intros~[];~exact~l).] 0.004 secs (0.004u,0.s)
Chars 1302 - 1376 [refine~(Coeq_ind~P~(fun~u~=>~t...] 0. secs (0.u,0.s)
Chars 1379 - 1398 [(intros~[];~exact~l).] 0.001 secs (0.u,0.s)
Chars 1399 - 1407 [Defined.] 0.002 secs (0.002u,0.s)
Chars 1455 - 1612 [Definition~Circle_ind_beta_loo...] 0.008 secs (0.008u,0.s)
Chars 1751 - 1782 [Arguments~Circle~:~simpl~never.] 0. secs (0.u,0.s)
Chars 1783 - 1812 [Arguments~base~:~simpl~never.] 0. secs (0.u,0.s)
Chars 1813 - 1842 [Arguments~loop~:~simpl~never.] 0. secs (0.u,0.s)
Chars 1843 - 1888 [Arguments~Circle_ind_beta_loop...] 0. secs (0.u,0.s)
Chars 1949 - 2075 [Definition~Circle_rec~(P~:~Typ...] 0.001 secs (0.001u,0.s)
Chars 2131 - 2229 [Definition~Circle_rec_beta_loo...] 0. secs (0.u,0.s)
Chars 2230 - 2236 [Proof.] 0. secs (0.u,0.s)
Chars 983 - 998 [(intros~[X~I~R]).] 4.676 secs (0.002u,0.029s)
Chars 1001 - 1130 [exact~~(GroupCoeq~(FreeGroup_r...] 0.003 secs (0.003u,0.s)
Chars 983 - 998 [(intros~[X~I~R]).] 0. secs (0.u,0.s)
Chars 1001 - 1130 [exact~~(GroupCoeq~(FreeGroup_r...] 0. secs (0.u,0.s)
Chars 1131 - 1139 [Defined.] 0. secs (0.u,0.s)
Chars 1260 - 1406 [Class~HasPresentation~(G~:~Gro...] 0.004 secs (0.004u,0.s)
Chars 1408 - 1470 [Coercion~presentation~:~HasPre...] 0. secs (0.u,0.s)
Chars 1624 - 1737 [Class~FinitelyGeneratedPresent...] 0.001 secs (0.u,0.s)
Chars 1827 - 1935 [Class~FinitelyRelatedPresentat...] 0.001 secs (0.001u,0.s)
Chars 2031 - 2185 [Class~FinitePresentation~(P~:~...] 0.004 secs (0.004u,0.s)
Chars 2329 - 2483 [Class~IsFinitelyGenerated~(G~:...] 0.005 secs (0.003u,0.001s)
Chars 2563 - 2713 [Class~IsFinitelyRelated~(G~:~G...] 0.005 secs (0.005u,0.s)
Chars 2715 - 2858 [Class~IsFinitelyPresented~(G~:...] 0.005 secs (0.004u,0.s)
Chars 3091 - 3308 [Theorem~grp_pres_rec~{funext~:...] 0.002 secs (0.002u,0.s)
Chars 3309 - 3315 [Proof.] 0. secs (0.u,0.s)
Chars 690 - 744 [(pose~(blakers_massey~n~n~(fun...] 40.219 secs (0.039u,0.039s)
Chars 747 - 1011 [(pose~~~(f~:=~~~~equiv_pushout...] 0.017 secs (0.014u,0.002s)
Chars 1014 - 1216 [srefine~~(@cancelR_equiv_conn_...] 0.081 secs (0.071u,0.009s)
Chars 1219 - 1228 [(intros~x).] 0.003 secs (0.003u,0.s)
Chars 1231 - 1452 [refine~~(_~@~~~(equiv_pushout_...] 0.036 secs (0.032u,0.003s)
Chars 1455 - 1492 [exact~(concat_p1~_~@~concat_1p...] 0.041 secs (0.03u,0.01s)
Chars 690 - 744 [(pose~(blakers_massey~n~n~(fun...] 0. secs (0.u,0.s)
Chars 747 - 1011 [(pose~~~(f~:=~~~~equiv_pushout...] 0. secs (0.u,0.s)
Chars 1014 - 1216 [srefine~~(@cancelR_equiv_conn_...] 0.002 secs (0.002u,0.s)
Chars 1219 - 1228 [(intros~x).] 0.002 secs (0.002u,0.s)
Chars 1231 - 1452 [refine~~(_~@~~~(equiv_pushout_...] 0.002 secs (0.002u,0.s)
Chars 1455 - 1492 [exact~(concat_p1~_~@~concat_1p...] 0.008 secs (0.006u,0.001s)
Chars 1493 - 1501 [Defined.] 0.197 secs (0.183u,0.013s)
Chars 2239 - 2257 [(unfold~Circle_rec).] 18.681 secs (8.539u,0.122s)
Chars 3994 - 4054 [(apply~CommaCategory.path_morp...] 40.133 secs (0.008u,0.025s)
Chars 4059 - 4072 [path_functor.] 0.009 secs (0.009u,0.s)
Chars 4077 - 4156 [exists~~~~(path_forall~_~_~(co...] 0.008 secs (0.007u,0.s)
Chars 4161 - 4174 [comma_laws_t.] 0.324 secs (0.253u,0.07s)
Chars 3994 - 4054 [(apply~CommaCategory.path_morp...] 0.005 secs (0.003u,0.002s)
Chars 4059 - 4072 [path_functor.] 0.001 secs (0.001u,0.s)
Chars 4077 - 4156 [exists~~~~(path_forall~_~_~(co...] 0.002 secs (0.002u,0.s)
Chars 4161 - 4174 [comma_laws_t.] 0.002 secs (0.002u,0.s)
Chars 4177 - 4181 [Qed.] 0.575 secs (0.54u,0.034s)
Chars 4185 - 4464 [Lemma~comma_category_projectio...] 0.005 secs (0.005u,0.s)
Chars 4467 - 4473 [Proof.] 0. secs (0.u,0.s)
Chars 725 - 732 [(intros).] 40.177 secs (0.u,0.036s)
Chars 733 - 753 [(unfold~nat_distance).] 0. secs (0.u,0.s)
Chars 754 - 872 [(destruct~(@nat_distance_sig~_...] 0.016 secs (0.015u,0.s)
Chars 873 - 874 [-] 0. secs (0.u,0.s)
Chars 875 - 908 [(apply~(left_cancellation~plus...] 0.008 secs (0.008u,0.s)
Chars 909 - 920 [(path_via~y).] 0.003 secs (0.003u,0.s)
Chars 921 - 922 [-] 0. secs (0.u,0.s)
Chars 923 - 982 [(rewrite~<-~(rings.plus_0_r~y)...] 0.011 secs (0.01u,0.s)
Chars 985 - 1024 [(apply~(left_cancellation~plus...] 0.008 secs (0.008u,0.s)
Chars 1025 - 1055 [(apply~naturals.zero_sum~in~E1).] 0.003 secs (0.001u,0.001s)
Chars 1058 - 1081 [(destruct~E1;~path_via~0).] 0.004 secs (0.003u,0.s)
Chars 1082 - 1083 [-] 0. secs (0.u,0.s)
Chars 1084 - 1143 [(rewrite~<-~(rings.plus_0_r~x)...] 0.011 secs (0.009u,0.001s)
Chars 1146 - 1185 [(apply~(left_cancellation~plus...] 0.008 secs (0.008u,0.s)
Chars 1186 - 1216 [(apply~naturals.zero_sum~in~E1).] 0.003 secs (0.003u,0.s)
Chars 1219 - 1242 [(destruct~E1;~path_via~0).] 0.005 secs (0.005u,0.s)
Chars 1243 - 1244 [-] 0. secs (0.u,0.s)
Chars 1245 - 1289 [(apply~(left_cancellation~plus...] 0.047 secs (0.034u,0.012s)
Chars 725 - 732 [(intros).] 0. secs (0.u,0.s)
Chars 733 - 753 [(unfold~nat_distance).] 0. secs (0.u,0.s)
Chars 754 - 872 [(destruct~(@nat_distance_sig~_...] 0.002 secs (0.002u,0.s)
Chars 875 - 908 [(apply~(left_cancellation~plus...] 0. secs (0.u,0.s)
Chars 909 - 920 [(path_via~y).] 0. secs (0.u,0.s)
Chars 923 - 982 [(rewrite~<-~(rings.plus_0_r~y)...] 0. secs (0.u,0.s)
Chars 985 - 1024 [(apply~(left_cancellation~plus...] 0. secs (0.u,0.s)
Chars 1025 - 1055 [(apply~naturals.zero_sum~in~E1).] 0. secs (0.u,0.s)
Chars 1058 - 1081 [(destruct~E1;~path_via~0).] 0.001 secs (0.001u,0.s)
Chars 1084 - 1143 [(rewrite~<-~(rings.plus_0_r~x)...] 0. secs (0.u,0.s)
Chars 1146 - 1185 [(apply~(left_cancellation~plus...] 0. secs (0.u,0.s)
Chars 1186 - 1216 [(apply~naturals.zero_sum~in~E1).] 0. secs (0.u,0.s)
Chars 1219 - 1242 [(destruct~E1;~path_via~0).] 0.001 secs (0.001u,0.s)
Chars 1245 - 1289 [(apply~(left_cancellation~plus...] 0.001 secs (0.u,0.s)
Chars 1290 - 1294 [Qed.] 0.006 secs (0.005u,0.s)
Chars 1296 - 1309 [End~contents.] 0.016 secs (0.014u,0.001s)
Chars 1401 - 1553 [#[global]~Instance~natdistance...] 0.005 secs (0.005u,0.s)
Chars 1554 - 1560 [Proof.] 0. secs (0.u,0.s)
Chars 1139 - 1173 [(unfold~path_baut,~BAut_pr1;~s...] 40.166 secs (0.003u,0.034s)
Chars 1176 - 1206 [(apply~ap_pr1_path_sigma_hprop).] 0.002 secs (0.001u,0.s)
Chars 1139 - 1173 [(unfold~path_baut,~BAut_pr1;~s...] 0.001 secs (0.001u,0.s)
Chars 1176 - 1206 [(apply~ap_pr1_path_sigma_hprop).] 0. secs (0.u,0.s)
Chars 1207 - 1215 [Defined.] 0.002 secs (0.002u,0.s)
Chars 1217 - 1377 [Definition~transport_path_baut...] 0.002 secs (0.001u,0.s)
Chars 1378 - 1384 [Proof.] 0. secs (0.u,0.s)
Chars 2239 - 2257 [(unfold~Circle_rec).] 40.064 secs (0.u,0.032s)
Chars 2260 - 2308 [refine~(cancelL~(transport_con...] 0.002 secs (0.001u,0.s)
Chars 2311 - 2372 [refine~((apD_const~(Circle_ind...] 0.004 secs (0.003u,0.001s)
Chars 2375 - 2422 [refine~(Circle_ind_beta_loop~(...] 0.002 secs (0.001u,0.s)
Chars 2239 - 2257 [(unfold~Circle_rec).] 0. secs (0.u,0.s)
Chars 2260 - 2308 [refine~(cancelL~(transport_con...] 0. secs (0.u,0.s)
Chars 2311 - 2372 [refine~((apD_const~(Circle_ind...] 0. secs (0.u,0.s)
Chars 2375 - 2422 [refine~(Circle_ind_beta_loop~(...] 0. secs (0.u,0.s)
Chars 2423 - 2431 [Defined.] 0.007 secs (0.006u,0.s)
Chars 2475 - 2535 [#[global]Instance~ispointed_Ci...] 0. secs (0.u,0.s)
Chars 2691 - 2712 [Section~EncodeDecode.] 0. secs (0.u,0.s)
Chars 2770 - 2792 [Context~`{Univalence}.] 0. secs (0.u,0.s)
Chars 3214 - 3306 [Definition~Circle_code~:~Circl...] 0.002 secs (0.001u,0.s)
Chars 3391 - 3487 [Definition~transport_Circle_co...] 0. secs (0.u,0.s)
Chars 3490 - 3496 [Proof.] 0. secs (0.u,0.s)
Chars 3318 - 3385 [refine~((equiv_precompose_cat_...] 40.182 secs (0.009u,0.031s)
Chars 3388 - 3426 [refine~(equiv_groupcoeq_rec~_~...] 0.002 secs (0.002u,0.s)
Chars 3429 - 3472 [srefine~(equiv_functor_sigma_p...] 0.002 secs (0.002u,0.s)
Chars 3475 - 3504 [2:~(apply~equiv_freegroup_rec).] 0.001 secs (0.u,0.s)
Chars 3507 - 3536 [(apply~equiv_functor_sigma_id).] 0.002 secs (0.002u,0.s)
Chars 3539 - 3548 [(intros~f).] 0.001 secs (0.001u,0.s)
Chars 3551 - 3575 [srapply~equiv_iff_hprop.] 0.246 secs (0.206u,0.038s)
Chars 3578 - 3579 [{] 0. secs (0.u,0.s)
Chars 3580 - 3589 [(intros~p).] 0.001 secs (0.001u,0.s)
Chars 3594 - 3598 [(hnf).] 0.001 secs (0.001u,0.s)
Chars 3603 - 3620 [rapply~Trunc_ind.] 0.108 secs (0.095u,0.012s)
Chars 3625 - 3647 [srapply~Coeq.Coeq_ind.] 0.005 secs (0.005u,0.s)
Chars 3652 - 3682 [2:~(intros;~apply~path_ishprop).] 0.066 secs (0.053u,0.012s)
Chars 3687 - 3701 [(intros~w;~hnf).] 0.003 secs (0.003u,0.s)
Chars 3706 - 3718 [(induction~w).] 0.005 secs (0.005u,0.s)
Chars 3723 - 3738 [1:~reflexivity.] 0.008 secs (0.007u,0.001s)
Chars 3743 - 3749 [(simpl).] 0.067 secs (0.066u,0.s)
Chars 3754 - 3774 [refine~((_~@~_)~@~_^).] 0.004 secs (0.004u,0.s)
Chars 3779 - 3830 [1,~3:~exact~(grp_homo_op~(Free...] 0.088 secs (0.085u,0.002s)
Chars 3835 - 3840 [f_ap.] 0.079 secs (0.078u,0.001s)
Chars 3845 - 3856 [(destruct~a).] 0.003 secs (0.003u,0.s)
Chars 3861 - 3898 [1:~refine~(p~_~@~(grp_homo_uni...] 0.003 secs (0.003u,0.s)
Chars 3903 - 3960 [refine~((grp_homo_inv~_~_~@~ap...] 0.011 secs (0.011u,0.s)
Chars 3965 - 3999 [refine~(p~_~@~(grp_homo_unit~_...] 0.003 secs (0.003u,0.s)
Chars 4000 - 4001 [}] 0. secs (0.u,0.s)
Chars 4004 - 4015 [(intros~p~r).] 0.001 secs (0.001u,0.s)
Chars 4018 - 4027 [(hnf~in~p).] 0. secs (0.u,0.s)
Chars 4030 - 4061 [(pose~(p'~:=~p~o~freegroup_eta)).] 0.003 secs (0.003u,0.s)
Chars 4064 - 4086 [(clearbody~p';~clear~p).] 0.002 secs (0.002u,0.s)
Chars 4089 - 4137 [specialize~(p'~(FreeGroup.word...] 0.002 secs (0.002u,0.s)
Chars 4140 - 4156 [refine~(_~@~p').] 0.006 secs (0.006u,0.s)
Chars 4159 - 4168 [clear~p'.] 0.001 secs (0.001u,0.s)
Chars 4171 - 4180 [symmetry.] 0.002 secs (0.002u,0.s)
Chars 4183 - 4214 [refine~(grp_homo_op~_~_~_~@~_).] 0.015 secs (0.015u,0.s)
Chars 4217 - 4247 [refine~(_~@~right_identity~_).] 0.009 secs (0.009u,0.s)
Chars 4250 - 4255 [f_ap.] 0.008 secs (0.008u,0.s)
Chars 3318 - 3385 [refine~((equiv_precompose_cat_...] 0. secs (0.u,0.s)
Chars 3388 - 3426 [refine~(equiv_groupcoeq_rec~_~...] 0. secs (0.u,0.s)
Chars 3429 - 3472 [srefine~(equiv_functor_sigma_p...] 0. secs (0.u,0.s)
Chars 3475 - 3504 [2:~(apply~equiv_freegroup_rec).] 0. secs (0.u,0.s)
Chars 3507 - 3536 [(apply~equiv_functor_sigma_id).] 0. secs (0.u,0.s)
Chars 3539 - 3548 [(intros~f).] 0. secs (0.u,0.s)
Chars 3551 - 3575 [srapply~equiv_iff_hprop.] 0. secs (0.u,0.s)
Chars 3580 - 3589 [(intros~p).] 0. secs (0.u,0.s)
Chars 3594 - 3598 [(hnf).] 0. secs (0.u,0.s)
Chars 3603 - 3620 [rapply~Trunc_ind.] 0.006 secs (0.005u,0.s)
Chars 3625 - 3647 [srapply~Coeq.Coeq_ind.] 0. secs (0.u,0.s)
Chars 3652 - 3682 [2:~(intros;~apply~path_ishprop).] 0.003 secs (0.003u,0.s)
Chars 3687 - 3701 [(intros~w;~hnf).] 0.002 secs (0.002u,0.s)
Chars 3706 - 3718 [(induction~w).] 0. secs (0.u,0.s)
Chars 3723 - 3738 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 3743 - 3749 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 3754 - 3774 [refine~((_~@~_)~@~_^).] 0.002 secs (0.002u,0.s)
Chars 3779 - 3830 [1,~3:~exact~(grp_homo_op~(Free...] 0.003 secs (0.003u,0.s)
Chars 3835 - 3840 [f_ap.] 0.001 secs (0.001u,0.s)
Chars 3845 - 3856 [(destruct~a).] 0.001 secs (0.001u,0.s)
Chars 3861 - 3898 [1:~refine~(p~_~@~(grp_homo_uni...] 0.001 secs (0.001u,0.s)
Chars 3903 - 3960 [refine~((grp_homo_inv~_~_~@~ap...] 0.001 secs (0.001u,0.s)
Chars 3965 - 3999 [refine~(p~_~@~(grp_homo_unit~_...] 0.001 secs (0.001u,0.s)
Chars 4004 - 4015 [(intros~p~r).] 0. secs (0.u,0.s)
Chars 4018 - 4027 [(hnf~in~p).] 0. secs (0.u,0.s)
Chars 4030 - 4061 [(pose~(p'~:=~p~o~freegroup_eta)).] 0. secs (0.u,0.s)
Chars 4064 - 4086 [(clearbody~p';~clear~p).] 0.001 secs (0.001u,0.s)
Chars 4089 - 4137 [specialize~(p'~(FreeGroup.word...] 0. secs (0.u,0.s)
Chars 4140 - 4156 [refine~(_~@~p').] 0. secs (0.u,0.s)
Chars 4159 - 4168 [clear~p'.] 0. secs (0.u,0.s)
Chars 4171 - 4180 [symmetry.] 0. secs (0.u,0.s)
Chars 4183 - 4214 [refine~(grp_homo_op~_~_~_~@~_).] 0. secs (0.u,0.s)
Chars 4217 - 4247 [refine~(_~@~right_identity~_).] 0. secs (0.u,0.s)
Chars 4250 - 4255 [f_ap.] 0. secs (0.u,0.s)
Chars 4256 - 4264 [Defined.] 0.298 secs (0.288u,0.009s)
Chars 4315 - 4420 [Definition~Build_Finite_GroupP...] 0. secs (0.u,0.s)
Chars 4421 - 4427 [Proof.] 0. secs (0.u,0.s)
Chars 4478 - 4538 [(apply~CommaCategory.path_morp...] 22.764 secs (19.068u,0.216s)
Chars 4478 - 4538 [(apply~CommaCategory.path_morp...] 40.07 secs (0.009u,0.026s)
Chars 4543 - 4556 [path_functor.] 0.015 secs (0.013u,0.001s)
Chars 4561 - 4567 [(simpl).] 0.004 secs (0.004u,0.s)
Chars 4572 - 4653 [exists~~~~(path_forall~_~_~(co...] 0.009 secs (0.009u,0.s)
Chars 4658 - 4671 [comma_laws_t.] 0.346 secs (0.304u,0.04s)
Chars 4478 - 4538 [(apply~CommaCategory.path_morp...] 0.005 secs (0.005u,0.s)
Chars 4543 - 4556 [path_functor.] 0.001 secs (0.001u,0.s)
Chars 4561 - 4567 [(simpl).] 0.002 secs (0.002u,0.s)
Chars 4572 - 4653 [exists~~~~(path_forall~_~_~(co...] 0.002 secs (0.002u,0.s)
Chars 4658 - 4671 [comma_laws_t.] 0.002 secs (0.002u,0.s)
Chars 4674 - 4678 [Qed.] 0.799 secs (0.773u,0.023s)
Chars 4682 - 5172 [Definition~comma_category_proj...] 0.018 secs (0.018u,0.s)
Chars 5173 - 5183 [End~comma.] 0.09 secs (0.084u,0.006s)
Chars 5185 - 5227 [Section~slice_category_project...] 0. secs (0.u,0.s)
Chars 5230 - 5258 [#[local]Open~Scope~type_scope.] 0. secs (0.u,0.s)
Chars 5261 - 5279 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 5283 - 5316 [Variable~(P~:~PreCategory~->~T...] 0. secs (0.u,0.s)
Chars 5319 - 5382 [Context~`{HF~:~forall~C~D,~P~C...] 0. secs (0.u,0.s)
Chars 5386 - 5430 [#[local]Notation~Cat~:=~(@sub_...] 0. secs (0.u,0.s)
Chars 5434 - 5462 [Variables~(C~D~:~PreCategory).] 0. secs (0.u,0.s)
Chars 5466 - 5493 [Hypothesis~(P1C~:~P~(1~*~C)).] 0. secs (0.u,0.s)
Chars 5496 - 5523 [Hypothesis~(PC1~:~P~(C~*~1)).] 0. secs (0.u,0.s)
Chars 5526 - 5546 [Hypothesis~(PC~:~P~C).] 0. secs (0.u,0.s)
Chars 5549 - 5624 [Hypothesis~(P_comma~:~forall~(...] 0.001 secs (0.001u,0.s)
Chars 5627 - 5703 [Hypothesis~(P_comma'~:~forall~...] 0.001 secs (0.001u,0.s)
Chars 5707 - 5738 [#[local]Open~Scope~functor_scope.] 0. secs (0.u,0.s)
Chars 5741 - 5773 [#[local]Open~Scope~category_sc...] 0. secs (0.u,0.s)
Chars 5777 - 5870 [#[local]~Notation~inv~D:=~~~(@...] 0. secs (0.u,0.s)
Chars 5932 - 6038 [Definition~slice_category_proj...] 0.004 secs (0.004u,0.s)
Chars 6041 - 6047 [Proof.] 0. secs (0.u,0.s)
Chars 1561 - 1565 [(red).] 40.18 secs (0.u,0.036s)
Chars 1566 - 1573 [(intros).] 0. secs (0.u,0.s)
Chars 1574 - 1614 [(destruct~(decide_rel~(<=)~x~y...] 0.006 secs (0.003u,0.002s)
Chars 1615 - 1616 [-] 0. secs (0.u,0.s)
Chars 1617 - 1622 [left.] 0.001 secs (0.001u,0.s)
Chars 1623 - 1640 [exists~(y~∸~x).] 0.002 secs (0.002u,0.s)
Chars 1643 - 1694 [(rewrite~rings.plus_comm;~appl...] 0.01 secs (0.01u,0.s)
Chars 1695 - 1696 [-] 0. secs (0.u,0.s)
Chars 1697 - 1703 [right.] 0.001 secs (0.001u,0.s)
Chars 1704 - 1721 [exists~(x~∸~y).] 0.002 secs (0.001u,0.s)
Chars 1724 - 1791 [(rewrite~rings.plus_comm;~appl...] 0.038 secs (0.034u,0.004s)
Chars 1561 - 1565 [(red).] 0. secs (0.u,0.s)
Chars 1566 - 1573 [(intros).] 0. secs (0.u,0.s)
Chars 1574 - 1614 [(destruct~(decide_rel~(<=)~x~y...] 0. secs (0.u,0.s)
Chars 1617 - 1622 [left.] 0. secs (0.u,0.s)
Chars 1623 - 1640 [exists~(y~∸~x).] 0. secs (0.u,0.s)
Chars 1643 - 1694 [(rewrite~rings.plus_comm;~appl...] 0.001 secs (0.001u,0.s)
Chars 1697 - 1703 [right.] 0. secs (0.u,0.s)
Chars 1704 - 1721 [exists~(x~∸~y).] 0. secs (0.u,0.s)
Chars 1724 - 1791 [(rewrite~rings.plus_comm;~appl...] 0.001 secs (0.001u,0.s)
Chars 1792 - 1800 [Defined.] 0.003 secs (0.u,0.002s)
Chars 1978 - 2049 [#[global]Instance~natdistance_...] 0.001 secs (0.001u,0.s)
Chars 2050 - 2056 [Proof.] 0. secs (0.u,0.s)
Chars 1387 - 1441 [refine~(transport_compose~idma...] 40.169 secs (0.003u,0.034s)
Chars 1444 - 1485 [refine~(_~@~transport_path_uni...] 0.012 secs (0.012u,0.s)
Chars 1488 - 1521 [(apply~ap10,~ap,~ap_pr1_path_b...] 0.003 secs (0.002u,0.s)
Chars 1387 - 1441 [refine~(transport_compose~idma...] 0. secs (0.u,0.s)
Chars 1444 - 1485 [refine~(_~@~transport_path_uni...] 0. secs (0.u,0.s)
Chars 1488 - 1521 [(apply~ap10,~ap,~ap_pr1_path_b...] 0. secs (0.u,0.s)
Chars 1522 - 1530 [Defined.] 0.002 secs (0.002u,0.s)
Chars 1620 - 1709 [#[global]~Instance~trunc_baut~...] 0. secs (0.u,0.s)
Chars 1710 - 1716 [Proof.] 0. secs (0.u,0.s)
Chars 3501 - 3557 [refine~(transport_compose~idma...] 40.164 secs (0.003u,0.032s)
Chars 3562 - 3611 [(unfold~Circle_code;~rewrite~C...] 0.003 secs (0.001u,0.001s)
Chars 3616 - 3646 [(apply~transport_path_universe).] 0.002 secs (0.001u,0.s)
Chars 3501 - 3557 [refine~(transport_compose~idma...] 0. secs (0.u,0.s)
Chars 3562 - 3611 [(unfold~Circle_code;~rewrite~C...] 0. secs (0.u,0.s)
Chars 3616 - 3646 [(apply~transport_path_universe).] 0. secs (0.u,0.s)
Chars 3649 - 3657 [Defined.] 0.003 secs (0.003u,0.s)
Chars 3732 - 3830 [Definition~transport_Circle_co...] 0.001 secs (0.001u,0.s)
Chars 3833 - 3839 [Proof.] 0. secs (0.u,0.s)
Chars 6052 - 6109 [refine~((ExponentialLaws.Law4....] 17.146 secs (12.194u,0.09s)
Chars 4430 - 4463 [snrapply~Build_GroupPresentation.] 40.163 secs (0.003u,0.029s)
Chars 4466 - 4467 [-] 0. secs (0.u,0.s)
Chars 4468 - 4482 [exact~(Fin~n).] 0. secs (0.u,0.s)
Chars 4485 - 4486 [-] 0. secs (0.u,0.s)
Chars 4487 - 4501 [exact~(Fin~m).] 0. secs (0.u,0.s)
Chars 4504 - 4505 [-] 0. secs (0.u,0.s)
Chars 4506 - 4514 [exact~f.] 0. secs (0.u,0.s)
Chars 4430 - 4463 [snrapply~Build_GroupPresentation.] 0. secs (0.u,0.s)
Chars 4468 - 4482 [exact~(Fin~n).] 0. secs (0.u,0.s)
Chars 4487 - 4501 [exact~(Fin~m).] 0. secs (0.u,0.s)
Chars 4506 - 4514 [exact~f.] 0. secs (0.u,0.s)
Chars 4515 - 4523 [Defined.] 0. secs (0.u,0.s)
Chars 4525 - 4685 [#[global]~Instance~FinitelyGen...] 0. secs (0.u,0.s)
Chars 4686 - 4692 [Proof.] 0. secs (0.u,0.s)
Chars 1719 - 1738 [(intros~[Z~p]~[W~q]).] 23.525 secs (10.u,0.164s)
Chars 6052 - 6109 [refine~((ExponentialLaws.Law4....] 40.054 secs (0.003u,0.024s)
Chars 6114 - 6191 [refine~(_~o~(Functor.Identity....] 0.01 secs (0.01u,0.s)
Chars 6196 - 6269 [refine~(_~o~@comma_category_pr...] 0.003 secs (0.003u,0.s)
Chars 6274 - 6310 [refine~(cat_over_induced_funct...] 0.003 secs (0.003u,0.s)
Chars 6315 - 6319 [(hnf).] 0.001 secs (0.001u,0.s)
Chars 6324 - 6359 [exact~(ProductLaws.Law1.functo...] 0.002 secs (0.002u,0.s)
Chars 6052 - 6109 [refine~((ExponentialLaws.Law4....] 0.001 secs (0.001u,0.s)
Chars 6114 - 6191 [refine~(_~o~(Functor.Identity....] 0.001 secs (0.001u,0.s)
Chars 6196 - 6269 [refine~(_~o~@comma_category_pr...] 0.001 secs (0.001u,0.s)
Chars 6274 - 6310 [refine~(cat_over_induced_funct...] 0.001 secs (0.u,0.s)
Chars 6315 - 6319 [(hnf).] 0. secs (0.001u,0.s)
Chars 6324 - 6359 [exact~(ProductLaws.Law1.functo...] 0. secs (0.u,0.s)
Chars 6362 - 6370 [Defined.] 0.004 secs (0.003u,0.s)
Chars 6374 - 6480 [Definition~coslice_category_pr...] 0.004 secs (0.004u,0.s)
Chars 6483 - 6489 [Proof.] 0. secs (0.u,0.s)
Chars 6494 - 6551 [refine~((ExponentialLaws.Law4....] 0.158 secs (0.002u,0.025s)
Chars 6556 - 6633 [refine~(_~o~(Functor.Identity....] 0.01 secs (0.01u,0.s)
Chars 6638 - 6711 [refine~(_~o~@comma_category_pr...] 0.004 secs (0.004u,0.s)
Chars 6716 - 6752 [refine~(cat_over_induced_funct...] 0.003 secs (0.003u,0.s)
Chars 6757 - 6761 [(hnf).] 0.001 secs (0.001u,0.s)
Chars 6766 - 6801 [exact~(ProductLaws.Law1.functo...] 0.002 secs (0.002u,0.s)
Chars 6494 - 6551 [refine~((ExponentialLaws.Law4....] 0.001 secs (0.001u,0.s)
Chars 6556 - 6633 [refine~(_~o~(Functor.Identity....] 0.001 secs (0.001u,0.s)
Chars 6638 - 6711 [refine~(_~o~@comma_category_pr...] 0.001 secs (0.001u,0.s)
Chars 6716 - 6752 [refine~(cat_over_induced_funct...] 0.001 secs (0.001u,0.s)
Chars 6757 - 6761 [(hnf).] 0. secs (0.u,0.s)
Chars 6766 - 6801 [exact~(ProductLaws.Law1.functo...] 0. secs (0.u,0.s)
Chars 6804 - 6812 [Defined.] 0.005 secs (0.005u,0.s)
Chars 6874 - 6979 [Definition~slice_category_proj...] 0.005 secs (0.003u,0.001s)
Chars 6982 - 6988 [Proof.] 0. secs (0.u,0.s)
Chars 2057 - 2068 [(intros~x~y).] 40.177 secs (0.001u,0.036s)
Chars 2069 - 2178 [(destruct~~~(nat_distance_sig~...] 0.023 secs (0.02u,0.001s)
Chars 2179 - 2180 [-] 0. secs (0.u,0.s)
Chars 2181 - 2186 [left.] 0.001 secs (0.001u,0.s)
Chars 2187 - 2225 [exists~(naturals_to_semiring~n...] 0.004 secs (0.003u,0.s)
Chars 2228 - 2285 [(rewrite~<-~(naturals.to_semir...] 0.013 secs (0.012u,0.s)
Chars 2288 - 2367 [(rewrite~(rings.preserves_plus...] 0.013 secs (0.01u,0.002s)
Chars 2370 - 2376 [split.] 0.001 secs (0.001u,0.s)
Chars 2377 - 2378 [-] 0. secs (0.u,0.s)
Chars 2379 - 2385 [right.] 0.001 secs (0.001u,0.s)
Chars 2386 - 2424 [exists~(naturals_to_semiring~n...] 0.005 secs (0.005u,0.s)
Chars 2427 - 2484 [(rewrite~<-~(naturals.to_semir...] 0.015 secs (0.014u,0.s)
Chars 2487 - 2566 [(rewrite~(rings.preserves_plus...] 0.014 secs (0.011u,0.003s)
Chars 2569 - 2575 [split.] 0.001 secs (0.001u,0.s)
Chars 2057 - 2068 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 2069 - 2178 [(destruct~~~(nat_distance_sig~...] 0. secs (0.u,0.s)
Chars 2181 - 2186 [left.] 0. secs (0.u,0.s)
Chars 2187 - 2225 [exists~(naturals_to_semiring~n...] 0. secs (0.u,0.s)
Chars 2228 - 2285 [(rewrite~<-~(naturals.to_semir...] 0. secs (0.u,0.s)
Chars 2288 - 2367 [(rewrite~(rings.preserves_plus...] 0.001 secs (0.001u,0.s)
Chars 2370 - 2376 [split.] 0. secs (0.u,0.s)
Chars 2379 - 2385 [right.] 0. secs (0.u,0.s)
Chars 2386 - 2424 [exists~(naturals_to_semiring~n...] 0. secs (0.u,0.s)
Chars 2427 - 2484 [(rewrite~<-~(naturals.to_semir...] 0. secs (0.u,0.s)
Chars 2487 - 2566 [(rewrite~(rings.preserves_plus...] 0.001 secs (0.001u,0.s)
Chars 2569 - 2575 [split.] 0. secs (0.u,0.s)
Chars 2576 - 2584 [Defined.] 0.035 secs (0.025u,0.009s)
Chars 1719 - 1738 [(intros~[Z~p]~[W~q]).] 40.071 secs (0.002u,0.035s)
Chars 1741 - 1759 [strip_truncations.] 0.114 secs (0.095u,0.017s)
Chars 1762 - 1828 [(refine~(@istrunc_equiv_istrun...] 0.022 secs (0.02u,0.001s)
Chars 1831 - 1857 [(symmetry~in~q;~destruct~q).] 0.001 secs (0.001u,0.s)
Chars 1860 - 1886 [(symmetry~in~p;~destruct~p).] 0.001 secs (0.u,0.s)
Chars 1889 - 1897 [exact~_.] 0.005 secs (0.003u,0.s)
Chars 1719 - 1738 [(intros~[Z~p]~[W~q]).] 0. secs (0.u,0.s)
Chars 1741 - 1759 [strip_truncations.] 0. secs (0.u,0.s)
Chars 1762 - 1828 [(refine~(@istrunc_equiv_istrun...] 0.001 secs (0.001u,0.s)
Chars 1831 - 1857 [(symmetry~in~q;~destruct~q).] 0. secs (0.u,0.s)
Chars 1860 - 1886 [(symmetry~in~p;~destruct~p).] 0. secs (0.u,0.s)
Chars 1889 - 1897 [exact~_.] 0. secs (0.u,0.s)
Chars 1898 - 1906 [Defined.] 0.004 secs (0.004u,0.s)
Chars 1979 - 2101 [Definition~merely_path_baut~`{...] 0.002 secs (0.002u,0.s)
Chars 2234 - 2571 [Ltac~~baut_reduce~:=~~~progres...] 0. secs (0.u,0.s)
Chars 2639 - 2727 [#[global]~Instance~trunc_el_ba...] 0. secs (0.u,0.s)
Chars 2728 - 2734 [Proof.] 0. secs (0.u,0.s)
Chars 3844 - 3901 [refine~(transport_compose~idma...] 40.197 secs (0.002u,0.032s)
Chars 3906 - 3919 [(rewrite~ap_V).] 0.002 secs (0.002u,0.s)
Chars 3924 - 3973 [(unfold~Circle_code;~rewrite~C...] 0.004 secs (0.004u,0.s)
Chars 3978 - 4016 [(rewrite~<-~(path_universe_V~i...] 0.003 secs (0.002u,0.s)
Chars 4021 - 4051 [(apply~transport_path_universe).] 0.002 secs (0.001u,0.s)
Chars 3844 - 3901 [refine~(transport_compose~idma...] 0. secs (0.u,0.s)
Chars 3906 - 3919 [(rewrite~ap_V).] 0. secs (0.u,0.s)
Chars 3924 - 3973 [(unfold~Circle_code;~rewrite~C...] 0. secs (0.u,0.s)
Chars 3978 - 4016 [(rewrite~<-~(path_universe_V~i...] 0. secs (0.u,0.s)
Chars 4021 - 4051 [(apply~transport_path_universe).] 0. secs (0.u,0.s)
Chars 4054 - 4062 [Defined.] 0.005 secs (0.005u,0.s)
Chars 4176 - 4267 [Definition~Circle_encode~(x~:~...] 0.001 secs (0.001u,0.s)
Chars 4397 - 4465 [Definition~Circle_decode~(x~:~...] 0. secs (0.u,0.s)
Chars 4468 - 4474 [Proof.] 0. secs (0.u,0.s)
Chars 6993 - 7050 [refine~((ExponentialLaws.Law4....] 18.142 secs (13.132u,-0.002s)
Chars 4695 - 4717 [unshelve~econstructor.] 40.168 secs (0.u,0.03s)
Chars 4720 - 4752 [2:~(simpl;~apply~tr;~reflexivi...] 0.003 secs (0.003u,0.s)
Chars 4695 - 4717 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 4720 - 4752 [2:~(simpl;~apply~tr;~reflexivi...] 0. secs (0.u,0.s)
Chars 4753 - 4761 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4763 - 4919 [#[global]~Instance~FinitelyRel...] 0. secs (0.u,0.s)
Chars 4920 - 4926 [Proof.] 0. secs (0.u,0.s)
Chars 4929 - 4951 [unshelve~econstructor.] 1.848 secs (0.001u,0.03s)
Chars 4954 - 4986 [2:~(simpl;~apply~tr;~reflexivi...] 0.003 secs (0.002u,0.s)
Chars 4929 - 4951 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 4954 - 4986 [2:~(simpl;~apply~tr;~reflexivi...] 0. secs (0.u,0.s)
Chars 4987 - 4995 [Defined.] 0. secs (0.u,0.s)
Chars 5092 - 5138 [#[local]Notation~ff~:=~(freegr...] 0. secs (0.u,0.s)
Chars 5263 - 5290 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 5313 - 5598 [Notation~"⟨~x~|~F~,~..~,~G~⟩"~...] 0. secs (0.u,0.s)
Chars 5622 - 5935 [Notation~"⟨~x~,~y~|~F~,~..~,~G...] 0.001 secs (0.001u,0.s)
Chars 5961 - 6306 [Notation~"⟨~x~,~y~,~z~|~F~,~.....] 0.001 secs (0.u,0.s)
Chars 6993 - 7050 [refine~((ExponentialLaws.Law4....] 40.053 secs (0.002u,0.024s)
Chars 7055 - 7134 [refine~(_~o~(Functor.Identity....] 0.009 secs (0.008u,0.s)
Chars 7139 - 7181 [refine~(_~o~ProductLaws.Swap.f...] 0.002 secs (0.002u,0.s)
Chars 7186 - 7260 [refine~(_~o~@comma_category_pr...] 0.003 secs (0.003u,0.s)
Chars 7265 - 7301 [refine~(cat_over_induced_funct...] 0.003 secs (0.003u,0.s)
Chars 7306 - 7310 [(hnf).] 0.001 secs (0.001u,0.s)
Chars 7315 - 7351 [exact~(ProductLaws.Law1.functo...] 0.001 secs (0.001u,0.s)
Chars 6993 - 7050 [refine~((ExponentialLaws.Law4....] 0.001 secs (0.001u,0.s)
Chars 7055 - 7134 [refine~(_~o~(Functor.Identity....] 0.001 secs (0.001u,0.s)
Chars 7139 - 7181 [refine~(_~o~ProductLaws.Swap.f...] 0.001 secs (0.001u,0.s)
Chars 7186 - 7260 [refine~(_~o~@comma_category_pr...] 0. secs (0.u,0.s)
Chars 7265 - 7301 [refine~(cat_over_induced_funct...] 0.001 secs (0.001u,0.s)
Chars 7306 - 7310 [(hnf).] 0. secs (0.u,0.s)
Chars 7315 - 7351 [exact~(ProductLaws.Law1.functo...] 0. secs (0.u,0.s)
Chars 7354 - 7362 [Defined.] 0.005 secs (0.005u,0.s)
Chars 7366 - 7473 [Definition~coslice_category_pr...] 0.005 secs (0.002u,0.001s)
Chars 7476 - 7482 [Proof.] 0. secs (0.u,0.s)
Chars 7487 - 7544 [refine~((ExponentialLaws.Law4....] 1.147 secs (0.003u,0.024s)
Chars 7549 - 7628 [refine~(_~o~(Functor.Identity....] 0.01 secs (0.01u,0.s)
Chars 7633 - 7675 [refine~(_~o~ProductLaws.Swap.f...] 0.002 secs (0.002u,0.s)
Chars 7680 - 7754 [refine~(_~o~@comma_category_pr...] 0.004 secs (0.003u,0.s)
Chars 7759 - 7795 [refine~(cat_over_induced_funct...] 0.003 secs (0.003u,0.s)
Chars 7800 - 7804 [(hnf).] 0.001 secs (0.001u,0.s)
Chars 7809 - 7845 [exact~(ProductLaws.Law1.functo...] 0.002 secs (0.002u,0.s)
Chars 7487 - 7544 [refine~((ExponentialLaws.Law4....] 0.001 secs (0.001u,0.s)
Chars 7549 - 7628 [refine~(_~o~(Functor.Identity....] 0.001 secs (0.001u,0.s)
Chars 7633 - 7675 [refine~(_~o~ProductLaws.Swap.f...] 0.001 secs (0.001u,0.s)
Chars 7680 - 7754 [refine~(_~o~@comma_category_pr...] 0.001 secs (0.001u,0.s)
Chars 7759 - 7795 [refine~(cat_over_induced_funct...] 0.001 secs (0.001u,0.s)
Chars 7800 - 7804 [(hnf).] 0. secs (0.u,0.s)
Chars 7809 - 7845 [exact~(ProductLaws.Law1.functo...] 0. secs (0.u,0.s)
Chars 7848 - 7856 [Defined.] 0.005 secs (0.004u,0.s)
Chars 7857 - 7895 [End~slice_category_projection_...] 0.064 secs (0.056u,0.007s)
Chars 2737 - 2757 [(destruct~Z~as~[Z~p]).] 40.146 secs (0.001u,0.034s)
Chars 2760 - 2778 [strip_truncations.] 0.05 secs (0.041u,0.008s)
Chars 2781 - 2801 [(destruct~p;~exact~_).] 0.002 secs (0.002u,0.s)
Chars 2737 - 2757 [(destruct~Z~as~[Z~p]).] 0. secs (0.u,0.s)
Chars 2760 - 2778 [strip_truncations.] 0. secs (0.u,0.s)
Chars 2781 - 2801 [(destruct~p;~exact~_).] 0. secs (0.u,0.s)
Chars 2802 - 2810 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2880 - 3052 [Definition~baut_prod_r~(X~A~:~...] 0.004 secs (0.003u,0.s)
Chars 3054 - 3271 [Definition~ap_baut_prod_r~`{Un...] 0.004 secs (0.004u,0.s)
Chars 3272 - 3278 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 4479 - 4563 [(revert~x;~refine~~~(Circle_in...] 40.171 secs (0.002u,0.034s)
Chars 4568 - 4608 [(apply~path_forall;~intros~z;~...] 0.003 secs (0.003u,0.s)
Chars 4613 - 4648 [refine~(transport_arrow~_~_~_~...] 0.002 secs (0.002u,0.s)
Chars 4653 - 4691 [refine~(transport_paths_r~loop...] 0.001 secs (0.001u,0.s)
Chars 4696 - 4732 [(rewrite~transport_Circle_code...] 0.002 secs (0.002u,0.s)
Chars 4737 - 4759 [(destruct~z~as~[n|~|~n]).] 0.001 secs (0.001u,0.s)
Chars 4764 - 4783 [2:~(apply~concat_Vp).] 0.001 secs (0.001u,0.s)
Chars 4788 - 4789 [{] 0. secs (0.u,0.s)
Chars 4790 - 4818 [(rewrite~<-~int_neg_pos_succ).] 0.001 secs (0.001u,0.s)
Chars 4825 - 4853 [(unfold~loopexp,~loopexp_pos).] 0. secs (0.u,0.s)
Chars 4860 - 4896 [(rewrite~pos_peano_ind_beta_po...] 0.002 secs (0.001u,0.s)
Chars 4903 - 4921 [(apply~concat_pV_p).] 0.001 secs (0.001u,0.s)
Chars 4922 - 4923 [}] 0. secs (0.u,0.s)
Chars 4928 - 4971 [(induction~n~as~[|~n~nH]~using...] 0.001 secs (0.001u,0.s)
Chars 4976 - 4995 [1:~(apply~concat_1p).] 0.001 secs (0.001u,0.s)
Chars 5000 - 5023 [(rewrite~<-~pos_add_1_r).] 0.001 secs (0.001u,0.s)
Chars 5028 - 5083 [(change~(pos~(n~+~1)%pos)~with...] 0.002 secs (0.002u,0.s)
Chars 5088 - 5110 [(rewrite~int_pred_succ).] 0.002 secs (0.002u,0.s)
Chars 5115 - 5140 [(cbn;~rewrite~pos_add_1_r).] 0.002 secs (0.002u,0.s)
Chars 5145 - 5164 [(unfold~loopexp_pos).] 0. secs (0.u,0.s)
Chars 5169 - 5205 [(rewrite~pos_peano_ind_beta_po...] 0.002 secs (0.001u,0.s)
Chars 5210 - 5222 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 4479 - 4563 [(revert~x;~refine~~~(Circle_in...] 0. secs (0.u,0.s)
Chars 4568 - 4608 [(apply~path_forall;~intros~z;~...] 0.001 secs (0.001u,0.s)
Chars 4613 - 4648 [refine~(transport_arrow~_~_~_~...] 0. secs (0.u,0.s)
Chars 4653 - 4691 [refine~(transport_paths_r~loop...] 0. secs (0.u,0.s)
Chars 4696 - 4732 [(rewrite~transport_Circle_code...] 0. secs (0.u,0.s)
Chars 4737 - 4759 [(destruct~z~as~[n|~|~n]).] 0. secs (0.u,0.s)
Chars 4764 - 4783 [2:~(apply~concat_Vp).] 0. secs (0.u,0.s)
Chars 4790 - 4818 [(rewrite~<-~int_neg_pos_succ).] 0. secs (0.u,0.s)
Chars 4825 - 4853 [(unfold~loopexp,~loopexp_pos).] 0. secs (0.u,0.s)
Chars 4860 - 4896 [(rewrite~pos_peano_ind_beta_po...] 0. secs (0.u,0.s)
Chars 4903 - 4921 [(apply~concat_pV_p).] 0. secs (0.u,0.s)
Chars 4928 - 4971 [(induction~n~as~[|~n~nH]~using...] 0. secs (0.u,0.s)
Chars 4976 - 4995 [1:~(apply~concat_1p).] 0. secs (0.u,0.s)
Chars 5000 - 5023 [(rewrite~<-~pos_add_1_r).] 0. secs (0.u,0.s)
Chars 5028 - 5083 [(change~(pos~(n~+~1)%pos)~with...] 0. secs (0.u,0.s)
Chars 5088 - 5110 [(rewrite~int_pred_succ).] 0. secs (0.u,0.s)
Chars 5115 - 5140 [(cbn;~rewrite~pos_add_1_r).] 0.001 secs (0.u,0.s)
Chars 5145 - 5164 [(unfold~loopexp_pos).] 0. secs (0.u,0.s)
Chars 5169 - 5205 [(rewrite~pos_peano_ind_beta_po...] 0. secs (0.u,0.s)
Chars 5210 - 5222 [reflexivity.] 0. secs (0.u,0.s)
Chars 5225 - 5233 [Defined.] 0.008 secs (0.006u,0.001s)
Chars 5409 - 5496 [Definition~Circle_encode_loope...] 0. secs (0.u,0.s)
Chars 5499 - 5505 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 3281 - 3285 [(cbn).] 40.177 secs (0.004u,0.034s)
Chars 3288 - 3330 [(apply~moveL_equiv_M;~cbn;~unf...] 0.016 secs (0.013u,0.002s)
Chars 3333 - 3404 [(rewrite~<-~(ap_compose~(baut_...] 0.006 secs (0.005u,0.s)
Chars 3407 - 3480 [(rewrite~<-~(ap_compose~pr1~(f...] 0.008 secs (0.006u,0.002s)
Chars 3483 - 3515 [(rewrite~ap_pr1_path_sigma_hpr...] 0.004 secs (0.004u,0.s)
Chars 3518 - 3543 [(apply~moveL_equiv_M;~cbn).] 0.072 secs (0.055u,0.016s)
Chars 3546 - 3576 [(apply~ap_prod_r_path_universe).] 0.002 secs (0.002u,0.s)
Chars 3281 - 3285 [(cbn).] 0. secs (0.u,0.s)
Chars 3288 - 3330 [(apply~moveL_equiv_M;~cbn;~unf...] 0.002 secs (0.002u,0.s)
Chars 3333 - 3404 [(rewrite~<-~(ap_compose~(baut_...] 0. secs (0.u,0.s)
Chars 3407 - 3480 [(rewrite~<-~(ap_compose~pr1~(f...] 0. secs (0.u,0.s)
Chars 3483 - 3515 [(rewrite~ap_pr1_path_sigma_hpr...] 0. secs (0.u,0.s)
Chars 3518 - 3543 [(apply~moveL_equiv_M;~cbn).] 0.001 secs (0.u,0.s)
Chars 3546 - 3576 [(apply~ap_prod_r_path_universe).] 0. secs (0.u,0.s)
Chars 3577 - 3581 [Qed.] 0.017 secs (0.013u,0.003s)
Chars 3790 - 4187 [Lemma~baut_ind_hset~`{Univalen...] 0.004 secs (0.003u,0.s)
Chars 4188 - 4194 [Proof.] 0. secs (0.u,0.s)
Chars 5510 - 5556 [(destruct~z~as~[n|~|~n];~unfol...] 40.172 secs (0.002u,0.035s)
Chars 5561 - 5562 [-] 0. secs (0.u,0.s)
Chars 5563 - 5607 [(induction~n~using~pos_peano_i...] 0.004 secs (0.003u,0.s)
Chars 5614 - 5615 [+] 0. secs (0.u,0.s)
Chars 5616 - 5656 [refine~(moveR_transport_V~_~lo...] 0.001 secs (0.u,0.s)
Chars 5665 - 5711 [by~symmetry;~apply~transport_C...] 0.003 secs (0.003u,0.s)
Chars 5718 - 5719 [+] 0. secs (0.u,0.s)
Chars 5720 - 5739 [(unfold~loopexp_pos).] 0. secs (0.u,0.s)
Chars 5748 - 5784 [(rewrite~pos_peano_ind_beta_po...] 0.002 secs (0.002u,0.s)
Chars 5793 - 5814 [(rewrite~transport_pp).] 0.002 secs (0.002u,0.s)
Chars 5823 - 5863 [refine~(moveR_transport_V~_~lo...] 0.002 secs (0.001u,0.s)
Chars 5872 - 5917 [refine~(_~@~(transport_Circle_...] 0.002 secs (0.002u,0.s)
Chars 5926 - 5944 [refine~(IHn~@~_^).] 0.002 secs (0.002u,0.s)
Chars 5953 - 5978 [(rewrite~int_neg_pos_succ).] 0.001 secs (0.001u,0.s)
Chars 5987 - 6012 [by~rewrite~int_succ_pred.] 0.001 secs (0.001u,0.s)
Chars 6017 - 6018 [-] 0. secs (0.u,0.s)
Chars 6019 - 6031 [reflexivity.] 0. secs (0.u,0.s)
Chars 6036 - 6037 [-] 0. secs (0.u,0.s)
Chars 6038 - 6082 [(induction~n~using~pos_peano_i...] 0.003 secs (0.003u,0.s)
Chars 6089 - 6090 [+] 0. secs (0.u,0.s)
Chars 6091 - 6127 [by~apply~transport_Circle_code...] 0.001 secs (0.001u,0.s)
Chars 6134 - 6135 [+] 0. secs (0.u,0.s)
Chars 6136 - 6155 [(unfold~loopexp_pos).] 0. secs (0.u,0.s)
Chars 6164 - 6200 [(rewrite~pos_peano_ind_beta_po...] 0.002 secs (0.002u,0.s)
Chars 6209 - 6230 [(rewrite~transport_pp).] 0.002 secs (0.002u,0.s)
Chars 6239 - 6279 [refine~(moveR_transport_p~_~lo...] 0.002 secs (0.002u,0.s)
Chars 6288 - 6334 [refine~(_~@~(transport_Circle_...] 0.002 secs (0.002u,0.s)
Chars 6343 - 6361 [refine~(IHn~@~_^).] 0.002 secs (0.002u,0.s)
Chars 6370 - 6393 [(rewrite~<-~pos_add_1_r).] 0.001 secs (0.001u,0.s)
Chars 6402 - 6447 [(change~(int_pred~(int_succ~(p...] 0.001 secs (0.001u,0.s)
Chars 6456 - 6476 [(apply~int_pred_succ).] 0. secs (0.u,0.s)
Chars 5510 - 5556 [(destruct~z~as~[n|~|~n];~unfol...] 0.001 secs (0.001u,0.s)
Chars 5563 - 5607 [(induction~n~using~pos_peano_i...] 0.001 secs (0.u,0.s)
Chars 5616 - 5656 [refine~(moveR_transport_V~_~lo...] 0. secs (0.u,0.s)
Chars 5665 - 5711 [by~symmetry;~apply~transport_C...] 0. secs (0.u,0.s)
Chars 5720 - 5739 [(unfold~loopexp_pos).] 0. secs (0.u,0.s)
Chars 5748 - 5784 [(rewrite~pos_peano_ind_beta_po...] 0. secs (0.u,0.s)
Chars 5793 - 5814 [(rewrite~transport_pp).] 0. secs (0.u,0.s)
Chars 5823 - 5863 [refine~(moveR_transport_V~_~lo...] 0. secs (0.u,0.s)
Chars 5872 - 5917 [refine~(_~@~(transport_Circle_...] 0. secs (0.u,0.s)
Chars 5926 - 5944 [refine~(IHn~@~_^).] 0. secs (0.u,0.s)
Chars 5953 - 5978 [(rewrite~int_neg_pos_succ).] 0. secs (0.u,0.s)
Chars 5987 - 6012 [by~rewrite~int_succ_pred.] 0. secs (0.u,0.s)
Chars 6019 - 6031 [reflexivity.] 0. secs (0.u,0.s)
Chars 6038 - 6082 [(induction~n~using~pos_peano_i...] 0.001 secs (0.001u,0.s)
Chars 6091 - 6127 [by~apply~transport_Circle_code...] 0. secs (0.u,0.s)
Chars 6136 - 6155 [(unfold~loopexp_pos).] 0. secs (0.u,0.s)
Chars 6164 - 6200 [(rewrite~pos_peano_ind_beta_po...] 0. secs (0.u,0.s)
Chars 6209 - 6230 [(rewrite~transport_pp).] 0. secs (0.u,0.s)
Chars 6239 - 6279 [refine~(moveR_transport_p~_~lo...] 0. secs (0.u,0.s)
Chars 6288 - 6334 [refine~(_~@~(transport_Circle_...] 0. secs (0.u,0.s)
Chars 6343 - 6361 [refine~(IHn~@~_^).] 0. secs (0.u,0.s)
Chars 6370 - 6393 [(rewrite~<-~pos_add_1_r).] 0. secs (0.u,0.s)
Chars 6402 - 6447 [(change~(int_pred~(int_succ~(p...] 0. secs (0.u,0.s)
Chars 6456 - 6476 [(apply~int_pred_succ).] 0. secs (0.u,0.s)
Chars 6479 - 6487 [Defined.] 0.058 secs (0.04u,0.017s)
Chars 6524 - 6596 [Definition~Circle_encode_isequ...] 0. secs (0.u,0.s)
Chars 6599 - 6605 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 4197 - 4227 [refine~(equiv_sig_ind~_~oE~_).] 40.141 secs (0.001u,0.035s)
Chars 4357 - 4536 [(refine~~~(equiv_functor_foral...] 0.042 secs (0.039u,0.002s)
Chars 4539 - 4540 [{] 0. secs (0.u,0.s)
Chars 4541 - 4550 [(intros~p).] 0. secs (0.u,0.s)
Chars 4551 - 4595 [(change~(IsHSet~(P~(BAut_pr1~X...] 0.001 secs (0.001u,0.s)
Chars 4596 - 4604 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 4605 - 4606 [}] 0. secs (0.u,0.s)
Chars 4609 - 4631 [(unfold~WeaklyConstant).] 0. secs (0.u,0.s)
Chars 4691 - 4725 [refine~(equiv_sig_coind~_~_~oE...] 0.001 secs (0.001u,0.s)
Chars 4728 - 4757 [srapply~equiv_functor_sigma'.] 0.002 secs (0.002u,0.s)
Chars 4760 - 4807 [1:~(apply~(equiv_paths_ind_r~X...] 0.001 secs (0.001u,0.s)
Chars 4810 - 4824 [(intros~p;~cbn).] 0.001 secs (0.001u,0.s)
Chars 4827 - 4863 [refine~(equiv_paths_ind_r~X~_~...] 0.002 secs (0.002u,0.s)
Chars 4866 - 4896 [srapply~equiv_functor_forall'.] 0.003 secs (0.003u,0.s)
Chars 4899 - 4924 [1:~(apply~equiv_equiv_path).] 0. secs (0.u,0.s)
Chars 4927 - 4941 [(intros~e;~cbn).] 0.002 secs (0.002u,0.s)
Chars 4944 - 4990 [refine~(_~oE~equiv_moveL_trans...] 0.001 secs (0.001u,0.s)
Chars 4994 - 5015 [(apply~equiv_concat_r).] 0.001 secs (0.001u,0.s)
Chars 5018 - 5079 [(rewrite~path_universe_transpo...] 0.003 secs (0.003u,0.s)
Chars 5082 - 5094 [reflexivity.] 0. secs (0.u,0.s)
Chars 4197 - 4227 [refine~(equiv_sig_ind~_~oE~_).] 0. secs (0.u,0.s)
Chars 4357 - 4536 [(refine~~~(equiv_functor_foral...] 0.001 secs (0.001u,0.s)
Chars 4541 - 4550 [(intros~p).] 0. secs (0.u,0.s)
Chars 4551 - 4595 [(change~(IsHSet~(P~(BAut_pr1~X...] 0. secs (0.u,0.s)
Chars 4596 - 4604 [exact~_.] 0. secs (0.u,0.s)
Chars 4609 - 4631 [(unfold~WeaklyConstant).] 0. secs (0.u,0.s)
Chars 4691 - 4725 [refine~(equiv_sig_coind~_~_~oE...] 0. secs (0.u,0.s)
Chars 4728 - 4757 [srapply~equiv_functor_sigma'.] 0. secs (0.u,0.s)
Chars 4760 - 4807 [1:~(apply~(equiv_paths_ind_r~X...] 0. secs (0.u,0.s)
Chars 4810 - 4824 [(intros~p;~cbn).] 0.001 secs (0.001u,0.s)
Chars 4827 - 4863 [refine~(equiv_paths_ind_r~X~_~...] 0. secs (0.u,0.s)
Chars 4866 - 4896 [srapply~equiv_functor_forall'.] 0. secs (0.u,0.s)
Chars 4899 - 4924 [1:~(apply~equiv_equiv_path).] 0. secs (0.u,0.s)
Chars 4927 - 4941 [(intros~e;~cbn).] 0.001 secs (0.001u,0.s)
Chars 4944 - 4990 [refine~(_~oE~equiv_moveL_trans...] 0. secs (0.u,0.s)
Chars 4994 - 5015 [(apply~equiv_concat_r).] 0. secs (0.u,0.s)
Chars 5018 - 5079 [(rewrite~path_universe_transpo...] 0. secs (0.u,0.s)
Chars 5082 - 5094 [reflexivity.] 0. secs (0.u,0.s)
Chars 5095 - 5103 [Defined.] 0.008 secs (0.008u,0.s)
Chars 5331 - 5464 [Definition~center_baut~`{Univa...] 0.003 secs (0.001u,0.001s)
Chars 5465 - 5471 [Proof.] 0. secs (0.u,0.s)
Chars 6609 - 6677 [refine~(isequiv_adjointify~(Ci...] 40.164 secs (0.001u,0.032s)
Chars 6764 - 6765 [-] 0. secs (0.u,0.s)
Chars 6766 - 6878 [refine~~(Circle_ind~(fun~x~=>~...] 0.003 secs (0.003u,0.s)
Chars 6952 - 7001 [by~apply~path_forall;~intros~z...] 0.005 secs (0.005u,0.s)
Chars 7061 - 7062 [-] 0. secs (0.u,0.s)
Chars 7063 - 7086 [(intros~[];~reflexivity).] 0.002 secs (0.001u,0.s)
Chars 6609 - 6677 [refine~(isequiv_adjointify~(Ci...] 0. secs (0.u,0.s)
Chars 6766 - 6878 [refine~~(Circle_ind~(fun~x~=>~...] 0. secs (0.u,0.s)
Chars 6952 - 7001 [by~apply~path_forall;~intros~z...] 0. secs (0.u,0.s)
Chars 7063 - 7086 [(intros~[];~reflexivity).] 0. secs (0.u,0.s)
Chars 7089 - 7097 [Defined.] 0.004 secs (0.003u,0.s)
Chars 7193 - 7322 [Definition~equiv_loopCircle_in...] 0.002 secs (0.002u,0.s)
Chars 7324 - 7341 [End~EncodeDecode.] 0.045 secs (0.045u,0.s)
Chars 7436 - 7508 [#[global]Instance~isconnected_...] 0. secs (0.u,0.s)
Chars 7509 - 7515 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 5474 - 5562 [refine~(equiv_functor_forall_i...] 40.173 secs (0.006u,0.036s)
Chars 5565 - 5612 [refine~(baut_ind_hset~X~(fun~Z...] 0.085 secs (0.07u,0.014s)
Chars 5615 - 5621 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 5624 - 5692 [(refine~(equiv_functor_sigma'~...] 0.002 secs (0.001u,0.s)
Chars 5695 - 5742 [(apply~equiv_functor_forall_id...] 0.004 secs (0.003u,0.s)
Chars 5745 - 5780 [refine~(_~oE~equiv_path_arrow~...] 0.002 secs (0.001u,0.s)
Chars 5783 - 5832 [refine~(_~oE~equiv_path_equiv~...] 0.004 secs (0.002u,0.s)
Chars 5835 - 5844 [revert~g.] 0. secs (0.u,0.s)
Chars 5845 - 5876 [(equiv_intro~(equiv_path~X~X)~g).] 0.006 secs (0.006u,0.s)
Chars 5879 - 5888 [revert~f.] 0. secs (0.u,0.s)
Chars 5889 - 5920 [(equiv_intro~(equiv_path~X~X)~f).] 0.006 secs (0.004u,0.001s)
Chars 5923 - 5974 [refine~(_~oE~equiv_concat_l~(e...] 0.002 secs (0.u,0.001s)
Chars 5977 - 6029 [refine~(_~oE~equiv_concat_r~(e...] 0.003 secs (0.003u,0.s)
Chars 6032 - 6081 [refine~(_~oE~(equiv_ap~(equiv_...] 0.007 secs (0.004u,0.002s)
Chars 6084 - 6140 [refine~(equiv_concat_l~(transp...] 0.002 secs (0.001u,0.s)
Chars 6143 - 6194 [refine~(equiv_concat_l~(concat...] 0.002 secs (0.002u,0.s)
Chars 6197 - 6232 [refine~(equiv_moveR_Vp~_~_~_~o...] 0.001 secs (0.u,0.s)
Chars 6235 - 6285 [refine~(equiv_concat_l~_~_~oE~...] 0.002 secs (0.002u,0.s)
Chars 6288 - 6289 [-] 0. secs (0.u,0.s)
Chars 6290 - 6319 [(apply~concat2;~apply~eissect).] 0.003 secs (0.002u,0.s)
Chars 6322 - 6323 [-] 0. secs (0.u,0.s)
Chars 6324 - 6363 [(symmetry;~apply~concat2;~appl...] 0.005 secs (0.004u,0.s)
Chars 5474 - 5562 [refine~(equiv_functor_forall_i...] 0. secs (0.u,0.s)
Chars 5565 - 5612 [refine~(baut_ind_hset~X~(fun~Z...] 0. secs (0.u,0.s)
Chars 5615 - 5621 [(simpl).] 0. secs (0.u,0.s)
Chars 5624 - 5692 [(refine~(equiv_functor_sigma'~...] 0.001 secs (0.001u,0.s)
Chars 5695 - 5742 [(apply~equiv_functor_forall_id...] 0.001 secs (0.001u,0.s)
Chars 5745 - 5780 [refine~(_~oE~equiv_path_arrow~...] 0. secs (0.u,0.s)
Chars 5783 - 5832 [refine~(_~oE~equiv_path_equiv~...] 0. secs (0.u,0.s)
Chars 5835 - 5844 [revert~g.] 0. secs (0.u,0.s)
Chars 5845 - 5876 [(equiv_intro~(equiv_path~X~X)~g).] 0. secs (0.u,0.s)
Chars 5879 - 5888 [revert~f.] 0. secs (0.u,0.s)
Chars 5889 - 5920 [(equiv_intro~(equiv_path~X~X)~f).] 0. secs (0.u,0.s)
Chars 5923 - 5974 [refine~(_~oE~equiv_concat_l~(e...] 0. secs (0.u,0.s)
Chars 5977 - 6029 [refine~(_~oE~equiv_concat_r~(e...] 0. secs (0.u,0.s)
Chars 6032 - 6081 [refine~(_~oE~(equiv_ap~(equiv_...] 0. secs (0.u,0.s)
Chars 6084 - 6140 [refine~(equiv_concat_l~(transp...] 0. secs (0.u,0.s)
Chars 6143 - 6194 [refine~(equiv_concat_l~(concat...] 0. secs (0.u,0.s)
Chars 6197 - 6232 [refine~(equiv_moveR_Vp~_~_~_~o...] 0. secs (0.u,0.s)
Chars 6235 - 6285 [refine~(equiv_concat_l~_~_~oE~...] 0. secs (0.u,0.s)
Chars 6290 - 6319 [(apply~concat2;~apply~eissect).] 0. secs (0.u,0.s)
Chars 6324 - 6363 [(symmetry;~apply~concat2;~appl...] 0.001 secs (0.001u,0.s)
Chars 6364 - 6372 [Defined.] 0.014 secs (0.012u,0.001s)
Chars 6629 - 6892 [Definition~id_center_baut~`{Un...] 0.005 secs (0.005u,0.s)
Chars 6893 - 6899 [Proof.] 0. secs (0.u,0.s)
Chars 7518 - 7552 [(apply~is0connected_merely_all...] 40.169 secs (0.001u,0.031s)
Chars 7555 - 7574 [1:~exact~(tr~base).] 0. secs (0.u,0.s)
Chars 7577 - 7604 [srefine~(Circle_ind~_~_~_).] 0. secs (0.u,0.s)
Chars 7607 - 7608 [-] 0. secs (0.u,0.s)
Chars 7609 - 7642 [simple~refine~(Circle_ind~_~_~_).] 0. secs (0.u,0.s)
Chars 7647 - 7648 [+] 0. secs (0.u,0.s)
Chars 7649 - 7662 [exact~(tr~1).] 0.001 secs (0.001u,0.s)
Chars 7667 - 7668 [+] 0. secs (0.u,0.s)
Chars 7669 - 7688 [(apply~path_ishprop).] 0.002 secs (0.002u,0.s)
Chars 7691 - 7692 [-] 0. secs (0.u,0.s)
Chars 7693 - 7712 [(apply~path_ishprop).] 0.01 secs (0.009u,0.s)
Chars 7518 - 7552 [(apply~is0connected_merely_all...] 0. secs (0.u,0.s)
Chars 7555 - 7574 [1:~exact~(tr~base).] 0. secs (0.u,0.s)
Chars 7577 - 7604 [srefine~(Circle_ind~_~_~_).] 0. secs (0.u,0.s)
Chars 7609 - 7642 [simple~refine~(Circle_ind~_~_~_).] 0. secs (0.u,0.s)
Chars 7649 - 7662 [exact~(tr~1).] 0. secs (0.u,0.s)
Chars 7669 - 7688 [(apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 7693 - 7712 [(apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 7713 - 7721 [Defined.] 0.004 secs (0.004u,0.s)
Chars 7770 - 7834 [#[global]Instance~istrunc_Circ...] 0. secs (0.u,0.s)
Chars 7835 - 7841 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 6902 - 6930 [(apply~path_forall;~intros~Z).] 40.197 secs (0.003u,0.035s)
Chars 6933 - 6972 [(assert~(IsHSet~(Z.1~=~Z.1))~b...] 0.059 secs (0.051u,0.008s)
Chars 6975 - 6987 [baut_reduce.] 0.068 secs (0.053u,0.014s)
Chars 6990 - 7075 [exact~(ap~(path_sigma_hprop~_~...] 0.043 secs (0.04u,0.002s)
Chars 6902 - 6930 [(apply~path_forall;~intros~Z).] 0.001 secs (0.u,0.001s)
Chars 6933 - 6972 [(assert~(IsHSet~(Z.1~=~Z.1))~b...] 0. secs (0.u,0.s)
Chars 6975 - 6987 [baut_reduce.] 0. secs (0.u,0.s)
Chars 6990 - 7075 [exact~(ap~(path_sigma_hprop~_~...] 0. secs (0.u,0.s)
Chars 7076 - 7084 [Defined.] 0.008 secs (0.007u,0.001s)
Chars 7248 - 7268 [Section~Center2BAut.] 0. secs (0.u,0.s)
Chars 7271 - 7318 [#[local]Arguments~equiv_path_e...] 0. secs (0.u,0.s)
Chars 7321 - 7372 [#[local]Arguments~equiv_path2_...] 0. secs (0.u,0.s)
Chars 7376 - 7559 [Definition~center2_baut~`{Univ...] 0.002 secs (0.001u,0.s)
Chars 7562 - 7568 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 7844 - 7855 [(intros~x~y).] 40.123 secs (0.001u,0.031s)
Chars 7858 - 7911 [(pose~proof~(merely_path_is0co...] 0.001 secs (0.001u,0.s)
Chars 7914 - 7967 [(pose~proof~(merely_path_is0co...] 0.001 secs (0.u,0.s)
Chars 7970 - 7988 [strip_truncations.] 0.046 secs (0.041u,0.005s)
Chars 7991 - 8005 [(destruct~p,~q).] 0.001 secs (0.001u,0.s)
Chars 8008 - 8076 [refine~(istrunc_equiv_istrunc~...] 0.002 secs (0.002u,0.s)
Chars 7844 - 7855 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 7858 - 7911 [(pose~proof~(merely_path_is0co...] 0. secs (0.u,0.s)
Chars 7914 - 7967 [(pose~proof~(merely_path_is0co...] 0. secs (0.u,0.s)
Chars 7970 - 7988 [strip_truncations.] 0. secs (0.u,0.s)
Chars 7991 - 8005 [(destruct~p,~q).] 0. secs (0.u,0.s)
Chars 8008 - 8076 [refine~(istrunc_equiv_istrunc~...] 0. secs (0.u,0.s)
Chars 8077 - 8085 [Defined.] 0.003 secs (0.001u,0.002s)
Chars 8284 - 8464 [Definition~Circle_action_is_it...] 0.005 secs (0.004u,0.s)
Chars 8465 - 8471 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 7573 - 7745 [refine~~(equiv_functor_forall_...] 40.179 secs (0.012u,0.038s)
Chars 7750 - 7751 [{] 0. secs (0.u,0.s)
Chars 7752 - 7787 [(symmetry;~apply~path_sigma_hp...] 0.004 secs (0.003u,0.s)
Chars 7788 - 7789 [}] 0. secs (0.u,0.s)
Chars 7794 - 7795 [{] 0. secs (0.u,0.s)
Chars 7796 - 7821 [(apply~path_sigma_hprop_1).] 0.002 secs (0.002u,0.s)
Chars 7822 - 7823 [}] 0. secs (0.u,0.s)
Chars 7828 - 7898 [(assert~(forall~Z~:~BAut~X,~Is...] 0.085 secs (0.073u,0.011s)
Chars 7903 - 7964 [refine~(baut_ind_hset~X~(fun~Z...] 0.003 secs (0.002u,0.s)
Chars 7969 - 8010 [simple~refine~(equiv_functor_s...] 0.002 secs (0.002u,0.s)
Chars 8015 - 8016 [{] 0. secs (0.u,0.s)
Chars 8017 - 8056 [refine~(_~oE~equiv_path2_unive...] 0.002 secs (0.001u,0.s)
Chars 8063 - 8085 [(apply~equiv_concat_lr).] 0.001 secs (0.001u,0.s)
Chars 8092 - 8093 [-] 0. secs (0.u,0.s)
Chars 8094 - 8126 [(symmetry;~apply~path_universe...] 0.003 secs (0.001u,0.001s)
Chars 8133 - 8134 [-] 0. secs (0.u,0.s)
Chars 8135 - 8157 [(apply~path_universe_1).] 0.001 secs (0.001u,0.s)
Chars 8158 - 8159 [}] 0. secs (0.u,0.s)
Chars 8164 - 8173 [(intros~f).] 0.001 secs (0.001u,0.s)
Chars 8178 - 8218 [(apply~equiv_functor_forall_id...] 0.007 secs (0.006u,0.s)
Chars 8223 - 8262 [refine~(_~oE~equiv_path3_unive...] 0.005 secs (0.004u,0.s)
Chars 8267 - 8316 [refine~(dpath_paths2~(path_uni...] 0.005 secs (0.005u,0.s)
Chars 8321 - 8325 [(cbn).] 0.006 secs (0.006u,0.s)
Chars 8330 - 8375 [(change~(equiv_idmap~X~==~equi...] 0.003 secs (0.002u,0.s)
Chars 8380 - 8409 [refine~(equiv_concat_lr~_~_).] 0.022 secs (0.014u,0.007s)
Chars 8414 - 8415 [-] 0. secs (0.u,0.s)
Chars 8416 - 8469 [refine~(_~@~(path2_universe_po...] 0.004 secs (0.004u,0.s)
Chars 8476 - 8535 [(abstract~(rewrite~!whiskerR_p...] 0.223 secs (0.188u,0.033s)
Chars 8540 - 8541 [-] 0. secs (0.u,0.s)
Chars 8542 - 8591 [refine~(path2_universe_precomp...] 0.004 secs (0.003u,0.s)
Chars 8598 - 8657 [(abstract~(rewrite~!whiskerL_p...] 0.156 secs (0.155u,0.001s)
Chars 7573 - 7745 [refine~~(equiv_functor_forall_...] 0. secs (0.u,0.s)
Chars 7752 - 7787 [(symmetry;~apply~path_sigma_hp...] 0. secs (0.u,0.s)
Chars 7796 - 7821 [(apply~path_sigma_hprop_1).] 0. secs (0.u,0.s)
Chars 7828 - 7898 [(assert~(forall~Z~:~BAut~X,~Is...] 0. secs (0.u,0.s)
Chars 7903 - 7964 [refine~(baut_ind_hset~X~(fun~Z...] 0. secs (0.u,0.s)
Chars 7969 - 8010 [simple~refine~(equiv_functor_s...] 0. secs (0.u,0.s)
Chars 8017 - 8056 [refine~(_~oE~equiv_path2_unive...] 0. secs (0.u,0.s)
Chars 8063 - 8085 [(apply~equiv_concat_lr).] 0. secs (0.u,0.s)
Chars 8094 - 8126 [(symmetry;~apply~path_universe...] 0. secs (0.u,0.s)
Chars 8135 - 8157 [(apply~path_universe_1).] 0. secs (0.u,0.s)
Chars 8164 - 8173 [(intros~f).] 0.001 secs (0.001u,0.s)
Chars 8178 - 8218 [(apply~equiv_functor_forall_id...] 0.002 secs (0.002u,0.s)
Chars 8223 - 8262 [refine~(_~oE~equiv_path3_unive...] 0.001 secs (0.001u,0.s)
Chars 8267 - 8316 [refine~(dpath_paths2~(path_uni...] 0.001 secs (0.001u,0.s)
Chars 8321 - 8325 [(cbn).] 0.002 secs (0.002u,0.s)
Chars 8330 - 8375 [(change~(equiv_idmap~X~==~equi...] 0.001 secs (0.001u,0.s)
Chars 8380 - 8409 [refine~(equiv_concat_lr~_~_).] 0.001 secs (0.001u,0.s)
Chars 8416 - 8469 [refine~(_~@~(path2_universe_po...] 0.001 secs (0.001u,0.s)
Chars 8476 - 8535 [(abstract~(rewrite~!whiskerR_p...] 0.001 secs (0.001u,0.s)
Chars 8542 - 8591 [refine~(path2_universe_precomp...] 0.001 secs (0.001u,0.s)
Chars 8598 - 8657 [(abstract~(rewrite~!whiskerL_p...] 0.001 secs (0.001u,0.s)
Chars 8660 - 8668 [Defined.] 0.053 secs (0.051u,0.001s)
Chars 8845 - 9195 [Definition~id_center2_baut~`{U...] 0.003 secs (0.003u,0.s)
Chars 9198 - 9204 [Proof.] 0. secs (0.u,0.s)
Chars 8474 - 8515 [refine~(_~@~loopexp_path_unive...] 40.14 secs (0.001u,0.026s)
Chars 8518 - 8561 [refine~(transport_compose~idma...] 0.002 secs (0.002u,0.s)
Chars 8564 - 8609 [refine~(ap~(fun~p~=>~transport...] 0.003 secs (0.003u,0.s)
Chars 8612 - 8645 [(unfold~equiv_loopCircle_int;~...] 0.003 secs (0.002u,0.s)
Chars 8648 - 8676 [(unfold~Circle_decode;~simpl).] 0.008 secs (0.007u,0.001s)
Chars 8679 - 8698 [(rewrite~ap_loopexp).] 0.002 secs (0.002u,0.s)
Chars 8701 - 8738 [refine~(ap~(fun~p~=>~loopexp~p...] 0.002 secs (0.002u,0.s)
Chars 8741 - 8768 [(apply~Circle_rec_beta_loop).] 0.001 secs (0.001u,0.s)
Chars 8474 - 8515 [refine~(_~@~loopexp_path_unive...] 0. secs (0.u,0.s)
Chars 8518 - 8561 [refine~(transport_compose~idma...] 0. secs (0.u,0.s)
Chars 8564 - 8609 [refine~(ap~(fun~p~=>~transport...] 0. secs (0.u,0.s)
Chars 8612 - 8645 [(unfold~equiv_loopCircle_int;~...] 0.001 secs (0.001u,0.s)
Chars 8648 - 8676 [(unfold~Circle_decode;~simpl).] 0.005 secs (0.003u,0.001s)
Chars 8679 - 8698 [(rewrite~ap_loopexp).] 0. secs (0.u,0.s)
Chars 8701 - 8738 [refine~(ap~(fun~p~=>~loopexp~p...] 0. secs (0.u,0.s)
Chars 8741 - 8768 [(apply~Circle_rec_beta_loop).] 0.039 secs (0.02u,0.018s)
Chars 8769 - 8777 [Defined.] 0.022 secs (0.019u,0.002s)
Chars 8855 - 9007 [Definition~Circle_ind_dp~(P~:~...] 0.009 secs (0.008u,0.s)
Chars 9009 - 9146 [Definition~Circle_ind_dp_beta_...] 0.001 secs (0.001u,0.s)
Chars 9147 - 9153 [Proof.] 0. secs (0.u,0.s)
Chars 9156 - 9184 [(apply~dp_apD_path_transport).] 0.108 secs (0.002u,0.03s)
Chars 9187 - 9222 [exact~(Circle_ind_beta_loop~_~...] 0.001 secs (0.001u,0.s)
Chars 9156 - 9184 [(apply~dp_apD_path_transport).] 0. secs (0.u,0.s)
Chars 9187 - 9222 [exact~(Circle_ind_beta_loop~_~...] 0. secs (0.u,0.s)
Chars 9223 - 9231 [Defined.] 0.001 secs (0.001u,0.s)
find_witness Control.Timeoutfind_witness Fun.Finally_raised: Control.TimeoutChars 9209 - 9237 [(apply~path_forall;~intros~Z).] 40.201 secs (0.002u,0.036s)
Chars 9242 - 9295 [(assert~(IsHSet~(idpath~Z.1~=~...] 0.09 secs (0.077u,0.012s)
Chars 9300 - 9312 [baut_reduce.] 0.064 secs (0.058u,0.006s)
Chars 9317 - 9321 [(cbn).] 0.124 secs (0.122u,0.001s)
Chars 9322 - 9371 [(unfold~functor_forall,~sig_re...] 0.003 secs (0.002u,0.s)
Chars 9372 - 9376 [(cbn).] 0.005 secs (0.004u,0.s)
Chars 9381 - 9412 [(rewrite~equiv_path2_universe_1).] 0.013 secs (0.011u,0.001s)
Chars 9417 - 9448 [(rewrite~!concat_p1,~!concat_Vp).] 0.032 secs (0.024u,0.007s)
Chars 9453 - 9459 [(simpl).] 0.003 secs (0.003u,0.s)
Chars 9464 - 9495 [(rewrite~!concat_p1,~!concat_Vp).] 0.022 secs (0.014u,0.007s)
Chars 9500 - 9512 [reflexivity.] 0.002 secs (0.001u,0.s)
Chars 9209 - 9237 [(apply~path_forall;~intros~Z).] 0.001 secs (0.001u,0.s)
Chars 9242 - 9295 [(assert~(IsHSet~(idpath~Z.1~=~...] 0. secs (0.u,0.s)
Chars 9300 - 9312 [baut_reduce.] 0. secs (0.u,0.s)
Chars 9317 - 9321 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 9322 - 9371 [(unfold~functor_forall,~sig_re...] 0.002 secs (0.002u,0.s)
Chars 9372 - 9376 [(cbn).] 0.002 secs (0.002u,0.s)
Chars 9381 - 9412 [(rewrite~equiv_path2_universe_1).] 0.002 secs (0.002u,0.s)
Chars 9417 - 9448 [(rewrite~!concat_p1,~!concat_Vp).] 0.002 secs (0.002u,0.s)
Chars 9453 - 9459 [(simpl).] 0.001 secs (0.u,0.s)
Chars 9464 - 9495 [(rewrite~!concat_p1,~!concat_Vp).] 0.001 secs (0.001u,0.s)
Chars 9500 - 9512 [reflexivity.] 0. secs (0.u,0.s)
Chars 9515 - 9523 [Defined.] 0.052 secs (0.04u,0.011s)
Chars 9525 - 9541 [End~Center2BAut.] 0.08 secs (0.076u,0.003s)
Chars 9543 - 9567 [Section~ClassifyingMaps.] 0. secs (0.u,0.s)
Chars 9727 - 9788 [Definition~subuniverse_merely_...] 0. secs (0.u,0.s)
Chars 9791 - 9797 [Proof.] 0. secs (0.u,0.s)
     = {| unsigned := 1073745919; _unsigned_in_range := eq_refl |}
     : word64
If ffalse or nil then ;; else If ttrue then ;; else ;; end end
     : st
find_witness Control.TimeouttestMmatch@{i j} = 
fun x : Type@{i} => x
     : Type@{i} -> Type@{max(i,j)}
(* i j |=  *)

Arguments testMmatch _%type_scope
testMmatch'@{i j} = 
fun x : Type@{i} => x
     : Type@{i} -> Type@{j}
(* i j |= i <= j *)

Arguments testMmatch' _%type_scope
testret@{u u0} = 
fun x : Type@{u} => x
     : Type@{u} -> Type@{u0}
(* u u0 |= u <= u0 *)

Arguments testret _%type_scope
testexact@{u u0} : Type@{u} -> Type@{u0}
(* u u0 |= u <= u0 *)

testexact is universe polymorphic
Arguments testexact _%type_scope
testexact is opaque
Expands to: Constant Mtac2Tests.bug_universes.testexact
[DEBUG] {|
  case_ind := nat;
  case_val := 3;
  case_return := Dyn (fun _ : nat => bool);
  case_branches := [m: Dyn true
                     | Dyn (fun _ : nat => false)]
|}
find_witness Control.TimeoutChars 9802 - 9857 [rapply~(Build_Subuniverse~(fun...] 40.185 secs (0.014u,0.041s)
Chars 9862 - 9890 [(intros~T~U~mere_eq~f~iseq_f).] 0. secs (0.u,0.s)
Chars 9895 - 9913 [strip_truncations.] 0.047 secs (0.041u,0.005s)
Chars 9918 - 9955 [(pose~(feq~:=~Build_Equiv~_~_~...] 0. secs (0.u,0.s)
Chars 9960 - 9991 [exact~(tr~(mere_eq~oE~feq^-1)).] 0.001 secs (0.001u,0.s)
Chars 9802 - 9857 [rapply~(Build_Subuniverse~(fun...] 0. secs (0.u,0.s)
Chars 9862 - 9890 [(intros~T~U~mere_eq~f~iseq_f).] 0. secs (0.u,0.s)
Chars 9895 - 9913 [strip_truncations.] 0. secs (0.u,0.s)
Chars 9918 - 9955 [(pose~(feq~:=~Build_Equiv~_~_~...] 0. secs (0.u,0.s)
Chars 9960 - 9991 [exact~(tr~(mere_eq~oE~feq^-1)).] 0. secs (0.u,0.s)
Chars 9994 - 10002 [Defined.] 0. secs (0.u,0.s)
Chars 10105 - 10212 [Proposition~equiv_baut_typeO~`...] 0. secs (0.u,0.s)
Chars 10215 - 10221 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 10226 - 10271 [(srapply~equiv_functor_sigma_i...] 24.846 secs (9.373u,-0.465s)
Chars 10226 - 10271 [(srapply~equiv_functor_sigma_i...] 40.085 secs (0.002u,0.036s)
Chars 10276 - 10303 [rapply~Trunc_functor_equiv.] 0.001 secs (0.001u,0.s)
Chars 10308 - 10349 [exact~((equiv_path_universe~_~...] 0.001 secs (0.u,0.s)
Chars 10226 - 10271 [(srapply~equiv_functor_sigma_i...] 0. secs (0.u,0.s)
Chars 10276 - 10303 [rapply~Trunc_functor_equiv.] 0. secs (0.u,0.s)
Chars 10308 - 10349 [exact~((equiv_path_universe~_~...] 0. secs (0.u,0.s)
Chars 10352 - 10360 [Defined.] 0.016 secs (0.009u,0.006s)
Chars 10466 - 10620 [Corollary~equiv_map_baut_fibra...] 0.001 secs (0.001u,0.s)
Chars 10623 - 10629 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 10634 - 10684 [refine~(_~oE~equiv_postcompose...] 40.17 secs (0.001u,0.036s)
Chars 10689 - 10727 [refine~(_~oE~equiv_sigma_fibra...] 0.001 secs (0.001u,0.s)
Chars 10732 - 10773 [(snrapply~equiv_functor_sigma_...] 0.003 secs (0.003u,0.s)
Chars 10778 - 10818 [(rapply~equiv_functor_forall_i...] 0.003 secs (0.001u,0.001s)
Chars 10823 - 10852 [by~apply~Trunc_functor_equiv.] 0.004 secs (0.004u,0.s)
Chars 10634 - 10684 [refine~(_~oE~equiv_postcompose...] 0. secs (0.u,0.s)
Chars 10689 - 10727 [refine~(_~oE~equiv_sigma_fibra...] 0. secs (0.u,0.s)
Chars 10732 - 10773 [(snrapply~equiv_functor_sigma_...] 0. secs (0.u,0.s)
Chars 10778 - 10818 [(rapply~equiv_functor_forall_i...] 0. secs (0.u,0.s)
Chars 10823 - 10852 [by~apply~Trunc_functor_equiv.] 0. secs (0.u,0.s)
Chars 10855 - 10863 [Defined.] 0.001 secs (0.001u,0.s)
Chars 10925 - 11088 [Proposition~pequiv_pbaut_typeO...] 0.001 secs (0.001u,0.s)
Chars 11091 - 11097 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 11102 - 11130 [(snrapply~Build_pEquiv';~cbn).] 33.497 secs (17.872u,-0.442s)
find_witness Fun.Finally_raised: Control.TimeoutChars 11102 - 11130 [(snrapply~Build_pEquiv';~cbn).] 40.075 secs (0.004u,0.036s)
Chars 11135 - 11161 [1:~exact~equiv_baut_typeO.] 0. secs (0.u,0.s)
Chars 11166 - 11192 [by~apply~path_sigma_hprop.] 0.008 secs (0.006u,0.001s)
Chars 11102 - 11130 [(snrapply~Build_pEquiv';~cbn).] 0.001 secs (0.001u,0.s)
Chars 11135 - 11161 [1:~exact~equiv_baut_typeO.] 0. secs (0.u,0.s)
Chars 11166 - 11192 [by~apply~path_sigma_hprop.] 0. secs (0.u,0.s)
Chars 11195 - 11203 [Defined.] 0.001 secs (0.001u,0.s)
Chars 11207 - 11557 [Definition~equiv_pmap_pbaut_pf...] 0.01 secs (0.009u,0.s)
Chars 11689 - 11860 [Proposition~equiv_pmap_pbaut_t...] 0.001 secs (0.001u,0.s)
Chars 11863 - 11869 [Proof.] 0. secs (0.u,0.s)
find_witness Fun.Finally_raised: Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Fun.Finally_raised: Control.TimeoutChars 11874 - 11933 [refine~(_~oE~equiv_pequiv_post...] 40.151 secs (0.002u,0.036s)
Chars 11938 - 11977 [rapply~equiv_pmap_typeO_type_c...] 0.002 secs (0.002u,0.s)
Chars 11874 - 11933 [refine~(_~oE~equiv_pequiv_post...] 0. secs (0.u,0.s)
Chars 11938 - 11977 [rapply~equiv_pmap_typeO_type_c...] 0. secs (0.u,0.s)
Chars 11980 - 11988 [Defined.] 0.001 secs (0.001u,0.s)
Chars 12086 - 12291 [Definition~equiv_pmap_pbaut_pf...] 0.004 secs (0.004u,0.s)
Chars 12293 - 12313 [End~ClassifyingMaps.] 0.013 secs (0.012u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 1.019 secs (0.996u,0.021s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMM_2_HALTING_dec
     : decidable MM_2_HALTING
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMM_MMA2_HALTING
     : Halt_MM ⪯ MMA2_HALTING
find_witness Control.Timeoutfind_witness Control.TimeoutSR_undec
     : undecidable SR
find_witness Control.Timeoutfailed to eliminate the functional dependencies of
(fun (_ : PositiveMap.key) (F : PositiveMap.t A -> PositiveMap.t A)
   (_ : PositiveMap.t A) (b2 : PositiveMap.key) (y0 z : PositiveMap.t A) =>
 (fun (t _ : PositiveMap.t A) (k : PositiveMap.key) =>
  F
    match PositiveMap.find k y with
    | Some v => PositiveMap.add k v t
    | None => t
    end) z y0 b2)
failed to eliminate the functional dependencies of
(fun (_ : PositiveMap.key) (F : PositiveMap.t A -> PositiveMap.t A)
   (_ : PositiveMap.t A) (y0 : PositiveMap.key) (y z : PositiveMap.t A) =>
 (fun (t _ : PositiveMap.t A) (k : PositiveMap.key) =>
  F
    match PositiveMap.find k H with
    | Some v => PositiveMap.add k v t
    | None => t
    end) z y y0)
find_witness Control.TimeoutTSR_undec
     : undecidable TSR
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMMA2_HALTING_undec
     : undecidable MMA2_HALTING
LPolyNC_SAT_undec
     : undecidable LPolyNC_SAT
find_witness Control.TimeoutMMA2_HALTS_ON_ZERO_undec
     : undecidable MMA2_HALTS_ON_ZERO
OrdersEx.Nat_as_OT.add_0_r: forall n : nat, n + 0 = n
OrdersEx.Nat_as_DT.add_0_r: forall n : nat, n + 0 = n
Nat.add_0_r: forall n : nat, n + 0 = n
NPeano.Nat.add_0_r: forall n : nat, n + 0 = n
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
find_witness Control.TimeoutBuilding split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
More readable: initial segment:
(getPosition (elem F))
With remainder:
[Ast.tRel 0]
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
More readable: initial segment:
(getPosition (elem F))
With remainder:
[Ast.tRel 0]
Tactic call ran for 0.618 secs (0.59u,0.026s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.449 secs (0.392u,0.056s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.043 secs (0.041u,0.002s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.024 secs (0.024u,0.s) (success)
Proving eq_indep_types_of_eq_types...
More readable: initial segment:
(getPosition (elem F))
With remainder:
[Ast.tRel 0]
Tactic call ran for 1.287 secs (1.265u,0.019s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 2.792 secs (2.768u,0.019s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
find_witness Control.TimeoutMore readable: initial segment:
(getPosition (elem F))
With remainder:
[Ast.tRel 0]
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.03 secs (0.03u,0.s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Tactic call ran for 0.039 secs (0.039u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.017 secs (0.017u,0.s) (success)
Tactic call ran for 0.155 secs (0.152u,0.003s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.171 secs (0.17u,0.001s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
find_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(getPosition (elem F))
With remainder:
[Ast.tRel 0]
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Fun.Finally_raised: Control.Timeout"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted decode_nat)
"open obligation decode_nat_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
find_witness Control.TimeoutMore readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building base_eq_dec...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building ident_interp_Proper...
Building invertIdent...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building ident_index...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building eta_ident_cps_gen...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building simple_idents...
Building all_raw_idents...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building invert_bind_args...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building to_type_split_types_subst_default_eq...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building projT1_add_types_from_raw_sig_eq...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building unify...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.563 secs (0.556u,0.006s) (success)
Proving invert_bind_args_raw_to_typed...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Tactic call ran for 0.399 secs (0.386u,0.011s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.026 secs (0.026u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.023 secs (0.023u,0.s) (success)
Proving eq_indep_types_of_eq_types...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Tactic call ran for 1.321 secs (1.296u,0.022s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
find_witness Control.TimeoutMore readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Tactic call ran for 2.919 secs (2.837u,0.075s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.013 secs (0.013u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.043 secs (0.042u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
find_witness Control.TimeoutProving Rewriter_Wf...
Tactic call ran for 0.02 secs (0.02u,0.s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.13 secs (0.13u,0.s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 22.228 secs (21.92u,0.252s) (successful)
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
More readable: initial segment:
(VectorDef.cons Y)
With remainder:
[Ast.tApp (Ast.tVar "f") [Ast.tRel 2]; Ast.tRel 1;
 Ast.tApp (Ast.tRel 5) [Ast.tRel 1; Ast.tRel 0]]
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building split_raw_ident_gen...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building invert_bind_args...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
find_witness Control.TimeoutMore readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building to_type_split_types_subst_default_eq...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building projT1_add_types_from_raw_sig_eq...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
find_witness Control.TimeoutMore readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building unify...
find_witness Control.TimeoutMore readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building unify_unknown...
Building final ident package...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Proving is_simple_correct0...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Tactic call ran for 0.765 secs (0.757u,0.007s) (success)
Proving invert_bind_args_raw_to_typed...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Tactic call ran for 0.487 secs (0.473u,0.012s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.063 secs (0.061u,0.002s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.028 secs (0.028u,0.s) (success)
Proving eq_indep_types_of_eq_types...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Tactic call ran for 1.601 secs (1.574u,0.023s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Tactic call ran for 3.258 secs (3.233u,0.018s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Error: "'step' should not fail here" !
Building eta_base_cps...
Building base_interp...
find_witness Control.TimeoutBuilding all_base...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Reifying...
Building all_base_and_interp...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building index_of_ident...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building ident_interp...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building base_eq_dec...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building base_beq_and_reflect...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building base_beq...
Building reflect_base_beq...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building baseHasNatAndCorrect...
Building baseHasNat...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building baseHasNatCorrect...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building base_interp_beq...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building reflect_base_interp_beq...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building try_make_base_transport_cps...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building try_make_base_transport_cps_correct...
find_witness Control.TimeoutMore readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building all_idents...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
find_witness Control.TimeoutCompiling decision tree...
Building all_ident_and_interp...
Splitting rewrite rules...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Assembling rewrite_head...
Reducing rewrite_head...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building buildInterpEagerIdentCorrect...
Tactic call ran for 0.244 secs (0.238u,0.004s) (success)
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building toRestrictedIdentAndCorrect...
Tactic call ran for 0.327 secs (0.321u,0.004s) (success)
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Tactic call ran for 0.158 secs (0.155u,0.003s) (success)
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Proving Rewriter_Wf...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building buildIdentAndInterpCorrect...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Tactic call ran for 0.168 secs (0.168u,0.s) (success)
Building buildIdent...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building buildInterpIdentCorrect...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building ident_is_var_like...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building eqv_Reflexive_Proper...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Tactic call ran for 2.126 secs (2.079u,0.04s) (success)
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building ident_interp_Proper...
Building invertIdent...
Proving Rewriter_Interp...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building buildInvertIdentCorrect...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Tactic call ran for 0.606 secs (0.602u,0.002s) (success)
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building base_default...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building package...
Building all_base...
Tactic call ran for 1.27 secs (1.257u,0.011s) (success)
Building all_idents...
Building ident_index...
Assembling verified rewriter...
Refining with verified rewriter...
Building eta_ident_cps_gen...
More readable: initial segment:
(VectorDef.rect2
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n) =>
    VectorDef.t C n) (VectorDef.nil C)
   (fun (n : nat) (_ : VectorDef.t A n) (_ : VectorDef.t B n)
      (H : VectorDef.t C n) (a : A) (b : B) => VectorDef.cons C (g a b) n H))
With remainder:
[]
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
find_witness Control.TimeoutBuilding eta_raw_ident_cps_gen...
H10_H10Z
     : H10 ⪯ H10Z
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
find_witness Control.Timeoutfind_witness Control.TimeoutCould not solve some subgoal( "pos1" ):
(proc s)
could not simplify some occuring term, shelved instead
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
find_witness Control.TimeoutBuilding eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building to_type_split_types_subst_default_eq...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building projT1_add_types_from_raw_sig_eq...
Building reflect_base_interp_beq...
find_witness Control.TimeoutBuilding try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building arg_types_unfolded...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building type_of_list_arg_types_beq_unfolded...
Building ident_interp_Proper...
Building invertIdent...
Building to_typed_unfolded...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building of_typed_ident_unfolded...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building arg_types_of_typed_ident_unfolded...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building unify...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building unify_unknown...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building final ident package...
Building add_types_from_raw_sig...
Proving is_simple_correct0...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Tactic call ran for 1.038 secs (1.028u,0.008s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.584 secs (0.571u,0.011s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.146 secs (0.143u,0.003s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.04 secs (0.039u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Tactic call ran for 1.681 secs (1.648u,0.028s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.752 secs (0.741u,0.01s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.482 secs (0.47u,0.011s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.062 secs (0.057u,0.005s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.029 secs (0.029u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 3.193 secs (3.179u,0.008s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Tactic call ran for 1.522 secs (1.481u,0.039s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 3.132 secs (3.116u,0.01s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
find_witness Control.TimeoutReifying...
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Compiling decision tree...
Splitting rewrite rules...
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Assembling rewrite_head...
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Reducing rewrite_head...
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Tactic call ran for 0.244 secs (0.239u,0.003s) (success)
Compiling decision tree...
Tactic call ran for 0.357 secs (0.351u,0.004s) (success)
Tactic call ran for 0.158 secs (0.157u,0.001s) (success)
Splitting rewrite rules...
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Assembling rewrite_head_no_dtree...
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Reducing rewrite_head_no_dtree...
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Proving Rewriter_Wf...
find_witness Control.TimeoutCould not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Tactic call ran for 0.166 secs (0.163u,0.001s) (success)
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Tactic call ran for 2.126 secs (2.08u,0.039s) (success)
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Proving Rewriter_Interp...
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Assembling rewrite_head...
Tactic call ran for 0.61 secs (0.603u,0.005s) (success)
Reducing rewrite_head...
Tactic call ran for 0.654 secs (0.633u,0.019s) (success)
Tactic call ran for 1.255 secs (1.24u,0.012s) (success)
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 47.518 secs (46.926u,0.497s) (successful)
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted Heq)
"open obligation var_Heq_term for it. You might want to register a instance before and rerun this."
Success: (dlet y0 : Z := e1 + e2 in
          [y; y + 1; y + 2; y + y0; y + (y0 + 1)])
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted Hm')
"open obligation var_Hm'_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted Heq)
"open obligation var_Heq_term for it. You might want to register a instance before and rerun this."
Tactic call ran for 5.988 secs (5.945u,0.034s) (success)
Could not solve some subgoal( "pos1" ):
(proc s)
Success: [x1; x1; x1; x2; x2; x2; x3; x3; x3]
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Tactic call ran for 0.272 secs (0.271u,0.s) (success)
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted Hm')
"open obligation var_Hm'_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Hm')
"open obligation var_Hm'_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted Heq)
"open obligation var_Heq_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos1" ):
(proc s)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Assembling rewrite_head_no_dtree...
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Reducing rewrite_head_no_dtree...
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted Hm')
"open obligation var_Hm'_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Hm')
"open obligation var_Hm'_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos1" ):
(proc s)
could not simplify some occuring term, shelved instead
find_witness Control.Timeoutcould not simplify some occuring term, shelved instead
Proving Rewriter_Wf...
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted H)
"open obligation var_H_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted H)
"open obligation var_H_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Heq)
"open obligation var_Heq_term for it. You might want to register a instance before and rerun this."
Tactic call ran for 0.632 secs (0.624u,0.007s) (success)
Could not solve some subgoal( "pos1" ):
(proc s)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Tactic call ran for 3.489 secs (3.428u,0.055s) (success)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
could not simplify some occuring term, shelved instead
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Proving Rewriter_Interp...
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
could not simplify some occuring term, shelved instead
Tactic call ran for 1.319 secs (1.31u,0.007s) (success)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
find_witness Control.Timeoutcould not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
Tactic call ran for 1.918 secs (1.901u,0.014s) (success)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Assembling verified rewriter...
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
could not simplify some occuring term, shelved instead
Refining with verified rewriter...
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
could not simplify some occuring term, shelved instead
"Did not find an instance for "
(extracted eqb)
"open obligation var_eqb_term for it. You might want to register a instance before and rerun this."
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Finished transaction in 112.73 secs (111.41u,1.131s) (successful)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT m)) (extT n')))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Finished transaction in 3.465 secs (3.416u,0.04s) (successful)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Finished transaction in 3.587 secs (3.55u,0.031s) (successful)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
"Did not find an instance for "
(extracted eqb0)
"open obligation var_eqb0_term for it. You might want to register a instance before and rerun this."
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
could not simplify some occuring term, shelved instead
find_witness Control.Timeoutcould not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT 0)) (extT 0)))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT 0)) (extT 0)))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT 0)) (extT 0)))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT 0)) (extT 0)))
could not simplify some occuring term, shelved instead
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
More readable: initial segment:
eqb
With remainder:
[Ast.tRel 5; Ast.tRel 2]
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT l)) (extT l)))
find_witness Control.Timeout"Did not find an instance for "
(extracted eqb0)
"open obligation var_eqb0_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT 0)) (extT 0)))
"Did not find an instance for "
(extracted eqb0)
"open obligation var_eqb0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqb0)
"open obligation var_eqb0_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT 0)) (extT 0)))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT 0)) (extT 0)))
"Did not find an instance for "
(extracted eqb0)
"open obligation var_eqb0_term for it. You might want to register a instance before and rerun this."
Could not solve some subgoal( "pos3" ):
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT 0)) (extT 0)))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT 0)) (extT 0)))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT 0)) (extT 0)))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT 0)) (extT 0)))
Could not solve some subgoal( "pos3" ):
(proc
   (L.app
      (L.app
         (rho
            (lam
               (lam
                  (lam
                     (lam
                        (lam
                           (L.app
                              (L.app
                                 (L.app # 1
                                    (lam
                                       (L.app
                                          (L.app
                                             (L.app # 1 (lam (extT true)))
                                             (lam
                                                (lam (lam (lam (extT false))))))
                                          I)))
                                 (lam
                                    (lam
                                       (lam
                                          (lam
                                             (L.app
                                                (L.app
                                                 (L.app # 4
                                                 (lam (extT false)))
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (lam
                                                 (L.app 
                                                 (L.app ... ...)
                                                 (L.app ... # 1))))))) I))))))
                              I))))))) (extT n)) (extT n)))
simplified dependent [if true]
e : (x <? n1)  = true
if (x <? n1)
then (fun E0 : (x <? n1) = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : (x <? n1) = false =>
 BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 (ltN_plus_lemma1 e) E0)))
rewrite if_dtt
if (n1 + x <? n1)
then (fun E0 : (n1 + x <? n1) = true => AA (ltN_of_nat (n1 + x) n1 E0))
else
(fun E0 : (n1 + x <? n1) = false =>
 BB (ltN_of_nat (n1 + x - n1) n2 (ltN_split_lemma1 (plus_ltN_lemma1 e) E0)))
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (x0 <? n)
then
(fun E0 : (x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) x0 E0))
else
(fun E0 : (x0 <? n) = false =>
 BB (exist (fun k : nat => (k <? 0) = true) (x0 - n) (ltN_split_lemma1 e E0)))
destruct  (Nat.add_0_r n)  in  x
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if true]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if false]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (proj1_sig x =? proj1_sig k)
then (fun _ : (proj1_sig x =? proj1_sig k) = true => AA tt)
else
(fun E0 : (proj1_sig x =? proj1_sig k) = false =>
 BB
   ((if proj1_sig x <? proj1_sig k as b1
      return ((proj1_sig x <? proj1_sig k) = b1 -> ltN n)
     then
      fun E1 : (proj1_sig x <? proj1_sig k) = true =>
      ltN_of_nat (proj1_sig x) n (ltN_pop_lemma1 n k x E1)
     else
      fun E1 : (proj1_sig x <? proj1_sig k) = false =>
      ltN_of_nat (Init.Nat.pred (proj1_sig x)) n (ltN_pop_lemma2 n k x E1 E0))
      eq_refl))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout     = "YAPIGOLT"
     : string
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutrecRel_prettify_arith_step
recRel_prettify_arith_step
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(VectorDef.fold_left Init.Nat.max 0)
With remainder:
[Ast.tApp
   (Ast.tConst (Kernames.MPfile ["VectorDef"; "Vectors"; "Coq"], "map") [])
   [Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["TM"; "TM"; "Undecidability"], "tape") 0) [])
      [Ast.tVar "sig"];
    Ast.tInd
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0)
      [];
    Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["TM_facts"; "Util"; "TM"; "Undecidability"],
          "sizeOfTape") []) [Ast.tVar "sig"]; Ast.tVar "n"; 
    Ast.tRel 0]]
find_witness Control.TimeoutMore readable: initial segment:
(VectorDef.fold_left Init.Nat.max 0)
With remainder:
[Ast.tApp
   (Ast.tConst (Kernames.MPfile ["VectorDef"; "Vectors"; "Coq"], "map") [])
   [Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["TM"; "TM"; "Undecidability"], "tape") 0) [])
      [Ast.tVar "sig"];
    Ast.tInd
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0)
      [];
    Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["TM_facts"; "Util"; "TM"; "Undecidability"],
          "sizeOfTape") []) [Ast.tVar "sig"]; Ast.tVar "n"; 
    Ast.tRel 0]]
'exp_seqpoly_R' is now a registered translation.
Finished transaction in 69.462 secs (28.854u,0.317s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.TimeoutFinished transaction in 3.563 secs (3.543u,0.012s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 101.927 secs (61.074u,0.51s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 4.9 secs (4.839u,0.051s) (successful)
find_witness Control.Timeoutrewrite if_dtt
if
((fix eqb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => match m with
           | 0 => true
           | S _ => false
           end
    | S n' => match m with
              | 0 => false
              | S m' => eqb n' m'
              end
    end)
   (let (a, _) :=
      (if
        match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := H in a) m'
        end as b0
        return
          (match (let (a, _) := k in a) with
           | 0 => false
           | S m' =>
               (fix leb (n m : nat) {struct n} : bool :=
                  match n with
                  | 0 => true
                  | S n' =>
                      match m with
                      | 0 => false
                      | S m'0 => leb n' m'0
                      end
                  end) (let (a, _) := H in a) m'
           end = b0 ->
           {k : nat
           | (fix leb (n m : nat) {struct n} : bool :=
                match n with
                | 0 => true
                | S n' => match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                end) k (S n) = true})
       then
        fun
          E1 : match (let (a, _) := k in a) with
               | 0 => false
               | S m' =>
                   (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m'0 => leb n' m'0
                          end
                      end) (let (a, _) := H in a) m'
               end = true =>
        exist
          (fun k : nat =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
              end) k (S n) = true) (let (a, _) := H in a)
          (ltN_intro_lemma1 (S n) k H E1)
       else
        fun
          E1 : match (let (a, _) := k in a) with
               | 0 => false
               | S m' =>
                   (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m'0 => leb n' m'0
                          end
                      end) (let (a, _) := H in a) m'
               end = false =>
        exist
          (fun k : nat =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
              end) k (S n) = true) (S (let (a, _) := H in a))
          (ltN_intro_lemma2 (S n) k H E1)) eq_refl in
    a)
   (let (a, _) :=
      (if
        match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := x in a) m'
        end as b0
        return
          (match (let (a, _) := k in a) with
           | 0 => false
           | S m' =>
               (fix leb (n m : nat) {struct n} : bool :=
                  match n with
                  | 0 => true
                  | S n' =>
                      match m with
                      | 0 => false
                      | S m'0 => leb n' m'0
                      end
                  end) (let (a, _) := x in a) m'
           end = b0 ->
           {k : nat
           | (fix leb (n m : nat) {struct n} : bool :=
                match n with
                | 0 => true
                | S n' => match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                end) k (S n) = true})
       then
        fun
          E1 : match (let (a, _) := k in a) with
               | 0 => false
               | S m' =>
                   (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m'0 => leb n' m'0
                          end
                      end) (let (a, _) := x in a) m'
               end = true =>
        exist
          (fun k : nat =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
              end) k (S n) = true) (let (a, _) := x in a)
          (ltN_intro_lemma1 (S n) k x E1)
       else
        fun
          E1 : match (let (a, _) := k in a) with
               | 0 => false
               | S m' =>
                   (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m'0 => leb n' m'0
                          end
                      end) (let (a, _) := x in a) m'
               end = false =>
        exist
          (fun k : nat =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
              end) k (S n) = true) (S (let (a, _) := x in a))
          (ltN_intro_lemma2 (S n) k x E1)) eq_refl in
    a))
then
(fun
   _ : (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end)
         (let (a, _) :=
            (if
              match (let (a, _) := k in a) with
              | 0 => false
              | S m' =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
                     end) (let (a, _) := H in a) m'
              end as b0
              return
                (match (let (a, _) := k in a) with
                 | 0 => false
                 | S m' =>
                     (fix leb (n m : nat) {struct n} : bool :=
                        match n with
                        | 0 => true
                        | S n' =>
                            match m with
                            | 0 => false
                            | S m'0 => leb n' m'0
                            end
                        end) (let (a, _) := H in a) m'
                 end = b0 ->
                 {k : nat
                 | (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                      end) k (S n) = true})
             then
              fun
                E1 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := H in a) m'
                     end = true =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (let (a, _) := H in a)
                (ltN_intro_lemma1 (S n) k H E1)
             else
              fun
                E1 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := H in a) m'
                     end = false =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (S (let (a, _) := H in a))
                (ltN_intro_lemma2 (S n) k H E1)) eq_refl in
          a)
         (let (a, _) :=
            (if
              match (let (a, _) := k in a) with
              | 0 => false
              | S m' =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
                     end) (let (a, _) := x in a) m'
              end as b0
              return
                (match (let (a, _) := k in a) with
                 | 0 => false
                 | S m' =>
                     (fix leb (n m : nat) {struct n} : bool :=
                        match n with
                        | 0 => true
                        | S n' =>
                            match m with
                            | 0 => false
                            | S m'0 => leb n' m'0
                            end
                        end) (let (a, _) := x in a) m'
                 end = b0 ->
                 {k : nat
                 | (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                      end) k (S n) = true})
             then
              fun
                E1 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := x in a) m'
                     end = true =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (let (a, _) := x in a)
                (ltN_intro_lemma1 (S n) k x E1)
             else
              fun
                E1 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := x in a) m'
                     end = false =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (S (let (a, _) := x in a))
                (ltN_intro_lemma2 (S n) k x E1)) eq_refl in
          a) = true => AA tt)
else
(fun
   E0 : (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end)
          (let (a, _) :=
             (if
               match (let (a, _) := k in a) with
               | 0 => false
               | S m' =>
                   (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m'0 => leb n' m'0
                          end
                      end) (let (a, _) := H in a) m'
               end as b0
               return
                 (match (let (a, _) := k in a) with
                  | 0 => false
                  | S m' =>
                      (fix leb (n m : nat) {struct n} : bool :=
                         match n with
                         | 0 => true
                         | S n' =>
                             match m with
                             | 0 => false
                             | S m'0 => leb n' m'0
                             end
                         end) (let (a, _) := H in a) m'
                  end = b0 ->
                  {k : nat
                  | (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m' => leb n' m'
                           end
                       end) k (S n) = true})
              then
               fun
                 E1 : match (let (a, _) := k in a) with
                      | 0 => false
                      | S m' =>
                          (fix leb (n m : nat) {struct n} : bool :=
                             match n with
                             | 0 => true
                             | S n' =>
                                 match m with
                                 | 0 => false
                                 | S m'0 => leb n' m'0
                                 end
                             end) (let (a, _) := H in a) m'
                      end = true =>
               exist
                 (fun k : nat =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m' => leb n' m'
                         end
                     end) k (S n) = true) (let (a, _) := H in a)
                 (ltN_intro_lemma1 (S n) k H E1)
              else
               fun
                 E1 : match (let (a, _) := k in a) with
                      | 0 => false
                      | S m' =>
                          (fix leb (n m : nat) {struct n} : bool :=
                             match n with
                             | 0 => true
                             | S n' =>
                                 match m with
                                 | 0 => false
                                 | S m'0 => leb n' m'0
                                 end
                             end) (let (a, _) := H in a) m'
                      end = false =>
               exist
                 (fun k : nat =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m' => leb n' m'
                         end
                     end) k (S n) = true) (S (let (a, _) := H in a))
                 (ltN_intro_lemma2 (S n) k H E1)) eq_refl in
           a)
          (let (a, _) :=
             (if
               match (let (a, _) := k in a) with
               | 0 => false
               | S m' =>
                   (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m'0 => leb n' m'0
                          end
                      end) (let (a, _) := x in a) m'
               end as b0
               return
                 (match (let (a, _) := k in a) with
                  | 0 => false
                  | S m' =>
                      (fix leb (n m : nat) {struct n} : bool :=
                         match n with
                         | 0 => true
                         | S n' =>
                             match m with
                             | 0 => false
                             | S m'0 => leb n' m'0
                             end
                         end) (let (a, _) := x in a) m'
                  end = b0 ->
                  {k : nat
                  | (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m' => leb n' m'
                           end
                       end) k (S n) = true})
              then
               fun
                 E1 : match (let (a, _) := k in a) with
                      | 0 => false
                      | S m' =>
                          (fix leb (n m : nat) {struct n} : bool :=
                             match n with
                             | 0 => true
                             | S n' =>
                                 match m with
                                 | 0 => false
                                 | S m'0 => leb n' m'0
                                 end
                             end) (let (a, _) := x in a) m'
                      end = true =>
               exist
                 (fun k : nat =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m' => leb n' m'
                         end
                     end) k (S n) = true) (let (a, _) := x in a)
                 (ltN_intro_lemma1 (S n) k x E1)
              else
               fun
                 E1 : match (let (a, _) := k in a) with
                      | 0 => false
                      | S m' =>
                          (fix leb (n m : nat) {struct n} : bool :=
                             match n with
                             | 0 => true
                             | S n' =>
                                 match m with
                                 | 0 => false
                                 | S m'0 => leb n' m'0
                                 end
                             end) (let (a, _) := x in a) m'
                      end = false =>
               exist
                 (fun k : nat =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m' => leb n' m'
                         end
                     end) k (S n) = true) (S (let (a, _) := x in a))
                 (ltN_intro_lemma2 (S n) k x E1)) eq_refl in
           a) = false =>
 BB
   ((if
      match
        (let (a, _) :=
           (if
             match (let (a, _) := k in a) with
             | 0 => false
             | S m' =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
                    end) (let (a, _) := x in a) m'
             end as b0
             return
               (match (let (a, _) := k in a) with
                | 0 => false
                | S m' =>
                    (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m'0 => leb n' m'0
                           end
                       end) (let (a, _) := x in a) m'
                end = b0 ->
                {k : nat
                | (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m' => leb n' m'
                         end
                     end) k (S n) = true})
            then
             fun
               E1 : match (let (a, _) := k in a) with
                    | 0 => false
                    | S m' =>
                        (fix leb (n m : nat) {struct n} : bool :=
                           match n with
                           | 0 => true
                           | S n' =>
                               match m with
                               | 0 => false
                               | S m'0 => leb n' m'0
                               end
                           end) (let (a, _) := x in a) m'
                    end = true =>
             exist
               (fun k : nat =>
                (fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) k (S n) = true) (let (a, _) := x in a)
               (ltN_intro_lemma1 (S n) k x E1)
            else
             fun
               E1 : match (let (a, _) := k in a) with
                    | 0 => false
                    | S m' =>
                        (fix leb (n m : nat) {struct n} : bool :=
                           match n with
                           | 0 => true
                           | S n' =>
                               match m with
                               | 0 => false
                               | S m'0 => leb n' m'0
                               end
                           end) (let (a, _) := x in a) m'
                    end = false =>
             exist
               (fun k : nat =>
                (fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) k (S n) = true) (S (let (a, _) := x in a))
               (ltN_intro_lemma2 (S n) k x E1)) eq_refl in
         a)
      with
      | 0 => false
      | S m' =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m'0 => leb n' m'0
                       end
             end)
            (let (a, _) :=
               (if
                 match (let (a, _) := k in a) with
                 | 0 => false
                 | S m'0 =>
                     (fix leb (n m : nat) {struct n} : bool :=
                        match n with
                        | 0 => true
                        | S n' =>
                            match m with
                            | 0 => false
                            | S m'1 => leb n' m'1
                            end
                        end) (let (a, _) := H in a) m'0
                 end as b0
                 return
                   (match (let (a, _) := k in a) with
                    | 0 => false
                    | S m'0 =>
                        (fix leb (n m : nat) {struct n} : bool :=
                           match n with
                           | 0 => true
                           | S n' =>
                               match m with
                               | 0 => false
                               | S m'1 => leb n' m'1
                               end
                           end) (let (a, _) := H in a) m'0
                    end = b0 ->
                    {k : nat
                    | (fix leb (n m : nat) {struct n} : bool :=
                         match n with
                         | 0 => true
                         | S n' =>
                             match m with
                             | 0 => false
                             | S m'0 => leb n' m'0
                             end
                         end) k (S n) = true})
                then
                 fun
                   E1 : match (let (a, _) := k in a) with
                        | 0 => false
                        | S m'0 =>
                            (fix leb (n m : nat) {struct n} : bool :=
                               match n with
                               | 0 => true
                               | S n' =>
                                   match m with
                                   | 0 => false
                                   | S m'1 => leb n' m'1
                                   end
                               end) (let (a, _) := H in a) m'0
                        end = true =>
                 exist
                   (fun k : nat =>
                    (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m'0 => leb n' m'0
                           end
                       end) k (S n) = true) (let (a, _) := H in a)
                   (ltN_intro_lemma1 (S n) k H E1)
                else
                 fun
                   E1 : match (let (a, _) := k in a) with
                        | 0 => false
                        | S m'0 =>
                            (fix leb (n m : nat) {struct n} : bool :=
                               match n with
                               | 0 => true
                               | S n' =>
                                   match m with
                                   | 0 => false
                                   | S m'1 => leb n' m'1
                                   end
                               end) (let (a, _) := H in a) m'0
                        end = false =>
                 exist
                   (fun k : nat =>
                    (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m'0 => leb n' m'0
                           end
                       end) k (S n) = true) (S (let (a, _) := H in a))
                   (ltN_intro_lemma2 (S n) k H E1)) eq_refl in
             a) m'
      end as b1
      return
        (match
           (let (a, _) :=
              (if
                match (let (a, _) := k in a) with
                | 0 => false
                | S m' =>
                    (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m'0 => leb n' m'0
                           end
                       end) (let (a, _) := x in a) m'
                end as b0
                return
                  (match (let (a, _) := k in a) with
                   | 0 => false
                   | S m' =>
                       (fix leb (n m : nat) {struct n} : bool :=
                          match n with
                          | 0 => true
                          | S n' =>
                              match m with
                              | 0 => false
                              | S m'0 => leb n' m'0
                              end
                          end) (let (a, _) := x in a) m'
                   end = b0 ->
                   {k : nat
                   | (fix leb (n m : nat) {struct n} : bool :=
                        match n with
                        | 0 => true
                        | S n' =>
                            match m with
                            | 0 => false
                            | S m' => leb n' m'
                            end
                        end) k (S n) = true})
               then
                fun
                  E1 : match (let (a, _) := k in a) with
                       | 0 => false
                       | S m' =>
                           (fix leb (n m : nat) {struct n} : bool :=
                              match n with
                              | 0 => true
                              | S n' =>
                                  match m with
                                  | 0 => false
                                  | S m'0 => leb n' m'0
                                  end
                              end) (let (a, _) := x in a) m'
                       end = true =>
                exist
                  (fun k : nat =>
                   (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                      end) k (S n) = true) (let (a, _) := x in a)
                  (ltN_intro_lemma1 (S n) k x E1)
               else
                fun
                  E1 : match (let (a, _) := k in a) with
                       | 0 => false
                       | S m' =>
                           (fix leb (n m : nat) {struct n} : bool :=
                              match n with
                              | 0 => true
                              | S n' =>
                                  match m with
                                  | 0 => false
                                  | S m'0 => leb n' m'0
                                  end
                              end) (let (a, _) := x in a) m'
                       end = false =>
                exist
                  (fun k : nat =>
                   (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                      end) k (S n) = true) (S (let (a, _) := x in a))
                  (ltN_intro_lemma2 (S n) k x E1)) eq_refl in
            a)
         with
         | 0 => false
         | S m' =>
             (fix leb (n m : nat) {struct n} : bool :=
                match n with
                | 0 => true
                | S n' => match m with
                          | 0 => false
                          | S m'0 => leb n' m'0
                          end
                end)
               (let (a, _) :=
                  (if
                    match (let (a, _) := k in a) with
                    | 0 => false
                    | S m'0 =>
                        (fix leb (n m : nat) {struct n} : bool :=
                           match n with
                           | 0 => true
                           | S n' =>
                               match m with
                               | 0 => false
                               | S m'1 => leb n' m'1
                               end
                           end) (let (a, _) := H in a) m'0
                    end as b0
                    return
                      (match (let (a, _) := k in a) with
                       | 0 => false
                       | S m'0 =>
                           (fix leb (n m : nat) {struct n} : bool :=
                              match n with
                              | 0 => true
                              | S n' =>
                                  match m with
                                  | 0 => false
                                  | S m'1 => leb n' m'1
                                  end
                              end) (let (a, _) := H in a) m'0
                       end = b0 ->
                       {k : nat
                       | (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) k (S n) = true})
                   then
                    fun
                      E1 : match (let (a, _) := k in a) with
                           | 0 => false
                           | S m'0 =>
                               (fix leb (n m : nat) {struct n} : bool :=
                                  match n with
                                  | 0 => true
                                  | S n' =>
                                      match m with
                                      | 0 => false
                                      | S m'1 => leb n' m'1
                                      end
                                  end) (let (a, _) := H in a) m'0
                           end = true =>
                    exist
                      (fun k : nat =>
                       (fix leb (n m : nat) {struct n} : bool :=
                          match n with
                          | 0 => true
                          | S n' =>
                              match m with
                              | 0 => false
                              | S m'0 => leb n' m'0
                              end
                          end) k (S n) = true) (let (a, _) := H in a)
                      (ltN_intro_lemma1 (S n) k H E1)
                   else
                    fun
                      E1 : match (let (a, _) := k in a) with
                           | 0 => false
                           | S m'0 =>
                               (fix leb (n m : nat) {struct n} : bool :=
                                  match n with
                                  | 0 => true
                                  | S n' =>
                                      match m with
                                      | 0 => false
                                      | S m'1 => leb n' m'1
                                      end
                                  end) (let (a, _) := H in a) m'0
                           end = false =>
                    exist
                      (fun k : nat =>
                       (fix leb (n m : nat) {struct n} : bool :=
                          match n with
                          | 0 => true
                          | S n' =>
                              match m with
                              | 0 => false
                              | S m'0 => leb n' m'0
                              end
                          end) k (S n) = true) (S (let (a, _) := H in a))
                      (ltN_intro_lemma2 (S n) k H E1)) eq_refl in
                a) m'
         end = b1 ->
         {k : nat
         | (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
              end) k n = true})
     then
      fun
        E1 : match
               (let (a, _) :=
                  (if
                    match (let (a, _) := k in a) with
                    | 0 => false
                    | S m' =>
                        (fix leb (n m : nat) {struct n} : bool :=
                           match n with
                           | 0 => true
                           | S n' =>
                               match m with
                               | 0 => false
                               | S m'0 => leb n' m'0
                               end
                           end) (let (a, _) := x in a) m'
                    end as b0
                    return
                      (match (let (a, _) := k in a) with
                       | 0 => false
                       | S m' =>
                           (fix leb (n m : nat) {struct n} : bool :=
                              match n with
                              | 0 => true
                              | S n' =>
                                  match m with
                                  | 0 => false
                                  | S m'0 => leb n' m'0
                                  end
                              end) (let (a, _) := x in a) m'
                       end = b0 ->
                       {k : nat
                       | (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m' => leb n' m'
                                end
                            end) k (S n) = true})
                   then
                    fun
                      E1 : match (let (a, _) := k in a) with
                           | 0 => false
                           | S m' =>
                               (fix leb (n m : nat) {struct n} : bool :=
                                  match n with
                                  | 0 => true
                                  | S n' =>
                                      match m with
                                      | 0 => false
                                      | S m'0 => leb n' m'0
                                      end
                                  end) (let (a, _) := x in a) m'
                           end = true =>
                    exist
                      (fun k : nat =>
                       (fix leb (n m : nat) {struct n} : bool :=
                          match n with
                          | 0 => true
                          | S n' =>
                              match m with
                              | 0 => false
                              | S m' => leb n' m'
                              end
                          end) k (S n) = true) (let (a, _) := x in a)
                      (ltN_intro_lemma1 (S n) k x E1)
                   else
                    fun
                      E1 : match (let (a, _) := k in a) with
                           | 0 => false
                           | S m' =>
                               (fix leb (n m : nat) {struct n} : bool :=
                                  match n with
                                  | 0 => true
                                  | S n' =>
                                      match m with
                                      | 0 => false
                                      | S m'0 => leb n' m'0
                                      end
                                  end) (let (a, _) := x in a) m'
                           end = false =>
                    exist
                      (fun k : nat =>
                       (fix leb (n m : nat) {struct n} : bool :=
                          match n with
                          | 0 => true
                          | S n' =>
                              match m with
                              | 0 => false
                              | S m' => leb n' m'
                              end
                          end) k (S n) = true) (S (let (a, _) := x in a))
                      (ltN_intro_lemma2 (S n) k x E1)) eq_refl in
                a)
             with
             | 0 => false
             | S m' =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
                    end)
                   (let (a, _) :=
                      (if
                        match (let (a, _) := k in a) with
                        | 0 => false
                        | S m'0 =>
                            (fix leb (n m : nat) {struct n} : bool :=
                               match n with
                               | 0 => true
                               | S n' =>
                                   match m with
                                   | 0 => false
                                   | S m'1 => leb n' m'1
                                   end
                               end) (let (a, _) := H in a) m'0
                        end as b0
                        return
                          (match (let (a, _) := k in a) with
                           | 0 => false
                           | S m'0 =>
                               (fix leb (n m : nat) {struct n} : bool :=
                                  match n with
                                  | 0 => true
                                  | S n' =>
                                      match m with
                                      | 0 => false
                                      | S m'1 => leb n' m'1
                                      end
                                  end) (let (a, _) := H in a) m'0
                           end = b0 ->
                           {k : nat
                           | (fix leb (n m : nat) {struct n} : bool :=
                                match n with
                                | 0 => true
                                | S n' =>
                                    match m with
                                    | 0 => false
                                    | S m'0 => leb n' m'0
                                    end
                                end) k (S n) = true})
                       then
                        fun
                          E1 : match (let (a, _) := k in a) with
                               | 0 => false
                               | S m'0 =>
                                   (fix leb (n m : nat) {struct n} : bool :=
                                      match n with
                                      | 0 => true
                                      | S n' =>
                                          match m with
                                          | 0 => false
                                          | S m'1 => leb n' m'1
                                          end
                                      end) (let (a, _) := H in a) m'0
                               end = true =>
                        exist
                          (fun k : nat =>
                           (fix leb (n m : nat) {struct n} : bool :=
                              match n with
                              | 0 => true
                              | S n' =>
                                  match m with
                                  | 0 => false
                                  | S m'0 => leb n' m'0
                                  end
                              end) k (S n) = true) 
                          (let (a, _) := H in a)
                          (ltN_intro_lemma1 (S n) k H E1)
                       else
                        fun
                          E1 : match (let (a, _) := k in a) with
                               | 0 => false
                               | S m'0 =>
                                   (fix leb (n m : nat) {struct n} : bool :=
                                      match n with
                                      | 0 => true
                                      | S n' =>
                                          match m with
                                          | 0 => false
                                          | S m'1 => leb n' m'1
                                          end
                                      end) (let (a, _) := H in a) m'0
                               end = false =>
                        exist
                          (fun k : nat =>
                           (fix leb (n m : nat) {struct n} : bool :=
                              match n with
                              | 0 => true
                              | S n' =>
                                  match m with
                                  | 0 => false
                                  | S m'0 => leb n' m'0
                                  end
                              end) k (S n) = true) 
                          (S (let (a, _) := H in a))
                          (ltN_intro_lemma2 (S n) k H E1)) eq_refl in
                    a) m'
             end = true =>
      exist
        (fun k : nat =>
         (fix leb (n m : nat) {struct n} : bool :=
            match n with
            | 0 => true
            | S n' => match m with
                      | 0 => false
                      | S m' => leb n' m'
                      end
            end) k n = true)
        (let (a, _) :=
           (if
             match (let (a, _) := k in a) with
             | 0 => false
             | S m' =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
                    end) (let (a, _) := H in a) m'
             end as b0
             return
               (match (let (a, _) := k in a) with
                | 0 => false
                | S m' =>
                    (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m'0 => leb n' m'0
                           end
                       end) (let (a, _) := H in a) m'
                end = b0 ->
                {k : nat
                | (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m' => leb n' m'
                         end
                     end) k (S n) = true})
            then
             fun
               E2 : match (let (a, _) := k in a) with
                    | 0 => false
                    | S m' =>
                        (fix leb (n m : nat) {struct n} : bool :=
                           match n with
                           | 0 => true
                           | S n' =>
                               match m with
                               | 0 => false
                               | S m'0 => leb n' m'0
                               end
                           end) (let (a, _) := H in a) m'
                    end = true =>
             exist
               (fun k : nat =>
                (fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) k (S n) = true) (let (a, _) := H in a)
               (ltN_intro_lemma1 (S n) k H E2)
            else
             fun
               E2 : match (let (a, _) := k in a) with
                    | 0 => false
                    | S m' =>
                        (fix leb (n m : nat) {struct n} : bool :=
                           match n with
                           | 0 => true
                           | S n' =>
                               match m with
                               | 0 => false
                               | S m'0 => leb n' m'0
                               end
                           end) (let (a, _) := H in a) m'
                    end = false =>
             exist
               (fun k : nat =>
                (fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) k (S n) = true) (S (let (a, _) := H in a))
               (ltN_intro_lemma2 (S n) k H E2)) eq_refl in
         a)
        (ltN_pop_lemma1 (S n)
           ((if
              match (let (a, _) := k in a) with
              | 0 => false
              | S m' =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
                     end) (let (a, _) := x in a) m'
              end as b0
              return
                (match (let (a, _) := k in a) with
                 | 0 => false
                 | S m' =>
                     (fix leb (n m : nat) {struct n} : bool :=
                        match n with
                        | 0 => true
                        | S n' =>
                            match m with
                            | 0 => false
                            | S m'0 => leb n' m'0
                            end
                        end) (let (a, _) := x in a) m'
                 end = b0 ->
                 {k : nat
                 | (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                      end) k (S n) = true})
             then
              fun
                E2 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := x in a) m'
                     end = true =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (let (a, _) := x in a)
                (ltN_intro_lemma1 (S n) k x E2)
             else
              fun
                E2 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := x in a) m'
                     end = false =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (S (let (a, _) := x in a))
                (ltN_intro_lemma2 (S n) k x E2)) eq_refl)
           ((if
              match (let (a, _) := k in a) with
              | 0 => false
              | S m' =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
                     end) (let (a, _) := H in a) m'
              end as b0
              return
                (match (let (a, _) := k in a) with
                 | 0 => false
                 | S m' =>
                     (fix leb (n m : nat) {struct n} : bool :=
                        match n with
                        | 0 => true
                        | S n' =>
                            match m with
                            | 0 => false
                            | S m'0 => leb n' m'0
                            end
                        end) (let (a, _) := H in a) m'
                 end = b0 ->
                 {k : nat
                 | (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                      end) k (S n) = true})
             then
              fun
                E2 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := H in a) m'
                     end = true =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (let (a, _) := H in a)
                (ltN_intro_lemma1 (S n) k H E2)
             else
              fun
                E2 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := H in a) m'
                     end = false =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (S (let (a, _) := H in a))
                (ltN_intro_lemma2 (S n) k H E2)) eq_refl) E1)
     else
      fun
        E1 : match
               (let (a, _) :=
                  (if
                    match (let (a, _) := k in a) with
                    | 0 => false
                    | S m' =>
                        (fix leb (n m : nat) {struct n} : bool :=
                           match n with
                           | 0 => true
                           | S n' =>
                               match m with
                               | 0 => false
                               | S m'0 => leb n' m'0
                               end
                           end) (let (a, _) := x in a) m'
                    end as b0
                    return
                      (match (let (a, _) := k in a) with
                       | 0 => false
                       | S m' =>
                           (fix leb (n m : nat) {struct n} : bool :=
                              match n with
                              | 0 => true
                              | S n' =>
                                  match m with
                                  | 0 => false
                                  | S m'0 => leb n' m'0
                                  end
                              end) (let (a, _) := x in a) m'
                       end = b0 ->
                       {k : nat
                       | (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m' => leb n' m'
                                end
                            end) k (S n) = true})
                   then
                    fun
                      E1 : match (let (a, _) := k in a) with
                           | 0 => false
                           | S m' =>
                               (fix leb (n m : nat) {struct n} : bool :=
                                  match n with
                                  | 0 => true
                                  | S n' =>
                                      match m with
                                      | 0 => false
                                      | S m'0 => leb n' m'0
                                      end
                                  end) (let (a, _) := x in a) m'
                           end = true =>
                    exist
                      (fun k : nat =>
                       (fix leb (n m : nat) {struct n} : bool :=
                          match n with
                          | 0 => true
                          | S n' =>
                              match m with
                              | 0 => false
                              | S m' => leb n' m'
                              end
                          end) k (S n) = true) (let (a, _) := x in a)
                      (ltN_intro_lemma1 (S n) k x E1)
                   else
                    fun
                      E1 : match (let (a, _) := k in a) with
                           | 0 => false
                           | S m' =>
                               (fix leb (n m : nat) {struct n} : bool :=
                                  match n with
                                  | 0 => true
                                  | S n' =>
                                      match m with
                                      | 0 => false
                                      | S m'0 => leb n' m'0
                                      end
                                  end) (let (a, _) := x in a) m'
                           end = false =>
                    exist
                      (fun k : nat =>
                       (fix leb (n m : nat) {struct n} : bool :=
                          match n with
                          | 0 => true
                          | S n' =>
                              match m with
                              | 0 => false
                              | S m' => leb n' m'
                              end
                          end) k (S n) = true) (S (let (a, _) := x in a))
                      (ltN_intro_lemma2 (S n) k x E1)) eq_refl in
                a)
             with
             | 0 => false
             | S m' =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
                    end)
                   (let (a, _) :=
                      (if
                        match (let (a, _) := k in a) with
                        | 0 => false
                        | S m'0 =>
                            (fix leb (n m : nat) {struct n} : bool :=
                               match n with
                               | 0 => true
                               | S n' =>
                                   match m with
                                   | 0 => false
                                   | S m'1 => leb n' m'1
                                   end
                               end) (let (a, _) := H in a) m'0
                        end as b0
                        return
                          (match (let (a, _) := k in a) with
                           | 0 => false
                           | S m'0 =>
                               (fix leb (n m : nat) {struct n} : bool :=
                                  match n with
                                  | 0 => true
                                  | S n' =>
                                      match m with
                                      | 0 => false
                                      | S m'1 => leb n' m'1
                                      end
                                  end) (let (a, _) := H in a) m'0
                           end = b0 ->
                           {k : nat
                           | (fix leb (n m : nat) {struct n} : bool :=
                                match n with
                                | 0 => true
                                | S n' =>
                                    match m with
                                    | 0 => false
                                    | S m'0 => leb n' m'0
                                    end
                                end) k (S n) = true})
                       then
                        fun
                          E1 : match (let (a, _) := k in a) with
                               | 0 => false
                               | S m'0 =>
                                   (fix leb (n m : nat) {struct n} : bool :=
                                      match n with
                                      | 0 => true
                                      | S n' =>
                                          match m with
                                          | 0 => false
                                          | S m'1 => leb n' m'1
                                          end
                                      end) (let (a, _) := H in a) m'0
                               end = true =>
                        exist
                          (fun k : nat =>
                           (fix leb (n m : nat) {struct n} : bool :=
                              match n with
                              | 0 => true
                              | S n' =>
                                  match m with
                                  | 0 => false
                                  | S m'0 => leb n' m'0
                                  end
                              end) k (S n) = true) 
                          (let (a, _) := H in a)
                          (ltN_intro_lemma1 (S n) k H E1)
                       else
                        fun
                          E1 : match (let (a, _) := k in a) with
                               | 0 => false
                               | S m'0 =>
                                   (fix leb (n m : nat) {struct n} : bool :=
                                      match n with
                                      | 0 => true
                                      | S n' =>
                                          match m with
                                          | 0 => false
                                          | S m'1 => leb n' m'1
                                          end
                                      end) (let (a, _) := H in a) m'0
                               end = false =>
                        exist
                          (fun k : nat =>
                           (fix leb (n m : nat) {struct n} : bool :=
                              match n with
                              | 0 => true
                              | S n' =>
                                  match m with
                                  | 0 => false
                                  | S m'0 => leb n' m'0
                                  end
                              end) k (S n) = true) 
                          (S (let (a, _) := H in a))
                          (ltN_intro_lemma2 (S n) k H E1)) eq_refl in
                    a) m'
             end = false =>
      exist
        (fun k : nat =>
         (fix leb (n m : nat) {struct n} : bool :=
            match n with
            | 0 => true
            | S n' => match m with
                      | 0 => false
                      | S m' => leb n' m'
                      end
            end) k n = true)
        match
          (let (a, _) :=
             (if
               match (let (a, _) := k in a) with
               | 0 => false
               | S m' =>
                   (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m'0 => leb n' m'0
                          end
                      end) (let (a, _) := H in a) m'
               end as b0
               return
                 (match (let (a, _) := k in a) with
                  | 0 => false
                  | S m' =>
                      (fix leb (n m : nat) {struct n} : bool :=
                         match n with
                         | 0 => true
                         | S n' =>
                             match m with
                             | 0 => false
                             | S m'0 => leb n' m'0
                             end
                         end) (let (a, _) := H in a) m'
                  end = b0 ->
                  {k : nat
                  | (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m' => leb n' m'
                           end
                       end) k (S n) = true})
              then
               fun
                 E2 : match (let (a, _) := k in a) with
                      | 0 => false
                      | S m' =>
                          (fix leb (n m : nat) {struct n} : bool :=
                             match n with
                             | 0 => true
                             | S n' =>
                                 match m with
                                 | 0 => false
                                 | S m'0 => leb n' m'0
                                 end
                             end) (let (a, _) := H in a) m'
                      end = true =>
               exist
                 (fun k : nat =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m' => leb n' m'
                         end
                     end) k (S n) = true) (let (a, _) := H in a)
                 (ltN_intro_lemma1 (S n) k H E2)
              else
               fun
                 E2 : match (let (a, _) := k in a) with
                      | 0 => false
                      | S m' =>
                          (fix leb (n m : nat) {struct n} : bool :=
                             match n with
                             | 0 => true
                             | S n' =>
                                 match m with
                                 | 0 => false
                                 | S m'0 => leb n' m'0
                                 end
                             end) (let (a, _) := H in a) m'
                      end = false =>
               exist
                 (fun k : nat =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m' => leb n' m'
                         end
                     end) k (S n) = true) (S (let (a, _) := H in a))
                 (ltN_intro_lemma2 (S n) k H E2)) eq_refl in
           a)
        with
        | 0 =>
            let (a, _) :=
              (if
                match (let (a, _) := k in a) with
                | 0 => false
                | S m' =>
                    (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m'0 => leb n' m'0
                           end
                       end) (let (a, _) := H in a) m'
                end as b0
                return
                  (match (let (a, _) := k in a) with
                   | 0 => false
                   | S m' =>
                       (fix leb (n m : nat) {struct n} : bool :=
                          match n with
                          | 0 => true
                          | S n' =>
                              match m with
                              | 0 => false
                              | S m'0 => leb n' m'0
                              end
                          end) (let (a, _) := H in a) m'
                   end = b0 ->
                   {k : nat
                   | (fix leb (n m : nat) {struct n} : bool :=
                        match n with
                        | 0 => true
                        | S n' =>
                            match m with
                            | 0 => false
                            | S m' => leb n' m'
                            end
                        end) k (S n) = true})
               then
                fun
                  E2 : match (let (a, _) := k in a) with
                       | 0 => false
                       | S m' =>
                           (fix leb (n m : nat) {struct n} : bool :=
                              match n with
                              | 0 => true
                              | S n' =>
                                  match m with
                                  | 0 => false
                                  | S m'0 => leb n' m'0
                                  end
                              end) (let (a, _) := H in a) m'
                       end = true =>
                exist
                  (fun k : nat =>
                   (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                      end) k (S n) = true) (let (a, _) := H in a)
                  (ltN_intro_lemma1 (S n) k H E2)
               else
                fun
                  E2 : match (let (a, _) := k in a) with
                       | 0 => false
                       | S m' =>
                           (fix leb (n m : nat) {struct n} : bool :=
                              match n with
                              | 0 => true
                              | S n' =>
                                  match m with
                                  | 0 => false
                                  | S m'0 => leb n' m'0
                                  end
                              end) (let (a, _) := H in a) m'
                       end = false =>
                exist
                  (fun k : nat =>
                   (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                      end) k (S n) = true) (S (let (a, _) := H in a))
                  (ltN_intro_lemma2 (S n) k H E2)) eq_refl in
            a
        | S u => u
        end
        (ltN_pop_lemma2 (S n)
           ((if
              match (let (a, _) := k in a) with
              | 0 => false
              | S m' =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
                     end) (let (a, _) := x in a) m'
              end as b0
              return
                (match (let (a, _) := k in a) with
                 | 0 => false
                 | S m' =>
                     (fix leb (n m : nat) {struct n} : bool :=
                        match n with
                        | 0 => true
                        | S n' =>
                            match m with
                            | 0 => false
                            | S m'0 => leb n' m'0
                            end
                        end) (let (a, _) := x in a) m'
                 end = b0 ->
                 {k : nat
                 | (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                      end) k (S n) = true})
             then
              fun
                E2 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := x in a) m'
                     end = true =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (let (a, _) := x in a)
                (ltN_intro_lemma1 (S n) k x E2)
             else
              fun
                E2 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := x in a) m'
                     end = false =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (S (let (a, _) := x in a))
                (ltN_intro_lemma2 (S n) k x E2)) eq_refl)
           ((if
              match (let (a, _) := k in a) with
              | 0 => false
              | S m' =>
                  (fix leb (n m : nat) {struct n} : bool :=
                     match n with
                     | 0 => true
                     | S n' =>
                         match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
                     end) (let (a, _) := H in a) m'
              end as b0
              return
                (match (let (a, _) := k in a) with
                 | 0 => false
                 | S m' =>
                     (fix leb (n m : nat) {struct n} : bool :=
                        match n with
                        | 0 => true
                        | S n' =>
                            match m with
                            | 0 => false
                            | S m'0 => leb n' m'0
                            end
                        end) (let (a, _) := H in a) m'
                 end = b0 ->
                 {k : nat
                 | (fix leb (n m : nat) {struct n} : bool :=
                      match n with
                      | 0 => true
                      | S n' =>
                          match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                      end) k (S n) = true})
             then
              fun
                E2 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := H in a) m'
                     end = true =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (let (a, _) := H in a)
                (ltN_intro_lemma1 (S n) k H E2)
             else
              fun
                E2 : match (let (a, _) := k in a) with
                     | 0 => false
                     | S m' =>
                         (fix leb (n m : nat) {struct n} : bool :=
                            match n with
                            | 0 => true
                            | S n' =>
                                match m with
                                | 0 => false
                                | S m'0 => leb n' m'0
                                end
                            end) (let (a, _) := H in a) m'
                     end = false =>
              exist
                (fun k : nat =>
                 (fix leb (n m : nat) {struct n} : bool :=
                    match n with
                    | 0 => true
                    | S n' =>
                        match m with
                        | 0 => false
                        | S m' => leb n' m'
                        end
                    end) k (S n) = true) (S (let (a, _) := H in a))
                (ltN_intro_lemma2 (S n) k H E2)) eq_refl) E1 E0)) eq_refl))
rewrite if_dtt
if (proj1_sig y <? proj1_sig Hxltx0)
then
(fun E1 : (proj1_sig y <? proj1_sig Hxltx0) = true =>
 ltN_of_nat (proj1_sig y) (S (S E)) (ltN_intro_lemma1 (S E) Hxltx0 y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig Hxltx0) = false =>
 ltN_of_nat (S (proj1_sig y)) (S (S E)) (ltN_intro_lemma2 (S E) Hxltx0 y E1))
rewrite if_dtt
if (proj1_sig m <? proj1_sig Hxltx0)
then
(fun E1 : (proj1_sig m <? proj1_sig Hxltx0) = true =>
 ltN_of_nat (proj1_sig m) (S (S E)) (ltN_intro_lemma1 (S E) Hxltx0 m E1))
else
(fun E1 : (proj1_sig m <? proj1_sig Hxltx0) = false =>
 ltN_of_nat (S (proj1_sig m)) (S (S E)) (ltN_intro_lemma2 (S E) Hxltx0 m E1))
find_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Control.TimeoutFinished transaction in 45.162 secs (4.707u,0.164s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0.474 secs (0.471u,0.001s) (successful)
find_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Control.Timeoutfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundMore readable: initial segment:
Some
With remainder:
[Ast.tRel 1]
find_witness Control.Timeoutrewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
find_witness Control.Timeoutrewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
find_witness Control.TimeoutCrunching: (forall x0 : R, interval_sum x r s x0 -> R0 < x0 \/ x0 = R0)
Crunching: (r >= 0)
Crunching: (Hlen >= 0)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Crunching: (H1 >= 0)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Crunching: (R0 < m \/ m = R0)
Crunching: (forall rr r : R, interval_sum p H8 rr r -> r >= 0)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Crunching: (forall x0 : R, interval_sum x r s x0 -> R0 < x0 \/ x0 = R0)
find_witness Control.Timeoutrewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Crunching: (r >= 0)
Crunching: (Hlen >= 0)
rewrite match_nat_dtt
match (proj1_sig H) with
| 0 => (fun _ : proj1_sig H = 0 => None)
| S m =>
(fun (k : nat) (E : proj1_sig H = S k) =>
 Some (ltN_of_nat k n0 (ltN_pred_lemma0 H k E)))
rewrite match_nat_dtt
match (proj1_sig H) with
| 0 => (fun _ : proj1_sig H = 0 => None)
| S m =>
(fun (k : nat) (E : proj1_sig H = S k) =>
 Some (ltN_of_nat k n0 (ltN_pred_lemma0 H k E)))
rewrite match_nat_dtt
match (proj1_sig H) with
| 0 => (fun _ : proj1_sig H = 0 => None)
| S m =>
(fun (k : nat) (E : proj1_sig H = S k) =>
 Some (ltN_of_nat k n0 (ltN_pred_lemma0 H k E)))
rewrite match_nat_dtt
match (proj1_sig H) with
| 0 => (fun _ : proj1_sig H = 0 => None)
| S m =>
(fun (k : nat) (E : proj1_sig H = S k) =>
 Some (ltN_of_nat k n0 (ltN_pred_lemma0 H k E)))
rewrite match_nat_dtt
match (proj1_sig (exist (fun k : nat => (k <? S b) = true) (S x) e)) with
| 0 =>
(fun _ : proj1_sig (exist (fun k : nat => (k <? S b) = true) (S x) e) = 0 =>
 None)
| S m =>
(fun (k : nat)
   (E : proj1_sig (exist (fun k0 : nat => (k0 <? S b) = true) (S x) e) = S k)
 =>
 Some
   (ltN_of_nat k b
      (ltN_pred_lemma0 (exist (fun k0 : nat => (k0 <? S b) = true) (S x) e) k
         E)))
rewrite match_nat_dtt
match (proj1_sig (exist (fun k : nat => (k <? S b) = true) (S x) e)) with
| 0 =>
(fun _ : proj1_sig (exist (fun k : nat => (k <? S b) = true) (S x) e) = 0 =>
 None)
| S m =>
(fun (k : nat)
   (E : proj1_sig (exist (fun k0 : nat => (k0 <? S b) = true) (S x) e) = S k)
 =>
 Some
   (ltN_of_nat k b
      (ltN_pred_lemma0 (exist (fun k0 : nat => (k0 <? S b) = true) (S x) e) k
         E)))
Crunching:
(cos_term (7 / 8) 0 + cos_term (7 / 8) 1 <= cos (7 / 8) ->
 cos (7 / 8) <= cos_term (7 / 8) 0 + cos_term (7 / 8) 1 + cos_term (7 / 8) 2 ->
 0 < cos (7 / 8))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Crunching: False
Crunching: (H1 >= 0)
Crunching: (interval_sum x H10 n H1 -> H1 >= 0)
Crunching: (n >= 0)
Crunching: (R0 < m \/ m = R0)
Crunching: (forall rr r : R, interval_sum p H8 rr r -> r >= 0)
Crunching: (k >= 0)
Crunching: (k >= 0)
Crunching: (k >= 0)
Crunching: (forall x0 : R, interval_sum x r s x0 -> R0 < x0 \/ x0 = R0)
find_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundCrunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(exists r3 r4 : R,
   interval_sum a0 rl rm r3 /\
   interval_sum a0 rm rr r4 /\ (r2 - r1)%R = (r3 + r4)%R)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(interval_sum l1 cv n p ->
 cv <= pol <= n ->
 exists r1 r2 : R,
   interval_sum l1 cv pol r1 /\ interval_sum l1 pol n r2 /\ p = (r1 + r2)%R)
find_witness Control.Timeoutfind_witness Control.Timeoutclear  IHn  : 
(False ->
 forall x0 : ltN 0,
 (fix Ffix (x x1 : nat) {struct x} : bool :=
    match x with
    | 0 => match x1 with
           | 0 => true
           | S _ => false
           end
    | S x2 => match x1 with
              | 0 => false
              | S x3 => Ffix x2 x3
              end
    end) x (let (x, _) := x0 in x) = true -> x = (let (a, _) := x0 in a))
Crunching: (r1 = r2)
Crunching: (0 < eps / 5 -> Rabs (H0 - x0) < eps)
find_witness Control.TimeoutCrunching:
(forall r3 : R,
 q <= m <= r3 /\ r3 <= n ->
 (forall r : R, m < r < r3 -> x r) ->
 (forall r : R, q < r < m -> ~ x r) ->
 (forall r : R, r3 < r < n -> ~ x r) -> (r3 - m)%R = r2)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
((forall r : R, NZ < r < EQ -> x r) ->
 (forall r : R, b < r < NZ -> ~ x r) ->
 (forall r : R, EQ < r < g -> ~ x r) -> (EQ - NZ)%R = r2)
Crunching: (r1 = r2)
Finished transaction in 600.303 secs (597.546u,1.27s) (successful)
find_witness Control.TimeoutCrunching: (pr_P u IH)
find_witness Control.TimeoutCrunching: (probability_of_outcome a b = probability_of_outcome b a)
find_witness Control.TimeoutCrunching: (0 < 2 -> pr_P P2 r)
Crunching:
(interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 x0
   (big_sum (fun i : nat => if Hf i then nth i f 0 else 0) (length f)))
Crunching:
(sum_over_list f = x0 ->
 interval_sum (fun rnd : R => Hf (sample f rnd) = true) R0 x0
   (big_sum (fun i : nat => if Hf i then nth i f R0 else R0) (length f)))
Crunching:
(Forall (fun x : R => 0 <= x) f ->
 sum_over_list f = Hxy ->
 interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 Hxy
   (big_sum (fun i : nat => if Hf i then nth i f 0 else 0) (length f)))
Crunching:
(forall r : R,
 Forall (fun x : R => 0 <= x) f ->
 sum_over_list f = r ->
 interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 r
   (pr_outcome_sum f Hf))
Crunching:
(probability_of_outcome b c =
 (norm (fun x z : nat => Σ (fun y : nat => ((b) † x y * c y z)%C) a) *
  (norm (fun x z : nat => Σ (fun y : nat => ((b) † x y * c y z)%C) a) * 1))%R)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
find_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
find_witness Control.TimeoutCrunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
find_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.TimeoutCrunching:
(R ->
 R ->
 forall ψ : Vector delta1,
 probability_of_outcome H2 ψ =
 (norm (fun x z : nat => Σ (fun y : nat => ((H2) † x y * ψ y z)%C) delta1)
  ^ 2)%R)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(R ->
 R ->
 forall ψ : Vector delta1,
 probability_of_outcome H2 ψ =
 (norm (fun x z : nat => Σ (fun y : nat => ((H2) † x y * ψ y z)%C) delta1)
  ^ 2)%R)
find_witness Control.TimeoutCrunching:
(interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 x0
   (big_sum (fun i : nat => if Hf i then nth i f 0 else 0) (length f)))
Crunching:
(sum_over_list f = x0 ->
 interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 x0
   (big_sum (fun i : nat => if Hf i then nth i f 0 else 0) (length f)))
Crunching:
(sum_over_list f = x0 ->
 interval_sum (fun rnd : R => Hf (sample f rnd) = true) R0 x0
   (big_sum (fun i : nat => if Hf i then nth i f R0 else R0) (length f)))
Crunching:
(interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 x0
   (big_sum (fun i : nat => if Hf i then nth i f 0 else 0) (length f)))
Crunching: (forall x y z : R, y <= z - x -> x + y <= z)
Crunching: (forall z : R, q2 <= z - q1 -> q1 + q2 <= z)
Crunching:
(Forall (fun x : R => 0 <= x) f ->
 sum_over_list f = Hxy ->
 interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 Hxy
   (big_sum (fun i : nat => if Hf i then nth i f 0 else 0) (length f)))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall r : R,
 Forall (fun x : R => 0 <= x) f ->
 sum_over_list f = r ->
 interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 r
   (pr_outcome_sum f Hf))
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(forall f : nat -> bool,
 distribution H1 ->
 pr_P (fun rnd : R => f (sample H1 rnd) = true) (pr_outcome_sum H1 f))
Crunching:
((fun x0 y : nat => if (x0 =? y) && (x0 <? x) then C1 else 0) =
 big_sum (fun i : nat => basis_vector p i × (basis_vector p i) †) x)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(pr_P (fun rnd : R => Hf (sample f rnd) = true) (pr_outcome_sum f Hf))
Crunching:
(pr_P (fun rnd : R => Hf (sample f rnd) = true) (pr_outcome_sum f Hf))
Crunching:
(pr_P (fun rnd : R => Hf (sample [] rnd) = true) (pr_outcome_sum [] Hf))
Crunching:
(pr_P (fun rnd : R => Hf (sample [] rnd) = true) (pr_outcome_sum [] Hf))
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (0 < cos (7 / 8))
Crunching:
(forall x : R,
 7 / 8 <= x <= 7 / 4 /\ (- cos x)%R = 0 ->
 ~
 0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) - (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0))) -
 (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) - (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)))) <
 0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) - (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0))) -
 (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) - (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)))) ->
 pr_P (fun _ : R => Hf 0%nat = true)
   (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) -
    (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0))) -
    (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) -
     (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0))))))
Crunching: (I 0 x y = Zero x y)
Crunching: (I 0 x y = Zero x y)
Crunching: (Ha >= 2 ^ l \/ Hb >= 1 -> f_to_vec l b Ha Hb = 0%R)
Crunching: (Ha >= 2 ^ l \/ Hb >= 1 -> f_to_vec l b Ha Hb = 0%R)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (forall f : nat -> bool, WF_Matrix (f_to_vec l f))
Crunching: (pr_P (fun _ : R => Hf 0%nat = true) 0)
Crunching:
((E <= n)%nat ->
 I b = big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) Eq2)
Crunching:
(I (S m) =
 I m
 .+ (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0)
    × (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0) †)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (0 < cos (7 / 8))
Crunching: (prob_partial_meas ψ ϕ = (norm ((ψ ⊗ I (2 ^ d)) † × ϕ) ^ 2)%R)
Crunching:
(forall x : R,
 7 / 8 <= x <= 7 / 4 /\ (- cos x)%R = 0 ->
 ~
 0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) - (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0))) -
 (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) - (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)))) <
 0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) - (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0))) -
 (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) - (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)))) ->
 pr_P (fun _ : R => Hf 0%nat = true)
   (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) -
    (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0))) -
    (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0)) -
     (0 - 0 - (0 - 0) - (0 - 0 - (0 - 0))))))
Crunching: (Ha >= 2 ^ l \/ Hb >= 1 -> f_to_vec l b Ha Hb = 0%R)
Crunching: (forall f : nat -> bool, WF_Matrix (f_to_vec l f))
Crunching:
(prob_partial_meas psi2 H8 =
 (norm
    (fun x z : nat =>
     Σ
       (fun y : nat =>
        (((psi2
           ⊗ (fun x0 y0 : nat =>
              if (x0 =? y0) && (x0 <? 2 ^ H) then C1 else 0)) y x) ^* *
         H8 y z)%C) (2 ^ d * 2 ^ H)) ^ 2)%R)
find_witness Control.TimeoutCrunching:
(forall (ϕ : Vector (2 ^ A)) (ψ : Vector (2 ^ (A + Hxz))),
 prob_partial_meas ϕ ψ =
 (norm
    (fun x z : nat =>
     Σ
       (fun y : nat =>
        (((ϕ
           ⊗ (fun x0 y0 : nat =>
              if (x0 =? y0) && (x0 <? 2 ^ Hxz) then C1 else 0)) y x) ^* *
         ψ y z)%C) (2 ^ A * 2 ^ Hxz)) ^ 2)%R)
Crunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.TimeoutCrunching:
(pr_outcome_sum Hneq p <= n ->
 exists r0 : R,
   0 <= r0 <= n /\ pr_P (fun rnd : R => p (sample Hneq rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= sc /\ pr_P (fun rnd : R => k (sample Hneq rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= sc /\ pr_P (fun rnd : R => k (sample Hneq rnd) = true) r0)
Crunching: (Ha >= 2 ^ l \/ Hb >= 1 -> f_to_vec l b Ha Hb = 0%R)
Crunching:
(exists r0 : R,
   0 <= r0 <= sc /\ pr_P (fun rnd : R => k (sample Hneq rnd) = true) r0)
Crunching: (prob_partial_meas ψ ϕ = (norm ((ψ ⊗ I (2 ^ d)) † × ϕ) ^ 2)%R)
Crunching: (forall f : nat -> bool, WF_Matrix (f_to_vec l f))
Crunching:
(forall (f : nat -> bool) (r : R),
 distribution [] ->
 pr_outcome_sum [] f <= r ->
 exists r0 : R,
   0 <= r0 <= r /\ pr_P (fun rnd : R => f (sample [] rnd) = true) r0)
Crunching:
(forall f' : nat -> bool,
 (forall i : nat, i < m -> H1 i = f' i) -> f_to_vec m H1 = f_to_vec m f')
Crunching: (prob_partial_meas ϕ ψ = (norm ((ϕ ⊗ I (2 ^ n)) † × ψ) ^ 2)%R)
find_witness Control.TimeoutCrunching:
(prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (y / 1)%nat * H11 (x mod 2 ^ t) (y mod 1)) =
 probability_of_outcome l2 H0)
Crunching:
(forall (ϕ ψ1 : Vector (2 ^ 0)) (ψ2 : Vector (2 ^ H'1)),
 Pure_State_Vector ψ2 ->
 prob_partial_meas ϕ
   (fun x y : nat =>
    ψ1 (x / 2 ^ H'1)%nat (y / 1)%nat * ψ2 (x mod 2 ^ H'1) (y mod 1)) =
 probability_of_outcome ϕ ψ1)
find_witness Control.TimeoutCrunching: (prob_partial_meas q (q' ⊗ WF) <= probability_of_outcome q q')
Crunching: (f_to_vec 0 H0 = f_to_vec 0 x0)
Crunching: (f_to_vec 0 H0 = f_to_vec 0 x0)
Crunching: (pr_P Hfalse x -> pr_P Hfalse y -> x = y)
find_witness Control.TimeoutCrunching: (b = (- - r2)%R)
Crunching:
(forall f' : nat -> bool,
 (forall i : nat, i < m -> H1 i = f' i) -> f_to_vec m H1 = f_to_vec m f')
find_witness Control.TimeoutCrunching:
(PI / 4 < PI / 2 ->
 forall (ϕ ψ1 : Vector (2 ^ m)) (ψ2 : Vector (2 ^ 0)),
 Pure_State_Vector ψ2 ->
 prob_partial_meas ϕ
   (fun x y : nat =>
    ψ1 (x / 2 ^ 0)%nat (y / 1)%nat * ψ2 (x mod 2 ^ 0) (y mod 1)) =
 probability_of_outcome ϕ ψ1)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((fun n : nat =>
  (forall i : nat, i < Eq0 -> alp_f2 i = H3 i) ->
  f_to_vec Eq0 alp_f2 = f_to_vec Eq0 H3) 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pr_P Hfalse x -> pr_P Hfalse y -> x = y)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (interval_sum Hfalse R0 R1 alp_f2 -> H12 = alp_f2)
Crunching:
(Pure_State_Vector H6 ->
 prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (y / 1)%nat * H6 (x mod 2 ^ t) (y mod 1)) =
 probability_of_outcome l2 H0)
find_witness Control.TimeoutCrunching:
(Pure_State_Vector abs ->
 prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (y / 1)%nat * abs (x mod 2 ^ t) (y mod 1)) =
 probability_of_outcome l2 H0)
Crunching:
(forall r1 : R,
 0 <= r1 <= r0 /\ r0 <= 1 ->
 (forall r : R, r1 < r < r0 -> Hfalse r) ->
 (forall r : R, 0 < r < r1 -> ~ Hfalse r) ->
 forall r2 : R, pr_P Hfalse r2 -> (r0 - r1)%R = r2)
Crunching:
(prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (y / 1)%nat * H11 (x mod 2 ^ t) (y mod 1)) =
 probability_of_outcome l2 H0)
Crunching:
(prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (fst (Nat.divmod y 0 0 0)) * H11 (x mod 2 ^ t) 0%nat) =
 probability_of_outcome l2 H0)
Crunching:
(prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (fst (Nat.divmod y 0 0 0)) * abs (x mod 2 ^ t) 0%nat) =
 probability_of_outcome l2 H0)
Crunching:
(forall (ϕ ψ1 : Vector (2 ^ 0)) (ψ2 : Vector (2 ^ H'1)),
 Pure_State_Vector ψ2 ->
 prob_partial_meas ϕ
   (fun x y : nat =>
    ψ1 (x / 2 ^ H'1)%nat (y / 1)%nat * ψ2 (x mod 2 ^ H'1) (y mod 1)) =
 probability_of_outcome ϕ ψ1)
Crunching:
(forall ψ2 : Vector (2 ^ H'1),
 Pure_State_Vector ψ2 ->
 prob_partial_meas Hyp_a
   (fun x y : nat =>
    abs (x / 2 ^ H'1)%nat (y / 1)%nat * ψ2 (x mod 2 ^ H'1) (y mod 1)) =
 probability_of_outcome Hyp_a abs)
find_witness Control.TimeoutCrunching: ((r3 - r0)%R = (r2 - r1)%R)
Crunching: ((forall x : R, (exists y : R, g x y) -> True) -> (H4 - D)%R = 0)
Crunching: (forall x y z : R, y <= z - x -> x + y <= z)
Crunching: (basis_vector Hb a H n = 0%R)
Crunching: (forall x y z : R, y <= z - x -> x + y <= z)
Crunching: (forall y : nat, H >= Hb \/ y >= 1 -> basis_vector Hb a H y = 0%R)
Crunching: (forall y : nat, H >= Hb \/ y >= 1 -> basis_vector Hb a H y = 0%R)
Crunching: (forall y : nat, H >= Hb \/ y >= 1 -> basis_vector Hb a H y = 0%R)
Crunching: (basis_vector Hb a H Hm = 0%R)
Crunching: (forall y : nat, H >= Hb \/ y >= 1 -> basis_vector Hb a H y = 0%R)
Crunching: (forall y : nat, H >= Hb \/ y >= 1 -> basis_vector Hb a H y = 0%R)
find_witness Control.TimeoutCrunching: (b = (- - r2)%R)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.003u,0.002s) (failure)
Crunching:
(pr_outcome_sum l Hn = r <-> pr_P (fun rnd : R => Hn (sample l rnd) = true) r)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(pr_outcome_sum l Hn = r <-> pr_P (fun rnd : R => Hn (sample l rnd) = true) r)
Crunching:
(forall (f : nat -> bool) (l : list R) (r : R),
 distribution l ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.002u,0.s) (failure)
Crunching:
(distribution n ->
 pr_outcome_sum n Hfalse = H2 <->
 pr_P (fun rnd : R => Hfalse (sample n rnd) = true) H2)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(PI / 4 < PI / 2 ->
 (forall r1 r2 : R, r1 > 0 -> r2 > 0 -> r1 * r2 > 0) ->
 pr_outcome_sum x Hfalse = y <->
 pr_P (fun rnd : R => Hfalse (sample x rnd) = true) y)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(pr_outcome_sum l Hn = r <-> pr_P (fun rnd : R => Hn (sample l rnd) = true) r)
Crunching:
(pr_outcome_sum l Hn = r <-> pr_P (fun rnd : R => Hn (sample l rnd) = true) r)
Crunching:
(pr_outcome_sum l Hn = r <-> pr_P (fun rnd : R => Hn (sample l rnd) = true) r)
Crunching:
(pr_outcome_sum l Hn = r <-> pr_P (fun rnd : R => Hn (sample l rnd) = true) r)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching: (list2D_to_matrix [[e]] = (basis_vector 1 0) † × basis_vector 1 0)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(pr_outcome_sum l Hn = r <-> pr_P (fun rnd : R => Hn (sample l rnd) = true) r)
Crunching: (0 < x -> (basis_vector x 0) † × basis_vector x 0 = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S y) y) † × basis_vector (S y) y)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S y) y) † × basis_vector (S y) y)
Crunching:
(pr_outcome_sum n0 Hn = H1 <->
 pr_P (fun rnd : R => Hn (sample n0 rnd) = true) H1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) n) † × basis_vector (S n) n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector d H1) † × basis_vector d H1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching: (list2D_to_matrix [[e]] = (basis_vector 1 0) † × basis_vector 1 0)
Crunching: (list2D_to_matrix [[((basis_vector 1 0 0 0) ^*)%C]] = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) n) † × basis_vector (S n) n)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching: (0 < x -> (basis_vector x 0) † × basis_vector x 0 = I 1)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(forall r : R,
 distribution H14 ->
 pr_outcome_sum H14 Hn = r <->
 pr_P (fun rnd : R => Hn (sample H14 rnd) = true) r)
Crunching:
(pr_outcome_sum l Hn = r <-> pr_P (fun rnd : R => Hn (sample l rnd) = true) r)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S y) y) † × basis_vector (S y) y)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S y) y) † × basis_vector (S y) y)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector (S y) y) † × basis_vector (S y) y)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector 0 Hm) † × basis_vector 0 Hm)
Crunching: (list2D_to_matrix [[0%R]] = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) n) † × basis_vector (S n) n)
Crunching:
(forall n : nat, (basis_vector (S n) n) † × basis_vector (S n) n = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector d H1) † × basis_vector d H1)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector d H1 y 0) ^* * basis_vector d H1 y 0)%C)
       d]] = I 1)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
Crunching:
(forall (f : nat -> bool) (l : list R) (r : R),
 distribution l ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => ((basis_vector d 0) † x y * basis_vector d 0 y z)%C) d) =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching: (list2D_to_matrix [[e]] = (basis_vector 1 0) † × basis_vector 1 0)
Crunching: (list2D_to_matrix [[((basis_vector 1 0 0 0) ^*)%C]] = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) n) † × basis_vector (S n) n)
Finished transaction in 0.683 secs (0.672u,0.008s) (successful)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) n) † × basis_vector (S n) n)
Finished transaction in 0.152 secs (0.152u,0.s) (successful)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) n) † × basis_vector (S n) n)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S y) y) † × basis_vector (S y) y)
Crunching: (0 < x -> (basis_vector x 0) † × basis_vector x 0 = I 1)
Finished transaction in 72.212 secs (70.038u,1.688s) (successful)
find_witness Control.TimeoutCrunching: (Forall (fun x : R => 0 - 0 - (0 - 0) <= x) (map Cmod2 (a :: l)))
Crunching: (Forall (fun x : R => 0 - 0 - (0 - 0) <= x) (map Cmod2 (a :: l)))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (Forall (fun x : R => 0 - 0 - (0 - 0) <= x) (map Cmod2 (a :: l)))
Crunching: (Forall (fun x : R => - 0 <= x) (map Cmod2 []))
Crunching:
(forall q : positive, Z.abs_N (Z.pos H ÷ Z.pos q) = (N.pos H / N.pos q)%N)
Crunching: (Forall (fun x : R => 0 - 0 - (0 - 0) <= x) (map Cmod2 (a :: l)))
find_witness Control.TimeoutCrunching: (Forall (fun x : R => - 0 <= x) (map Cmod2 []))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Finished transaction in 14.262 secs (14.029u,0.167s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall q : positive, Z.abs_N (Z.pos H ÷ Z.pos q) = (N.pos H / N.pos q)%N)
Crunching:
(forall q : positive, Z.abs_N (Z.pos H ÷ Z.pos q) = (N.pos H / N.pos q)%N)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (Forall (fun x : R => 0 - 0 - (0 - 0) <= x) (map Cmod2 (a :: l)))
find_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (Forall (fun x : R => - 0 <= x) (map Cmod2 []))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (Forall (fun x : R => - 0 <= x) (map Cmod2 []))
Crunching:
(HB < l ->
 WF_Matrix (basis_vector l HB) /\
 (basis_vector l HB) † × basis_vector l HB = I 1)
Crunching: (Forall (fun x : R => - 0 <= x) (map Cmod2 []))
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 27.895 secs (27.706u,0.108s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 0.092 secs (0.09u,0.002s) (successful)
Finished transaction in 0.131 secs (0.126u,0.004s) (successful)
Finished transaction in 0.096 secs (0.095u,0.s) (successful)
Crunching:
(HB < l ->
 WF_Matrix (basis_vector l HB) /\
 (basis_vector l HB) † × basis_vector l HB = I 1)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall q : positive, Z.abs_N (Z.pos H ÷ Z.pos q) = (N.pos H / N.pos q)%N)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall q : positive, Z.abs_N (Z.pos H ÷ Z.pos q) = (N.pos H / N.pos q)%N)
Crunching:
(forall q : positive, Z.abs_N (Z.pos H ÷ Z.pos q) = (N.pos H / N.pos q)%N)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (basis_vector (S i) i a n = 0%R)
Crunching: (basis_vector l eps X X0 = 0%R)
Crunching:
(WF_Matrix (basis_vector l eps) /\
 (basis_vector l eps) † × basis_vector l eps = I 1)
find_witness Control.TimeoutCrunching: (Forall (fun x : R => 0 - 0 - (0 - 0) <= x) (map Cmod2 (a :: l)))
find_witness Control.TimeoutCrunching:
(Σ
   (fun y0 : nat =>
    ((if (y0 =? i) && (x =? 0) then C1 else 0%R) ^* *
     (if (y0 =? i) && (y =? 0) then C1 else 0%R))%C) l = C1)
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 24.022 secs (23.832u,0.164s) (successful)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall l : Vector H,
 sum_over_list (map Cmod2 (vec_to_list' a l)) =
 big_sum (fun i : nat => (Cmod (l (i + H - a)%nat 0%nat) ^ 2)%R) a)
find_witness Control.TimeoutCrunching:
(fst
   (Σ
      (fun y : nat =>
       ((if (y =? i) && true then C1 else 0%R) ^* *
        (if (y =? i) && true then C1 else 0%R))%C) l) =
 fst (if true && true then C1 else 0%R))
Crunching:
(fst
   (Σ
      (fun y : nat =>
       ((if (y =? i) && (x =? 0) then IPR 1 else R0) ^* *
        (if (y =? i) && (x =? 0) then IPR 1 else R0))%C) l) =
 fst (if true && true then IPR 1 else R0))
Crunching:
(fst
   (Σ
      (fun y0 : nat =>
       ((if (y0 =? i) && (x =? 0) then IPR 1 else R0) ^* *
        (if (y0 =? i) && (y =? 0) then IPR 1 else R0))%C) l) =
 fst (if true && true then IPR 1 else R0))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 9.501 secs (9.429u,0.064s) (successful)
Crunching: (Hcase - (k, r) = (Heq, Hneq) -> Hcase - (Heq, Hneq) - (k, r) = 0)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall l : Vector p,
 sum_over_list (map Cmod2 (vec_to_list' x l)) =
 big_sum (fun i : nat => (Cmod (l (i + p - x)%nat 0%nat) ^ 2)%R) x)
Crunching:
(forall l : Vector H,
 sum_over_list (map Cmod2 (vec_to_list' a l)) =
 big_sum (fun i : nat => (Cmod (l (i + H - a)%nat 0%nat) ^ 2)%R) a)
Crunching:
(exists x0 : nat,
   x0 < l /\
   ((if (x0 =? i) && (x =? 0) then 1²%R else (- 0)%R) ^* *
    (if (x0 =? i) && (y =? 0) then 1²%R else (- 0)%R))%C =
   (if true && true then 1²%R else (- 0)%R) /\
   (forall x' : nat,
    x' < l ->
    x0 <> x' ->
    ((if (x' =? i) && (x =? 0) then 1²%R else (- 0)%R) ^* *
     (if (x' =? i) && (y =? 0) then 1²%R else (- 0)%R))%C = 0))
Crunching:
(C1 =
 Σ
   (fun y0 : nat =>
    ((if (y0 =? i) && (x =? 0) then C1 else 0%R) ^* *
     (if (y0 =? i) && (y =? 0) then C1 else 0%R))%C) l)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(Σ
   (fun y0 : nat =>
    ((if (y0 =? i) && (x =? 0) then C1 else 0%R) ^* *
     (if (y0 =? i) && (y =? 0) then C1 else 0%R))%C) l = C1)
Crunching:
(Σ
   (fun y0 : nat =>
    ((if (y0 =? HB) && (x =? 0) then C1 else 0%R) ^* *
     (if (y0 =? HB) && (y =? 0) then C1 else 0%R))%C) l =
 (if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l HB) † × basis_vector l HB)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector l HB y 0) ^* * basis_vector l HB y 0)%C)
       l]] = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l HB) † × basis_vector l HB)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector l HB y 0) ^* * basis_vector l HB y 0)%C)
       l]] = I 1)
Crunching:
(forall m n : nat,
 m < LT ->
 n < LT -> m <> n -> (basis_vector LT m) † × basis_vector LT n = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector z intz y 0) ^* * basis_vector z n y 0)%C) z]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector z intz y 0) ^* * basis_vector z n y 1)%C) z)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector z intz y0 0) ^* * basis_vector z n y0 (S (S y)))%C) z)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector z intz y 1) ^* * basis_vector z n y 0)%C) z)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector z intz y0 1) ^* * basis_vector z n y0 (S y))%C) z)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector z intz y 0) ^* * basis_vector z n y 0)%C) z]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector z intz y 0) ^* * basis_vector z n y 1)%C) z)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector z intz y0 0) ^* * basis_vector z n y0 (S (S y)))%C) z)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector z intz y 1) ^* * basis_vector z n y 0)%C) z)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector z intz y0 1) ^* * basis_vector z n y0 (S y))%C) z)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector z intz y (S (S x))) ^* * basis_vector z n y 0)%C) z)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector z intz y0 (S (S x))) ^* * basis_vector z n y0 (S y))%C) z)
Crunching:
(forall m n : nat,
 m < x -> n < x -> m <> n -> (basis_vector x m) † × basis_vector x n = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x f)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x f y 0)%C)
       x]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x f y 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x LT y0 0) ^* * basis_vector x f y0 (S (S y)))%C) x)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector x LT y 1) ^* * basis_vector x f y 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x LT y0 1) ^* * basis_vector x f y0 (S y))%C) x)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector x LT y (S (S x0))) ^* * basis_vector x f y 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x LT y0 (S (S x0))) ^* * basis_vector x f y0 (S y))%C) x)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S LT) LT) † × basis_vector (S LT) r)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S LT) LT y 0) ^* * basis_vector (S LT) r y 0) LT +
      (basis_vector (S LT) LT LT 0) ^* * basis_vector (S LT) r LT 0)%C]] =
 Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S LT) LT) † × basis_vector (S LT) r)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S LT) LT y 0) ^* * basis_vector (S LT) r y 0) LT +
      (basis_vector (S LT) LT LT 0) ^* * basis_vector (S LT) r LT 0)%C]] =
 Zero)
Crunching:
(LT < x ->
 s1 < x -> LT <> s1 -> (basis_vector x LT) † × basis_vector x s1 = Zero)
Crunching: (a <> b -> (basis_vector x a) † × basis_vector x b = Zero)
Crunching: (a <> b -> (basis_vector x a) † × basis_vector x b = Zero)
Crunching: (a <> b -> (basis_vector x a) † × basis_vector x b = Zero)
Crunching:
(x < Hab -> p <> x -> (basis_vector Hab p) † × basis_vector Hab x = Zero)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(forall m n : nat,
 m < LT ->
 n < LT -> m <> n -> (basis_vector LT m) † × basis_vector LT n = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector LT a) † × basis_vector LT b)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 0)%C)
       LT]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 1)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 0) ^* * basis_vector LT b y0 (S (S y)))%C) LT)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 1) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 1) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector LT a y (S (S x))) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 (S (S x))) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(forall x : nat, ((basis_vector LT a) † × basis_vector LT b) x = Zero x)
Finished transaction in 21.013 secs (20.737u,0.125s) (successful)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector LT a) † × basis_vector LT b)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 0)%C)
       LT]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 1)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 0) ^* * basis_vector LT b y0 (S (S y)))%C) LT)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 1) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 1) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector LT a y (S (S x))) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 (S (S x))) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(forall x : nat, ((basis_vector LT a) † × basis_vector LT b) x = Zero x)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector LT a) † × basis_vector LT 0)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT 0 y 0)%C)
       LT]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector LT a) † × basis_vector LT b)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 0)%C)
       LT]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 1)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 0) ^* * basis_vector LT b y0 (S (S y)))%C) LT)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 1) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 1) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector LT a y (S (S x))) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 (S (S x))) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector LT a) † × basis_vector LT b)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 0)%C)
       LT]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 1)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 0) ^* * basis_vector LT b y0 (S (S y)))%C) LT)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 1) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 1) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector LT a y (S (S x))) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 (S (S x))) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector LT a) † × basis_vector LT b)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 0)%C)
       LT]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 1)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 0) ^* * basis_vector LT b y0 (S (S y)))%C) LT)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 1) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 1) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector LT a y (S (S x))) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 (S (S x))) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector LT a) † × basis_vector LT b)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 0)%C)
       LT]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 1)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 0) ^* * basis_vector LT b y0 (S (S y)))%C) LT)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 1) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 1) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector LT a y (S (S x))) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 (S (S x))) ^* * basis_vector LT b y0 (S y))%C) LT)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector LT a) † × basis_vector LT b)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 0)%C)
       LT]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 1)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 0) ^* * basis_vector LT b y0 (S (S y)))%C) LT)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector LT a y 1) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 1) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector LT a y (S (S x))) ^* * basis_vector LT b y 0)%C) LT)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector LT a y0 (S (S x))) ^* * basis_vector LT b y0 (S y))%C) LT)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector LT a) † × basis_vector LT b)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 0)%C)
       LT]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector LT a) † × basis_vector LT b)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector LT a) † × basis_vector LT b)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector LT a y 0) ^* * basis_vector LT b y 0)%C)
       LT]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z x)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector z intz y 0) ^* * basis_vector z x y 0)%C) z]] = Zero)
Crunching: False
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z x)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector z intz y 0) ^* * basis_vector z x y 0)%C) z]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z x)
Crunching: (intz <> x -> (basis_vector z intz) † × basis_vector z x = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z x)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector z intz y 0) ^* * basis_vector z x y 0)%C) z]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z x)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z x)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z x)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector z intz y 0) ^* * basis_vector z x y 0)%C) z]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z x)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z x)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector z intz y 0) ^* * basis_vector z n y 0)%C) z]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector z intz) † × basis_vector z n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector z intz y 0) ^* * basis_vector z n y 0)%C) z]] = Zero)
Crunching:
(forall m n : nat,
 m < x -> n < x -> m <> n -> (basis_vector x m) † × basis_vector x n = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(Zero =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector
            xCrunching:
             (list2D_to_matrix [[e]] =
              (basis_vector x LT) † × basis_vector x n)
            Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(Zero =
 list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]])
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x f)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x f y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x n y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S LT) LT) † × basis_vector (S LT) r)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S LT) LT) † × basis_vector (S LT) r)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S LT) LT) † × basis_vector (S LT) r)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S LT) LT) † × basis_vector (S LT) r)
Crunching:
(LT < x ->
 s1 < x -> LT <> s1 -> (basis_vector x LT) † × basis_vector x s1 = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector x LT) † × basis_vector x s1)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector x LT y 0) ^* * basis_vector x s1 y 0)%C)
       x]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S LT) LT) † × basis_vector (S LT) s1)
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
rewrite if_dtt
if (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x))
then
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = true =>
 proj1_sig
   (ltN_of_nat (proj1_sig (ltN_S y)) 2
      (ltN_intro_lemma1 1 (ltN_S x) (ltN_S y) E)))
else
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = false =>
 proj1_sig
   (ltN_of_nat (S (proj1_sig (ltN_S y))) 2
      (ltN_intro_lemma2 1 (ltN_S x) (ltN_S y) E)))
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Crunching: (∣1⟩ = basis_vector 2 1)
find_witness Control.TimeoutCrunching:
(forall j : nat, WF_Matrix m -> (m × basis_vector n j) i 0 = m i j)
rewrite if_dtt
if (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x))
then
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = true =>
 proj1_sig
   (ltN_of_nat (proj1_sig (ltN_S y)) 2
      (ltN_intro_lemma1 1 (ltN_S x) (ltN_S y) E)))
else
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = false =>
 proj1_sig
   (ltN_of_nat (S (proj1_sig (ltN_S y))) 2
      (ltN_intro_lemma2 1 (ltN_S x) (ltN_S y) E)))
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Crunching: False
rewrite if_dtt
if (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x))
then
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = true =>
 proj1_sig
   (ltN_of_nat (proj1_sig (ltN_S y)) 2
      (ltN_intro_lemma1 1 (ltN_S x) (ltN_S y) E)))
else
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = false =>
 proj1_sig
   (ltN_of_nat (S (proj1_sig (ltN_S y))) 2
      (ltN_intro_lemma2 1 (ltN_S x) (ltN_S y) E)))
find_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundrewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Crunching: ((fun n0 : nat => ?k@{m:=n0} <= n) m)
Crunching: (∣1⟩ = basis_vector 2 1)
rewrite if_dtt
if (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x))
then
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = true =>
 proj1_sig
   (ltN_of_nat (proj1_sig (ltN_S y)) 2
      (ltN_intro_lemma1 1 (ltN_S x) (ltN_S y) E)))
else
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = false =>
 proj1_sig
   (ltN_of_nat (S (proj1_sig (ltN_S y))) 2
      (ltN_intro_lemma2 1 (ltN_S x) (ltN_S y) E)))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: False
Crunching:
(1 < 0 ->
 (fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      ((fix map (l : list (R * R)) : list R :=
          match l with
          | [] => []
          | a :: t =>
              ((let (x, _) := a in x) * ((let (x, _) := a in x) * R1) +
               (let (_, y) := a in y) * ((let (_, y) := a in y) * R1))%R
              :: map t
          end)
         ((fix vec_to_list'
             (nmax n : nat) (v : nat -> nat -> R * R) {struct n} :
               list (R * R) :=
             match n with
             | 0%nat => []
             | S n' =>
                 v
                   ((fix sub (n0 m : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => n0
                       | S k =>
                           match m with
                           | 0%nat => n0
                           | S l => sub k l
                           end
                       end) nmax n) 0%nat :: vec_to_list' nmax n' v
             end) b b LT)) R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      ((fix map (l : list (R * R)) : list R :=
          match l with
          | [] => []
          | a :: t =>
              ((let (x, _) := a in x) * ((let (x, _) := a in x) * R1) +
               (let (_, y) := a in y) * ((let (_, y) := a in y) * R1))%R
              :: map t
          end)
         ((fix vec_to_list'
             (nmax n : nat) (v : nat -> nat -> R * R) {struct n} :
               list (R * R) :=
             match n with
             | 0%nat => []
             | S n' =>
                 v
                   ((fix sub (n0 m : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => n0
                       | S k =>
                           match m with
                           | 0%nat => n0
                           | S l => sub k l
                           end
                       end) nmax n) 0%nat :: vec_to_list' nmax n' v
             end) b b LT))) = R1)
Crunching: ((fun n0 : nat => ?k@{m:=n0} <= n) m)
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
find_witness Control.TimeoutCrunching: ((fun n0 : nat => ?k@{m:=n0} <= n) m)
Crunching: (distribution (apply_u contra))
Crunching: (distribution (apply_u contra))
rewrite if_dtt
if (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x))
then
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = true =>
 proj1_sig
   (ltN_of_nat (proj1_sig (ltN_S y)) 2
      (ltN_intro_lemma1 1 (ltN_S x) (ltN_S y) E)))
else
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = false =>
 proj1_sig
   (ltN_of_nat (S (proj1_sig (ltN_S y))) 2
      (ltN_intro_lemma2 1 (ltN_S x) (ltN_S y) E)))
find_witness Control.TimeoutCrunching: (distribution (apply_u contra))
Crunching: (distribution (apply_u contra))
find_witness Control.Timeoutfind_witness Control.Timeoutrewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Crunching: (1 <= 0)
Crunching: (distribution (apply_u contra))
Crunching: (distribution (apply_u contra))
rewrite if_dtt
if (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x))
then
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = true =>
 proj1_sig
   (ltN_of_nat (proj1_sig (ltN_S y)) 2
      (ltN_intro_lemma1 1 (ltN_S x) (ltN_S y) E)))
else
(fun E : (proj1_sig (ltN_S y) <? proj1_sig (ltN_S x)) = false =>
 proj1_sig
   (ltN_of_nat (S (proj1_sig (ltN_S y))) 2
      (ltN_intro_lemma2 1 (ltN_S x) (ltN_S y) E)))
Crunching: (distribution (apply_u contra))
Crunching: (distribution (apply_u contra))
Crunching: (distribution (apply_u contra))
Crunching: (distribution (apply_u contra))
Crunching: (WF_Matrix m -> (m × basis_vector n Hm) Hn 0 = m Hn Hm)
Crunching: (distribution (apply_u H5))
Crunching: (distribution (apply_u H5))
Crunching: (distribution (apply_u H5))
Crunching: (0%R = B x y)
Crunching: (A = B)
Crunching:
(WF_Matrix A ->
 (forall k : nat, k < 0 -> n × basis_vector 0 k = A × basis_vector 0 k) ->
 n = A)
Crunching: (Forall (fun x : R => 0 <= x) (apply_u H4))
Crunching: (Forall (fun x : R => 0 <= x) (apply_u H4))
Crunching: (0%R = B x y)
Crunching: (Forall (fun x : R => 0 <= x) (apply_u H4))
Crunching: (A = B)
Crunching:
(WF_Matrix A ->
 (forall k : nat, k < 0 -> n × basis_vector 0 k = A × basis_vector 0 k) ->
 n = A)
Crunching: (Forall (fun x : R => 0 <= x) (apply_u Hfalse))
Crunching: (distribution (apply_u contra))
Crunching: (distribution (apply_u contra))
Crunching: (distribution (apply_u contra))
Crunching:
((forall k : nat, k < p -> q × basis_vector p k = n × basis_vector p k) ->
 q = n)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (A = B)
Crunching:
((1 + 0)%R = 1 ->
 (0 + 1)%R = 1 ->
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H1) 0))) =
 (2 ^ H1)%nat)
Crunching: (H1 = x)
Crunching: (H1 = x)
Crunching: (H1 = x)
Crunching: (H1 = x)
find_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (A x y = B x y)
Crunching: ((fun n : nat => x = x -> y = y -> A x n = B x y) y)
Crunching: (A x y = B x y)
Crunching: (x = x -> y = y -> A x y = B x y)
Crunching: (A = B)
Finished transaction in 0.272 secs (0.27u,0.002s) (successful)
Finished transaction in 0.001 secs (0.001u,0.s) (successful)
Crunching:
(WF_Matrix A ->
 (forall k : nat, k < 0 -> n × basis_vector 0 k = A × basis_vector 0 k) ->
 n = A)
find_witness Control.TimeoutCrunching: (√ (H1 + b) <= √ H1 + √ b)
Crunching: (length (apply_u H) = (2 ^ HP)%nat)
Crunching: (length (apply_u H2) = (2 ^ HP)%nat)
Crunching: (length (apply_u n) = (2 ^ HP)%nat)
Crunching:
(forall z r : nat,
 r > 0 -> z < r -> n = x * r + z <-> n / r = x /\ n mod r = z)
Crunching:
((1 + 0)%R = 1 ->
 (0 + 1)%R = 1 ->
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H1) 0))) =
 (2 ^ H1)%nat)
Crunching:
(fst (Nat.divmod x z 0 z) = 0 /\ z - snd (Nat.divmod x z 0 z) = z <->
 x = 0 * S z + z)
find_witness Control.TimeoutCrunching: Z
Crunching:
(forall z r : nat,
 r > 0 -> z < r -> n = x * r + z <-> n / r = x /\ n mod r = z)
find_witness Control.TimeoutCrunching:
((H < 2 ^ H2)%nat ->
 WF_Matrix p ->
 nth H (apply_u p) 0 =
 probability_of_outcome (basis_vector (2 ^ H2) H)
   (p × basis_vector (2 ^ H2) 0))
Crunching:
(nth n (apply_u a) 0 =
 probability_of_outcome
   (fun i j : nat => if (i =? n) && (j =? 0) then C1 else 0)
   (a × (fun i j : nat => if (i =? 0) && (j =? 0) then C1 else 0)))
Crunching:
(nth 0 (apply_u a) 0 =
 probability_of_outcome
   (fun i j : nat => if (i =? 0) && (j =? 0) then C1 else 0)
   (a × (fun i j : nat => if (i =? 0) && (j =? 0) then C1 else 0)))
Crunching:
(nth m (map Cmod2 (vec_to_list (n × basis_vector (2 ^ l2) 0))) 0 =
 probability_of_outcome (basis_vector (2 ^ l2) m)
   (n × basis_vector (2 ^ l2) 0))
Crunching: (z = H0 * S H1 + H1 <-> z / S H1 = H0 /\ z mod S H1 = H1)
Crunching: (z = H0 * H' + H1 <-> z / H' = H0 /\ z mod H' = H1)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(x < 2 ^ a ->
 y < 2 ^ b ->
 basis_vector (2 ^ (a + b)) (x * 2 ^ b + y) =
 basis_vector (2 ^ a) x ⊗ basis_vector (2 ^ b) y)
find_witness Fun.Finally_raised: Control.TimeoutCrunching:
(basis_vector (2 ^ (f1 + f2)) (X * 2 ^ f2 + X0) =
 basis_vector (2 ^ f1) X ⊗ basis_vector (2 ^ f2) X0)
Crunching:
(nth x (apply_u a) 0 =
 probability_of_outcome
   (fun i j : nat => if (i =? x) && (j =? 0) then C1 else 0)
   (a × (fun i j : nat => if (i =? 0) && (j =? 0) then C1 else 0)))
Crunching:
(nth x (apply_u a) 0 =
 probability_of_outcome
   (fun i j : nat => if (i =? x) && (j =? 0) then C1 else 0)
   (a × (fun i j : nat => if (i =? 0) && (j =? 0) then C1 else 0)))
Crunching:
((H < 2 ^ H2)%nat ->
 WF_Matrix p ->
 nth H (apply_u p) 0 =
 probability_of_outcome (basis_vector (2 ^ H2) H)
   (p × basis_vector (2 ^ H2) 0))
Crunching:
(basis_vector (2 ^ (0 + m)) (Hn * 2 ^ m + 0) =
 basis_vector (S Hn) Hn ⊗ basis_vector (2 ^ m) 0)
find_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.TimeoutCrunching: (0 <= m -> Forall (fun x : R => 0 <= x) (repeat m Hn))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (Forall (fun x : R => 0 <= x) (repeat y Hfalse))
Crunching: (0 <= q)
Crunching: (0 <= l1 -> Forall (fun x : R => 0 <= x) (repeat l1 Hfalse))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(x < 2 ^ a ->
 y < 2 ^ b ->
 basis_vector (2 ^ (a + b)) (x * 2 ^ b + y) =
 basis_vector (2 ^ a) x ⊗ basis_vector (2 ^ b) y)
Crunching: (Forall (fun x : R => 0 <= x) (repeat s start))
find_witness Control.TimeoutCrunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
Crunching: (forall x y z : R, x - y <= z -> x - z <= y)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
find_witness Control.TimeoutCrunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
clear  H0a'  :  (False -> cmpA a a' <> Lt)
Crunching: (x - z0 <= y)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching: (forall x y z : R, x - y <= z -> x - z <= y)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching: ((0 + 0) * (0 ^ H + 0 ^ H) <= 0)
Crunching: Z
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching: Z
Crunching:
((fun n : nat =>
  (x + y) * (x ^ H + y ^ H) <= S (S n) * (x * x ^ H + y * y ^ H)) 0)
Crunching: (0 <= sample (uniform 0 u) r < u)%nat
Crunching: (0 <= sample (uniform 0 u) r < u)%nat
Crunching:
(forall f' : nat -> bool,
 (forall x0 : nat, x0 < x -> Hy x0 = f' x0) ->
 funbool_to_nat x Hy = funbool_to_nat x f')
Crunching: (eq_nat (funbool_to_nat 0 f) H1)
find_witness Control.TimeoutCrunching: (eq_nat (funbool_to_nat 0 f) H1)
Crunching: (forall x y : R, Rabs x < Rabs y -> y > 0 -> x < y)
Crunching: (0 <= sample (uniform 0 u) r < u)%nat
Crunching: Type
Crunching: (0 <= sample (uniform 0 u) r < u)%nat
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (eq_nat (funbool_to_nat 0 f) H1)
Crunching: (eq_nat (funbool_to_nat 0 f) H1)
Crunching: (distribution (uniform n (S H0)))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(cos_in 0 1 ->
 continuity_pt sqrt 1 -> (0 < m)%nat -> distribution (uniform 0 m))
Crunching: ((0 < m)%nat -> distribution (uniform 0 m))
Crunching: ((0 < m)%nat -> distribution (uniform 0 m))
Crunching: ((0 < m)%nat -> distribution (uniform 0 m))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) e (let (a, _) := k in a))
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) e
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e p) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S e)
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e p) E1))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) e x)
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e x = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) e
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S x) e0)
      (exist (fun k : nat => (k <? S n) = true) e p) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e x = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S e)
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S x) e0)
      (exist (fun k : nat => (k <? S n) = true) e p) E1))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) e x)
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e x = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) e
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S x) e0)
      (exist (fun k : nat => (k <? S n) = true) e p) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e x = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S e)
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S x) e0)
      (exist (fun k : nat => (k <? S n) = true) e p) E1))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) e (let (a, _) := k in a))
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) e
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e p) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S e)
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e p) E1))
find_witness Control.TimeoutCrunching: (S a + S b <= S a * S b)
find_witness Control.Timeoutrewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) l' (let (a, _) := k in a))
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) l' (let (a, _) := k in a) = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) l'
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) l' p) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) l' (let (a, _) := k in a) = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S l')
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) l' p) E1))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) l' (let (a, _) := k in a))
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) l' (let (a, _) := k in a) = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) l'
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) l' p) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) l' (let (a, _) := k in a) = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S l')
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) l' p) E1))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) e (let (a, _) := k in a))
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) e
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e H) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S e)
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e H) E1))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) e (let (a, _) := k in a))
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) e
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e p1) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S e)
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e p1) E1))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) e x)
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e x = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) e
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S x) e0)
      (exist (fun k : nat => (k <? S n) = true) e p) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e x = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S e)
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S x) e0)
      (exist (fun k : nat => (k <? S n) = true) e p) E1))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) e x)
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e x = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) e
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S x) e0)
      (exist (fun k : nat => (k <? S n) = true) e p) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e x = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S e)
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S x) e0)
      (exist (fun k : nat => (k <? S n) = true) e p) E1))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) e x)
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e x = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) e
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S x) e0)
      (exist (fun k : nat => (k <? S n) = true) e p) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e x = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S e)
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S x) e0)
      (exist (fun k : nat => (k <? S n) = true) e p) E1))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) e (let (a, _) := k in a))
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) e
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e p) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S e)
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e p) E1))
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) e (let (a, _) := k in a))
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) e
   (ltN_intro_lemma1 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e p) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) e (let (a, _) := k in a) = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S e)
   (ltN_intro_lemma2 (S n)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S n) = true) (S (let (a, _) := k in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) n = true) := k in
          b)) (exist (fun k : nat => (k <? S n) = true) e p) E1))
Crunching: (S a + S b <= S a * S b)
find_witness Control.TimeoutCrunching: (AGREE - b <= ?y)
Crunching:
(binlist_to_nat ((r :: r0) ++ res) =
 binlist_to_nat (r :: r0) + 2 ^ length (r :: r0) * binlist_to_nat res)
Crunching:
((forall r1 r2 r3 r4 : R, r1 = r2 -> (r2 < r4)%R -> r4 = r3 -> (r1 < r3)%R) ->
 binlist_to_nat (Hx ++ e) =
 binlist_to_nat Hx + 2 ^ length Hx * binlist_to_nat e)
Crunching:
((forall r1 r2 r3 r4 : R, r1 = r2 -> (r2 < r4)%R -> r4 = r3 -> (r1 < r3)%R) ->
 binlist_to_nat (Hx ++ e) =
 binlist_to_nat Hx + 2 ^ length Hx * binlist_to_nat e)
Crunching:
(binlist_to_nat (r :: r0) + 2 ^ length (r :: r0) * binlist_to_nat res =
 binlist_to_nat ((r :: r0) ++ res))
Crunching:
(binlist_to_nat ((r :: r0) ++ res) =
 binlist_to_nat (r :: r0) + 2 ^ length (r :: r0) * binlist_to_nat res)
Crunching: (forall x y : nat, ~ x <= y -> x > y)
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: False
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: False
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: False
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
bad
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: False
find_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
(abstract_domain_R v1 v2)
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (binlist_to_nat (repeat false H) = 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: False
(abstract_domain_R v1 v2)
Crunching: False
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (-2 <= 1)%R
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (binlist_to_nat (repeat false x) = 0)
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (-2 <= 1)%R
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (binlist_to_nat (repeat false x) = 0)
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (binlist_to_nat (repeat false H) = 0)
Crunching: (binlist_to_nat (repeat false H) = 0)
Crunching: (-2 <= 1)%R
Crunching: (binlist_to_nat (repeat false x) = 0)
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (-2 <= 1)%R
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (PI_2_3_7_tg (S n0) <= PI_2_3_7_tg n0)%R
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (fst a (2 ^ a + m) = S (fst a m))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: U
Crunching: False
bad
bad
Crunching: (binlist_to_nat (repeat false H5) = 0)
bad
Crunching: (binlist_to_nat (repeat false x) = 0)
Crunching:
(match
   (fix pow (n m : nat) {struct m} : nat :=
      match m with
      | 0%nat => 1%nat
      | S m0 =>
          (fix mul (n0 m1 : nat) {struct n0} : nat :=
             match n0 with
             | 0%nat => 0%nat
             | S p =>
                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                    match n1 with
                    | 0%nat => m2
                    | S p0 => S (add p0 m2)
                    end) m1 (mul p m1)
             end) n (pow n m0)
      end) 2%nat SF
 with
 | 0%nat =>
     (fix pow (n m : nat) {struct m} : nat :=
        match m with
        | 0%nat => 1%nat
        | S m0 =>
            (fix mul (n0 m1 : nat) {struct n0} : nat :=
               match n0 with
               | 0%nat => 0%nat
               | S p =>
                   (fix add (n1 m2 : nat) {struct n1} : nat :=
                      match n1 with
                      | 0%nat => m2
                      | S p0 => S (add p0 m2)
                      end) m1 (mul p m1)
               end) n (pow n m0)
        end) 2%nat SF
 | S y' =>
     let (x, _) :=
       (fix divmod (x y q u : nat) {struct x} : nat * nat :=
          match x with
          | 0%nat => (q, u)
          | S x' =>
              match u with
              | 0%nat => divmod x' y (S q) y
              | S u' => divmod x' y q u'
              end
          end)
         ((fix add (n m : nat) {struct n} : nat :=
             match n with
             | 0%nat => m
             | S p => S (add p m)
             end)
            ((fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat SF) H4) y' 0%nat y' in
     x
 end =
 S
   match
     (fix pow (n m : nat) {struct m} : nat :=
        match m with
        | 0%nat => 1%nat
        | S m0 =>
            (fix mul (n0 m1 : nat) {struct n0} : nat :=
               match n0 with
               | 0%nat => 0%nat
               | S p =>
                   (fix add (n1 m2 : nat) {struct n1} : nat :=
                      match n1 with
                      | 0%nat => m2
                      | S p0 => S (add p0 m2)
                      end) m1 (mul p m1)
               end) n (pow n m0)
        end) 2%nat SF
   with
   | 0 =>
       (fix pow (n m : nat) {struct m} : nat :=
          match m with
          | 0%nat => 1%nat
          | S m0 =>
              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                 match n0 with
                 | 0%nat => 0%nat
                 | S p =>
                     (fix add (n1 m2 : nat) {struct n1} : nat :=
                        match n1 with
                        | 0%nat => m2
                        | S p0 => S (add p0 m2)
                        end) m1 (mul p m1)
                 end) n (pow n m0)
          end) 2%nat SF
   | S y' =>
       let (x, _) :=
         (fix divmod (x y q u : nat) {struct x} : nat * nat :=
            match x with
            | 0%nat => (q, u)
            | S x' =>
                match u with
                | 0%nat => divmod x' y (S q) y
                | S u' => divmod x' y q u'
                end
            end) H4 y' 0%nat y' in
       x
   end)
Crunching: (binlist_to_nat (repeat false x) = 0)
Crunching:
(match
   (fix pow (n m : nat) {struct m} : nat :=
      match m with
      | 0%nat => 1%nat
      | S m0 =>
          (fix mul (n0 m1 : nat) {struct n0} : nat :=
             match n0 with
             | 0%nat => 0%nat
             | S p =>
                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                    match n1 with
                    | 0%nat => m2
                    | S p0 => S (add p0 m2)
                    end) m1 (mul p m1)
             end) n (pow n m0)
      end) 2%nat SF
 with
 | 0%nat =>
     (fix pow (n m : nat) {struct m} : nat :=
        match m with
        | 0%nat => 1%nat
        | S m0 =>
            (fix mul (n0 m1 : nat) {struct n0} : nat :=
               match n0 with
               | 0%nat => 0%nat
               | S p =>
                   (fix add (n1 m2 : nat) {struct n1} : nat :=
                      match n1 with
                      | 0%nat => m2
                      | S p0 => S (add p0 m2)
                      end) m1 (mul p m1)
               end) n (pow n m0)
        end) 2%nat SF
 | S y' =>
     let (x, _) :=
       (fix divmod (x y q u : nat) {struct x} : nat * nat :=
          match x with
          | 0%nat => (q, u)
          | S x' =>
              match u with
              | 0%nat => divmod x' y (S q) y
              | S u' => divmod x' y q u'
              end
          end)
         ((fix add (n m : nat) {struct n} : nat :=
             match n with
             | 0%nat => m
             | S p => S (add p m)
             end)
            ((fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat SF) H4) y' 0%nat y' in
     x
 end =
 S
   match
     (fix pow (n m : nat) {struct m} : nat :=
        match m with
        | 0%nat => 1%nat
        | S m0 =>
            (fix mul (n0 m1 : nat) {struct n0} : nat :=
               match n0 with
               | 0%nat => 0%nat
               | S p =>
                   (fix add (n1 m2 : nat) {struct n1} : nat :=
                      match n1 with
                      | 0%nat => m2
                      | S p0 => S (add p0 m2)
                      end) m1 (mul p m1)
               end) n (pow n m0)
        end) 2%nat SF
   with
   | 0 =>
       (fix pow (n m : nat) {struct m} : nat :=
          match m with
          | 0%nat => 1%nat
          | S m0 =>
              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                 match n0 with
                 | 0%nat => 0%nat
                 | S p =>
                     (fix add (n1 m2 : nat) {struct n1} : nat :=
                        match n1 with
                        | 0%nat => m2
                        | S p0 => S (add p0 m2)
                        end) m1 (mul p m1)
                 end) n (pow n m0)
          end) 2%nat SF
   | S y' =>
       let (x, _) :=
         (fix divmod (x y q u : nat) {struct x} : nat * nat :=
            match x with
            | 0%nat => (q, u)
            | S x' =>
                match u with
                | 0%nat => divmod x' y (S q) y
                | S u' => divmod x' y q u'
                end
            end) H4 y' 0%nat y' in
       x
   end)
Crunching:
(match
   (fix pow (n m : nat) {struct m} : nat :=
      match m with
      | 0%nat => 1%nat
      | S m0 =>
          (fix mul (n0 m1 : nat) {struct n0} : nat :=
             match n0 with
             | 0%nat => 0%nat
             | S p =>
                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                    match n1 with
                    | 0%nat => m2
                    | S p0 => S (add p0 m2)
                    end) m1 (mul p m1)
             end) n (pow n m0)
      end) 2%nat SF
 with
 | 0%nat =>
     (fix pow (n m : nat) {struct m} : nat :=
        match m with
        | 0%nat => 1%nat
        | S m0 =>
            (fix mul (n0 m1 : nat) {struct n0} : nat :=
               match n0 with
               | 0%nat => 0%nat
               | S p =>
                   (fix add (n1 m2 : nat) {struct n1} : nat :=
                      match n1 with
                      | 0%nat => m2
                      | S p0 => S (add p0 m2)
                      end) m1 (mul p m1)
               end) n (pow n m0)
        end) 2%nat SF
 | S y' =>
     let (x, _) :=
       (fix divmod (x y q u : nat) {struct x} : nat * nat :=
          match x with
          | 0%nat => (q, u)
          | S x' =>
              match u with
              | 0%nat => divmod x' y (S q) y
              | S u' => divmod x' y q u'
              end
          end)
         ((fix add (n m : nat) {struct n} : nat :=
             match n with
             | 0%nat => m
             | S p => S (add p m)
             end)
            ((fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat SF) H4) y' 0%nat y' in
     x
 end =
 S
   match
     (fix pow (n m : nat) {struct m} : nat :=
        match m with
        | 0%nat => 1%nat
        | S m0 =>
            (fix mul (n0 m1 : nat) {struct n0} : nat :=
               match n0 with
               | 0%nat => 0%nat
               | S p =>
                   (fix add (n1 m2 : nat) {struct n1} : nat :=
                      match n1 with
                      | 0%nat => m2
                      | S p0 => S (add p0 m2)
                      end) m1 (mul p m1)
               end) n (pow n m0)
        end) 2%nat SF
   with
   | 0 =>
       (fix pow (n m : nat) {struct m} : nat :=
          match m with
          | 0%nat => 1%nat
          | S m0 =>
              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                 match n0 with
                 | 0%nat => 0%nat
                 | S p =>
                     (fix add (n1 m2 : nat) {struct n1} : nat :=
                        match n1 with
                        | 0%nat => m2
                        | S p0 => S (add p0 m2)
                        end) m1 (mul p m1)
                 end) n (pow n m0)
          end) 2%nat SF
   | S y' =>
       let (x, _) :=
         (fix divmod (x y q u : nat) {struct x} : nat * nat :=
            match x with
            | 0%nat => (q, u)
            | S x' =>
                match u with
                | 0%nat => divmod x' y (S q) y
                | S u' => divmod x' y q u'
                end
            end) H4 y' 0%nat y' in
       x
   end)
Crunching:
(match
   (fix pow (n m : nat) {struct m} : nat :=
      match m with
      | 0%nat => 1%nat
      | S m0 =>
          (fix mul (n0 m1 : nat) {struct n0} : nat :=
             match n0 with
             | 0%nat => 0%nat
             | S p =>
                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                    match n1 with
                    | 0%nat => m2
                    | S p0 => S (add p0 m2)
                    end) m1 (mul p m1)
             end) n (pow n m0)
      end) 2%nat SF
 with
 | 0%nat =>
     (fix pow (n m : nat) {struct m} : nat :=
        match m with
        | 0%nat => 1%nat
        | S m0 =>
            (fix mul (n0 m1 : nat) {struct n0} : nat :=
               match n0 with
               | 0%nat => 0%nat
               | S p =>
                   (fix add (n1 m2 : nat) {struct n1} : nat :=
                      match n1 with
                      | 0%nat => m2
                      | S p0 => S (add p0 m2)
                      end) m1 (mul p m1)
               end) n (pow n m0)
        end) 2%nat SF
 | S y' =>
     let (x, _) :=
       (fix divmod (x y q u : nat) {struct x} : nat * nat :=
          match x with
          | 0%nat => (q, u)
          | S x' =>
              match u with
              | 0%nat => divmod x' y (S q) y
              | S u' => divmod x' y q u'
              end
          end)
         ((fix add (n m : nat) {struct n} : nat :=
             match n with
             | 0%nat => m
             | S p => S (add p m)
             end)
            ((fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat SF) H4) y' 0%nat y' in
     x
 end =
 S
   match
     (fix pow (n m : nat) {struct m} : nat :=
        match m with
        | 0%nat => 1%nat
        | S m0 =>
            (fix mul (n0 m1 : nat) {struct n0} : nat :=
               match n0 with
               | 0%nat => 0%nat
               | S p =>
                   (fix add (n1 m2 : nat) {struct n1} : nat :=
                      match n1 with
                      | 0%nat => m2
                      | S p0 => S (add p0 m2)
                      end) m1 (mul p m1)
               end) n (pow n m0)
        end) 2%nat SF
   with
   | 0 =>
       (fix pow (n m : nat) {struct m} : nat :=
          match m with
          | 0%nat => 1%nat
          | S m0 =>
              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                 match n0 with
                 | 0%nat => 0%nat
                 | S p =>
                     (fix add (n1 m2 : nat) {struct n1} : nat :=
                        match n1 with
                        | 0%nat => m2
                        | S p0 => S (add p0 m2)
                        end) m1 (mul p m1)
                 end) n (pow n m0)
          end) 2%nat SF
   | S y' =>
       let (x, _) :=
         (fix divmod (x y q u : nat) {struct x} : nat * nat :=
            match x with
            | 0%nat => (q, u)
            | S x' =>
                match u with
                | 0%nat => divmod x' y (S q) y
                | S u' => divmod x' y q u'
                end
            end) H4 y' 0%nat y' in
       x
   end)
Crunching: (-2 <= 1)%R
Crunching: (binlist_to_nat (repeat false x) = 0)
Crunching: (-2 <= 1)%R
Crunching: (binlist_to_nat (repeat false x) = 0)
bad
bad
Crunching: (binlist_to_nat (repeat false H) = 0)
Crunching: False
Crunching: (binlist_to_nat (repeat false H) = 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (binlist_to_nat (repeat false x) = 0)
Crunching: (-2 <= 1)%R
Crunching: (binlist_to_nat (repeat false x) = 0)
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (binlist_to_nat (repeat false H') = 0)
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (S (fst a m) = fst a (2 ^ a + m))
Crunching: (PI_2_3_7_tg (S n0) <= PI_2_3_7_tg n0)%R
Crunching: U
bad
find_witness Control.Timeoutbad
find_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Micromega_plugin.Coq_micromega.CsdpNotFoundfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: ((n < 2 ^ a)%nat -> fst a n = 0%nat)
find_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(binlist_to_nat (nat_to_binlist h 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching:
(binlist_to_nat (nat_to_binlist h 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (Nat.testbit (snd n 0) 0 = false)
Crunching:
(binlist_to_nat (nat_to_binlist h 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching:
(binlist_to_nat (nat_to_binlist h 0) = binlist_to_nat (nat_to_binlist' 0))
find_witness Control.TimeoutCrunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching: (forall n : nat, binlist_to_nat (nat_to_binlist f n) = n)
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching: (snd H9 e' = e')
Crunching: (snd H9 e' = e')
Crunching: (binlist_to_nat (nat_to_binlist le_mn2 n) = n)
Crunching: (snd H9 e' = e')
Crunching: Type
Crunching: False
Crunching: (forall n : nat, binlist_to_nat (nat_to_binlist f n) = n)
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching: (binlist_to_nat (nat_to_binlist le_mn2 n) = n)
bad
Crunching: Type
Crunching: Type
bad
find_witness Control.TimeoutCrunching: ((q < 2 ^ H9)%nat -> snd H9 q = q)
Crunching: (snd H9 e' = e')
Crunching: (snd H9 e' = e')
Crunching: (snd H9 e' = e')
Crunching: (snd H9 e' = e')
Crunching: (snd H9 e' = e')
bad
Crunching: Type
Crunching: Type
Crunching: Type
Crunching:
((S l <=
  (fix Ffix (x x0 : nat) {struct x0} : nat :=
     match x0 with
     | 0 => 1
     | S x1 =>
         (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
            match x2 with
            | 0 => 0
            | S x4 =>
                (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                   match x5 with
                   | 0 => x6
                   | S x7 => S (Ffix1 x7 x6)
                   end) x3 (Ffix0 x4 x3)
            end) x (Ffix x x1)
     end) 2 H9)%nat ->
 match
   (fix Ffix (x0 x1 : nat) {struct x1} : nat :=
      match x1 with
      | 0%nat => 1%nat
      | S x2 =>
          (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
             match x3 with
             | 0%nat => 0%nat
             | S x5 =>
                 (fix Ffix1 (x6 x7 : nat) {struct x6} : nat :=
                    match x6 with
                    | 0%nat => x7
                    | S x8 => S (Ffix1 x8 x7)
                    end) x4 (Ffix0 x5 x4)
             end) x0 (Ffix x0 x2)
      end) 2%nat H9
 with
 | 0%nat => l
 | S x0 =>
     (fix Ffix (x1 x2 : nat) {struct x1} : nat :=
        match x1 with
        | 0%nat => x1
        | S x3 => match x2 with
                  | 0%nat => x1
                  | S x4 => Ffix x3 x4
                  end
        end) x0
       (let (_, H) :=
          (fix Ffix (x1 x2 x3 x4 : nat) {struct x1} : nat * nat :=
             match x1 with
             | 0%nat => (x3, x4)
             | S x5 =>
                 match x4 with
                 | 0%nat => Ffix x5 x2 (S x3) x2
                 | S x6 => Ffix x5 x2 x3 x6
                 end
             end) l x0 0%nat x0 in
        H)
 end = l)
Crunching: positive
Crunching: Type
bad
Crunching:
(Nat.testbit (binlist_to_nat (nat_to_binlist f H8)) m = Nat.testbit H8 m)
Crunching: (forall n : nat, binlist_to_nat (nat_to_binlist f n) = n)
Crunching: False
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
(cc_good (CC.update (writes_conditions i) x cc_spec cc)
   (fun n : name =>
    if name_eqb n next_name
    then CC.cc_c (CC.update (writes_conditions i) x cc_spec cc)
    else cctx n)
   (fun n : name => if name_eqb n next_name then x mod wordmax else ctx n)
   (new_cc_to_name r i next_name))
Crunching: (snd r (2 ^ r + x) = n)
find_witness Control.TimeoutCrunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (binlist_to_nat (nat_to_binlist' l) = l)
Crunching: ((2 ^ p + IH)%nat = IH)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
(cc_good (CC.update (writes_conditions i) x cc_spec cc)
   (fun n : name =>
    if name_eqb n next_name
    then CC.cc_c (CC.update (writes_conditions i) x cc_spec cc)
    else cctx n)
   (fun n : name => if name_eqb n next_name then x mod wordmax else ctx n)
   (new_cc_to_name r i next_name))
Crunching: (cos 1 < 1 - 1 / 2 + 1 / 24)
bad
Crunching: (binlist_to_nat H9 = H1)
Crunching: (binlist_to_nat H9 = H1)
Crunching: (snd r (2 ^ r + x) = a)
Crunching: ((1 + 0 < 1 + 1)%R -> 0 = Heq)
Crunching: ((1 + 0 < 1 + 1)%R -> 0 = Heq)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching:
((forall m : nat, (m < 0)%nat -> snd r (2 ^ r + x) = m) ->
 snd r (2 ^ r + x) = 0%nat)
Crunching: (binlist_to_nat (nat_to_binlist' l) = l)
Crunching: (Z.of_nat (snd r (2 ^ r + 0)) = Z.of_nat Hr)
Crunching: (forall n : nat, nat_to_binlist' n = H -> binlist_to_nat H = n)
Crunching: (Z.of_nat (snd r (2 ^ r + 0)) = Z.of_nat Hr)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (n = snd r (2 ^ r + x))
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (n = snd r (2 ^ r + x))
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching: (snd r (2 ^ r + x) = n)
Crunching:
(∣0⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Finished transaction in 24.553 secs (23.992u,0.523s) (successful)
Finished transaction in 6.611 secs (6.522u,0.086s) (successful)
Finished transaction in 0.021 secs (0.021u,0.s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
Finished transaction in 1.567 secs (1.556u,0.009s) (successful)
Tactic call ran for 0.015 secs (0.015u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Tactic call ran for 0.011 secs (0.011u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutclear  H1  :  (False -> b1 = false)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCompilation incomplete.
You may need to add new compilation lemmas using `Hint Extern 1 => simple eapply … : compiler` or to tell Rupicola about your custom bindings using `Hint Extern 2 (IsRupicolaBinding (xlet (A := ?A) ?vars _ _)) => exact (RupicolaBinding A vars) : typeclass_instances`.
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 21.552 secs (21.34u,0.211s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 0.008 secs (0.008u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutbuild_inputs start
build_inputs end
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutbuild_merge_base_addresses start
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutbuild_merge_base_addresses end
build_merge_base_addresses start
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutbuild_merge_base_addresses end
find_witness Control.Timeoutbuild_merge_stack_placeholders start
build_merge_stack_placeholders end
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutget callee_saved_registers start
get callee_saved_registers end
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Finished transaction in 155.751 secs (152.713u,2.69s) (successful)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Finished transaction in 2.601 secs (2.594u,0.007s) (successful)
Building index_of_base...
Finished transaction in 0.004 secs (0.001u,0.002s) (successful)
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
get callee_saved_registers start
SymexLines start
SymexLines end
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
(type -> signed (Z.to_nat (Z.log2_up (bitwidth_of (signed HE)))) = signed HE)
(type -> signed (Z.to_nat (Z.log2_up (bitwidth_of (signed HE)))) = signed HE)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Finished transaction in 3.546 secs (3.542u,0.003s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
get callee_saved_registers start
get callee_saved_registers end
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
LoadArray start
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
LoadArray end
LoadOutputs start
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
LoadOutputs end
LoadOutputs start
find_witness Control.TimeoutFinished transaction in 17.843 secs (17.799u,0.043s) (successful)
Finished transaction in 0.003 secs (0.001u,0.001s) (successful)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
LoadOutputs end
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
(interp_beq p a' <> true)
find_witness Control.TimeoutBuilding base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Finished transaction in 36.44 secs (36.022u,0.414s) (successful)
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Finished transaction in 3.942 secs (3.935u,0.006s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
find_witness Control.TimeoutBuilding eqv_Reflexive_Proper...
find_witness Control.TimeoutBuilding ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Finished transaction in 8.747 secs (8.708u,0.039s) (successful)
Finished transaction in 0.004 secs (0.002u,0.001s) (successful)
Finished transaction in 70.83 secs (30.018u,0.391s) (successful)
Finished transaction in 4.087 secs (4.079u,0.002s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 6.876 secs (6.855u,0.02s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 10.707 secs (10.444u,0.225s) (successful)
find_witness Control.TimeoutFinished transaction in 0.039 secs (0.039u,0.s) (successful)
Finished transaction in 0.006 secs (0.006u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Fun.Finally_raised: Control.TimeoutFinished transaction in 3.169 secs (3.167u,0.002s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
find_witness Control.TimeoutFinished transaction in 50.656 secs (50.468u,0.192s) (successful)
Finished transaction in 2.761 secs (2.724u,0.026s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 4.101 secs (4.095u,0.005s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(eq (of_ a) (of_ b))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 38.783 secs (38.161u,0.436s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 8.556 secs (8.541u,0.015s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeout(eq (of_ a) (of_ b))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(eq (of_ a) (of_ b))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 26.042 secs (25.856u,0.147s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(eq (of_ a) (of_ b))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(eq (of_ a) (of_ b))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(EQ mod m)
find_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(k mod m)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(Hneg mod m)
find_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(Hneg mod m)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(Hneg mod m)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(EQ mod m)
find_witness Control.Timeoutfind_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(EQ mod m)
find_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
(EQ mod m)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 39.902 secs (39.087u,0.789s) (successful)
find_witness Control.TimeoutFinished transaction in 0.004 secs (0.004u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify __.m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
__.m
expr.reify_in_context: Failure in reifying:
(m mod __.m)
find_witness Control.Timeoutfind_witness Control.TimeoutUnrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify __.m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
__.m
expr.reify_in_context: Failure in reifying:
(m mod __.m)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 70.428 secs (69.537u,0.782s) (successful)
find_witness Control.TimeoutFinished transaction in 0.001 secs (0.001u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.006u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFalse
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 15.444 secs (15.309u,0.11s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 7.314 secs (7.293u,0.01s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Fun.Finally_raised: Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutwidth : Z
BW : (Bitwidth.Bitwidth width)
word : (Interface.word width)
mem : (map.map word.rep Init.Byte.byte)
locals : (map.map string word.rep)
env : (map.map string (list string * list string * Syntax.cmd))
ext_spec : Semantics.ExtSpec
varname_gen : (nat -> string)
error : Syntax.expr
parameters_sentinel : parameters
inname_gen : (nat -> string)
outname_gen : (nat -> string)
m : Z
name : string
H3 : (API.Expr (type_listZ -> type_listZ))
k' : (list bedrock_func)
e' : (list word.rep)
H : True
px : word.rep
pout : word.rep
wold_out : (list word.rep)
t : Semantics.trace
m0 : map.rep
Rx : (map.rep -> Prop)
Rout : (map.rep -> Prop)
H0 : (precondition square (map word.unsigned e', tt))
H1 : ((Bignum 0 px e' * Rx)%sep m0)
H2 : ((Bignum 0 pout wold_out * Rout)%sep m0)
F :
(forall H5 H6 : list Z,
 H5 = H6 ->
 ZRange.type.base.option.is_bounded_by (Some montgomery_domain_bounds) H5 &&
 true = true ->
 ZRange.type.base.option.is_bounded_by (Some montgomery_domain_bounds)
   (expr.Interp (@Compilers.ident_interp) H3 H5) = true /\
 expr.Interp (@Compilers.ident_interp) H3 H5 =
 expr.Interp (@Compilers.ident_interp)
   (WordByWordMontgomeryReificationCache.WordByWordMontgomery.reified_square_gen @
    (fun var : API.type -> Type => GallinaReify.base.reify width) @
    (fun var : API.type -> Type => GallinaReify.base.reify n) @
    (fun var : API.type -> Type => GallinaReify.base.reify m) @
    (fun var : API.type -> Type => GallinaReify.base.reify (m' m width))) H6)
H5 :
(ZRange.type.base.option.is_bounded_by (Some montgomery_domain_bounds)
   (expr.Interp (@Compilers.ident_interp) H3 ?H5) = true)
H6 :
(expr.Interp (@Compilers.ident_interp) H3 ?H5 =
 expr.Interp (@Compilers.ident_interp)
   (WordByWordMontgomeryReificationCache.WordByWordMontgomery.reified_square_gen @
    (fun var : API.type -> Type => GallinaReify.base.reify width) @
    (fun var : API.type -> Type => GallinaReify.base.reify n) @
    (fun var : API.type -> Type => GallinaReify.base.reify m) @
    (fun var : API.type -> Type => GallinaReify.base.reify (m' m width))) 
   ?H6)
============================
(call (make_bedrock_func name square H3 :: k') name t m0 [
   pout; px]
   (fun (t' : Semantics.trace) (m' : map.rep) (rets : list word.rep) =>
    t = t' /\
    rets = [] /\
    (exists wout : list word.rep,
       (emp
          (postcondition square (map word.unsigned e', tt)
             (map word.unsigned wout)) * Bignum 0 pout wout * Rout)%sep m')))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
a : Z
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Fun.Finally_raised: Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : bool
no_select : bool
should_split_mul : bool
should_split_multiret : bool
unfold_value_barrier : bool
widen_carry : bool
widen_bytes : bool
m : Z
machine_wordsize : Z
possible_values :=
(if BoundsPipeline.widen_carry
 then [0; machine_wordsize; 2 * machine_wordsize]
 else [0; 1; machine_wordsize; 2 * machine_wordsize]) : 
(list Z)
possible_values_with_bytes :=
(if BoundsPipeline.widen_carry
 then
  0
  :: (if BoundsPipeline.widen_bytes
      then [machine_wordsize; 2 * machine_wordsize]
      else [8; machine_wordsize; 2 * machine_wordsize])
 else
  0
  :: 1
     :: (if BoundsPipeline.widen_bytes
         then [machine_wordsize; 2 * machine_wordsize]
         else [8; machine_wordsize; 2 * machine_wordsize])) : 
(list Z)
res :
(forall var : type -> Type,
 expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
b : (type -> Type)
l2 : (type -> Type)
H : True
Hres :
(forall (H1 : Z) (H3 H2 : list Z) (H4 : Z) (H6 H5 : list Z),
 H1 = H4 ->
 H3 = H6 ->
 H2 = H5 ->
 ZRange.type.base.option.is_bounded_by (Some r[0 ~> 1]%zrange) H1 &&
 (ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H3 &&
  (ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H2 && true)) =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1 H3 H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 H3 H2 =
 expr.Interp (@Compilers.ident_interp) reified_selectznz_gen H4 H6 H5)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 ?H2) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 ?H3 ?H2 =
 expr.Interp (@Compilers.ident_interp) reified_selectznz_gen ?H4 ?H6 ?H5)
============================
(wf [] (res b) (res l2))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
requests : (list string)
curve_good : (check_args requests (Success tt) = Success tt)
res :
(Expr
   (type.base (base.type.type_base Compilers.Z) ->
    type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Fun.Finally_raised: Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
s : (type -> Type)
k : (type -> Type)
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = __.s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (__.s - c <> 0)
H3 : (0 < __.s)
H4 : (__.s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < __.s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (__.s = 2 ^ Z.log2 __.s)
H16 : (__.s <= uweight machine_wordsize n)
H17 : (__.s <= uweight 8 n_bytes)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res s) (res k))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res var1) (res var2))
bad
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
False
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res var1) (res var2))
bad
find_witness Control.Timeoutfind_witness Control.Timeoutbad
Finished transaction in 21.002 secs (20.703u,0.219s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
k : (type -> Type)
pk : (type -> Type)
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res k) (res pk))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
k : (type -> Type)
pk : (type -> Type)
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res k) (res pk))
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
s : (type -> Type)
k : (type -> Type)
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = __.s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (__.s - c <> 0)
H3 : (0 < __.s)
H4 : (__.s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < __.s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (__.s = 2 ^ Z.log2 __.s)
H16 : (__.s <= uweight machine_wordsize n)
H17 : (__.s <= uweight 8 n_bytes)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res s) (res k))
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
var1 : (type -> Type)
var2 : (type -> Type)
find_witness Control.TimeoutHres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res var1) (res var2))
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res var1) (res var2))
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
False
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
m' := (m - Z.of_nat n) : Z
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * __.m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
False
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res var1) (res var2))
bad
find_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
find_witness Control.Timeoutout of reach
Tactic call ran for 0.008 secs (0.007u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFalse
bad
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutbad
find_witness Control.Timeoutbad
find_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
k : (type -> Type)
pk : (type -> Type)
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res k) (res pk))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
k : (type -> Type)
pk : (type -> Type)
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res k) (res pk))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
k : (type -> Type)
pk : (type -> Type)
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.009 secs (0.009u,0.s) (failure)
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
find_witness Control.Timeoutfind_witness Control.Timeoutbad
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
s : (type -> Type)
k : (type -> Type)
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = __.s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (__.s - c <> 0)
H3 : (0 < __.s)
H4 : (__.s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
var1 : (type -> Type)
var2 : (type -> Type)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
(wf [] (res var1) (res var2))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.008 secs (0.007u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
s : (type -> Type)
k : (type -> Type)
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = __.s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (__.s - c <> 0)
H3 : (0 < __.s)
H4 : (__.s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < __.s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
find_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
Hres :
(forall H21 H22 : list Z,
 H21 = H22 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H21 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H21) = true /\
 expr.Interp (@Compilers.ident_interp) res H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H22)
H21 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H21) = true)
H22 :
(expr.Interp (@Compilers.ident_interp) res ?H21 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H22)
============================
False
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
m' := (m - Z.of_nat n) : Z
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * __.m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
find_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
H11 : ((m * m') mod r = -1 mod r)
H12 : (0 < machine_wordsize)
H13 : (1 < m)
H14 : (m < r ^ Z.of_nat n)
H15 : (s = 2 ^ Z.log2 s)
H16 : (s <= uweight machine_wordsize n)
H17 : (s <= uweight 8 n_bytes)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
k : (type -> Type)
pk : (type -> Type)
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = s - c)
H1 : (Z.pos (Z.to_pos m) <> 0)
H2 : (s - c <> 0)
H3 : (0 < s)
H4 : (s <> 0)
H5 : (0 < machine_wordsize)
H6 : (n <> 0%nat)
H7 : (Datatypes.length bounds = n)
H8 : (0 < 1)
H19 : (1 <= machine_wordsize)
H9 : (0 < c)
H18 : (c < s)
H10 : ((r * r') mod m = 1)
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
m : Z
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
s : (type -> Type)
k : (type -> Type)
H : (Z.pos (Z.to_pos m) = m)
H0 : (m = __.s - c)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutbad
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.001u,0.002s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.003u,0.001s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
(UnsaturatedSolinas.to_bytes n s c width = ErrorT.Success res -> False)
out of reach
Tactic call ran for 0.006 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutbad
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.005u,0.001s) (failure)
(UnsaturatedSolinas.to_bytes n s c width = ErrorT.Success res -> False)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutwidth : Z
n : nat
s : Z
c : (list (Z * Z))
res : (forall var : API.type -> Type, API.expr (type_listZ -> type_listZ))
H : True
find_witness Control.Timeoutf :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some tight_bounds) H1 && true = true ->
 ZRange.type.base.option.is_bounded_by (Some prime_bytes_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp)
   (UnsaturatedSolinasReificationCache.UnsaturatedSolinas.reified_to_bytes_gen @
    (fun var : API.type -> Type =>
     GallinaReify.base.reify
       (Qnum
          (inject_Z (Z.log2_up (s - Associational.eval c)) /
           inject_Z (Z.of_nat n)))) @
    (fun var : API.type -> Type =>
     GallinaReify.base.reify
       (QDen
          (inject_Z (Z.log2_up (s - Associational.eval c)) /
           inject_Z (Z.of_nat n)))) @
    (fun var : API.type -> Type => GallinaReify.base.reify s) @
    (fun var : API.type -> Type => GallinaReify.base.reify n) @
    (fun var : API.type -> Type => GallinaReify.base.reify width) @
    (fun var : API.type -> Type => GallinaReify.base.reify (m_enc n s c))) H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some prime_bytes_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp)
   (UnsaturatedSolinasReificationCache.UnsaturatedSolinas.reified_to_bytes_gen @
    (fun var : API.type -> Type =>
     GallinaReify.base.reify
       (Qnum
          (inject_Z (Z.log2_up (s - Associational.eval c)) /
           inject_Z (Z.of_nat n)))) @
    (fun var : API.type -> Type =>
     GallinaReify.base.reify
       (QDen
          (inject_Z (Z.log2_up (s - Associational.eval c)) /
           inject_Z (Z.of_nat n)))) @
    (fun var : API.type -> Type => GallinaReify.base.reify s) @
    (fun var : API.type -> Type => GallinaReify.base.reify n) @
    (fun var : API.type -> Type => GallinaReify.base.reify width) @
    (fun var : API.type -> Type => GallinaReify.base.reify (m_enc n s c)))
   ?H2)
============================
False
False
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.003u,0.001s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
l2 : (list Z)
H : True
H0 :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
Hres :
(forall H2 H3 : list Z,
 H2 = H3 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H2 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H3)
H2 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H2) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H3)
============================
(expr.Interp (@Compilers.ident_interp) H0 l2 = l2)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
H : True
q : Q
r : Q
H0 : (0 < q)%Q
H1 : (/ q < r)%Q
Hres :
(forall H3 H4 : list Z,
 H3 = H4 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H3 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H3) = true /\
 expr.Interp (@Compilers.ident_interp) res H3 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H4)
H3 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H3) = true)
H4 :
(expr.Interp (@Compilers.ident_interp) res ?H3 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H4)
============================
(1 < q * r)%Q
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
l2 : (list Z)
H : True
H0 :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
Hres :
(forall H2 H3 : list Z,
 H2 = H3 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H2 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H2) = true /\
 expr.Interp (@Compilers.ident_interp) res H2 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H3)
H2 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H2) = true)
H3 :
(expr.Interp (@Compilers.ident_interp) res ?H2 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H3)
============================
(expr.Interp (@Compilers.ident_interp) H0 l2 = l2)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(match v with
 | 0%Z => 0%Z
 | Z.pos a =>
     match
       match
         match match n with
               | 0%N => 0%Z
               | N.pos p => Z.pos p
               end with
         | 0%Z => 1%Z
         | Z.pos p =>
             (fix iter_fix (x : Z) (n : positive) {struct n} : Z :=
                match n with
                | (n'~1)%positive =>
                    match iter_fix (iter_fix x n') n' with
                    | 0%Z => 0%Z
                    | Z.pos y' => Z.pos y'~0
                    | Z.neg y' => Z.neg y'~0
                    end
                | (n'~0)%positive => iter_fix (iter_fix x n') n'
                | 1%positive =>
                    match x with
                    | 0%Z => 0%Z
                    | Z.pos y' => Z.pos y'~0
                    | Z.neg y' => Z.neg y'~0
                    end
                end) 1%Z p
         | Z.neg p =>
             (fix iter_fix (x : Z) (n : positive) {struct n} : Z :=
                match n with
                | (n'~1)%positive =>
                    match iter_fix (iter_fix x n') n' with
                    | Z.pos (_~1 as p0) | Z.pos (_~0 as p0) =>
                        Z.pos match p0 with
                              | p2~1 | p2~0 => p2
                              | 1 => 1
                              end
                    | Z.neg p0 =>
                        Z.neg
                          match p0 with
                          | p1~1 =>
                              (fix succ (x0 : positive) : positive :=
                                 match x0 with
                                 | (p2~1)%positive => ((succ p2)~0)%positive
                                 | (p2~0)%positive => (p2~1)%positive
                                 | 1%positive => 2%positive
                                 end) p1
                          | p1~0 => p1
                          | 1 => 1
                          end
                    | _ => 0%Z
                    end
                | (n'~0)%positive => iter_fix (iter_fix x n') n'
                | 1%positive =>
                    match x with
                    | Z.pos (_~1 as p0) | Z.pos (_~0 as p0) =>
                        Z.pos match p0 with
                              | p2~1 | p2~0 => p2
                              | 1 => 1
                              end
                    | Z.neg p0 =>
                        Z.neg
                          match p0 with
                          | p1~1 =>
                              (fix succ (x0 : positive) : positive :=
                                 match x0 with
                                 | (p2~1)%positive => ((succ p2)~0)%positive
                                 | (p2~0)%positive => (p2~1)%positive
                                 | 1%positive => 2%positive
                                 end) p1
                          | p1~0 => p1
                          | 1 => 1
                          end
                    | _ => 0%Z
                    end
                end) 1%Z p
         end
       with
       | 0%Z => (-1)%Z
       | Z.pos p~1 => Z.pos p~0
       | Z.pos p~0 =>
           Z.pos
             ((fix pred_double (x : positive) : positive :=
                 match x with
                 | (p0~1)%positive => (p0~0~1)%positive
                 | (p0~0)%positive => ((pred_double p0)~1)%positive
                 | 1%positive => 1%positive
                 end) p)
       | 1%Z => 0%Z
       | Z.neg x' =>
           Z.neg
             ((fix add (x y : positive) {struct x} : positive :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~0)%positive
                     | (q~0)%positive => ((add p q)~1)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~0)%positive
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q~1)%positive => ((add p q)~1)%positive
                     | (q~0)%positive => ((add p q)~0)%positive
                     | 1%positive => (p~1)%positive
                     end
                 | 1%positive =>
                     match y with
                     | (q~1)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~0)%positive
                     | (q~0)%positive => (q~1)%positive
                     | 1%positive => 2%positive
                     end
                 end
               with add_carry (x y : positive) {struct x} : positive :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~1)%positive
                     | (q~0)%positive => ((add_carry p q)~0)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~1)%positive
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~0)%positive
                     | (q~0)%positive => ((add p q)~1)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~0)%positive
                     end
                 | 1%positive =>
                     match y with
                     | (q~1)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~1)%positive
                     | (q~0)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~0)%positive
                     | 1%positive => 3%positive
                     end
                 end
               for
               add) x' 1%positive)
       end
     with
     | 0%Z => 0%Z
     | Z.pos b =>
         match
           (fix land (p q : positive) {struct p} : N :=
              match p with
              | (p0~1)%positive =>
                  match q with
                  | (q0~1)%positive =>
                      match land p0 q0 with
                      | 0%N => 1%N
                      | N.pos p1 => N.pos p1~1
                      end
                  | (q0~0)%positive =>
                      match land p0 q0 with
                      | 0%N => 0%N
                      | N.pos p1 => N.pos p1~0
                      end
                  | 1%positive => 1%N
                  end
              | (p0~0)%positive =>
                  match q with
                  | (q0~1)%positive | (q0~0)%positive =>
                      match land p0 q0 with
                      | 0%N => 0%N
                      | N.pos p1 => N.pos p1~0
                      end
                  | 1%positive => 0%N
                  end
              | 1%positive =>
                  match q with
                  | (_~0)%positive => 0%N
                  | _ => 1%N
                  end
              end) a b
         with
         | 0%N => 0%Z
         | N.pos p => Z.pos p
         end
     | Z.neg b =>
         match
           match
             match b with
             | (p~1)%positive => N.pos p~0
             | (p~0)%positive =>
                 N.pos
                   ((fix pred_double (x : positive) : positive :=
                       match x with
                       | (p0~1)%positive => (p0~0~1)%positive
                       | (p0~0)%positive => ((pred_double p0)~1)%positive
                       | 1%positive => 1%positive
                       end) p)
             | 1%positive => 0%N
             end
           with
           | 0%N => N.pos a
           | N.pos q =>
               (fix ldiff (p q0 : positive) {struct p} : N :=
                  match p with
                  | (p0~1)%positive =>
                      match q0 with
                      | (q1~1)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 0%N
                          | N.pos p1 => N.pos p1~0
                          end
                      | (q1~0)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 1%N
                          | N.pos p1 => N.pos p1~1
                          end
                      | 1%positive => N.pos p0~0
                      end
                  | (p0~0)%positive =>
                      match q0 with
                      | (q1~1)%positive | (q1~0)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 0%N
                          | N.pos p1 => N.pos p1~0
                          end
                      | 1%positive => N.pos p
                      end
                  | 1%positive =>
                      match q0 with
                      | (_~0)%positive => 1%N
                      | _ => 0%N
                      end
                  end) a q
           end
         with
         | 0%N => 0%Z
         | N.pos p => Z.pos p
         end
     end
 | Z.neg a =>
     match
       match
         match match n with
               | 0%N => 0%Z
               | N.pos p => Z.pos p
               end with
         | 0%Z => 1%Z
         | Z.pos p =>
             (fix iter_fix (x : Z) (n : positive) {struct n} : Z :=
                match n with
                | (n'~1)%positive =>
                    match iter_fix (iter_fix x n') n' with
                    | 0%Z => 0%Z
                    | Z.pos y' => Z.pos y'~0
                    | Z.neg y' => Z.neg y'~0
                    end
                | (n'~0)%positive => iter_fix (iter_fix x n') n'
                | 1%positive =>
                    match x with
                    | 0%Z => 0%Z
                    | Z.pos y' => Z.pos y'~0
                    | Z.neg y' => Z.neg y'~0
                    end
                end) 1%Z p
         | Z.neg p =>
             (fix iter_fix (x : Z) (n : positive) {struct n} : Z :=
                match n with
                | (n'~1)%positive =>
                    match iter_fix (iter_fix x n') n' with
                    | Z.pos (_~1 as p0) | Z.pos (_~0 as p0) =>
                        Z.pos match p0 with
                              | p2~1 | p2~0 => p2
                              | 1 => 1
                              end
                    | Z.neg p0 =>
                        Z.neg
                          match p0 with
                          | p1~1 =>
                              (fix succ (x0 : positive) : positive :=
                                 match x0 with
                                 | (p2~1)%positive => ((succ p2)~0)%positive
                                 | (p2~0)%positive => (p2~1)%positive
                                 | 1%positive => 2%positive
                                 end) p1
                          | p1~0 => p1
                          | 1 => 1
                          end
                    | _ => 0%Z
                    end
                | (n'~0)%positive => iter_fix (iter_fix x n') n'
                | 1%positive =>
                    match x with
                    | Z.pos (_~1 as p0) | Z.pos (_~0 as p0) =>
                        Z.pos match p0 with
                              | p2~1 | p2~0 => p2
                              | 1 => 1
                              end
                    | Z.neg p0 =>
                        Z.neg
                          match p0 with
                          | p1~1 =>
                              (fix succ (x0 : positive) : positive :=
                                 match x0 with
                                 | (p2~1)%positive => ((succ p2)~0)%positive
                                 | (p2~0)%positive => (p2~1)%positive
                                 | 1%positive => 2%positive
                                 end) p1
                          | p1~0 => p1
                          | 1 => 1
                          end
                    | _ => 0%Z
                    end
                end) 1%Z p
         end
       with
       | 0%Z => (-1)%Z
       | Z.pos p~1 => Z.pos p~0
       | Z.pos p~0 =>
           Z.pos
             ((fix pred_double (x : positive) : positive :=
                 match x with
                 | (p0~1)%positive => (p0~0~1)%positive
                 | (p0~0)%positive => ((pred_double p0)~1)%positive
                 | 1%positive => 1%positive
                 end) p)
       | 1%Z => 0%Z
       | Z.neg x' =>
           Z.neg
             ((fix add (x y : positive) {struct x} : positive :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~0)%positive
                     | (q~0)%positive => ((add p q)~1)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~0)%positive
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q~1)%positive => ((add p q)~1)%positive
                     | (q~0)%positive => ((add p q)~0)%positive
                     | 1%positive => (p~1)%positive
                     end
                 | 1%positive =>
                     match y with
                     | (q~1)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~0)%positive
                     | (q~0)%positive => (q~1)%positive
                     | 1%positive => 2%positive
                     end
                 end
               with add_carry (x y : positive) {struct x} : positive :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~1)%positive
                     | (q~0)%positive => ((add_carry p q)~0)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~1)%positive
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~0)%positive
                     | (q~0)%positive => ((add p q)~1)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~0)%positive
                     end
                 | 1%positive =>
                     match y with
                     | (q~1)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~1)%positive
                     | (q~0)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~0)%positive
                     | 1%positive => 3%positive
                     end
                 end
               for
               add) x' 1%positive)
       end
     with
     | 0%Z => 0%Z
     | Z.pos b =>
         match
           match
             match a with
             | (p~1)%positive => N.pos p~0
             | (p~0)%positive =>
                 N.pos
                   ((fix pred_double (x : positive) : positive :=
                       match x with
                       | (p0~1)%positive => (p0~0~1)%positive
                       | (p0~0)%positive => ((pred_double p0)~1)%positive
                       | 1%positive => 1%positive
                       end) p)
             | 1%positive => 0%N
             end
           with
           | 0%N => N.pos b
           | N.pos q =>
               (fix ldiff (p q0 : positive) {struct p} : N :=
                  match p with
                  | (p0~1)%positive =>
                      match q0 with
                      | (q1~1)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 0%N
                          | N.pos p1 => N.pos p1~0
                          end
                      | (q1~0)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 1%N
                          | N.pos p1 => N.pos p1~1
                          end
                      | 1%positive => N.pos p0~0
                      end
                  | (p0~0)%positive =>
                      match q0 with
                      | (q1~1)%positive | (q1~0)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 0%N
                          | N.pos p1 => N.pos p1~0
                          end
                      | 1%positive => N.pos p
                      end
                  | 1%positive =>
                      match q0 with
                      | (_~0)%positive => 1%N
                      | _ => 0%N
                      end
                  end) b q
           end
         with
         | 0%N => 0%Z
         | N.pos p => Z.pos p
         end
     | Z.neg b =>
         Z.neg
           match
             match
               match a with
               | (p~1)%positive => N.pos p~0
               | (p~0)%positive =>
                   N.pos
                     ((fix pred_double (x : positive) : positive :=
                         match x with
                         | (p0~1)%positive => (p0~0~1)%positive
                         | (p0~0)%positive => ((pred_double p0)~1)%positive
                         | 1%positive => 1%positive
                         end) p)
               | 1%positive => 0%N
               end
             with
             | 0%N =>
                 match b with
                 | (p~1)%positive => N.pos p~0
                 | (p~0)%positive =>
                     N.pos
                       ((fix pred_double (x : positive) : positive :=
                           match x with
                           | (p0~1)%positive => (p0~0~1)%positive
                           | (p0~0)%positive => ((pred_double p0)~1)%positive
                           | 1%positive => 1%positive
                           end) p)
                 | 1%positive => 0%N
                 end
             | N.pos p =>
                 match
                   match b with
                   | (p0~1)%positive => N.pos p0~0
                   | (p0~0)%positive =>
                       N.pos
                         ((fix pred_double (x : positive) : positive :=
                             match x with
                             | (p1~1)%positive => (p1~0~1)%positive
                             | (p1~0)%positive =>
                                 ((pred_double p1)~1)%positive
                             | 1%positive => 1%positive
                             end) p0)
                   | 1%positive => 0%N
                   end
                 with
                 | 0%N =>
                     match a with
                     | (p0~1)%positive => N.pos p0~0
                     | (p0~0)%positive =>
                         N.pos
                           ((fix pred_double (x : positive) : positive :=
                               match x with
                               | (p1~1)%positive => (p1~0~1)%positive
                               | (p1~0)%positive =>
                                   ((pred_double p1)~1)%positive
                               | 1%positive => 1%positive
                               end) p0)
                     | 1%positive => 0%N
                     end
                 | N.pos q =>
                     N.pos
                       ((fix lor (p0 q0 : positive) {struct p0} : positive :=
                           match p0 with
                           | (p1~1)%positive =>
                               match q0 with
                               | (q1~1)%positive | (q1~0)%positive =>
                                   ((lor p1 q1)~1)%positive
                               | 1%positive => p0
                               end
                           | (p1~0)%positive =>
                               match q0 with
                               | (q1~1)%positive => ((lor p1 q1)~1)%positive
                               | (q1~0)%positive => ((lor p1 q1)~0)%positive
                               | 1%positive => (p1~1)%positive
                               end
                           | 1%positive =>
                               match q0 with
                               | (q1~0)%positive => (q1~1)%positive
                               | _ => q0
                               end
                           end) p q)
                 end
             end
           with
           | 0%N => 1
           | N.pos p =>
               (fix succ (x : positive) : positive :=
                  match x with
                  | (p0~1)%positive => ((succ p0)~0)%positive
                  | (p0~0)%positive => (p0~1)%positive
                  | 1%positive => 2%positive
                  end) p
           end
     end
 end = v)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.022 secs (0.022u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.022 secs (0.02u,0.002s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(match v with
 | 0%Z => 0%Z
 | Z.pos a =>
     match
       match
         match match n with
               | 0%N => 0%Z
               | N.pos p => Z.pos p
               end with
         | 0%Z => 1%Z
         | Z.pos p =>
             (fix iter_fix (x : Z) (n : positive) {struct n} : Z :=
                match n with
                | (n'~1)%positive =>
                    match iter_fix (iter_fix x n') n' with
                    | 0%Z => 0%Z
                    | Z.pos y' => Z.pos y'~0
                    | Z.neg y' => Z.neg y'~0
                    end
                | (n'~0)%positive => iter_fix (iter_fix x n') n'
                | 1%positive =>
                    match x with
                    | 0%Z => 0%Z
                    | Z.pos y' => Z.pos y'~0
                    | Z.neg y' => Z.neg y'~0
                    end
                end) 1%Z p
         | Z.neg p =>
             (fix iter_fix (x : Z) (n : positive) {struct n} : Z :=
                match n with
                | (n'~1)%positive =>
                    match iter_fix (iter_fix x n') n' with
                    | Z.pos (_~1 as p0) | Z.pos (_~0 as p0) =>
                        Z.pos match p0 with
                              | p2~1 | p2~0 => p2
                              | 1 => 1
                              end
                    | Z.neg p0 =>
                        Z.neg
                          match p0 with
                          | p1~1 =>
                              (fix succ (x0 : positive) : positive :=
                                 match x0 with
                                 | (p2~1)%positive => ((succ p2)~0)%positive
                                 | (p2~0)%positive => (p2~1)%positive
                                 | 1%positive => 2%positive
                                 end) p1
                          | p1~0 => p1
                          | 1 => 1
                          end
                    | _ => 0%Z
                    end
                | (n'~0)%positive => iter_fix (iter_fix x n') n'
                | 1%positive =>
                    match x with
                    | Z.pos (_~1 as p0) | Z.pos (_~0 as p0) =>
                        Z.pos match p0 with
                              | p2~1 | p2~0 => p2
                              | 1 => 1
                              end
                    | Z.neg p0 =>
                        Z.neg
                          match p0 with
                          | p1~1 =>
                              (fix succ (x0 : positive) : positive :=
                                 match x0 with
                                 | (p2~1)%positive => ((succ p2)~0)%positive
                                 | (p2~0)%positive => (p2~1)%positive
                                 | 1%positive => 2%positive
                                 end) p1
                          | p1~0 => p1
                          | 1 => 1
                          end
                    | _ => 0%Z
                    end
                end) 1%Z p
         end
       with
       | 0%Z => (-1)%Z
       | Z.pos p~1 => Z.pos p~0
       | Z.pos p~0 =>
           Z.pos
             ((fix pred_double (x : positive) : positive :=
                 match x with
                 | (p0~1)%positive => (p0~0~1)%positive
                 | (p0~0)%positive => ((pred_double p0)~1)%positive
                 | 1%positive => 1%positive
                 end) p)
       | 1%Z => 0%Z
       | Z.neg x' =>
           Z.neg
             ((fix add (x y : positive) {struct x} : positive :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~0)%positive
                     | (q~0)%positive => ((add p q)~1)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~0)%positive
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q~1)%positive => ((add p q)~1)%positive
                     | (q~0)%positive => ((add p q)~0)%positive
                     | 1%positive => (p~1)%positive
                     end
                 | 1%positive =>
                     match y with
                     | (q~1)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~0)%positive
                     | (q~0)%positive => (q~1)%positive
                     | 1%positive => 2%positive
                     end
                 end
               with add_carry (x y : positive) {struct x} : positive :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~1)%positive
                     | (q~0)%positive => ((add_carry p q)~0)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~1)%positive
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~0)%positive
                     | (q~0)%positive => ((add p q)~1)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~0)%positive
                     end
                 | 1%positive =>
                     match y with
                     | (q~1)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~1)%positive
                     | (q~0)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~0)%positive
                     | 1%positive => 3%positive
                     end
                 end
               for
               add) x' 1%positive)
       end
     with
     | 0%Z => 0%Z
     | Z.pos b =>
         match
           (fix land (p q : positive) {struct p} : N :=
              match p with
              | (p0~1)%positive =>
                  match q with
                  | (q0~1)%positive =>
                      match land p0 q0 with
                      | 0%N => 1%N
                      | N.pos p1 => N.pos p1~1
                      end
                  | (q0~0)%positive =>
                      match land p0 q0 with
                      | 0%N => 0%N
                      | N.pos p1 => N.pos p1~0
                      end
                  | 1%positive => 1%N
                  end
              | (p0~0)%positive =>
                  match q with
                  | (q0~1)%positive | (q0~0)%positive =>
                      match land p0 q0 with
                      | 0%N => 0%N
                      | N.pos p1 => N.pos p1~0
                      end
                  | 1%positive => 0%N
                  end
              | 1%positive =>
                  match q with
                  | (_~0)%positive => 0%N
                  | _ => 1%N
                  end
              end) a b
         with
         | 0%N => 0%Z
         | N.pos p => Z.pos p
         end
     | Z.neg b =>
         match
           match
             match b with
             | (p~1)%positive => N.pos p~0
             | (p~0)%positive =>
                 N.pos
                   ((fix pred_double (x : positive) : positive :=
                       match x with
                       | (p0~1)%positive => (p0~0~1)%positive
                       | (p0~0)%positive => ((pred_double p0)~1)%positive
                       | 1%positive => 1%positive
                       end) p)
             | 1%positive => 0%N
             end
           with
           | 0%N => N.pos a
           | N.pos q =>
               (fix ldiff (p q0 : positive) {struct p} : N :=
                  match p with
                  | (p0~1)%positive =>
                      match q0 with
                      | (q1~1)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 0%N
                          | N.pos p1 => N.pos p1~0
                          end
                      | (q1~0)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 1%N
                          | N.pos p1 => N.pos p1~1
                          end
                      | 1%positive => N.pos p0~0
                      end
                  | (p0~0)%positive =>
                      match q0 with
                      | (q1~1)%positive | (q1~0)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 0%N
                          | N.pos p1 => N.pos p1~0
                          end
                      | 1%positive => N.pos p
                      end
                  | 1%positive =>
                      match q0 with
                      | (_~0)%positive => 1%N
                      | _ => 0%N
                      end
                  end) a q
           end
         with
         | 0%N => 0%Z
         | N.pos p => Z.pos p
         end
     end
 | Z.neg a =>
     match
       match
         match match n with
               | 0%N => 0%Z
               | N.pos p => Z.pos p
               end with
         | 0%Z => 1%Z
         | Z.pos p =>
             (fix iter_fix (x : Z) (n : positive) {struct n} : Z :=
                match n with
                | (n'~1)%positive =>
                    match iter_fix (iter_fix x n') n' with
                    | 0%Z => 0%Z
                    | Z.pos y' => Z.pos y'~0
                    | Z.neg y' => Z.neg y'~0
                    end
                | (n'~0)%positive => iter_fix (iter_fix x n') n'
                | 1%positive =>
                    match x with
                    | 0%Z => 0%Z
                    | Z.pos y' => Z.pos y'~0
                    | Z.neg y' => Z.neg y'~0
                    end
                end) 1%Z p
         | Z.neg p =>
             (fix iter_fix (x : Z) (n : positive) {struct n} : Z :=
                match n with
                | (n'~1)%positive =>
                    match iter_fix (iter_fix x n') n' with
                    | Z.pos (_~1 as p0) | Z.pos (_~0 as p0) =>
                        Z.pos match p0 with
                              | p2~1 | p2~0 => p2
                              | 1 => 1
                              end
                    | Z.neg p0 =>
                        Z.neg
                          match p0 with
                          | p1~1 =>
                              (fix succ (x0 : positive) : positive :=
                                 match x0 with
                                 | (p2~1)%positive => ((succ p2)~0)%positive
                                 | (p2~0)%positive => (p2~1)%positive
                                 | 1%positive => 2%positive
                                 end) p1
                          | p1~0 => p1
                          | 1 => 1
                          end
                    | _ => 0%Z
                    end
                | (n'~0)%positive => iter_fix (iter_fix x n') n'
                | 1%positive =>
                    match x with
                    | Z.pos (_~1 as p0) | Z.pos (_~0 as p0) =>
                        Z.pos match p0 with
                              | p2~1 | p2~0 => p2
                              | 1 => 1
                              end
                    | Z.neg p0 =>
                        Z.neg
                          match p0 with
                          | p1~1 =>
                              (fix succ (x0 : positive) : positive :=
                                 match x0 with
                                 | (p2~1)%positive => ((succ p2)~0)%positive
                                 | (p2~0)%positive => (p2~1)%positive
                                 | 1%positive => 2%positive
                                 end) p1
                          | p1~0 => p1
                          | 1 => 1
                          end
                    | _ => 0%Z
                    end
                end) 1%Z p
         end
       with
       | 0%Z => (-1)%Z
       | Z.pos p~1 => Z.pos p~0
       | Z.pos p~0 =>
           Z.pos
             ((fix pred_double (x : positive) : positive :=
                 match x with
                 | (p0~1)%positive => (p0~0~1)%positive
                 | (p0~0)%positive => ((pred_double p0)~1)%positive
                 | 1%positive => 1%positive
                 end) p)
       | 1%Z => 0%Z
       | Z.neg x' =>
           Z.neg
             ((fix add (x y : positive) {struct x} : positive :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~0)%positive
                     | (q~0)%positive => ((add p q)~1)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~0)%positive
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q~1)%positive => ((add p q)~1)%positive
                     | (q~0)%positive => ((add p q)~0)%positive
                     | 1%positive => (p~1)%positive
                     end
                 | 1%positive =>
                     match y with
                     | (q~1)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~0)%positive
                     | (q~0)%positive => (q~1)%positive
                     | 1%positive => 2%positive
                     end
                 end
               with add_carry (x y : positive) {struct x} : positive :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~1)%positive
                     | (q~0)%positive => ((add_carry p q)~0)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~1)%positive
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q~1)%positive => ((add_carry p q)~0)%positive
                     | (q~0)%positive => ((add p q)~1)%positive
                     | 1%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p0~1 => (succ p0)~0
                              | p0~0 => p0~1
                              | 1 => 2
                              end) p)~0)%positive
                     end
                 | 1%positive =>
                     match y with
                     | (q~1)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~1)%positive
                     | (q~0)%positive =>
                         (((fix succ (x0 : positive) : positive :=
                              match x0 with
                              | p~1 => (succ p)~0
                              | p~0 => p~1
                              | 1 => 2
                              end) q)~0)%positive
                     | 1%positive => 3%positive
                     end
                 end
               for
               add) x' 1%positive)
       end
     with
     | 0%Z => 0%Z
     | Z.pos b =>
         match
           match
             match a with
             | (p~1)%positive => N.pos p~0
             | (p~0)%positive =>
                 N.pos
                   ((fix pred_double (x : positive) : positive :=
                       match x with
                       | (p0~1)%positive => (p0~0~1)%positive
                       | (p0~0)%positive => ((pred_double p0)~1)%positive
                       | 1%positive => 1%positive
                       end) p)
             | 1%positive => 0%N
             end
           with
           | 0%N => N.pos b
           | N.pos q =>
               (fix ldiff (p q0 : positive) {struct p} : N :=
                  match p with
                  | (p0~1)%positive =>
                      match q0 with
                      | (q1~1)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 0%N
                          | N.pos p1 => N.pos p1~0
                          end
                      | (q1~0)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 1%N
                          | N.pos p1 => N.pos p1~1
                          end
                      | 1%positive => N.pos p0~0
                      end
                  | (p0~0)%positive =>
                      match q0 with
                      | (q1~1)%positive | (q1~0)%positive =>
                          match ldiff p0 q1 with
                          | 0%N => 0%N
                          | N.pos p1 => N.pos p1~0
                          end
                      | 1%positive => N.pos p
                      end
                  | 1%positive =>
                      match q0 with
                      | (_~0)%positive => 1%N
                      | _ => 0%N
                      end
                  end) b q
           end
         with
         | 0%N => 0%Z
         | N.pos p => Z.pos p
         end
     | Z.neg b =>
         Z.neg
           match
             match
               match a with
               | (p~1)%positive => N.pos p~0
               | (p~0)%positive =>
                   N.pos
                     ((fix pred_double (x : positive) : positive :=
                         match x with
                         | (p0~1)%positive => (p0~0~1)%positive
                         | (p0~0)%positive => ((pred_double p0)~1)%positive
                         | 1%positive => 1%positive
                         end) p)
               | 1%positive => 0%N
               end
             with
             | 0%N =>
                 match b with
                 | (p~1)%positive => N.pos p~0
                 | (p~0)%positive =>
                     N.pos
                       ((fix pred_double (x : positive) : positive :=
                           match x with
                           | (p0~1)%positive => (p0~0~1)%positive
                           | (p0~0)%positive => ((pred_double p0)~1)%positive
                           | 1%positive => 1%positive
                           end) p)
                 | 1%positive => 0%N
                 end
             | N.pos p =>
                 match
                   match b with
                   | (p0~1)%positive => N.pos p0~0
                   | (p0~0)%positive =>
                       N.pos
                         ((fix pred_double (x : positive) : positive :=
                             match x with
                             | (p1~1)%positive => (p1~0~1)%positive
                             | (p1~0)%positive =>
                                 ((pred_double p1)~1)%positive
                             | 1%positive => 1%positive
                             end) p0)
                   | 1%positive => 0%N
                   end
                 with
                 | 0%N =>
                     match a with
                     | (p0~1)%positive => N.pos p0~0
                     | (p0~0)%positive =>
                         N.pos
                           ((fix pred_double (x : positive) : positive :=
                               match x with
                               | (p1~1)%positive => (p1~0~1)%positive
                               | (p1~0)%positive =>
                                   ((pred_double p1)~1)%positive
                               | 1%positive => 1%positive
                               end) p0)
                     | 1%positive => 0%N
                     end
                 | N.pos q =>
                     N.pos
                       ((fix lor (p0 q0 : positive) {struct p0} : positive :=
                           match p0 with
                           | (p1~1)%positive =>
                               match q0 with
                               | (q1~1)%positive | (q1~0)%positive =>
                                   ((lor p1 q1)~1)%positive
                               | 1%positive => p0
                               end
                           | (p1~0)%positive =>
                               match q0 with
                               | (q1~1)%positive => ((lor p1 q1)~1)%positive
                               | (q1~0)%positive => ((lor p1 q1)~0)%positive
                               | 1%positive => (p1~1)%positive
                               end
                           | 1%positive =>
                               match q0 with
                               | (q1~0)%positive => (q1~1)%positive
                               | _ => q0
                               end
                           end) p q)
                 end
             end
           with
           | 0%N => 1
           | N.pos p =>
               (fix succ (x : positive) : positive :=
                  match x with
                  | (p0~1)%positive => ((succ p0)~0)%positive
                  | (p0~0)%positive => (p0~1)%positive
                  | 1%positive => 2%positive
                  end) p
           end
     end
 end = v)
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.019 secs (0.019u,0.s) (success)
out of reach
Tactic call ran for 0.013 secs (0.012u,0.s) (failure)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.013 secs (0.011u,0.001s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_boundsfind_witness Control.Timeoutfind_witness Control.Timeout) H1 && true =
 trueoutput_options : output_options_opt
 low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.019 secs (0.018u,0.001s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
find_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
Tactic call ran for 0.018 secs (0.018u,0.s) (success)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
(∀ (pred : g (buf_push buf x) → predicate) (k : nlet_eq_k g (buf_push buf x)) 
   (k_impl : cmd) (R : map.rep → Prop),
   (buffer_at c buf a ⋆ R) m
   → Z.of_nat (length buf) + 1 <= c
     → DEXPR m l buf_expr a
       → DEXPR m l len_expr (word.of_Z (Z.of_nat (length buf)))
         → DEXPR m l x_expr (word_of_byte x)
           → (∀ m,
                (buffer_at c (buf ++ [x]) a ⋆ R) m
                → <{ Trace := t; Memory := m; Locals := l; Functions := e }>
                    k_impl
                  <{ pred (k (buf_push buf x) eq_refl) }>)
             → <{ Trace := t; Memory := m; Locals := l; Functions := e }>
                 bedrock_func_body:(
                 store1($buf_expr + $len_expr, $x_expr);
                 $k_impl
                )
               <{ pred (let/n x as var eq:Heq := buf_push buf x in k x Heq) }>)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutoutput_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.009 secs (0.009u,0.s) (failure)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.009 secs (0.009u,0.s) (failure)
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
output_options : output_options_opt
low_level_rewriter_method : low_level_rewriter_method_opt
only_signed : only_signed_opt
no_select : no_select_opt
should_split_mul : should_split_mul_opt
should_split_multiret : should_split_multiret_opt
unfold_value_barrier : unfold_value_barrier_opt
widen_carry : widen_carry_opt
widen_bytes : widen_bytes_opt
n : nat
machine_wordsize : machine_wordsize_opt
possible_values := possible_values_of_machine_wordsize : (list Z)
possible_values_with_bytes := possible_values_of_machine_wordsize_with_bytes
: (list Z)
res :
(Expr
   (type.base (base.type.list (base.type.type_base Compilers.Z)) ->
    type.base (base.type.list (base.type.type_base Compilers.Z))))
x : (type -> Type)
H : True
var2 : (type -> Type)
Hres :
(forall H1 H2 : list Z,
 H1 = H2 ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds) H1 && true =
 true ->
 ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res H1) = true /\
 expr.Interp (@Compilers.ident_interp) res H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen H2)
H1 :
(ZRange.type.base.option.is_bounded_by (Some saturated_bounds)
   (expr.Interp (@Compilers.ident_interp) res ?H1) = true)
H2 :
(expr.Interp (@Compilers.ident_interp) res ?H1 =
 expr.Interp (@Compilers.ident_interp) reified_id_gen ?H2)
============================
(wf [] (res x) (res var2))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.001s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
(∀ (pred : g (buf_push buf x) → predicate) (k : nlet_eq_k g (buf_push buf x)) 
   (k_impl : cmd) (R : map.rep → Prop),
   (buffer_at c buf a ⋆ R) m
   → Z.of_nat (length buf) + 1 <= c
     → DEXPR m l buf_expr a
       → DEXPR m l len_expr (word.of_Z (Z.of_nat (length buf)))
         → DEXPR m l x_expr (word_of_byte x)
           → (∀ m,
                (buffer_at c (buf ++ [x]) a ⋆ R) m
                → <{ Trace := t; Memory := m; Locals := l; Functions := e }>
                    k_impl
                  <{ pred (k (buf_push buf x) eq_refl) }>)
             → <{ Trace := t; Memory := m; Locals := l; Functions := e }>
                 bedrock_func_body:(
                 store1($buf_expr + $len_expr, $x_expr);
                 $k_impl
                )
               <{ pred (let/n x as var eq:Heq := buf_push buf x in k x Heq) }>)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutFinished transaction in 32.483 secs (31.994u,0.45s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 0.015 secs (0.015u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.011 secs (0.004u,0.006s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Fun.Finally_raised: Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.008 secs (0.006u,0.001s) (failure)
out of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
out of reach
Tactic call ran for 0.016 secs (0.01u,0.006s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.007 secs (0.006u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.01 secs (0.009u,0.001s) (failure)
out of reach
Tactic call ran for 0.01 secs (0.006u,0.003s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
(forall x y : dag,
 ?R x y -> build_inputarray len x = (fst (build_inputarray_G vals (G, d)), y))
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
find_witness Control.Timeout(forall x y : dag,
 ?R x y -> build_inputarray len x = (fst (build_inputarray_G vals (G, d)), y))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
(forall x y : dag,
 ?R x y -> build_inputarray len x = (fst (build_inputarray_G vals (G, d)), y))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.007 secs (0.006u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
find_witness Control.TimeoutFinished transaction in 3.846 secs (3.83u,0.01s) (successful)
Finished transaction in 0.006 secs (0.006u,0.s) (successful)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 5.271 secs (5.252u,0.012s) (successful)
Finished transaction in 0.005 secs (0.005u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
find_witness Control.Timeoutfind_witness Control.Timeout(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
find_witness Control.Timeoutfind_witness Control.Timeout(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
find_witness Control.Timeout(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(Forall2
   (fun (idx0 : option idx) (v : Z) =>
    forall idx' : idx, idx0 = Some idx' -> eval_idx_Z G s idx' v)
   (List.map (get_reg s) (List.map reg_index regs))
   (List.map (Semantics.get_reg m) regs))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(Forall2
   (fun (idx0 : option idx) (v : Z) =>
    forall idx' : idx, idx0 = Some idx' -> eval_idx_Z G s idx' v)
   (List.map (get_reg s) (List.map reg_index regs))
   (List.map (Semantics.get_reg m) regs))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(make_ctx consts_list n = 0 \/ In (n, make_ctx consts_list n) consts_list)
find_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(Forall2
   (fun (idx0 : option idx) (v : Z) =>
    forall idx' : idx, idx0 = Some idx' -> eval_idx_Z G s idx' v)
   (List.map (get_reg s) (List.map reg_index regs))
   (List.map (Semantics.get_reg m) regs))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 68.338 secs (27.122u,0.519s) (successful)
Finished transaction in 0.007 secs (0.006u,0.001s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
rewrite if_dtt
if (n =? S r)
then
(fun E : (n =? S r) = true =>
 ltN_of_nat 0 n
   (ltN_S_mod_lemma1 (exist (fun k : nat => (k <? n) = true) r Hr) E))
else
(fun E : (n =? S r) = false =>
 ltN_of_nat (S r) n
   (ltN_S_mod_lemma2 (exist (fun k : nat => (k <? n) = true) r Hr) E))
Finished transaction in 79.031 secs (78.642u,0.316s) (successful)
bad
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 184.642 secs (140.384u,3.309s) (successful)
Finished transaction in 0.01 secs (0.01u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 46.941 secs (5.912u,0.428s) (successful)
Finished transaction in 0.005 secs (0.005u,0.s) (successful)
bad
find_witness Control.Timeoutrewrite if_dtt
if (n =? proj1_sig r)
then
(fun E : (n =? proj1_sig r) = true =>
 ltN_of_nat 0 (S n) (ltN_S_mod_lemma1 r E))
else
(fun E : (n =? proj1_sig r) = false =>
 ltN_of_nat (S (proj1_sig r)) (S n) (ltN_S_mod_lemma2 r E))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Finished transaction in 53.985 secs (12.877u,0.449s) (successful)
Finished transaction in 0.006 secs (0.005u,0.s) (successful)
out of reach
Tactic call ran for 0.005 secs (0.003u,0.002s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutrewrite if_dtt
if (1 =? S (proj1_sig (snd qr)))
then
(fun E : (1 =? S (proj1_sig (snd qr))) = true =>
 ltN_of_nat 0 1 (ltN_S_mod_lemma1 (snd qr) E))
else
(fun E : (1 =? S (proj1_sig (snd qr))) = false =>
 ltN_of_nat (S (proj1_sig (snd qr))) 1 (ltN_S_mod_lemma2 (snd qr) E))
find_witness Control.Timeout(Proper (?abstract_domain'_R@{t:=type.base t; G':=a; HGG':=b} t0)
   (bottom' t0))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
(Proper (?abstract_domain'_R@{t:=type.base t; G':=a; HGG':=b} t0)
   (bottom' t0))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(Proper (?abstract_domain'_R@{t:=type.base t; G':=a; HGG':=b} t0)
   (bottom' t0))
find_witness Control.Timeout(Proper (?abstract_domain'_R@{t:=type.base t; G':=a; HGG':=b} t0)
   (bottom' t0))
find_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
(Proper (?abstract_domain'_R@{t:=type.base t; G':=a; HGG':=b} t0)
   (bottom' t0))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(Proper (?abstract_domain'_R@{t:=type.base t; G':=a; HGG':=b} t0)
   (bottom' t0))
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
(Proper (?abstract_domain'_R@{t:=type.base t; G':=a; HGG':=b} t0)
   (bottom' t0))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.007 secs (0.006u,0.001s) (success)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.021 secs (0.021u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 50.978 secs (9.902u,0.411s) (successful)
Finished transaction in 0.006 secs (0.005u,0.s) (successful)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCompilation incomplete.
You may need to add new compilation lemmas using `Hint Extern 1 => simple eapply … : compiler` or to tell Rupicola about your custom bindings using `Hint Extern 2 (IsRupicolaBinding (xlet (A := ?A) ?vars _ _)) => exact (RupicolaBinding A vars) : typeclass_instances`.
rewrite if_dtt
if (n =? S (proj1_sig k))
then
(fun E : (n =? S (proj1_sig k)) = true =>
 ltN_of_nat 0 n (ltN_S_mod_lemma1 k E))
else
(fun E : (n =? S (proj1_sig k)) = false =>
 ltN_of_nat (S (proj1_sig k)) n (ltN_S_mod_lemma2 k E))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutout of reach
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Finished transaction in 45.515 secs (4.577u,0.375s) (successful)
Finished transaction in 0.005 secs (0.005u,0.s) (successful)
bad
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 42.478 secs (0.963u,0.555s) (successful)
Finished transaction in 0.006 secs (0.004u,0.001s) (successful)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.008 secs (0.007u,0.001s) (failure)
Finished transaction in 46.948 secs (5.933u,0.38s) (successful)
Finished transaction in 0.006 secs (0.006u,0.s) (successful)
Finished transaction in 42.213 secs (0.817u,0.514s) (successful)
Finished transaction in 0.004 secs (0.004u,0.s) (successful)
find_witness Control.Timeout(gensym_dag_ok H1 d ->
 build_inputs types d = (inputs, d') ->
 exists G' : symbol -> option Z,
   Forall2
     (fun (v1 : idx + list idx) (v2 : Z + list Z) =>
      match v1 with
      | inl idx =>
          match v2 with
          | inl v => eval_idx_Z G' d' idx v
          | inr _ => False
          end
      | inr idxs =>
          match v2 with
          | inl _ => False
          | inr vs => Forall2 (eval_idx_Z G' d') idxs vs
          end
      end) inputs args /\
   gensym_dag_ok G' d' /\
   (forall (e : Symbolic.expr) (n : Z), eval H1 d e n -> eval G' d' e n))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 53.576 secs (12.525u,0.402s) (successful)
Finished transaction in 0.005 secs (0.005u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutWarning: gather_SEP with numeric arguments is deprecated
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 105.499 secs (62.873u,1.583s) (successful)
Finished transaction in 0.006 secs (0.004u,0.001s) (successful)
(Z * Z ->
 forall var2 : type -> Type,
 wf nil
   (EvalWithBound relax_zrange assume_cast_truncates skip_annotations_under
      strip_preexisting_annotations e bound H)
   (EvalWithBound relax_zrange assume_cast_truncates skip_annotations_under
      strip_preexisting_annotations e bound var2))
out of reach
Tactic call ran for 0.003 secs (0.001u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutbad
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutclear  IHn  :  (False -> (0 <? 0) = true -> False)
clear  IHn  :  (False -> (0 <? 0) = true -> False)
clear  IHn  :  (False -> (0 <? 0) = true -> False)
clear  IHn  :  (False -> (0 <? 0) = true -> False)
clear  IHn  :  (False -> (0 <? 0) = true -> False)
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.008 secs (0.008u,0.s) (success)
find_witness Control.Timeout((R_list_scalar_or_array i1 w1 ⋆ R_list_scalar_or_array i2 w2)%sep x)
clear  H0a'  :  (False -> cmpA a a' <> Lt)
Finished transaction in 106.86 secs (63.83u,1.843s) (successful)
Finished transaction in 0.005 secs (0.005u,0.s) (successful)
bad
bad
bad
bad
bad
bad
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
Crunching: (fst n (2 ^ n * l + p1) = l)
Crunching: (fst n (l * 2 ^ n + p1) = l)
Crunching: (fst n (2 ^ n * l + p1) = l)
bad
Crunching: (fst n (l * 2 ^ n + p1) = l)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching: (fst n (l * 2 ^ n + p1) = l)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
Crunching: (fst n (2 ^ n * l + p1) = l)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (fst n (l * 2 ^ n + p1) = l)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching: (fst n (2 ^ n * l + p1) = l)
Crunching: (fst n (l * 2 ^ n + p1) = l)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
find_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
Crunching: (((n * 2 ^ Hab + m) / 2 ^ Hab)%nat = n)
Crunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
Crunching:
(forall l : list bool,
 Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
bad
Crunching:
(forall l : list bool,
 Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
bad
bad
bad
find_witness Control.Timeoutbad
Crunching:
(forall l : list bool,
 Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
bad
bad
bad
Crunching: (snd LE (EQ * 2 ^ LE + a) = a)
bad
Crunching: (∣0⟩ = basis_vector 2 0)
bad
Crunching:
(forall l : list bool,
 Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (snd LE (EQ * 2 ^ LE + a) = a)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(Forall (fun b : bool => b = true) (Hc :: x) ->
 length (if Hc then false :: incr_bin x else true :: x) = S (S (length x)))
Crunching: False
Crunching: False
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (a = snd LE (EQ * 2 ^ LE + a))
Crunching: (snd LE (EQ * 2 ^ LE + a) = a)
Crunching: (snd n (x * 2 ^ n + y) = y)
Finished transaction in 42.078 secs (0.505u,0.585s) (successful)
Finished transaction in 0.008 secs (0.006u,0.002s) (successful)
find_witness Control.TimeoutCrunching:
(Nat.testbit (length (incr_bin [a])) m ⊕ Nat.testbit (length [a]) m = false)
Crunching: (forall y : C, P' + y = y + P')
Crunching: (exp_in 0 (exp 0) -> length (incr_bin n) = length n)
Crunching: (exp_in 0 (exp 0) -> length (incr_bin n) = length n)
find_witness Control.Timeoutbad
(wf nil
   (GeneralizeVar.GeneralizeVar
      (E (fun _ : type => FMapPositive.PositiveMap.key))
      (partial.value_with_lets ZRange.type.base.option.interp))
   (GeneralizeVar.GeneralizeVar
      (E (fun _ : type => FMapPositive.PositiveMap.key))
      (partial.value_with_lets ZRange.type.base.option.interp)))
Crunching: (length (incr_bin z1) = length z1)
bad
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(Nat.testbit (length (incr_bin [a])) m ⊕ Nat.testbit (length [a]) m = false)
Crunching: (true = x)
