find_witness Control.TimeoutChars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 42 [Require~Import~Basics.Overture...] 0.023 secs (0.013u,0.009s)
Chars 260 - 319 [Ltac~show_goal~:=~match~goal~w...] 0. secs (0.u,0.s)
Chars 321 - 550 [Ltac~~show_hyp~id~:=~~~match~g...] 0. secs (0.u,0.s)
Chars 552 - 657 [Ltac~~show_hyps~:=~try~match~r...] 0. secs (0.u,0.s)
Chars 709 - 803 [Ltac~do_nat~n~tac~:=~match~n~w...] 0. secs (0.u,0.s)
Chars 858 - 947 [Ltac~~on_last_hyp~tac~:=~match...] 0. secs (0.u,0.s)
Chars 1008 - 1095 [Ltac~destruct_one_pair~:=~matc...] 0. secs (0.u,0.s)
Chars 1133 - 1183 [Ltac~destruct_pairs~:=~repeat~...] 0. secs (0.u,0.s)
Chars 1287 - 1443 [Ltac~~destruct_one_ex~:=~~~let...] 0. secs (0.u,0.s)
Chars 1488 - 1537 [Ltac~destruct_exists~:=~repeat...] 0. secs (0.u,0.s)
Chars 1599 - 1668 [Ltac~destruct_conjs~:=~repeat~...] 0. secs (0.u,0.s)
Chars 1791 - 1869 [Tactic~Notation~"destruct"~"ex...] 0. secs (0.u,0.s)
Chars 1937 - 2001 [Tactic~Notation~"destruct"~"or...] 0. secs (0.u,0.s)
Chars 2065 - 2193 [Ltac~discriminates~:=~match~go...] 0. secs (0.u,0.s)
Chars 2231 - 2306 [Ltac~revert_last~:=~match~goal...] 0. secs (0.u,0.s)
Chars 2388 - 2423 [Ltac~reverse~:=~repeat~revert_...] 0. secs (0.u,0.s)
Chars 2488 - 2633 [Ltac~~revert_until~id~:=~~~on_...] 0. secs (0.u,0.s)
Chars 2671 - 2917 [Ltac~~clear_dup~:=~~~match~goa...] 0. secs (0.u,0.s)
Chars 2919 - 2955 [Ltac~clear_dups~:=~repeat~clea...] 0. secs (0.u,0.s)
Chars 3005 - 3182 [Ltac~~clear_except~hyp~:=~~~re...] 0. secs (0.u,0.s)
Chars 3250 - 3278 [Ltac~subst_no_fail~:=~idtac.] 0. secs (0.u,0.s)
Chars 3395 - 3440 [Tactic~Notation~"subst"~"*"~:=...] 0. secs (0.u,0.s)
Chars 3442 - 3980 [Ltac~~on_application~f~tac~T~:...] 0. secs (0.u,0.s)
Chars 4082 - 4212 [Ltac~~on_call~f~tac~:=~~~match...] 0. secs (0.u,0.s)
Chars 4308 - 4377 [Ltac~destruct_call~f~:=~let~ta...] 0. secs (0.u,0.s)
Chars 4379 - 4427 [Ltac~destruct_calls~f~:=~repea...] 0. secs (0.u,0.s)
Chars 4429 - 4540 [Ltac~~destruct_call_in~f~H~:=~...] 0. secs (0.u,0.s)
Chars 4542 - 4621 [Ltac~destruct_call_as~f~l~:=~l...] 0. secs (0.u,0.s)
Chars 4623 - 4744 [Ltac~~destruct_call_as_in~f~l~...] 0. secs (0.u,0.s)
Chars 4746 - 4807 [Tactic~Notation~"destruct_call...] 0. secs (0.u,0.s)
Chars 4876 - 4972 [Tactic~Notation~"destruct_call...] 0. secs (0.u,0.s)
Chars 5039 - 5121 [Tactic~Notation~"destruct_call...] 0. secs (0.u,0.s)
Chars 5123 - 5238 [Tactic~Notation~~"destruct_cal...] 0. secs (0.u,0.s)
Chars 5285 - 5330 [Definition~fix_proto~{A~:~Type...] 0. secs (0.u,0.s)
Chars 5332 - 5444 [Ltac~~destruct_rec_calls~:=~~~...] 0. secs (0.u,0.s)
Chars 5446 - 5529 [Ltac~~destruct_all_rec_calls~:...] 0. secs (0.u,0.s)
Chars 5600 - 5632 [Ltac~autoinjection~tac~:=~idtac.] 0. secs (0.u,0.s)
Chars 5721 - 5792 [Ltac~inject~H~:=~progress~(inv...] 0. secs (0.u,0.s)
Chars 5794 - 5867 [Ltac~autoinjections~:=~repeat~...] 0. secs (0.u,0.s)
Chars 5943 - 6021 [Ltac~~destruct_nondep~H~:=~let...] 0. secs (0.u,0.s)
Chars 6123 - 6250 [Ltac~~bang~:=~~~match~goal~wit...] 0. secs (0.u,0.s)
Chars 6347 - 6462 [Tactic~Notation~"contradiction...] 0. secs (0.u,0.s)
Chars 6620 - 6813 [Ltac~~add_hypothesis~H'~p~:=~~...] 0. secs (0.u,0.s)
Chars 6874 - 6972 [Ltac~~replace_hyp~H~c~:=~~~let...] 0. secs (0.u,0.s)
Chars 7051 - 7363 [Ltac~~refine_hyp~c~:=~~~let~ta...] 0. secs (0.u,0.s)
Chars 7626 - 7866 [Ltac~~program_simplify~:=~~~si...] 0. secs (0.u,0.s)
Chars 7926 - 8073 [Ltac~~program_solve_wf~:=~~~ma...] 0. secs (0.u,0.s)
Chars 8075 - 8111 [Create~HintDb~program~discrimi...] 0. secs (0.u,0.s)
Chars 8113 - 8212 [Ltac~~program_simpl~:=~~~progr...] 0. secs (0.u,0.s)
Chars 8214 - 8249 [Obligation~Tactic~:=~program_s...] 0. secs (0.u,0.s)
Chars 8251 - 8297 [Definition~obligation~(A~:~Typ...] 0. secs (0.u,0.s)
Chars 8532 - 8789 [Tactic~Notation~"clear"~"depen...] 0. secs (0.u,0.s)
Chars 8894 - 8966 [Tactic~Notation~"revert"~"depe...] 0. secs (0.u,0.s)
Chars 9036 - 10609 [Tactic~Notation~"do_with_holes...] 0. secs (0.u,0.s)
Chars 10664 - 12238 [Tactic~Notation~"do_with_holes...] 0. secs (0.u,0.s)
Chars 12351 - 12379 [Unset~Primitive~Projections.] 0. secs (0.u,0.s)
Chars 12380 - 12417 [Class~IsGlobalAxiom~(A~:~Type)...] 0.001 secs (0.001u,0.s)
Chars 12418 - 12444 [Set~Primitive~Projections.] 0. secs (0.u,0.s)
Chars 12445 - 12500 [#[global]Hint~Mode~IsGlobalAxi...] 0. secs (0.u,0.s)
Chars 12576 - 12644 [#[global]Instance~is_global_ax...] 0. secs (0.u,0.s)
Chars 12646 - 12719 [Ltac~is_global_axiom~A~:=~let~...] 0. secs (0.u,0.s)
Chars 12721 - 12809 [Ltac~~global_axiom~:=~try~matc...] 0. secs (0.u,0.s)
Chars 12854 - 12916 [Tactic~Notation~"srefine"~ucon...] 0. secs (0.u,0.s)
Chars 12995 - 13078 [Tactic~Notation~"nrefine"~ucon...] 0. secs (0.u,0.s)
Chars 13164 - 13255 [Tactic~Notation~"snrefine"~uco...] 0. secs (0.u,0.s)
Chars 13575 - 13663 [Tactic~Notation~"rapply"~ucons...] 0. secs (0.u,0.s)
Chars 13664 - 13754 [Tactic~Notation~"rapply'"~ucon...] 0. secs (0.u,0.s)
Chars 13756 - 13846 [Tactic~Notation~"srapply"~ucon...] 0. secs (0.u,0.s)
Chars 13847 - 13939 [Tactic~Notation~"srapply'"~uco...] 0. secs (0.u,0.s)
Chars 13941 - 14031 [Tactic~Notation~"nrapply"~ucon...] 0. secs (0.u,0.s)
Chars 14032 - 14124 [Tactic~Notation~"nrapply'"~uco...] 0. secs (0.u,0.s)
Chars 14126 - 14218 [Tactic~Notation~"snrapply"~uco...] 0. secs (0.u,0.s)
Chars 14219 - 14313 [Tactic~Notation~"snrapply'"~uc...] 0. secs (0.u,0.s)
Chars 14369 - 14718 [Ltac~~done~:=~~~trivial;~intro...] 0. secs (0.u,0.s)
Chars 14720 - 14768 [Tactic~Notation~"by"~tactic(ta...] 0. secs (0.u,0.s)
Chars 14832 - 15145 [Ltac~~by_extensionality~x~:=~~...] 0. secs (0.u,0.s)
Chars 15423 - 15504 [Tactic~Notation~"funext"~simpl...] 0. secs (0.u,0.s)
Chars 15505 - 15601 [Tactic~Notation~"funext"~simpl...] 0. secs (0.u,0.s)
Chars 15602 - 15730 [Tactic~Notation~~"funext"~simp...] 0. secs (0.u,0.s)
Chars 15731 - 15892 [Tactic~Notation~~"funext"~simp...] 0. secs (0.u,0.s)
Chars 15893 - 16087 [Tactic~Notation~~"funext"~simp...] 0. secs (0.u,0.s)
Chars 16088 - 16315 [Tactic~Notation~~"funext"~simp...] 0. secs (0.u,0.s)
Chars 16421 - 16504 [Ltac~assert_fails~tac~:=~tryif...] 0. secs (0.u,0.s)
Chars 16505 - 16618 [Tactic~Notation~"assert_succee...] 0. secs (0.u,0.s)
Chars 16619 - 16691 [Tactic~Notation~"assert_succee...] 0. secs (0.u,0.s)
Chars 16692 - 16758 [Tactic~Notation~"assert_fails"...] 0. secs (0.u,0.s)
Chars 16884 - 17040 [Ltac~~path_induction~:=~~~intr...] 0. secs (0.u,0.s)
Chars 17872 - 18094 [Ltac~~f_ap~:=~~~idtac;~~~~lazy...] 0. secs (0.u,0.s)
Chars 18225 - 18484 [Ltac~~expand~:=~~~idtac;~~~~ma...] 0. secs (0.u,0.s)
Chars 18803 - 19426 [Ltac~~atomic~x~:=~~~idtac;~~~~...] 0. secs (0.u,0.s)
Chars 19474 - 19553 [Ltac~head~expr~:=~match~expr~w...] 0. secs (0.u,0.s)
Chars 19634 - 20054 [Ltac~~get_constructor_head~T~:...] 0. secs (0.u,0.s)
Chars 20122 - 20261 [Ltac~~ntc_constructor~:=~~~laz...] 0. secs (0.u,0.s)
Chars 20431 - 20561 [Ltac~~case_path~x~:=~~~let~x'~...] 0. secs (0.u,0.s)
Chars 20722 - 20880 [Ltac~~revert_opaque~x~:=~~~rev...] 0. secs (0.u,0.s)
Chars 21058 - 21478 [Tactic~Notation~"transparent"~...] 0. secs (0.u,0.s)
Chars 21602 - 21778 [Tactic~Notation~~"transparent"...] 0. secs (0.u,0.s)
Chars 21779 - 21897 [Tactic~Notation~~"transparent"...] 0. secs (0.u,0.s)
Chars 21898 - 22041 [Tactic~Notation~~"transparent"...] 0. secs (0.u,0.s)
Chars 22104 - 22233 [Ltac~~remember_as~term~name~eq...] 0. secs (0.u,0.s)
Chars 22235 - 22347 [Tactic~Notation~"remember"~con...] 0. secs (0.u,0.s)
Chars 22418 - 22541 [Ltac~~recall_as~term~name~eqna...] 0. secs (0.u,0.s)
Chars 22543 - 22651 [Tactic~Notation~"recall"~const...] 0. secs (0.u,0.s)
Chars 22769 - 22968 [Ltac~~rel_hnf~:=~~~idtac;~~~~m...] 0. secs (0.u,0.s)
Chars 23317 - 23564 [Ltac~~tryif_cps~require~if_yes...] 0. secs (0.u,0.s)
Chars 24274 - 24477 [#[local]~Ltac~~peel_evars~term...] 0. secs (0.u,0.s)
Chars 24479 - 24759 [#[local]~Ltac~~pi_to_sig~ty~:=...] 0. secs (0.u,0.s)
Chars 24761 - 24866 [#[local]~Ltac~~ctor_to_sig~cto...] 0. secs (0.u,0.s)
Chars 24868 - 25027 [#[local]~Ltac~~unify_first_eva...] 0. secs (0.u,0.s)
Chars 25029 - 25250 [#[local]~Ltac~~unify_with_proj...] 0. secs (0.u,0.s)
Chars 25330 - 25531 [#[local]~Ltac~~refine_with_exi...] 0. secs (0.u,0.s)
Chars 25580 - 26987 [Ltac~~issig~:=~~~hnf;~~~~(let~...] 0. secs (0.u,0.s)
Chars 27051 - 27127 [Definition~issig_contr~(A~:~Ty...] 0. secs (0.u,0.s)
Chars 27128 - 27134 [Proof.] 0. secs (0.u,0.s)
Chars 27137 - 27143 [issig.] 0.073 secs (0.014u,0.006s)
Chars 27137 - 27143 [issig.] 0. secs (0.u,0.s)
Chars 27144 - 27152 [Defined.] 0.002 secs (0.001u,0.001s)
Chars 27154 - 27233 [Definition~issig_equiv~(A~B~:~...] 0. secs (0.u,0.s)
Chars 27234 - 27240 [Proof.] 0. secs (0.u,0.s)
Chars 27243 - 27249 [issig.] 0.054 secs (0.008u,0.011s)
Chars 27243 - 27249 [issig.] 0. secs (0.u,0.s)
Chars 27250 - 27258 [Defined.] 0.002 secs (0.001u,0.001s)
Chars 27260 - 27432 [Definition~issig_isequiv~{A~B~...] 0.004 secs (0.001u,0.003s)
Chars 27433 - 27439 [Proof.] 0. secs (0.u,0.s)
Chars 27442 - 27448 [issig.] 0.372 secs (0.059u,0.04s)
Chars 27442 - 27448 [issig.] 0. secs (0.u,0.s)
Chars 27449 - 27457 [Defined.] 0.026 secs (0.014u,0.011s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 39 - 80 [Require~Export~Overture~Basics...] 0.031 secs (0.019u,0.011s)
Chars 82 - 108 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 109 - 132 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 133 - 161 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 162 - 186 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 188 - 217 [Declare~Scope~morphism_scope.] 0. secs (0.u,0.s)
Chars 218 - 247 [Declare~Scope~category_scope.] 0. secs (0.u,0.s)
Chars 248 - 275 [Declare~Scope~object_scope.] 0. secs (0.u,0.s)
Chars 277 - 320 [Delimit~Scope~morphism_scope~w...] 0. secs (0.u,0.s)
Chars 321 - 364 [Delimit~Scope~category_scope~w...] 0. secs (0.u,0.s)
Chars 365 - 404 [Delimit~Scope~object_scope~wit...] 0. secs (0.u,0.s)
Chars 406 - 438 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 1463 - 2946 [Record~PreCategory~:=~~Build_P...] 0.015 secs (0.008u,0.006s)
Chars 2948 - 2991 [Bind~Scope~category_scope~with...] 0. secs (0.u,0.s)
Chars 2992 - 3028 [Bind~Scope~object_scope~with~o...] 0. secs (0.u,0.s)
Chars 3029 - 3069 [Bind~Scope~morphism_scope~with...] 0. secs (0.u,0.s)
Chars 3138 - 3178 [Arguments~object~!C%category~/...] 0. secs (0.u,0.s)
Chars 3179 - 3225 [Arguments~morphism~!C%category...] 0. secs (0.u,0.s)
Chars 3226 - 3279 [Arguments~identity~{!C}%catego...] 0. secs (0.u,0.s)
Chars 3280 - 3356 [Arguments~compose~{!C}%categor...] 0. secs (0.u,0.s)
Chars 3358 - 3402 [#[local]Infix~"o"~:=~compose~:...] 0. secs (0.u,0.s)
Chars 3530 - 3588 [#[local]Notation~"x~-->~y"~:=~...] 0. secs (0.u,0.s)
Chars 3589 - 3641 [#[local]Notation~"1"~:=~(ident...] 0. secs (0.u,0.s)
Chars 3751 - 4139 [Definition~Build_PreCategory~o...] 0.004 secs (0.001u,0.003s)
Chars 4141 - 4181 [#[global]Existing~Instance~tru...] 0. secs (0.u,0.s)
Chars 4238 - 4275 [Create~HintDb~category~discrim...] 0. secs (0.u,0.s)
Chars 4328 - 4365 [Create~HintDb~morphism~discrim...] 0. secs (0.u,0.s)
Chars 4367 - 4453 [#[export]~Hint~Resolve~left_id...] 0.001 secs (0.001u,0.s)
Chars 4454 - 4517 [#[export]Hint~Rewrite~left_ide...] 0. secs (0.u,0.s)
Chars 4518 - 4581 [#[export]Hint~Rewrite~left_ide...] 0. secs (0.u,0.s)
Chars 4633 - 4657 [Section~identity_unique.] 0. secs (0.u,0.s)
Chars 4660 - 4685 [Variable~(C~:~PreCategory).] 0. secs (0.u,0.s)
Chars 4731 - 4942 [Lemma~identity_unique~(id0~id1...] 0.002 secs (0.u,0.001s)
Chars 4945 - 4951 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 43 - 70 [Require~Import~HoTT.Basics.] 0.337 secs (0.264u,0.072s)
Chars 71 - 111 [Require~Import~Types.Forall~Ty...] 0.511 secs (0.423u,0.085s)
Chars 167 - 258 [Inductive~W~(A~:~Type)~(B~:~A~...] 0.002 secs (0.002u,0.s)
Chars 260 - 344 [Definition~w_label~{A}~{B}~(w~...] 0. secs (0.u,0.s)
Chars 346 - 449 [Definition~w_arg~{A}~{B}~(w~:~...] 0.001 secs (0.001u,0.s)
Chars 451 - 529 [Definition~issig_W~(A~:~Type)~...] 0.014 secs (0.014u,0.s)
Chars 548 - 736 [Definition~equiv_path_wtype~{A...] 0.004 secs (0.004u,0.s)
Chars 738 - 873 [Definition~equiv_path_wtype'~{...] 0.002 secs (0.002u,0.s)
Chars 874 - 880 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 114 - 141 [Require~Import~HoTT.Basics.] 0.327 secs (0.253u,0.073s)
Chars 142 - 240 [Require~Import~Types.Sigma~Typ...] 0.563 secs (0.477u,0.084s)
Chars 242 - 270 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 272 - 302 [Generalizable~Variables~A~B~f.] 0. secs (0.u,0.s)
Chars 321 - 846 [#[global]~Instance~isequiv_pat...] 0.019 secs (0.019u,0.s)
Chars 848 - 960 [Definition~equiv_path~(A~B~:~T...] 0.002 secs (0.002u,0.s)
Chars 962 - 1075 [Definition~equiv_path_V~`{Fune...] 0.001 secs (0.001u,0.s)
Chars 1076 - 1082 [Proof.] 0. secs (0.u,0.s)
Chars 1085 - 1096 [(destruct~p).] 0.056 secs (0.001u,0.015s)
Chars 1097 - 1103 [(simpl).] 0. secs (0.u,0.s)
Chars 1104 - 1137 [(unfold~equiv_path,~equiv_inve...] 0. secs (0.u,0.s)
Chars 1138 - 1144 [(simpl).] 0. secs (0.u,0.s)
Chars 1145 - 1154 [(apply~ap).] 0.001 secs (0.u,0.s)
Chars 1157 - 1204 [refine~(@path_ishprop~_~(hprop...] 0.001 secs (0.001u,0.s)
Chars 1085 - 1096 [(destruct~p).] 0. secs (0.u,0.s)
Chars 1097 - 1103 [(simpl).] 0. secs (0.u,0.s)
Chars 1104 - 1137 [(unfold~equiv_path,~equiv_inve...] 0. secs (0.u,0.s)
Chars 1138 - 1144 [(simpl).] 0. secs (0.u,0.s)
Chars 1145 - 1154 [(apply~ap).] 0. secs (0.u,0.s)
Chars 1157 - 1204 [refine~(@path_ishprop~_~(hprop...] 0. secs (0.u,0.s)
Chars 1205 - 1213 [Defined.] 0.002 secs (0.001u,0.s)
Chars 1261 - 1298 [#[universes(polymorphic=no)]Ax...] 0. secs (0.u,0.s)
Chars 1299 - 1325 [Existing~Class~Univalence.] 0. secs (0.u,0.s)
Chars 1424 - 1500 [#[global]~Instance~is_global_a...] 0. secs (0.u,0.s)
Chars 1502 - 1589 [Axiom~~~(isequiv_equiv_path~:~...] 0. secs (0.u,0.s)
Chars 1590 - 1634 [#[global]Existing~Instance~ise...] 0. secs (0.u,0.s)
Chars 1873 - 1938 [#[global]Instance~Univalence_i...] 0. secs (0.u,0.s)
Chars 1939 - 1948 [Admitted.] 0. secs (0.u,0.s)
Chars 1950 - 1969 [Section~Univalence.] 0. secs (0.u,0.s)
Chars 1970 - 1992 [Context~`{Univalence}.] 0. secs (0.u,0.s)
Chars 1994 - 2091 [Definition~path_universe_uncur...] 0.003 secs (0.002u,0.001s)
Chars 2093 - 2225 [Definition~path_universe~{A~B~...] 0.001 secs (0.u,0.001s)
Chars 2227 - 2298 [#[global]Arguments~path_univer...] 0. secs (0.u,0.s)
Chars 2300 - 2427 [Definition~eta_path_universe~{...] 0.002 secs (0.001u,0.001s)
Chars 2429 - 2576 [Definition~eta_path_universe_u...] 0.001 secs (0.001u,0.s)
Chars 2578 - 2673 [Definition~isequiv_path_univer...] 0.007 secs (0.007u,0.s)
Chars 2675 - 2817 [Definition~equiv_path_universe...] 0.001 secs (0.001u,0.s)
Chars 2820 - 2926 [Definition~equiv_equiv_path~(A...] 0.001 secs (0.001u,0.s)
Chars 3049 - 3183 [Definition~path_universe_equiv...] 0.021 secs (0.015u,0.005s)
Chars 3184 - 3338 [Definition~path_universe_uncur...] 0.001 secs (0.001u,0.s)
Chars 3339 - 3479 [Definition~path_universe_trans...] 0.002 secs (0.002u,0.s)
Chars 3480 - 3646 [Definition~path_universe_uncur...] 0.004 secs (0.004u,0.s)
Chars 3647 - 3783 [Definition~equiv_path_path_uni...] 0.003 secs (0.003u,0.s)
Chars 3784 - 3940 [Definition~equiv_path_path_uni...] 0.001 secs (0.u,0.s)
Chars 3941 - 4098 [Definition~transport_idmap_pat...] 0.003 secs (0.003u,0.s)
Chars 4099 - 4276 [Definition~transport_idmap_pat...] 0.002 secs (0.002u,0.s)
Chars 4317 - 4455 [Definition~equiv_path_pp~`{Fun...] 0.001 secs (0.001u,0.s)
Chars 4456 - 4462 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 83 - 152 [Require~Import~Category.Core~F...] 0.027 secs (0.017u,0.009s)
Chars 153 - 210 [Require~Import~Functor.Identit...] 0. secs (0.u,0.s)
Chars 211 - 304 [Require~Import~NaturalTransfor...] 1.784 secs (1.598u,0.183s)
Chars 305 - 374 [Require~Import~Functor.Dual~Na...] 0.104 secs (0.088u,0.014s)
Chars 375 - 463 [Require~Import~Adjoint.Core~Ad...] 0.033 secs (0.03u,0.003s)
Chars 464 - 510 [Require~Import~HProp~Types.Sig...] 0.006 secs (0.005u,0.s)
Chars 512 - 538 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 539 - 562 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 563 - 591 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 592 - 616 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 618 - 664 [#[local]Open~Scope~natural_tra...] 0. secs (0.u,0.s)
Chars 665 - 697 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 699 - 712 [Section~left.] 0. secs (0.u,0.s)
Chars 840 - 864 [Section~also_categories.] 0. secs (0.u,0.s)
Chars 869 - 898 [Variables~(C~C'~:~PreCategory).] 0. secs (0.u,0.s)
Chars 903 - 930 [Variable~(CF~:~Functor~C~C').] 0. secs (0.u,0.s)
Chars 935 - 964 [Variables~(D~D'~:~PreCategory).] 0. secs (0.u,0.s)
Chars 969 - 996 [Variable~(DF~:~Functor~D~D').] 0. secs (0.u,0.s)
Chars 1002 - 1027 [Variable~(G~:~Functor~D~C).] 0. secs (0.u,0.s)
Chars 1032 - 1057 [Variable~(F~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 1062 - 1082 [Variable~(A~:~F~-|~G).] 0. secs (0.u,0.s)
Chars 1087 - 1115 [Variable~(G'~:~Functor~D'~C').] 0. secs (0.u,0.s)
Chars 1120 - 1148 [Variable~(F'~:~Functor~C'~D').] 0. secs (0.u,0.s)
Chars 1153 - 1176 [Variable~(A'~:~F'~-|~G').] 0. secs (0.u,0.s)
Chars 1181 - 1235 [Variable~(T~:~NaturalTransform...] 0. secs (0.u,0.s)
Chars 1241 - 1316 [Definition~left_morphism_of~:~...] 0. secs (0.u,0.s)
Chars 1321 - 1327 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 28 - 97 [Require~Import~Category.Core~F...] 0.027 secs (0.015u,0.011s)
Chars 98 - 131 [Require~Import~Functor.Prod.Core.] 1.868 secs (1.697u,0.166s)
Chars 132 - 189 [Require~Import~Functor.Paths~N...] 0.023 secs (0.019u,0.003s)
Chars 190 - 247 [Require~Import~Functor.Identit...] 0. secs (0.u,0.s)
Chars 248 - 293 [Require~Import~ExponentialLaws...] 0.034 secs (0.029u,0.004s)
Chars 294 - 391 [Require~Import~Types.Prod~HoTT...] 0.005 secs (0.002u,0.003s)
Chars 393 - 419 [Set~Universe~Polymorphism.] 0.002 secs (0.u,0.002s)
Chars 420 - 443 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 444 - 472 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 473 - 497 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 499 - 530 [#[local]Open~Scope~functor_scope.] 0. secs (0.u,0.s)
Chars 593 - 606 [Section~Law4.] 0. secs (0.u,0.s)
Chars 609 - 627 [Context~`{Funext}.] 0.002 secs (0.u,0.002s)
Chars 630 - 662 [Variables~(C1~C2~D~:~PreCatego...] 0. secs (0.u,0.s)
Chars 666 - 726 [Lemma~helper1~c~:~functor~C1~C...] 0.007 secs (0.003u,0.003s)
Chars 729 - 735 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.336 secs (0.255u,0.08s)
Chars 23 - 52 [Require~Import~Cubical.DPath.] 1.51 secs (1.385u,0.121s)
Chars 53 - 87 [Require~Import~Cubical.PathSqu...] 0.091 secs (0.088u,0.003s)
Chars 88 - 123 [Require~Import~Cubical.DPathSq...] 0.037 secs (0.035u,0.001s)
Chars 124 - 156 [Require~Import~Cubical.PathCube.] 1.474 secs (1.367u,0.104s)
Chars 158 - 184 [Declare~Scope~dcube_scope.] 0. secs (0.u,0.s)
Chars 185 - 222 [Delimit~Scope~dcube_scope~with...] 0. secs (0.u,0.s)
Chars 293 - 1826 [Definition~DPathCube~{A}~(B~:~...] 0.021 secs (0.02u,0.s)
Chars 1827 - 1833 [Proof.] 0. secs (0.u,0.s)
Chars 1836 - 1850 [(destruct~cube).] 0.133 secs (0.017u,0.032s)
Chars 1853 - 1906 [exact~(PathCube~bs0ii~bs1ii~bs...] 0.003 secs (0.002u,0.s)
Chars 1836 - 1850 [(destruct~cube).] 0.001 secs (0.001u,0.s)
Chars 1853 - 1906 [exact~(PathCube~bs0ii~bs1ii~bs...] 0. secs (0.u,0.s)
Chars 1907 - 1915 [Defined.] 0.008 secs (0.007u,0.s)
Chars 1917 - 3786 [Definition~equiv_dc_const'~{A~...] 0.757 secs (0.689u,0.066s)
Chars 3787 - 3793 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 43 - 81 [Require~Import~HoTT.Basics~HoT...] 1.731 secs (1.513u,0.214s)
Chars 4956 - 4962 [intro.] 40.052 secs (0.u,0.003s)
Chars 4967 - 5041 [(etransitivity;~[~symmetry;~ap...] 0.005 secs (0.004u,0.s)
Chars 4956 - 4962 [intro.] 0. secs (0.u,0.s)
Chars 4967 - 5041 [(etransitivity;~[~symmetry;~ap...] 0.001 secs (0.u,0.s)
Chars 5044 - 5048 [Qed.] 0. secs (0.u,0.s)
Chars 5175 - 5320 [Definition~concat_left_identit...] 0.003 secs (0.003u,0.s)
Chars 5324 - 5462 [Definition~concat_right_identi...] 0.002 secs (0.002u,0.s)
Chars 5463 - 5483 [End~identity_unique.] 0.003 secs (0.002u,0.s)
Chars 5573 - 5609 [Module~Export~CategoryCoreNota...] 0. secs (0.u,0.s)
Chars 5612 - 5650 [Infix~"o"~:=~compose~:~morphis...] 0. secs (0.u,0.s)
Chars 5784 - 5843 [#[local]Notation~"x~-->~y"~:=~...] 0. secs (0.u,0.s)
Chars 5846 - 5904 [#[local]Notation~"x~-->~y"~:=~...] 0. secs (0.u,0.s)
Chars 5907 - 5953 [Notation~"1"~:=~(identity~_)~:...] 0. secs (0.u,0.s)
Chars 5954 - 5980 [End~CategoryCoreNotations.] 0. secs (0.u,0.s)
Chars 6121 - 6262 [Tactic~Notation~"try_associati...] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 3796 - 3813 [by~destruct~cube.] 5.77 secs (0.039u,0.035s)
Chars 3796 - 3813 [by~destruct~cube.] 0.003 secs (0.003u,0.s)
Chars 3814 - 3822 [Defined.] 0.012 secs (0.009u,0.002s)
Chars 3824 - 3862 [Notation~dc_const'~:=~equiv_dc...] 0. secs (0.u,0.s)
Chars 3864 - 5313 [Definition~equiv_dc_const~{A~B...] 0.314 secs (0.274u,0.039s)
Chars 5314 - 5320 [Proof.] 0. secs (0.u,0.s)
Chars 5323 - 5340 [by~destruct~cube.] 0.18 secs (0.028u,0.036s)
Chars 5323 - 5340 [by~destruct~cube.] 0.003 secs (0.003u,0.s)
Chars 5341 - 5349 [Defined.] 0.009 secs (0.009u,0.s)
Chars 5351 - 5387 [Notation~dc_const~:=~equiv_dc_...] 0. secs (0.u,0.s)
Chars 5419 - 5431 [Section~Kan.] 0. secs (0.u,0.s)
Chars 5434 - 6523 [Context~{A}~{x000~x010~x100~x1...] 0.017 secs (0.012u,0.004s)
Chars 6527 - 6903 [Definition~dc_fill_left~(t1ii~...] 0.017 secs (0.015u,0.002s)
Chars 6906 - 6912 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 38 [From~HoTT~Require~Import~Basic...] 1.711 secs (1.518u,0.188s)
Chars 78 - 105 [Section~concat_square_vert.] 0. secs (0.u,0.s)
Chars 109 - 128 [Context~{X~:~Type}.] 0. secs (0.u,0.s)
Chars 148 - 171 [Context~{a0~b0~c0~:~X}.] 0. secs (0.u,0.s)
Chars 174 - 197 [Context~{a1~b1~c1~:~X}.] 0. secs (0.u,0.s)
Chars 217 - 241 [Context~{a01~:~a0~=~a1}.] 0. secs (0.u,0.s)
Chars 244 - 268 [Context~{b01~:~b0~=~b1}.] 0. secs (0.u,0.s)
Chars 271 - 295 [Context~{c01~:~c0~=~c1}.] 0. secs (0.u,0.s)
Chars 299 - 323 [Context~{ab0~:~a0~=~b0}.] 0. secs (0.u,0.s)
Chars 326 - 350 [Context~{ab1~:~a1~=~b1}.] 0. secs (0.u,0.s)
Chars 354 - 378 [Context~{bc0~:~b0~=~c0}.] 0. secs (0.u,0.s)
Chars 381 - 405 [Context~{bc1~:~b1~=~c1}.] 0. secs (0.u,0.s)
Chars 425 - 461 [Context~(p~:~ab0~@~b01~=~a01~@...] 0. secs (0.u,0.s)
Chars 464 - 500 [Context~(q~:~bc0~@~c01~=~b01~@...] 0. secs (0.u,0.s)
Chars 504 - 584 [#[local]~Definition~concat_squ...] 0. secs (0.u,0.s)
Chars 587 - 593 [Proof.] 0. secs (0.u,0.s)
Chars 82 - 162 [Require~Import~Equiv.BiInv~Ext...] 3.911 secs (3.677u,0.224s)
Chars 163 - 186 [Require~Import~PathAny.] 0. secs (0.u,0.s)
Chars 187 - 233 [Require~Import~Colimits.Coeq~C...] 0. secs (0.u,0.s)
Chars 235 - 262 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 263 - 291 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 883 - 1203 [Record~Subuniverse@{i}~:={~~~~...] 0.003 secs (0.002u,0.s)
Chars 1277 - 1348 [Class~In~(O~:~Subuniverse)~(T~...] 0. secs (0.u,0.s)
Chars 1664 - 1781 [#[global]~Instance~hprop_inO~~...] 0.001 secs (0.001u,0.s)
Chars 2154 - 2334 [Definition~inO_equiv_inO~{O~:~...] 0.001 secs (0.001u,0.s)
Chars 2336 - 2471 [Definition~inO_equiv_inO'~{O~:...] 0.003 secs (0.002u,0.s)
Chars 2473 - 2662 [Definition~iff_inO_equiv~`{Fun...] 0.002 secs (0.002u,0.s)
Chars 2664 - 2839 [Definition~equiv_inO_equiv~`{F...] 0.004 secs (0.004u,0.s)
Chars 2889 - 3001 [Definition~Type_@{i~j}~(O~:~Su...] 0. secs (0.u,0.s)
Chars 3003 - 3060 [Coercion~TypeO_pr1~O~(T~:~Type...] 0. secs (0.u,0.s)
Chars 3113 - 3239 [Definition~path_TypeO@{i~j}~{f...] 0.005 secs (0.005u,0.s)
Chars 3241 - 3512 [Definition~equiv_path_TypeO@{i...] 0.005 secs (0.005u,0.s)
Chars 3557 - 3633 [#[global]~Instance~inO_TypeO~~...] 0. secs (0.u,0.s)
Chars 3720 - 3834 [Class~MapIn~(O~:~Subuniverse)~...] 0.001 secs (0.001u,0.s)
Chars 3836 - 3880 [#[global]Existing~Instance~inO...] 0. secs (0.u,0.s)
Chars 3882 - 3902 [Section~Subuniverse.] 0. secs (0.u,0.s)
Chars 3905 - 3931 [Context~(O~:~Subuniverse).] 0. secs (0.u,0.s)
Chars 3974 - 4065 [#[global]~Instance~ishprop_map...] 0. secs (0.u,0.s)
Chars 4068 - 4074 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 67 - 118 [Require~Import~HoTT.Basics~HoT...] 3.544 secs (3.23u,0.298s)
Chars 883 - 944 [refine~(equiv_path_wtype~_~_~o...] 40.113 secs (0.004u,0.018s)
Chars 947 - 976 [(apply~equiv_functor_sigma_id).] 0.002 secs (0.002u,0.s)
Chars 979 - 1018 [(destruct~z~as~[z1~z2],~z'~as~...] 0.006 secs (0.006u,0.s)
Chars 1021 - 1035 [(cbn;~intros~p).] 0.002 secs (0.001u,0.s)
Chars 1038 - 1049 [(destruct~p).] 0.002 secs (0.001u,0.s)
Chars 1052 - 1064 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 883 - 944 [refine~(equiv_path_wtype~_~_~o...] 0. secs (0.u,0.s)
Chars 947 - 976 [(apply~equiv_functor_sigma_id).] 0.001 secs (0.001u,0.s)
Chars 979 - 1018 [(destruct~z~as~[z1~z2],~z'~as~...] 0.001 secs (0.001u,0.s)
Chars 1021 - 1035 [(cbn;~intros~p).] 0.002 secs (0.001u,0.001s)
Chars 1038 - 1049 [(destruct~p).] 0. secs (0.u,0.s)
Chars 1052 - 1064 [reflexivity.] 0. secs (0.u,0.s)
Chars 1065 - 1073 [Defined.] 0.009 secs (0.009u,0.s)
Chars 1114 - 1227 [#[global]~Instance~istrunc_wty...] 0. secs (0.u,0.s)
Chars 1228 - 1234 [Proof.] 0. secs (0.u,0.s)
Chars 119 - 145 [Require~Import~Extensions.] 3.27 secs (3.14u,0.127s)
Chars 146 - 194 [Require~Import~ReflectiveSubun...] 1.745 secs (1.658u,0.085s)
Chars 196 - 223 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 224 - 252 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 3489 - 4402 [Fixpoint~ExtendableAlong_Over@...] 0.009 secs (0.008u,0.s)
ExtendableAlong_Over
     : forall (n : nat) (A B : Type) (f : A -> B) 
       (C : B -> Type),
       (forall b : B, C b -> Type) -> ExtendableAlong n f C -> Type
Chars 4403 - 4442 [Check~ExtendableAlong_Over@{a~...] 0. secs (0.u,0.s)
Chars 4683 - 4986 [Definition~extendable_over_pos...] 0.002 secs (0.001u,0.s)
Chars 4987 - 4993 [Proof.] 0. secs (0.u,0.s)
Chars 4465 - 4479 [(destruct~p,~q).] 39.406 secs (0.001u,0.016s)
Chars 4480 - 4486 [(simpl).] 0. secs (0.u,0.s)
Chars 4489 - 4518 [(apply~path_equiv,~path_arrow).] 0.001 secs (0.001u,0.s)
Chars 4521 - 4543 [(intros~x;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 4465 - 4479 [(destruct~p,~q).] 0. secs (0.u,0.s)
Chars 4480 - 4486 [(simpl).] 0. secs (0.u,0.s)
Chars 4489 - 4518 [(apply~path_equiv,~path_arrow).] 0. secs (0.u,0.s)
Chars 4521 - 4543 [(intros~x;~reflexivity).] 0. secs (0.u,0.s)
Chars 4544 - 4552 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4554 - 4763 [Definition~path_universe_compo...] 0.004 secs (0.004u,0.s)
Chars 4764 - 4770 [Proof.] 0. secs (0.u,0.s)
Chars 44 - 80 [Require~Import~Basics~Types~Wi...] 3.279 secs (3.001u,0.268s)
Chars 81 - 112 [Require~Import~TruncType~HProp.] 0.072 secs (0.064u,0.007s)
Chars 113 - 167 [Require~Import~Modalities.Moda...] 5.412 secs (5.18u,0.217s)
Chars 220 - 248 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 249 - 279 [Generalizable~Variables~A~X~n.] 0. secs (0.u,0.s)
Chars 1090 - 1110 [Module~Export~Trunc.] 0. secs (0.u,0.s)
Chars 1111 - 1148 [Delimit~Scope~trunc_scope~with...] 0. secs (0.u,0.s)
Chars 1150 - 1245 [#[universes(cumulative),~priva...] 0. secs (0.u,0.s)
Chars 1246 - 1280 [Bind~Scope~trunc_scope~with~Tr...] 0. secs (0.u,0.s)
Chars 1281 - 1302 [Arguments~tr~{n~A}~a.] 0. secs (0.u,0.s)
Chars 1394 - 1494 [#[global]~Instance~istrunc_tru...] 0. secs (0.u,0.s)
Chars 1495 - 1504 [Admitted.] 0. secs (0.u,0.s)
Chars 1506 - 1699 [Definition~Trunc_ind~{n}~{A}~(...] 0.002 secs (0.002u,0.s)
Chars 1701 - 1711 [End~Trunc.] 0. secs (0.u,0.s)
Chars 1766 - 1869 [Definition~Trunc_rec~{n}~{A}~{...] 0.002 secs (0.002u,0.s)
Chars 1904 - 1947 [Definition~Tr~(n~:~trunc_index...] 0. secs (0.u,0.s)
Chars 1948 - 1954 [Proof.] 0. secs (0.u,0.s)
Chars 1334 - 1623 [(refine~~~(_~o~(counit~A'~oR~(...] 40.143 secs (0.048u,0.023s)
Chars 1334 - 1623 [(refine~~~(_~o~(counit~A'~oR~(...] 0.002 secs (0.002u,0.s)
Chars 1628 - 1636 [Defined.] 0.002 secs (0.001u,0.s)
Chars 1639 - 1659 [End~also_categories.] 0.005 secs (0.004u,0.s)
Chars 1697 - 1718 [Section~only_functor.] 0. secs (0.u,0.s)
Chars 1723 - 1751 [Variables~(C~D~:~PreCategory).] 0. secs (0.u,0.s)
Chars 1757 - 1782 [Variable~(G~:~Functor~D~C).] 0. secs (0.u,0.s)
Chars 1787 - 1812 [Variable~(F~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 1817 - 1837 [Variable~(A~:~F~-|~G).] 0. secs (0.u,0.s)
Chars 1842 - 1868 [Variable~(G'~:~Functor~D~C).] 0. secs (0.u,0.s)
Chars 1873 - 1899 [Variable~(F'~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 1904 - 1927 [Variable~(A'~:~F'~-|~G').] 0. secs (0.u,0.s)
Chars 1932 - 1972 [Variable~(T~:~NaturalTransform...] 0. secs (0.u,0.s)
Chars 1978 - 2046 [Definition~left_morphism_of_no...] 0. secs (0.u,0.s)
Chars 2051 - 2057 [Proof.] 0. secs (0.u,0.s)
Chars 740 - 753 [path_functor.] 40.127 secs (0.011u,0.019s)
Chars 758 - 851 [(abstract~(exp_laws_t;~rewrite...] 0.102 secs (0.087u,0.013s)
Chars 740 - 753 [path_functor.] 0. secs (0.u,0.s)
Chars 758 - 851 [(abstract~(exp_laws_t;~rewrite...] 0.001 secs (0.001u,0.s)
Chars 854 - 862 [Defined.] 0.01 secs (0.009u,0.s)
Chars 866 - 939 [Lemma~helper2_helper~c~x~:~inv...] 0.004 secs (0.003u,0.s)
Chars 942 - 948 [Proof.] 0. secs (0.u,0.s)
Chars 953 - 966 [path_functor.] 0.151 secs (0.006u,0.021s)
Chars 971 - 991 [(abstract~exp_laws_t).] 0.04 secs (0.034u,0.006s)
Chars 953 - 966 [path_functor.] 0. secs (0.u,0.s)
Chars 971 - 991 [(abstract~exp_laws_t).] 0. secs (0.u,0.s)
Chars 994 - 1002 [Defined.] 0.005 secs (0.003u,0.001s)
Chars 1006 - 1066 [Lemma~helper2~c~:~inverse~C1~C...] 0.003 secs (0.003u,0.s)
Chars 1069 - 1075 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 45 - 83 [Require~Import~HoTT.Basics~HoT...] 1.713 secs (1.545u,0.164s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 84 - 126 [Require~Import~HProp~TruncType...] 3.568 secs (3.331u,0.193s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 127 - 180 [Require~Import~Modality~Access...] 4.344 secs (4.173u,0.161s)
Chars 182 - 210 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 261 - 308 [Definition~Op~`{Funext}~(U~:~H...] 0. secs (0.u,0.s)
Chars 309 - 315 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 124 [Require~Import~HoTT.Classes.in...] 9.468 secs (8.92u,0.522s)
Chars 237 - 282 [#[global]Instance~join_hor~:~(...] 0.001 secs (0.001u,0.s)
Chars 283 - 344 [Definition~hand~(X~Y~:~HProp)~...] 0.011 secs (0.01u,0.s)
Chars 345 - 393 [#[global]Instance~meet_hprop~:...] 0. secs (0.u,0.s)
Chars 394 - 450 [#[global]Instance~bottom_hprop...] 0. secs (0.u,0.s)
Chars 451 - 500 [#[global]Instance~top_hprop~:~...] 0. secs (0.u,0.s)
Chars 502 - 519 [Section~contents.] 0. secs (0.u,0.s)
Chars 522 - 544 [Context~`{Univalence}.] 0. secs (0.u,0.s)
Chars 682 - 730 [Notation~lor~:=~(hor~:~HProp~-...] 0. secs (0.u,0.s)
Chars 805 - 915 [#[local]~Ltac~~hor_intros~:=~~...] 0. secs (0.u,0.s)
Chars 919 - 962 [Instance~commutative_hor~:~(Co...] 0. secs (0.u,0.s)
Chars 965 - 971 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 87 [Require~Import~HoTT.Classes.in...] 9.594 secs (9.039u,0.538s)
Chars 89 - 125 [Generalizable~Variables~A~B~C~...] 0. secs (0.u,0.s)
Chars 127 - 204 [#[global]~Instance~bounded_sl_...] 0.001 secs (0.u,0.s)
Chars 205 - 211 [Proof.] 0. secs (0.u,0.s)
Chars 4079 - 4100 [(apply~istrunc_forall).] 36.084 secs (0.006u,0.026s)
Chars 4079 - 4100 [(apply~istrunc_forall).] 0. secs (0.u,0.s)
Chars 4103 - 4111 [Defined.] 0. secs (0.u,0.s)
Chars 4168 - 4292 [Definition~mapinO_homotopic~{A...] 0. secs (0.u,0.s)
Chars 4295 - 4301 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 28 [Require~Import~Basics~Types.] 1.717 secs (1.535u,0.178s)
Chars 6917 - 6928 [(destruct~c).] 40.178 secs (0.028u,0.032s)
Chars 6933 - 6952 [(apply~cu_fill_left).] 0.006 secs (0.004u,0.001s)
Chars 6917 - 6928 [(destruct~c).] 0.002 secs (0.002u,0.s)
Chars 6933 - 6952 [(apply~cu_fill_left).] 0.002 secs (0.002u,0.s)
Chars 6955 - 6963 [Defined.] 0.006 secs (0.004u,0.001s)
Chars 6967 - 7344 [Definition~dc_fill_right~(t0ii...] 0.017 secs (0.013u,0.003s)
Chars 7347 - 7353 [Proof.] 0. secs (0.u,0.s)
Chars 598 - 629 [refine~(concat_pp_p~_~_~_~@~_).] 40.119 secs (0.002u,0.02s)
Chars 634 - 660 [refine~(whiskerL~_~q~@~_).] 0.002 secs (0.002u,0.s)
Chars 665 - 696 [refine~(concat_p_pp~_~_~_~@~_).] 0.002 secs (0.002u,0.s)
Chars 701 - 727 [refine~(whiskerR~p~_~@~_).] 0.002 secs (0.002u,0.s)
Chars 732 - 750 [(apply~concat_pp_p).] 0.001 secs (0.001u,0.s)
Chars 598 - 629 [refine~(concat_pp_p~_~_~_~@~_).] 0. secs (0.u,0.s)
Chars 634 - 660 [refine~(whiskerL~_~q~@~_).] 0. secs (0.u,0.s)
Chars 665 - 696 [refine~(concat_p_pp~_~_~_~@~_).] 0. secs (0.u,0.s)
Chars 701 - 727 [refine~(whiskerR~p~_~@~_).] 0. secs (0.u,0.s)
Chars 732 - 750 [(apply~concat_pp_p).] 0. secs (0.u,0.s)
Chars 753 - 761 [Defined.] 0.001 secs (0.001u,0.s)
Chars 763 - 786 [End~concat_square_vert.] 0.005 secs (0.005u,0.s)
Chars 788 - 838 [Infix~"[-]"~:=~concat_square_v...] 0. secs (0.u,0.s)
Chars 880 - 906 [Section~concat_square_hor.] 0. secs (0.u,0.s)
Chars 910 - 929 [Context~{X~:~Type}.] 0. secs (0.u,0.s)
Chars 949 - 972 [Context~{a0~b0~c0~:~X}.] 0. secs (0.u,0.s)
Chars 975 - 998 [Context~{a1~b1~c1~:~X}.] 0. secs (0.u,0.s)
Chars 1018 - 1042 [Context~{a01~:~a0~=~a1}.] 0. secs (0.u,0.s)
Chars 1045 - 1069 [Context~{b01~:~b0~=~b1}.] 0. secs (0.u,0.s)
Chars 1072 - 1096 [Context~{c01~:~c0~=~c1}.] 0. secs (0.u,0.s)
Chars 1100 - 1124 [Context~{ab0~:~a0~=~b0}.] 0. secs (0.u,0.s)
Chars 1127 - 1151 [Context~{ab1~:~a1~=~b1}.] 0. secs (0.u,0.s)
Chars 1155 - 1179 [Context~{bc0~:~b0~=~c0}.] 0. secs (0.u,0.s)
Chars 1182 - 1206 [Context~{bc1~:~b1~=~c1}.] 0. secs (0.u,0.s)
Chars 1226 - 1262 [Context~(p~:~a01~@~ab1~=~ab0~@...] 0. secs (0.u,0.s)
Chars 1265 - 1301 [Context~(q~:~b01~@~bc1~=~bc0~@...] 0. secs (0.u,0.s)
Chars 1305 - 1384 [#[local]Definition~concat_squa...] 0. secs (0.u,0.s)
Chars 1387 - 1393 [Proof.] 0. secs (0.u,0.s)
Chars 265 - 318 [Require~Export~HoTT.Classes.in...] 9.958 secs (9.375u,0.549s)
Chars 320 - 416 [Require~Import~HoTT.Basics~HoT...] 0.026 secs (0.024u,0.001s)
Chars 418 - 461 [Import~algebra_notations~ne_li...] 0. secs (0.u,0.s)
Chars 463 - 487 [Section~is_homomorphism.] 0. secs (0.u,0.s)
Chars 490 - 559 [Context~{σ}~{A~B~:~Algebra~σ}~...] 0. secs (0.u,0.s)
Chars 845 - 1083 [Fixpoint~OpPreserving~{w~:~Sym...] 0.003 secs (0.003u,0.s)
Chars 1087 - 1283 [#[global]~Instance~trunc_oppre...] 0.001 secs (0.001u,0.s)
Chars 1286 - 1292 [Proof.] 0. secs (0.u,0.s)
Chars 4306 - 4315 [(intros~b).] 3.405 secs (-2.369u,-0.116s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 38 [Require~Import~HoTT.Basics~HoT...] 1.753 secs (1.561u,0.187s)
Chars 254 - 300 [Require~Export~HoTT.Algebra.Un...] 10.405 secs (9.767u,0.617s)
Chars 302 - 424 [Require~Import~HoTT.Basics~HoT...] 0.031 secs (0.03u,0.s)
Chars 426 - 457 [#[local]Open~Scope~Algebra_scope.] 0. secs (0.u,0.s)
Chars 458 - 485 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 627 - 912 [#[universes(polymorphic=no)]~D...] 0.003 secs (0.003u,0.s)
Chars 914 - 1082 [#[universes(polymorphic=no)]~D...] 0.001 secs (0.001u,0.s)
Chars 1210 - 1488 [#[universes(polymorphic=no)]~D...] 0.002 secs (0.001u,0.s)
Chars 1490 - 1668 [#[universes(polymorphic=no)]~D...] 0.001 secs (0.001u,0.s)
Chars 1794 - 2221 [#[universes(polymorphic=no)]~D...] 0.012 secs (0.012u,0.s)
Chars 2223 - 2434 [Definition~cons_dom~{σ}~(A~:~C...] 0.002 secs (0.002u,0.s)
Chars 2462 - 2585 [Definition~nil_dom~{σ}~(A~:~Ca...] 0.001 secs (0.001u,0.s)
Chars 2652 - 2843 [Definition~FiniteOperation~{σ~...] 0.001 secs (0.001u,0.s)
Chars 2954 - 3198 [Fixpoint~CurriedOperation~{σ}~...] 0.002 secs (0.002u,0.s)
Chars 3479 - 3819 [Fixpoint~operation_uncurry~{σ}...] 0.005 secs (0.004u,0.s)
Chars 3821 - 4146 [#[local]~Example~computation_e...] 0.011 secs (0.011u,0.s)
Chars 4147 - 4153 [Proof.] 0. secs (0.u,0.s)
Chars 4156 - 4168 [reflexivity.] 0.095 secs (0.002u,0.034s)
Chars 4156 - 4168 [reflexivity.] 0. secs (0.u,0.s)
Chars 4169 - 4173 [Qed.] 0.007 secs (0.007u,0.s)
Chars 4452 - 4794 [Fixpoint~operation_curry~{σ}~(...] 0.008 secs (0.008u,0.s)
Chars 4796 - 5142 [#[local]~Example~computation_e...] 0.015 secs (0.013u,0.001s)
Chars 5143 - 5149 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 56 [Require~Import~HoTT.Types.Univ...] 1.006 secs (0.825u,0.177s)
Chars 1237 - 1268 [(intros~z;~induction~z~as~[a~w]).] 40.103 secs (0.002u,0.019s)
Chars 1271 - 1302 [(intro~y;~destruct~y~as~[a0~w0]).] 0.002 secs (0.001u,0.s)
Chars 1305 - 1363 [nrefine~(istrunc_equiv_istrunc...] 0.003 secs (0.003u,0.s)
Chars 5152 - 5164 [reflexivity.] 0.259 secs (0.001u,0.035s)
Chars 1366 - 1387 [rapply~istrunc_sigma.] 0.067 secs (0.058u,0.007s)
Chars 1390 - 1403 [(cbn;~intro~p).] 0.002 secs (0.001u,0.s)
Chars 1406 - 1417 [(destruct~p).] 0.001 secs (0.u,0.s)
Chars 1420 - 1476 [(apply~(istrunc_equiv_istrunc~...] 0.005 secs (0.005u,0.s)
Chars 1237 - 1268 [(intros~z;~induction~z~as~[a~w]).] 0. secs (0.u,0.s)
Chars 1271 - 1302 [(intro~y;~destruct~y~as~[a0~w0]).] 0. secs (0.u,0.s)
Chars 1305 - 1363 [nrefine~(istrunc_equiv_istrunc...] 0. secs (0.u,0.s)
Chars 1366 - 1387 [rapply~istrunc_sigma.] 0.001 secs (0.001u,0.s)
Chars 1390 - 1403 [(cbn;~intro~p).] 0.001 secs (0.001u,0.s)
Chars 5152 - 5164 [reflexivity.] 0. secs (0.u,0.s)
Chars 1406 - 1417 [(destruct~p).] 0. secs (0.u,0.s)
Chars 1420 - 1476 [(apply~(istrunc_equiv_istrunc~...] 0. secs (0.u,0.s)
Chars 1477 - 1485 [Defined.] 0.004 secs (0.003u,0.s)
Chars 5165 - 5169 [Qed.] 0.007 secs (0.007u,0.s)
Chars 5171 - 5398 [Lemma~expand_cons_dom'~{σ}~(A~...] 0.002 secs (0.002u,0.s)
Chars 5399 - 5405 [Proof.] 0. secs (0.u,0.s)
Chars 1297 - 1318 [(induction~w;~exact~_).] 4.972 secs (0.013u,0.033s)
Chars 1297 - 1318 [(induction~w;~exact~_).] 0.001 secs (0.001u,0.s)
Chars 1321 - 1325 [Qed.] 0.003 secs (0.003u,0.s)
Chars 1589 - 1687 [Class~IsHomomorphism~:~Type~:=...] 0.001 secs (0.001u,0.s)
Chars 1691 - 1818 [#[global]~Instance~trunc_is_ho...] 0. secs (0.u,0.s)
Chars 1821 - 1827 [Proof.] 0. secs (0.u,0.s)
Chars 29 - 65 [Require~Import~Algebra.Groups....] 8.244 secs (7.832u,0.393s)
Chars 66 - 105 [Require~Import~Algebra.Groups....] 0.088 secs (0.081u,0.006s)
Chars 106 - 129 [Require~Import~WildCat.] 0.009 secs (0.008u,0.001s)
Chars 130 - 157 [Require~Import~Truncations.] 0.004 secs (0.004u,0.s)
Chars 158 - 187 [Require~Import~Factorization.] 0. secs (0.u,0.s)
Chars 188 - 215 [Require~Import~HFiber~HSet.] 0. secs (0.u,0.s)
Chars 254 - 284 [#[local]Open~Scope~mc_add_scope.] 0. secs (0.u,0.s)
Chars 357 - 419 [Definition~grp_image~{A~B~:~Gr...] 0. secs (0.u,0.s)
Chars 420 - 426 [Proof.] 0. secs (0.u,0.s)
Chars 91 - 311 [Require~Import~HoTT.Types.Univ...] 11.152 secs (10.517u,0.608s)
Chars 313 - 386 [Import~algebra_notations~quoti...] 0. secs (0.u,0.s)
Chars 577 - 599 [Section~cong_quotient.] 0. secs (0.u,0.s)
Chars 602 - 844 [Context~`{Univalence}~{σ~:~Sig...] 0.002 secs (0.002u,0.s)
Chars 848 - 1028 [Definition~cong_quotient~(_~:~...] 0.012 secs (0.012u,0.s)
Chars 1032 - 1132 [#[global]~Instance~equivalence...] 0. secs (0.u,0.s)
Chars 1135 - 1141 [Proof.] 0. secs (0.u,0.s)
Chars 4996 - 5068 [(revert~C~ext~D~E~g;~simple_in...] 40.159 secs (0.008u,0.033s)
Chars 5071 - 5088 [1:~by~apply~idmap.] 0. secs (0.u,0.s)
Chars 5091 - 5103 [(intros~ext').] 0.002 secs (0.002u,0.s)
Chars 5106 - 5112 [split.] 0.003 secs (0.002u,0.s)
Chars 5115 - 5116 [-] 0. secs (0.u,0.s)
Chars 5117 - 5128 [(intros~h~k).] 0.002 secs (0.001u,0.s)
Chars 5133 - 5241 [exists~~~~(fun~b~=>~~~~g~b~((f...] 0.016 secs (0.013u,0.002s)
Chars 5246 - 5255 [(intros~a).] 0.002 secs (0.001u,0.s)
Chars 5260 - 5319 [refine~((ap_transport~((fst~ex...] 0.006 secs (0.005u,0.001s)
Chars 5324 - 5344 [(apply~moveR_equiv_M).] 0.036 secs (0.02u,0.015s)
Chars 5349 - 5402 [exact~((fst~ext'~h~(fun~a~=>~(...] 0.005 secs (0.004u,0.001s)
Chars 5405 - 5406 [-] 0. secs (0.u,0.s)
Chars 5407 - 5424 [(intros~p~q~p'~q').] 0.002 secs (0.002u,0.s)
Chars 5429 - 5751 [refine~~(IHn~(fun~b~=>~p~b~=~q...] 0.019 secs (0.016u,0.002s)
Chars 5756 - 5767 [(intros~b~c).] 0.002 secs (0.001u,0.s)
Chars 5772 - 5810 [refine~(_~oE~equiv_moveR_equiv...] 0.003 secs (0.003u,0.s)
Chars 5815 - 5836 [(apply~equiv_concat_l).] 0.003 secs (0.003u,0.s)
Chars 5841 - 5880 [refine~(_~@~(ap_transport~c~(g...] 0.004 secs (0.003u,0.s)
Chars 5885 - 5913 [(apply~ap,~symmetry,~eisretr).] 0.005 secs (0.005u,0.s)
Chars 4996 - 5068 [(revert~C~ext~D~E~g;~simple_in...] 0.002 secs (0.002u,0.s)
Chars 5071 - 5088 [1:~by~apply~idmap.] 0. secs (0.u,0.s)
Chars 5091 - 5103 [(intros~ext').] 0.001 secs (0.001u,0.s)
Chars 5106 - 5112 [split.] 0.002 secs (0.002u,0.s)
Chars 5117 - 5128 [(intros~h~k).] 0.001 secs (0.001u,0.s)
Chars 5133 - 5241 [exists~~~~(fun~b~=>~~~~g~b~((f...] 0.001 secs (0.001u,0.s)
Chars 5246 - 5255 [(intros~a).] 0.001 secs (0.001u,0.s)
Chars 5260 - 5319 [refine~((ap_transport~((fst~ex...] 0.001 secs (0.001u,0.s)
Chars 5324 - 5344 [(apply~moveR_equiv_M).] 0.001 secs (0.001u,0.s)
Chars 5349 - 5402 [exact~((fst~ext'~h~(fun~a~=>~(...] 0.001 secs (0.001u,0.s)
Chars 5407 - 5424 [(intros~p~q~p'~q').] 0.001 secs (0.001u,0.s)
Chars 5429 - 5751 [refine~~(IHn~(fun~b~=>~p~b~=~q...] 0.001 secs (0.001u,0.s)
Chars 5756 - 5767 [(intros~b~c).] 0.001 secs (0.001u,0.s)
Chars 5772 - 5810 [refine~(_~oE~equiv_moveR_equiv...] 0.001 secs (0.001u,0.s)
Chars 5815 - 5836 [(apply~equiv_concat_l).] 0.001 secs (0.001u,0.s)
Chars 5841 - 5880 [refine~(_~@~(ap_transport~c~(g...] 0.001 secs (0.001u,0.s)
Chars 5885 - 5913 [(apply~ap,~symmetry,~eisretr).] 0.001 secs (0.001u,0.s)
Chars 5914 - 5922 [Defined.] 0.01 secs (0.009u,0.s)
Chars 5924 - 6357 [Definition~extendable_over_pos...] 0.004 secs (0.004u,0.s)
Chars 6451 - 6681 [Definition~extendable_over_con...] 0.001 secs (0.001u,0.s)
Chars 6682 - 6688 [Proof.] 0. secs (0.u,0.s)
Chars 4773 - 4782 [revert~f.] 40.096 secs (0.u,0.016s)
Chars 4783 - 4814 [(equiv_intro~(equiv_path~A~B)~f).] 0.003 secs (0.002u,0.s)
Chars 4817 - 4826 [revert~g.] 0. secs (0.u,0.s)
Chars 4827 - 4858 [(equiv_intro~(equiv_path~B~C)~g).] 0.003 secs (0.003u,0.s)
Chars 4861 - 4924 [refine~((ap~path_universe_uncu...] 0.003 secs (0.002u,0.s)
Chars 4927 - 4966 [refine~(eta_path_universe~(f~@...] 0.002 secs (0.002u,0.s)
Chars 4969 - 5018 [(apply~concat2;~symmetry;~appl...] 0.01 secs (0.005u,0.004s)
Chars 4773 - 4782 [revert~f.] 0. secs (0.u,0.s)
Chars 4783 - 4814 [(equiv_intro~(equiv_path~A~B)~f).] 0. secs (0.u,0.s)
Chars 4817 - 4826 [revert~g.] 0. secs (0.u,0.s)
Chars 4827 - 4858 [(equiv_intro~(equiv_path~B~C)~g).] 0. secs (0.u,0.s)
Chars 4861 - 4924 [refine~((ap~path_universe_uncu...] 0. secs (0.u,0.s)
Chars 4927 - 4966 [refine~(eta_path_universe~(f~@...] 0. secs (0.u,0.s)
Chars 4969 - 5018 [(apply~concat2;~symmetry;~appl...] 0.001 secs (0.001u,0.s)
Chars 5019 - 5027 [Defined.] 0.003 secs (0.001u,0.001s)
Chars 5029 - 5186 [Definition~path_universe_compo...] 0.011 secs (0.009u,0.002s)
Chars 5187 - 5193 [Proof.] 0. secs (0.u,0.s)
     = f p (f q (f r b))
     : B
     = f p (f q (f r t))
     : A
     = a,, b,, c,, d,, e,, tt
     : vec A (3 + 2)
Chars 39 - 73 [Require~Import~Algebra.Congrue...] 7.96 secs (7.578u,0.363s)
Chars 74 - 110 [Require~Import~Algebra.Groups....] 0.471 secs (0.466u,0.004s)
Chars 111 - 150 [Require~Import~Algebra.Groups....] 0.087 secs (0.087u,0.s)
Chars 151 - 187 [Require~Export~Algebra.Groups....] 0.031 secs (0.03u,0.s)
Chars 188 - 225 [Require~Export~Algebra.Groups....] 0.03 secs (0.03u,0.s)
Chars 226 - 259 [Require~Export~Colimits.Quotient.] 0.638 secs (0.616u,0.02s)
Chars 260 - 280 [Require~Import~HSet.] 0.003 secs (0.001u,0.001s)
Chars 281 - 310 [Require~Import~Spaces.Finite.] 0.785 secs (0.772u,0.012s)
Chars 311 - 334 [Require~Import~WildCat.] 0.025 secs (0.025u,0.s)
Chars 362 - 393 [#[local]Open~Scope~mc_mult_scope.] 0. secs (0.u,0.s)
Chars 394 - 424 [#[local]Open~Scope~wc_iso_scope.] 0. secs (0.u,0.s)
Chars 426 - 458 [Section~GroupCongruenceQuotient.] 0. secs (0.u,0.s)
Chars 462 - 593 [Context~{G~:~Group}~{R~:~Relat...] 0.001 secs (0.001u,0.s)
Chars 597 - 636 [Definition~CongruenceQuotient~...] 0. secs (0.u,0.s)
Chars 640 - 696 [#[global]Instance~congquot_sgo...] 0. secs (0.u,0.s)
Chars 699 - 705 [Proof.] 0. secs (0.u,0.s)
Chars 57 - 103 [Require~Import~HoTT.Classes.th...] 9.706 secs (9.259u,0.423s)
Chars 710 - 719 [(intros~x).] 0.858 secs (0.001u,0.029s)
Chars 724 - 745 [srapply~Quotient_rec.] 0.067 secs (0.057u,0.009s)
Chars 750 - 751 [{] 0. secs (0.u,0.s)
Chars 752 - 770 [(intro~y;~revert~x).] 0.001 secs (0.u,0.001s)
Chars 777 - 798 [srapply~Quotient_rec.] 0.065 secs (0.055u,0.009s)
Chars 805 - 806 [{] 0. secs (0.u,0.s)
Chars 807 - 816 [(intros~x).] 0. secs (0.u,0.s)
Chars 825 - 840 [(apply~class_of).] 0.001 secs (0.001u,0.s)
Chars 849 - 863 [exact~(x~*~y).] 0.001 secs (0.u,0.s)
Chars 864 - 865 [}] 0. secs (0.u,0.s)
Chars 872 - 885 [(intros~a~b~r).] 0. secs (0.u,0.s)
Chars 892 - 896 [(cbn).] 0. secs (0.u,0.s)
Chars 903 - 915 [(apply~qglue).] 0.001 secs (0.001u,0.s)
Chars 922 - 938 [by~apply~iscong.] 0.002 secs (0.002u,0.s)
Chars 939 - 940 [}] 0. secs (0.u,0.s)
Chars 945 - 958 [(intros~a~b~r).] 0.001 secs (0.001u,0.s)
Chars 963 - 972 [revert~x.] 0.001 secs (0.001u,0.s)
Chars 977 - 1004 [srapply~Quotient_ind_hprop.] 0.083 secs (0.069u,0.013s)
Chars 1009 - 1017 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 1022 - 1034 [(apply~qglue).] 0.015 secs (0.014u,0.s)
Chars 1039 - 1055 [by~apply~iscong.] 0.002 secs (0.001u,0.001s)
Chars 710 - 719 [(intros~x).] 0. secs (0.u,0.s)
Chars 724 - 745 [srapply~Quotient_rec.] 0. secs (0.u,0.s)
Chars 752 - 770 [(intro~y;~revert~x).] 0. secs (0.u,0.s)
Chars 777 - 798 [srapply~Quotient_rec.] 0. secs (0.u,0.s)
Chars 807 - 816 [(intros~x).] 0. secs (0.u,0.s)
Chars 825 - 840 [(apply~class_of).] 0. secs (0.u,0.s)
Chars 849 - 863 [exact~(x~*~y).] 0. secs (0.u,0.s)
Chars 872 - 885 [(intros~a~b~r).] 0. secs (0.u,0.s)
Chars 892 - 896 [(cbn).] 0. secs (0.u,0.s)
Chars 903 - 915 [(apply~qglue).] 0. secs (0.u,0.s)
Chars 922 - 938 [by~apply~iscong.] 0. secs (0.u,0.s)
Chars 945 - 958 [(intros~a~b~r).] 0.001 secs (0.001u,0.s)
Chars 963 - 972 [revert~x.] 0.001 secs (0.001u,0.s)
Chars 977 - 1004 [srapply~Quotient_ind_hprop.] 0.001 secs (0.001u,0.s)
Chars 1009 - 1017 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 1022 - 1034 [(apply~qglue).] 0.001 secs (0.001u,0.s)
Chars 1039 - 1055 [by~apply~iscong.] 0. secs (0.u,0.s)
Chars 1058 - 1066 [Defined.] 0.002 secs (0.001u,0.s)
Chars 1070 - 1133 [#[global]Instance~congquot_mon...] 0. secs (0.u,0.s)
Chars 1136 - 1142 [Proof.] 0. secs (0.u,0.s)
Chars 104 - 396 [Require~Import~HoTT.Classes.th...] 0.724 secs (0.715u,0.007s)
Chars 397 - 442 [Require~Export~HoTT.Classes.or...] 0.143 secs (0.142u,0.s)
Chars 444 - 482 [Generalizable~Variables~N~R~Rl...] 0. secs (0.u,0.s)
Chars 484 - 507 [Section~naturals_order.] 0. secs (0.u,0.s)
Chars 508 - 540 [Context~`{Funext}~`{Univalence}.] 0. secs (0.u,0.s)
Chars 541 - 582 [Context~`{Naturals~N}~`{!Trivi...] 0.002 secs (0.001u,0.s)
Chars 584 - 628 [Instance~nat_nonneg~~x:~(PropH...] 0.001 secs (0.001u,0.s)
Chars 629 - 635 [Proof.] 0. secs (0.u,0.s)
Chars 1957 - 1994 [srapply~(Build_Modality~(IsTru...] 40.213 secs (0.054u,0.038s)
Chars 1997 - 1998 [-] 0. secs (0.u,0.s)
Chars 1999 - 2053 [(intros~A~B~?~f~?;~apply~(istr...] 0.003 secs (0.003u,0.s)
Chars 2056 - 2057 [-] 0. secs (0.u,0.s)
Chars 2058 - 2074 [exact~(Trunc~n).] 0. secs (0.u,0.s)
Chars 2077 - 2078 [-] 0. secs (0.u,0.s)
Chars 2079 - 2112 [(intros;~apply~istrunc_truncat...] 0. secs (0.u,0.s)
Chars 2115 - 2116 [-] 0. secs (0.u,0.s)
Chars 2117 - 2136 [(intros~A;~apply~tr).] 0. secs (0.u,0.s)
Chars 2139 - 2140 [-] 0. secs (0.u,0.s)
Chars 2141 - 2169 [(intros~A~B~?~f~oa;~cbn~in~*).] 0.001 secs (0.u,0.s)
Chars 2174 - 2199 [exact~(Trunc_ind~B~f~oa).] 0.001 secs (0.001u,0.s)
Chars 2202 - 2203 [-] 0. secs (0.u,0.s)
Chars 2204 - 2224 [(intros;~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 1957 - 1994 [srapply~(Build_Modality~(IsTru...] 0. secs (0.u,0.s)
Chars 1999 - 2053 [(intros~A~B~?~f~?;~apply~(istr...] 0. secs (0.u,0.s)
Chars 2058 - 2074 [exact~(Trunc~n).] 0. secs (0.u,0.s)
Chars 2079 - 2112 [(intros;~apply~istrunc_truncat...] 0. secs (0.u,0.s)
Chars 2117 - 2136 [(intros~A;~apply~tr).] 0. secs (0.u,0.s)
Chars 2141 - 2169 [(intros~A~B~?~f~oa;~cbn~in~*).] 0. secs (0.u,0.s)
Chars 2174 - 2199 [exact~(Trunc_ind~B~f~oa).] 0. secs (0.u,0.s)
Chars 2204 - 2224 [(intros;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 2225 - 2233 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2515 - 2554 [Coercion~Tr~:~trunc_index~>->~...] 0. secs (0.u,0.s)
Chars 2881 - 2906 [Add~Printing~Coercion~Tr.] 0. secs (0.u,0.s)
Chars 2908 - 2935 [Section~TruncationModality.] 0. secs (0.u,0.s)
Chars 2938 - 2964 [Context~(n~:~trunc_index).] 0. secs (0.u,0.s)
Chars 2968 - 3096 [Definition~trunc_iff_isequiv_t...] 0.001 secs (0.001u,0.s)
Chars 3100 - 3210 [#[global]~Instance~isequiv_tr~...] 0.001 secs (0.u,0.s)
Chars 3214 - 3312 [Definition~equiv_tr~(A~:~Type)...] 0.002 secs (0.002u,0.s)
Chars 3316 - 3407 [Definition~untrunc_istrunc~{A~...] 0.002 secs (0.002u,0.s)
Chars 3810 - 3951 [Definition~Trunc_functor@{i~j~...] 0.001 secs (0.u,0.s)
Chars 3955 - 4061 [#[global]~Instance~is0functor_...] 0.003 secs (0.002u,0.s)
Chars 4065 - 4216 [#[global]~Instance~Trunc_funct...] 0.002 secs (0.002u,0.s)
Chars 4220 - 4334 [Definition~Trunc_functor_equiv...] 0.001 secs (0.001u,0.s)
Chars 4338 - 4506 [Definition~Trunc_functor_compo...] 0.004 secs (0.003u,0.s)
Chars 4510 - 4624 [Definition~Trunc_functor_idmap...] 0.001 secs (0.001u,0.s)
Chars 4628 - 4763 [Definition~isequiv_Trunc_funct...] 0.002 secs (0.002u,0.s)
Chars 4767 - 4889 [Definition~equiv_Trunc_prod_cm...] 0.001 secs (0.001u,0.s)
Chars 4893 - 4943 [#[global]Instance~is1functor_T...] 0.006 secs (0.003u,0.003s)
Chars 4946 - 4952 [Proof.] 0. secs (0.u,0.s)
Chars 2064 - 2190 [(refine~~~(_~o~@left_morphism_...] 40.13 secs (0.015u,0.026s)
Chars 2064 - 2190 [(refine~~~(_~o~@left_morphism_...] 0.001 secs (0.001u,0.s)
Chars 2195 - 2203 [Defined.] 0.002 secs (0.001u,0.s)
Chars 2206 - 2223 [End~only_functor.] 0.003 secs (0.003u,0.s)
Chars 2224 - 2233 [End~left.] 0.007 secs (0.004u,0.002s)
Chars 2235 - 2249 [Section~right.] 0. secs (0.u,0.s)
Chars 2330 - 2727 [Definition~right_morphism_of~C...] 0.024 secs (0.022u,0.001s)
Chars 2731 - 3069 [Definition~right_morphism_of_n...] 0.009 secs (0.008u,0.s)
Chars 3070 - 3080 [End~right.] 0.001 secs (0.001u,0.s)
Chars 1080 - 1093 [path_functor.] 40.114 secs (0.006u,0.018s)
Chars 1098 - 1142 [exists~(path_forall~_~_~(helpe...] 0.004 secs (0.004u,0.s)
Chars 1147 - 1192 [(abstract~(unfold~helper2_help...] 0.814 secs (0.674u,0.132s)
Chars 1080 - 1093 [path_functor.] 0. secs (0.u,0.s)
Chars 1098 - 1142 [exists~(path_forall~_~_~(helpe...] 0. secs (0.u,0.s)
Chars 1147 - 1192 [(abstract~(unfold~helper2_help...] 0. secs (0.u,0.s)
Chars 1195 - 1203 [Defined.] 0.054 secs (0.047u,0.007s)
Chars 1207 - 1304 [Lemma~law~:~~~functor~C1~C2~D~...] 0.004 secs (0.004u,0.s)
Chars 1307 - 1313 [Proof.] 0. secs (0.u,0.s)
Chars 318 - 341 [snrapply~easy_modality.] 40.15 secs (0.002u,0.025s)
Chars 344 - 345 [-] 0. secs (0.u,0.s)
Chars 346 - 371 [(intros~X;~exact~(U~->~X)).] 0. secs (0.u,0.s)
Chars 374 - 375 [-] 0. secs (0.u,0.s)
Chars 376 - 392 [(intros~T~x;~cbn).] 0. secs (0.u,0.s)
Chars 397 - 416 [exact~(fun~_~=>~x).] 0. secs (0.u,0.s)
Chars 419 - 420 [-] 0. secs (0.u,0.s)
Chars 421 - 443 [(cbn;~intros~A~B~f~z~u).] 0.001 secs (0.001u,0.s)
Chars 448 - 483 [refine~(transport~B~_~(f~(z~u)...] 0.001 secs (0.u,0.001s)
Chars 488 - 516 [(apply~path_arrow;~intros~u').] 0.001 secs (0.u,0.s)
Chars 521 - 550 [(apply~ap;~apply~path_ishprop).] 0.004 secs (0.003u,0.s)
Chars 553 - 554 [-] 0. secs (0.u,0.s)
Chars 555 - 575 [(cbn;~intros~A~B~f~a).] 0.002 secs (0.002u,0.s)
Chars 580 - 607 [(apply~path_arrow;~intros~u).] 0.002 secs (0.002u,0.s)
Chars 612 - 677 [(transitivity~(transport~B~1~(...] 0.008 secs (0.008u,0.s)
Chars 682 - 726 [(apply~(ap~(fun~p~=>~transport...] 0.002 secs (0.002u,0.s)
Chars 731 - 829 [(transitivity~(path_arrow~(fun...] 0.015 secs (0.015u,0.s)
Chars 834 - 835 [*] 0. secs (0.u,0.s)
Chars 836 - 845 [(apply~ap).] 0.001 secs (0.001u,0.s)
Chars 852 - 881 [(apply~path_forall;~intros~u').] 0.002 secs (0.002u,0.s)
Chars 888 - 903 [(apply~ap_const).] 0.001 secs (0.u,0.s)
Chars 908 - 909 [*] 0. secs (0.u,0.s)
Chars 910 - 931 [(apply~eta_path_arrow).] 0.001 secs (0.u,0.s)
Chars 934 - 935 [-] 0. secs (0.u,0.s)
Chars 936 - 950 [(intros~A~z~z').] 0. secs (0.u,0.s)
Chars 955 - 992 [srefine~(isequiv_adjointify~_~...] 0.001 secs (0.001u,0.s)
Chars 997 - 998 [*] 0. secs (0.u,0.s)
Chars 999 - 1036 [(intros~f;~apply~path_arrow;~i...] 0.001 secs (0.001u,0.s)
Chars 1043 - 1064 [exact~(ap10~(f~u)~u).] 0.001 secs (0.001u,0.s)
Chars 1069 - 1070 [*] 0. secs (0.u,0.s)
Chars 1071 - 1108 [(intros~f;~apply~path_arrow;~i...] 0.003 secs (0.003u,0.s)
Chars 1115 - 1159 [transitivity~(path_arrow~z~z'~...] 0.003 secs (0.003u,0.s)
Chars 1166 - 1167 [+] 0. secs (0.u,0.s)
Chars 1168 - 1188 [(unfold~to;~apply~ap).] 0.002 secs (0.002u,0.s)
Chars 1197 - 1226 [(apply~path_forall;~intros~u').] 0.003 secs (0.002u,0.s)
Chars 1235 - 1273 [(apply~(ap~(fun~u0~=>~ap10~(f~...] 0.002 secs (0.002u,0.s)
Chars 1282 - 1301 [(apply~path_ishprop).] 0.003 secs (0.003u,0.s)
Chars 1308 - 1309 [+] 0. secs (0.u,0.s)
Chars 1310 - 1331 [(apply~eta_path_arrow).] 0.001 secs (0.001u,0.s)
Chars 1336 - 1337 [*] 0. secs (0.u,0.s)
Chars 1338 - 1347 [(intros~p).] 0.001 secs (0.001u,0.s)
Chars 1354 - 1384 [refine~(eta_path_arrow~_~_~_).] 0.001 secs (0.001u,0.s)
Chars 318 - 341 [snrapply~easy_modality.] 0. secs (0.u,0.s)
Chars 346 - 371 [(intros~X;~exact~(U~->~X)).] 0. secs (0.u,0.s)
Chars 376 - 392 [(intros~T~x;~cbn).] 0. secs (0.u,0.s)
Chars 397 - 416 [exact~(fun~_~=>~x).] 0. secs (0.u,0.s)
Chars 421 - 443 [(cbn;~intros~A~B~f~z~u).] 0. secs (0.u,0.s)
Chars 448 - 483 [refine~(transport~B~_~(f~(z~u)...] 0. secs (0.u,0.s)
Chars 488 - 516 [(apply~path_arrow;~intros~u').] 0. secs (0.u,0.s)
Chars 521 - 550 [(apply~ap;~apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 555 - 575 [(cbn;~intros~A~B~f~a).] 0.001 secs (0.u,0.s)
Chars 580 - 607 [(apply~path_arrow;~intros~u).] 0.001 secs (0.001u,0.s)
Chars 612 - 677 [(transitivity~(transport~B~1~(...] 0.001 secs (0.001u,0.s)
Chars 682 - 726 [(apply~(ap~(fun~p~=>~transport...] 0. secs (0.u,0.s)
Chars 731 - 829 [(transitivity~(path_arrow~(fun...] 0.001 secs (0.001u,0.s)
Chars 836 - 845 [(apply~ap).] 0. secs (0.u,0.s)
Chars 852 - 881 [(apply~path_forall;~intros~u').] 0.001 secs (0.001u,0.s)
Chars 888 - 903 [(apply~ap_const).] 0. secs (0.u,0.s)
Chars 910 - 931 [(apply~eta_path_arrow).] 0. secs (0.u,0.s)
Chars 936 - 950 [(intros~A~z~z').] 0. secs (0.u,0.s)
Chars 955 - 992 [srefine~(isequiv_adjointify~_~...] 0. secs (0.u,0.s)
Chars 999 - 1036 [(intros~f;~apply~path_arrow;~i...] 0. secs (0.u,0.s)
Chars 1043 - 1064 [exact~(ap10~(f~u)~u).] 0. secs (0.u,0.s)
Chars 1071 - 1108 [(intros~f;~apply~path_arrow;~i...] 0.002 secs (0.002u,0.s)
Chars 1115 - 1159 [transitivity~(path_arrow~z~z'~...] 0. secs (0.u,0.s)
Chars 1168 - 1188 [(unfold~to;~apply~ap).] 0.001 secs (0.001u,0.s)
Chars 1197 - 1226 [(apply~path_forall;~intros~u').] 0.001 secs (0.001u,0.s)
Chars 1235 - 1273 [(apply~(ap~(fun~u0~=>~ap10~(f~...] 0. secs (0.u,0.s)
Chars 1282 - 1301 [(apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 1310 - 1331 [(apply~eta_path_arrow).] 0. secs (0.u,0.s)
Chars 1338 - 1347 [(intros~p).] 0. secs (0.u,0.s)
Chars 1354 - 1384 [refine~(eta_path_arrow~_~_~_).] 0. secs (0.u,0.s)
Chars 1385 - 1393 [Defined.] 0.008 secs (0.005u,0.002s)
Chars 1548 - 1610 [#[global]Instance~lex_open~~`{...] 0. secs (0.u,0.s)
Chars 1611 - 1617 [Proof.] 0. secs (0.u,0.s)
Chars 976 - 986 [(intros~?~?).] 40.186 secs (0.u,0.034s)
Chars 991 - 1040 [(apply~path_iff_hprop;~hor_int...] 0.325 secs (0.264u,0.06s)
Chars 976 - 986 [(intros~?~?).] 0. secs (0.u,0.s)
Chars 991 - 1040 [(apply~path_iff_hprop;~hor_int...] 0.001 secs (0.001u,0.s)
Chars 1043 - 1051 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1055 - 1100 [Instance~commutative_hand~:~(C...] 0. secs (0.u,0.s)
Chars 1103 - 1109 [Proof.] 0. secs (0.u,0.s)
Chars 212 - 240 [(repeat~(split;~try~apply~_)).] 40.231 secs (0.042u,0.06s)
Chars 212 - 240 [(repeat~(split;~try~apply~_)).] 0. secs (0.u,0.s)
Chars 241 - 245 [Qed.] 0. secs (0.u,0.s)
Chars 247 - 342 [#[global]~Instance~bounded_joi...] 0. secs (0.u,0.s)
Chars 343 - 349 [Proof.] 0. secs (0.u,0.s)
Chars 4306 - 4315 [(intros~b).] 40.057 secs (0.u,0.026s)
Chars 4320 - 4414 [exact~(inO_equiv_inO~(hfiber~f...] 0.014 secs (0.011u,0.003s)
Chars 4306 - 4315 [(intros~b).] 0. secs (0.u,0.s)
Chars 4320 - 4414 [exact~(inO_equiv_inO~(hfiber~f...] 0. secs (0.u,0.s)
Chars 4417 - 4425 [Defined.] 0. secs (0.u,0.s)
Chars 4492 - 4602 [#[global]~Instance~mapinO_pr1~...] 0. secs (0.u,0.s)
Chars 4605 - 4611 [Proof.] 0. secs (0.u,0.s)
Chars 7358 - 7369 [(destruct~c).] 40.185 secs (0.03u,0.028s)
Chars 7374 - 7394 [(apply~cu_fill_right).] 0.006 secs (0.005u,0.s)
Chars 7358 - 7369 [(destruct~c).] 0.002 secs (0.002u,0.s)
Chars 7374 - 7394 [(apply~cu_fill_right).] 0.002 secs (0.002u,0.s)
Chars 7397 - 7405 [Defined.] 0.007 secs (0.006u,0.s)
Chars 7409 - 7832 [Definition~dc_fill_top~(t0ii~:...] 0.037 secs (0.026u,0.01s)
Chars 7835 - 7841 [Proof.] 0. secs (0.u,0.s)
Chars 1398 - 1429 [refine~(concat_p_pp~_~_~_~@~_).] 40.162 secs (0.035u,0.025s)
Chars 1434 - 1460 [refine~(whiskerR~p~_~@~_).] 0.002 secs (0.002u,0.s)
Chars 1465 - 1496 [refine~(concat_pp_p~_~_~_~@~_).] 0.002 secs (0.002u,0.s)
Chars 1501 - 1527 [refine~(whiskerL~_~q~@~_).] 0.002 secs (0.002u,0.s)
Chars 1532 - 1550 [(apply~concat_p_pp).] 0.001 secs (0.001u,0.s)
Chars 1398 - 1429 [refine~(concat_p_pp~_~_~_~@~_).] 0. secs (0.u,0.s)
Chars 1434 - 1460 [refine~(whiskerR~p~_~@~_).] 0. secs (0.u,0.s)
Chars 1465 - 1496 [refine~(concat_pp_p~_~_~_~@~_).] 0. secs (0.u,0.s)
Chars 1501 - 1527 [refine~(whiskerL~_~q~@~_).] 0. secs (0.u,0.s)
Chars 1532 - 1550 [(apply~concat_p_pp).] 0. secs (0.u,0.s)
Chars 1553 - 1561 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1563 - 1585 [End~concat_square_hor.] 0.005 secs (0.003u,0.001s)
Chars 1587 - 1636 [Infix~"[I]"~:=~concat_square_h...] 0. secs (0.u,0.s)
Chars 1695 - 1776 [Definition~rlucancel~{X}~{a~b~...] 0.001 secs (0.001u,0.s)
Chars 1777 - 1783 [Proof.] 0. secs (0.u,0.s)
Chars 5408 - 5416 [intro~i.] 40.179 secs (0.001u,0.034s)
Chars 5419 - 5460 [(induction~i~using~fin_ind;~in...] 0.009 secs (0.008u,0.001s)
Chars 5463 - 5464 [-] 0. secs (0.u,0.s)
Chars 5465 - 5482 [(unfold~cons_dom').] 0.001 secs (0.u,0.s)
Chars 5487 - 5520 [(rewrite~compute_fin_ind_fin_z...] 0.024 secs (0.02u,0.003s)
Chars 5525 - 5537 [reflexivity.] 0. secs (0.u,0.s)
Chars 5540 - 5541 [-] 0. secs (0.u,0.s)
Chars 5542 - 5559 [(unfold~cons_dom').] 0.001 secs (0.001u,0.s)
Chars 5564 - 5597 [by~rewrite~compute_fin_ind_fsucc.] 0.047 secs (0.042u,0.004s)
Chars 5408 - 5416 [intro~i.] 0. secs (0.u,0.s)
Chars 5419 - 5460 [(induction~i~using~fin_ind;~in...] 0.001 secs (0.001u,0.s)
Chars 5465 - 5482 [(unfold~cons_dom').] 0. secs (0.u,0.s)
Chars 5487 - 5520 [(rewrite~compute_fin_ind_fin_z...] 0.001 secs (0.001u,0.s)
Chars 5525 - 5537 [reflexivity.] 0. secs (0.u,0.s)
Chars 5542 - 5559 [(unfold~cons_dom').] 0. secs (0.u,0.s)
Chars 5564 - 5597 [by~rewrite~compute_fin_ind_fsucc.] 0.001 secs (0.001u,0.s)
Chars 5598 - 5602 [Qed.] 0.052 secs (0.039u,0.012s)
Chars 5604 - 5783 [Lemma~expand_cons_dom~`{Funext...] 0.002 secs (0.001u,0.001s)
Chars 5784 - 5790 [Proof.] 0. secs (0.u,0.s)
Chars 1832 - 1853 [(apply~istrunc_forall).] 40.151 secs (0.004u,0.031s)
Chars 1832 - 1853 [(apply~istrunc_forall).] 0. secs (0.u,0.s)
Chars 1856 - 1860 [Qed.] 0. secs (0.u,0.s)
Chars 1861 - 1881 [End~is_homomorphism.] 0.005 secs (0.005u,0.s)
Chars 1883 - 2051 [Record~Homomorphism~{σ}~{A~B~:...] 0.004 secs (0.004u,0.s)
Chars 2053 - 2081 [Arguments~Homomorphism~{σ}.] 0. secs (0.u,0.s)
Chars 2083 - 2150 [Arguments~BuildHomomorphism~{σ...] 0. secs (0.u,0.s)
Chars 2262 - 2314 [#[global]Coercion~def_hom~:~Ho...] 0. secs (0.u,0.s)
Chars 2316 - 2361 [#[global]Existing~Instance~is_...] 0. secs (0.u,0.s)
Chars 2363 - 2469 [Lemma~apD10_homomorphism~{σ}~{...] 0.002 secs (0.001u,0.s)
Chars 2470 - 2476 [Proof.] 0. secs (0.u,0.s)
Chars 429 - 495 [snrapply~(Build_Subgroup~_~(fu...] 40.124 secs (0.001u,0.03s)
Chars 498 - 511 [(repeat~split).] 0.001 secs (0.001u,0.s)
Chars 514 - 525 [1:~exact~_.] 0.007 secs (0.003u,0.002s)
Chars 528 - 578 [1:~(apply~tr;~exists~mon_unit;...] 0.003 secs (0.003u,0.s)
Chars 581 - 582 [{] 0. secs (0.u,0.s)
Chars 583 - 627 [(intros~x~y~p~q;~strip_truncat...] 0.068 secs (0.058u,0.008s)
Chars 632 - 666 [(destruct~p~as~[a~[]],~q~as~[b...] 0.003 secs (0.003u,0.s)
Chars 671 - 686 [exists~(a~+~b).] 0.001 secs (0.u,0.s)
Chars 691 - 709 [(apply~grp_homo_op).] 0.001 secs (0.001u,0.s)
Chars 710 - 711 [}] 0. secs (0.u,0.s)
Chars 714 - 725 [(intros~b~p).] 0. secs (0.u,0.s)
Chars 728 - 746 [strip_truncations.] 0.083 secs (0.056u,0.026s)
Chars 749 - 770 [(destruct~p~as~[a~[]]).] 0.002 secs (0.002u,0.s)
Chars 773 - 796 [(apply~tr;~exists~(-~a)).] 0.002 secs (0.002u,0.s)
Chars 799 - 818 [(apply~grp_homo_inv).] 0. secs (0.u,0.s)
Chars 429 - 495 [snrapply~(Build_Subgroup~_~(fu...] 0. secs (0.u,0.s)
Chars 498 - 511 [(repeat~split).] 0. secs (0.u,0.s)
Chars 514 - 525 [1:~exact~_.] 0. secs (0.u,0.s)
Chars 528 - 578 [1:~(apply~tr;~exists~mon_unit;...] 0. secs (0.u,0.s)
Chars 583 - 627 [(intros~x~y~p~q;~strip_truncat...] 0.001 secs (0.001u,0.s)
Chars 632 - 666 [(destruct~p~as~[a~[]],~q~as~[b...] 0. secs (0.u,0.s)
Chars 671 - 686 [exists~(a~+~b).] 0. secs (0.u,0.s)
Chars 691 - 709 [(apply~grp_homo_op).] 0. secs (0.u,0.s)
Chars 714 - 725 [(intros~b~p).] 0. secs (0.u,0.s)
Chars 728 - 746 [strip_truncations.] 0. secs (0.u,0.s)
Chars 749 - 770 [(destruct~p~as~[a~[]]).] 0. secs (0.u,0.s)
Chars 773 - 796 [(apply~tr;~exists~(-~a)).] 0. secs (0.u,0.s)
Chars 799 - 818 [(apply~grp_homo_inv).] 0. secs (0.u,0.s)
Chars 819 - 827 [Defined.] 0.005 secs (0.005u,0.s)
Chars 829 - 901 [Definition~grp_image_in~{A~B~:...] 0.001 secs (0.001u,0.s)
Chars 902 - 908 [Proof.] 0. secs (0.u,0.s)
Chars 2479 - 2487 [intro~p.] 0.625 secs (0.001u,0.03s)
Chars 2488 - 2502 [by~destruct~p.] 0.004 secs (0.004u,0.s)
Chars 2479 - 2487 [intro~p.] 0. secs (0.u,0.s)
Chars 2488 - 2502 [by~destruct~p.] 0. secs (0.u,0.s)
Chars 2503 - 2511 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2513 - 2634 [Definition~SigHomomorphism~{σ}...] 0.001 secs (0.001u,0.s)
Chars 2636 - 2730 [Lemma~issig_homomorphism~{σ}~(...] 0.001 secs (0.u,0.s)
Chars 2731 - 2737 [Proof.] 0. secs (0.u,0.s)
Chars 2740 - 2746 [issig.] 0.127 secs (0.015u,0.033s)
Chars 2740 - 2746 [issig.] 0. secs (0.u,0.s)
Chars 2747 - 2755 [Defined.] 0.002 secs (0.002u,0.s)
Chars 2757 - 2902 [#[global]~Instance~trunc_homom...] 0.001 secs (0.001u,0.s)
Chars 2903 - 2909 [Proof.] 0. secs (0.u,0.s)
Chars 1146 - 1158 [constructor.] 40.174 secs (0.001u,0.034s)
Chars 1163 - 1164 [-] 0. secs (0.u,0.s)
Chars 1165 - 1203 [refine~(quotient_ind_prop~(Ψ~s...] 0.075 secs (0.06u,0.014s)
Chars 1204 - 1221 [(intros~x~y~z~P~Q).] 0.001 secs (0.001u,0.s)
Chars 1228 - 1241 [(apply~subrel).] 0.001 secs (0.001u,0.s)
Chars 1248 - 1266 [by~transitivity~x.] 0.01 secs (0.01u,0.s)
Chars 1271 - 1272 [-] 0. secs (0.u,0.s)
Chars 1273 - 1311 [refine~(quotient_ind_prop~(Ψ~s...] 0.135 secs (0.099u,0.035s)
Chars 1312 - 1321 [intro~x1.] 0.001 secs (0.u,0.001s)
Chars 1328 - 1366 [refine~(quotient_ind_prop~(Ψ~s...] 0.085 secs (0.078u,0.007s)
Chars 1367 - 1389 [(intros~x2~C~y1~y2~P~Q).] 0.001 secs (0.001u,0.s)
Chars 1396 - 1405 [symmetry.] 0.004 secs (0.004u,0.s)
Chars 1412 - 1423 [by~apply~C.] 0.002 secs (0.001u,0.s)
Chars 1428 - 1429 [-] 0. secs (0.u,0.s)
Chars 1430 - 1468 [refine~(quotient_ind_prop~(Ψ~s...] 0.142 secs (0.131u,0.01s)
Chars 1469 - 1478 [intro~x1.] 0.001 secs (0.001u,0.s)
Chars 1485 - 1523 [refine~(quotient_ind_prop~(Ψ~s...] 0.095 secs (0.094u,0.s)
Chars 1524 - 1533 [intro~x2.] 0.001 secs (0.001u,0.s)
Chars 1540 - 1578 [refine~(quotient_ind_prop~(Ψ~s...] 0.078 secs (0.078u,0.s)
Chars 1579 - 1603 [(intros~x3~C~D~y1~y2~P~Q).] 0.001 secs (0.001u,0.s)
Chars 1610 - 1626 [transitivity~x2.] 0.004 secs (0.004u,0.s)
Chars 1633 - 1634 [+] 0. secs (0.u,0.s)
Chars 1635 - 1677 [exact~(C~y1~x2~P~(EquivRel_Ref...] 0.004 secs (0.004u,0.s)
Chars 1684 - 1685 [+] 0. secs (0.u,0.s)
Chars 1686 - 1728 [exact~(D~x2~y2~(EquivRel_Refle...] 0.003 secs (0.003u,0.s)
Chars 1146 - 1158 [constructor.] 0. secs (0.u,0.s)
Chars 1165 - 1203 [refine~(quotient_ind_prop~(Ψ~s...] 0. secs (0.u,0.s)
Chars 1204 - 1221 [(intros~x~y~z~P~Q).] 0. secs (0.u,0.s)
Chars 1228 - 1241 [(apply~subrel).] 0. secs (0.u,0.s)
Chars 1248 - 1266 [by~transitivity~x.] 0. secs (0.u,0.s)
Chars 1273 - 1311 [refine~(quotient_ind_prop~(Ψ~s...] 0. secs (0.u,0.s)
Chars 1312 - 1321 [intro~x1.] 0. secs (0.u,0.s)
Chars 1328 - 1366 [refine~(quotient_ind_prop~(Ψ~s...] 0. secs (0.u,0.s)
Chars 1367 - 1389 [(intros~x2~C~y1~y2~P~Q).] 0. secs (0.u,0.s)
Chars 1396 - 1405 [symmetry.] 0. secs (0.u,0.s)
Chars 1412 - 1423 [by~apply~C.] 0. secs (0.u,0.s)
Chars 1430 - 1468 [refine~(quotient_ind_prop~(Ψ~s...] 0. secs (0.u,0.s)
Chars 1469 - 1478 [intro~x1.] 0. secs (0.u,0.s)
Chars 1485 - 1523 [refine~(quotient_ind_prop~(Ψ~s...] 0. secs (0.u,0.s)
Chars 1524 - 1533 [intro~x2.] 0. secs (0.u,0.s)
Chars 1540 - 1578 [refine~(quotient_ind_prop~(Ψ~s...] 0. secs (0.u,0.s)
Chars 1579 - 1603 [(intros~x3~C~D~y1~y2~P~Q).] 0. secs (0.u,0.s)
Chars 1610 - 1626 [transitivity~x2.] 0. secs (0.u,0.s)
Chars 1635 - 1677 [exact~(C~y1~x2~P~(EquivRel_Ref...] 0. secs (0.u,0.s)
Chars 1686 - 1728 [exact~(D~x2~y2~(EquivRel_Refle...] 0. secs (0.u,0.s)
Chars 1731 - 1739 [Defined.] 0.016 secs (0.016u,0.s)
Chars 1743 - 2031 [Lemma~for_all_relation_quotien...] 0.005 secs (0.005u,0.s)
Chars 2034 - 2040 [Proof.] 0. secs (0.u,0.s)
Chars 6691 - 6706 [revert~C~ext~D.] 40.154 secs (0.001u,0.032s)
Chars 6709 - 6755 [(simple_induction~n~n~IHn;~int...] 0.003 secs (0.003u,0.s)
Chars 6758 - 6769 [1:~exact~tt.] 0. secs (0.u,0.s)
Chars 6772 - 6778 [split.] 0.002 secs (0.001u,0.s)
Chars 6781 - 6782 [-] 0. secs (0.u,0.s)
Chars 6783 - 6795 [(intros~g~g').] 0.001 secs (0.001u,0.s)
Chars 6800 - 6825 [exists~(fst~ext'~g').1.] 0.002 secs (0.002u,0.s)
Chars 6830 - 6939 [exact~(fun~a~=>~transport_cons...] 0.005 secs (0.004u,0.s)
Chars 6942 - 6943 [-] 0. secs (0.u,0.s)
Chars 6944 - 6961 [(intros~h~k~h'~k').] 0.001 secs (0.001u,0.s)
Chars 6966 - 7132 [refine~~(extendable_over_postc...] 0.005 secs (0.004u,0.s)
Chars 7137 - 7205 [exact~(fun~b~c~=>~equiv_concat...] 0.002 secs (0.002u,0.s)
Chars 6691 - 6706 [revert~C~ext~D.] 0. secs (0.u,0.s)
Chars 6709 - 6755 [(simple_induction~n~n~IHn;~int...] 0.001 secs (0.001u,0.s)
Chars 6758 - 6769 [1:~exact~tt.] 0. secs (0.u,0.s)
Chars 6772 - 6778 [split.] 0. secs (0.u,0.s)
Chars 6783 - 6795 [(intros~g~g').] 0. secs (0.u,0.s)
Chars 6800 - 6825 [exists~(fst~ext'~g').1.] 0. secs (0.u,0.s)
Chars 6830 - 6939 [exact~(fun~a~=>~transport_cons...] 0. secs (0.u,0.s)
Chars 6944 - 6961 [(intros~h~k~h'~k').] 0. secs (0.u,0.s)
Chars 6966 - 7132 [refine~~(extendable_over_postc...] 0. secs (0.u,0.s)
Chars 7137 - 7205 [exact~(fun~b~c~=>~equiv_concat...] 0. secs (0.u,0.s)
Chars 7206 - 7214 [Defined.] 0.004 secs (0.004u,0.s)
Chars 7297 - 7554 [Fixpoint~apD_extendable_eq~(n~...] 0.001 secs (0.u,0.s)
Chars 7555 - 7561 [Proof.] 0. secs (0.u,0.s)
Chars 7564 - 7575 [(destruct~n).] 0.192 secs (0.001u,0.032s)
Chars 7578 - 7579 [-] 0. secs (0.u,0.s)
Chars 7580 - 7591 [exact~Unit.] 0. secs (0.u,0.s)
Chars 7594 - 7595 [-] 0. secs (0.u,0.s)
Chars 7596 - 7607 [(apply~prod).] 0. secs (0.u,0.s)
Chars 7612 - 7613 [+] 0. secs (0.u,0.s)
Chars 7614 - 7743 [exact~~(forall~(h~:~forall~a,~...] 0.007 secs (0.007u,0.s)
Chars 7748 - 7749 [+] 0. secs (0.u,0.s)
Chars 7750 - 8022 [exact~~(forall~h~k,~~~apD_exte...] 0.009 secs (0.008u,0.s)
Chars 7564 - 7575 [(destruct~n).] 0. secs (0.u,0.s)
Chars 7580 - 7591 [exact~Unit.] 0. secs (0.u,0.s)
Chars 7596 - 7607 [(apply~prod).] 0. secs (0.u,0.s)
Chars 7614 - 7743 [exact~~(forall~(h~:~forall~a,~...] 0. secs (0.u,0.s)
Chars 7750 - 8022 [exact~~(forall~h~k,~~~apD_exte...] 0. secs (0.u,0.s)
Chars 8023 - 8031 [Defined.] 0.002 secs (0.002u,0.s)
Chars 8065 - 8269 [Definition~ooExtendableAlong_O...] 0.001 secs (0.001u,0.s)
ooExtendableAlong_Over
     : forall (f : ?A -> ?B) (C : ?B -> Type),
       (forall b : ?B, C b -> Type) -> ooExtendableAlong f C -> Type
where
?A : [ |- Type]
?B : [ |- Type]
Chars 8341 - 8382 [Check~ooExtendableAlong_Over@{...] 0. secs (0.u,0.s)
Chars 8432 - 8718 [Definition~ooextendable_over_c...] 0.002 secs (0.002u,0.s)
Chars 8797 - 9103 [Definition~ooextendable_over_h...] 0.002 secs (0.002u,0.s)
Chars 9104 - 9110 [Proof.] 0. secs (0.u,0.s)
Chars 5196 - 5205 [revert~f.] 40.105 secs (0.001u,0.016s)
Chars 5206 - 5237 [(equiv_intro~(equiv_path~A~B)~f).] 0.004 secs (0.002u,0.s)
Chars 5240 - 5249 [revert~g.] 0. secs (0.u,0.s)
Chars 5250 - 5281 [(equiv_intro~(equiv_path~B~C)~g).] 0.003 secs (0.002u,0.s)
Chars 5284 - 5347 [refine~((ap~path_universe_uncu...] 0.003 secs (0.003u,0.s)
Chars 5350 - 5389 [refine~(eta_path_universe~(f~@...] 0.002 secs (0.001u,0.001s)
Chars 5392 - 5441 [(apply~concat2;~symmetry;~appl...] 0.009 secs (0.009u,0.s)
Chars 5196 - 5205 [revert~f.] 0. secs (0.u,0.s)
Chars 5206 - 5237 [(equiv_intro~(equiv_path~A~B)~f).] 0. secs (0.u,0.s)
Chars 5240 - 5249 [revert~g.] 0. secs (0.u,0.s)
Chars 5250 - 5281 [(equiv_intro~(equiv_path~B~C)~g).] 0. secs (0.u,0.s)
Chars 5284 - 5347 [refine~((ap~path_universe_uncu...] 0. secs (0.u,0.s)
Chars 5350 - 5389 [refine~(eta_path_universe~(f~@...] 0. secs (0.u,0.s)
Chars 5392 - 5441 [(apply~concat2;~symmetry;~appl...] 0.001 secs (0.001u,0.s)
Chars 5442 - 5450 [Defined.] 0.006 secs (0.002u,0.001s)
Chars 5452 - 5551 [Definition~path_universe_1~{A~...] 0.002 secs (0.002u,0.s)
Chars 5553 - 5691 [Definition~path_universe_V_unc...] 0.001 secs (0.001u,0.s)
Chars 5692 - 5698 [Proof.] 0. secs (0.u,0.s)
Chars 350 - 378 [(repeat~(split;~try~apply~_)).] 13.173 secs (0.007u,0.032s)
Chars 350 - 378 [(repeat~(split;~try~apply~_)).] 0. secs (0.u,0.s)
Chars 379 - 383 [Qed.] 0. secs (0.u,0.s)
Chars 385 - 480 [#[global]~Instance~bounded_mee...] 0. secs (0.u,0.s)
Chars 481 - 487 [Proof.] 0. secs (0.u,0.s)
Chars 488 - 516 [(repeat~(split;~try~apply~_)).] 0.095 secs (0.007u,0.032s)
Chars 488 - 516 [(repeat~(split;~try~apply~_)).] 0. secs (0.u,0.s)
Chars 517 - 521 [Qed.] 0. secs (0.u,0.s)
Chars 523 - 602 [#[global]~Instance~bounded_lat...] 0.001 secs (0.u,0.001s)
Chars 603 - 609 [Proof.] 0. secs (0.u,0.s)
Chars 610 - 632 [(repeat~split;~apply~_).] 0.136 secs (0.042u,0.036s)
Chars 610 - 632 [(repeat~split;~apply~_).] 0.002 secs (0.002u,0.s)
Chars 633 - 637 [Qed.] 0.001 secs (0.001u,0.s)
Chars 639 - 740 [#[global]~Instance~bounded_sl_...] 0.001 secs (0.001u,0.s)
Chars 741 - 747 [Proof.] 0. secs (0.u,0.s)
Chars 1147 - 1172 [(apply~class_of,~mon_unit).] 40.138 secs (0.u,0.03s)
Chars 1147 - 1172 [(apply~class_of,~mon_unit).] 0. secs (0.u,0.s)
Chars 1175 - 1183 [Defined.] 0. secs (0.u,0.s)
Chars 1187 - 1247 [#[global]Instance~congquot_neg...] 0. secs (0.u,0.s)
Chars 1250 - 1256 [Proof.] 0. secs (0.u,0.s)
Chars 636 - 671 [(apply~(to_semiring_nonneg~(f:...] 40.148 secs (0.016u,0.027s)
Chars 636 - 671 [(apply~(to_semiring_nonneg~(f:...] 0. secs (0.u,0.s)
Chars 672 - 676 [Qed.] 0.001 secs (0.u,0.s)
Chars 678 - 738 [Lemma~nat_le_plus~{x~y~:~N}~:~...] 0.001 secs (0.001u,0.s)
Chars 739 - 745 [Proof.] 0. secs (0.u,0.s)
Chars 1261 - 1286 [srapply~Quotient_functor.] 0.838 secs (0.003u,0.028s)
Chars 1291 - 1307 [1:~(apply~negate).] 0.001 secs (0.001u,0.s)
Chars 1312 - 1325 [(intros~x~y~p).] 0. secs (0.u,0.s)
Chars 1330 - 1362 [(rewrite~<-~(left_identity~(-~...] 0.012 secs (0.01u,0.s)
Chars 1367 - 1393 [(destruct~(left_inverse~y)).] 0.005 secs (0.005u,0.s)
Chars 1398 - 1416 [(set~(-~y~*~y~*~-~x)).] 0.002 secs (0.002u,0.s)
Chars 1421 - 1454 [(rewrite~<-~(right_identity~(-...] 0.013 secs (0.012u,0.s)
Chars 1459 - 1486 [(destruct~(right_inverse~x)).] 0.006 secs (0.006u,0.s)
Chars 1491 - 1509 [(unfold~g;~clear~g).] 0.002 secs (0.002u,0.s)
Chars 1514 - 1546 [(rewrite~<-~simple_associativi...] 0.03 secs (0.025u,0.004s)
Chars 1551 - 1581 [(apply~iscong;~try~reflexivity).] 0.004 secs (0.003u,0.s)
Chars 1586 - 1616 [(apply~iscong;~try~reflexivity).] 0.004 secs (0.004u,0.s)
Chars 1621 - 1633 [by~symmetry.] 0.001 secs (0.001u,0.s)
Chars 1261 - 1286 [srapply~Quotient_functor.] 0. secs (0.u,0.s)
Chars 1291 - 1307 [1:~(apply~negate).] 0. secs (0.u,0.s)
Chars 1312 - 1325 [(intros~x~y~p).] 0. secs (0.u,0.s)
Chars 1330 - 1362 [(rewrite~<-~(left_identity~(-~...] 0. secs (0.u,0.s)
Chars 1367 - 1393 [(destruct~(left_inverse~y)).] 0. secs (0.u,0.s)
Chars 1398 - 1416 [(set~(-~y~*~y~*~-~x)).] 0. secs (0.u,0.s)
Chars 1421 - 1454 [(rewrite~<-~(right_identity~(-...] 0. secs (0.u,0.s)
Chars 1459 - 1486 [(destruct~(right_inverse~x)).] 0. secs (0.u,0.s)
Chars 1491 - 1509 [(unfold~g;~clear~g).] 0.001 secs (0.u,0.001s)
Chars 1514 - 1546 [(rewrite~<-~simple_associativi...] 0. secs (0.u,0.s)
Chars 1551 - 1581 [(apply~iscong;~try~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 1586 - 1616 [(apply~iscong;~try~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 1621 - 1633 [by~symmetry.] 0. secs (0.u,0.s)
Chars 1636 - 1644 [Defined.] 0.002 secs (0.002u,0.s)
Chars 1648 - 1718 [#[global]Instance~congquot_sgo...] 0. secs (0.u,0.s)
Chars 1721 - 1727 [Proof.] 0. secs (0.u,0.s)
Chars 4957 - 4980 [(apply~Build_Is1Functor).] 40.147 secs (0.001u,0.024s)
Chars 4985 - 4986 [-] 0. secs (0.u,0.s)
Chars 4987 - 5013 [(apply~@O_functor_homotopy).] 0.001 secs (0.001u,0.s)
Chars 5018 - 5019 [-] 0. secs (0.u,0.s)
Chars 5020 - 5047 [(apply~@Trunc_functor_idmap).] 0.001 secs (0.u,0.s)
Chars 5052 - 5053 [-] 0. secs (0.u,0.s)
Chars 5054 - 5083 [(apply~@Trunc_functor_compose).] 0.002 secs (0.002u,0.s)
Chars 4957 - 4980 [(apply~Build_Is1Functor).] 0. secs (0.u,0.s)
Chars 4987 - 5013 [(apply~@O_functor_homotopy).] 0. secs (0.u,0.s)
Chars 5020 - 5047 [(apply~@Trunc_functor_idmap).] 0. secs (0.u,0.s)
Chars 5054 - 5083 [(apply~@Trunc_functor_compose).] 0. secs (0.u,0.s)
Chars 5086 - 5094 [Defined.] 0. secs (0.u,0.s)
Chars 5096 - 5119 [End~TruncationModality.] 0.005 secs (0.004u,0.s)
Chars 5214 - 5305 [#[global]~Instance~inO_tr_istr...] 0. secs (0.u,0.s)
Chars 5306 - 5312 [Proof.] 0. secs (0.u,0.s)
Chars 5315 - 5326 [assumption.] 1.116 secs (0.u,0.024s)
Chars 5315 - 5326 [assumption.] 0. secs (0.u,0.s)
Chars 5327 - 5335 [Defined.] 0. secs (0.u,0.s)
Chars 5408 - 5494 [Definition~istrunc_inO_tr~{n~:...] 0. secs (0.u,0.s)
Chars 5495 - 5501 [Proof.] 0. secs (0.u,0.s)
Chars 1114 - 1124 [(intros~?~?).] 24.048 secs (13.989u,0.039s)
Chars 5504 - 5515 [assumption.] 1.449 secs (0.u,0.024s)
Chars 5504 - 5515 [assumption.] 0. secs (0.u,0.s)
Chars 5516 - 5524 [Defined.] 0. secs (0.u,0.s)
Chars 5899 - 6012 [#[export]~Hint~Extern~1000~(Is...] 0. secs (0.u,0.s)
Chars 6424 - 6548 [#[global]~Instance~mapinO_tr_i...] 0. secs (0.u,0.s)
Chars 6549 - 6555 [Proof.] 0. secs (0.u,0.s)
Chars 6558 - 6569 [assumption.] 0.063 secs (0.001u,0.023s)
Chars 6558 - 6569 [assumption.] 0. secs (0.u,0.s)
Chars 6570 - 6578 [Defined.] 0. secs (0.u,0.s)
Chars 6580 - 6699 [Definition~istruncmap_mapinO_t...] 0. secs (0.u,0.s)
Chars 6700 - 6706 [Proof.] 0. secs (0.u,0.s)
Chars 1786 - 1814 [refine~(equiv_compose'~_~_).] 19.069 secs (0.001u,0.02s)
Chars 1817 - 1818 [-] 0. secs (0.u,0.s)
Chars 1819 - 1859 [exact~(equiv_concat_r~(concat_...] 0.001 secs (0.001u,0.s)
Chars 1862 - 1863 [-] 0. secs (0.u,0.s)
Chars 1864 - 1903 [exact~(equiv_concat_l~(concat_...] 0.003 secs (0.002u,0.s)
Chars 1786 - 1814 [refine~(equiv_compose'~_~_).] 0. secs (0.u,0.s)
Chars 1819 - 1859 [exact~(equiv_concat_r~(concat_...] 0. secs (0.u,0.s)
Chars 1864 - 1903 [exact~(equiv_concat_l~(concat_...] 0. secs (0.u,0.s)
Chars 1904 - 1912 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1914 - 1996 [Definition~rlucancel_inv~{X}~{...] 0.007 secs (0.006u,0.001s)
Chars 1998 - 2079 [Definition~lrucancel~{X}~{a~b~...] 0.001 secs (0.001u,0.s)
Chars 2080 - 2086 [Proof.] 0. secs (0.u,0.s)
Chars 6709 - 6720 [assumption.] 0.891 secs (0.u,0.025s)
Chars 6709 - 6720 [assumption.] 0. secs (0.u,0.s)
Chars 6721 - 6729 [Defined.] 0. secs (0.u,0.s)
Chars 6731 - 6799 [#[export]Hint~Immediate~istrun...] 0. secs (0.u,0.s)
Chars 6860 - 6889 [#[local]Open~Scope~trunc_scope.] 0. secs (0.u,0.s)
Chars 7154 - 7226 [Definition~merely~(A~:~Type@{i...] 0.001 secs (0.001u,0.s)
Chars 7228 - 7293 [Definition~hexists~{X}~(P~:~X~...] 0.001 secs (0.u,0.s)
Chars 7295 - 7349 [Definition~hor~(P~Q~:~Type)~:~...] 0. secs (0.u,0.s)
Chars 7351 - 7395 [Notation~"A~\/~B"~:=~(hor~A~B)...] 0. secs (0.u,0.s)
Chars 7397 - 7455 [Definition~himage~{X}~{Y}~(f~:...] 0.001 secs (0.001u,0.s)
Chars 7457 - 7528 [Definition~contr_inhab_prop~{A...] 0. secs (0.u,0.s)
Chars 7529 - 7535 [Proof.] 0. secs (0.u,0.s)
Chars 1318 - 1488 [(split;~path_functor;~~~[~exis...] 42.01 secs (1.772u,0.115s)
Chars 2089 - 2117 [refine~(equiv_compose'~_~_).] 2.799 secs (0.001u,0.019s)
Chars 2120 - 2121 [-] 0. secs (0.u,0.s)
Chars 2122 - 2162 [exact~(equiv_concat_r~(concat_...] 0.001 secs (0.001u,0.s)
Chars 2165 - 2166 [-] 0. secs (0.u,0.s)
Chars 2167 - 2206 [exact~(equiv_concat_l~(concat_...] 0.001 secs (0.001u,0.s)
Chars 2089 - 2117 [refine~(equiv_compose'~_~_).] 0. secs (0.u,0.s)
Chars 2122 - 2162 [exact~(equiv_concat_r~(concat_...] 0. secs (0.u,0.s)
Chars 2167 - 2206 [exact~(equiv_concat_l~(concat_...] 0. secs (0.u,0.s)
Chars 2207 - 2215 [Defined.] 0.001 secs (0.u,0.s)
Chars 2277 - 2483 [Definition~equiv_path_ind_rluc...] 0.003 secs (0.u,0.002s)
Chars 2484 - 2490 [Proof.] 0. secs (0.u,0.s)
Chars 1318 - 1488 [(split;~path_functor;~~~[~exis...] 0.011 secs (0.011u,0.s)
Chars 1491 - 1495 [Qed.] 1.672 secs (1.592u,0.072s)
Chars 1496 - 1505 [End~Law4.] 0.026 secs (0.026u,0.s)
find_witness Control.TimeoutChars 1620 - 1653 [(apply~lex_from_isconnected_pa...] 40.156 secs (0.001u,0.023s)
Chars 1656 - 1671 [(intros~A~?~x~y).] 0. secs (0.u,0.s)
Chars 1674 - 1701 [(assert~(uc~:~U~->~Contr~A)).] 0.001 secs (0.001u,0.s)
Chars 1704 - 1705 [{] 0. secs (0.u,0.s)
Chars 1706 - 1715 [(intros~u).] 0. secs (0.u,0.s)
Chars 1720 - 1753 [(pose~(contr_inhabited_hprop~U...] 0.003 secs (0.003u,0.s)
Chars 1758 - 1811 [refine~(contr_equiv~(U~->~A)~(...] 0.018 secs (0.017u,0.s)
Chars 1816 - 1825 [(apply~Ac).] 0. secs (0.u,0.s)
Chars 1826 - 1827 [}] 0. secs (0.u,0.s)
Chars 1830 - 1864 [simple~refine~(Build_Contr~_~_...] 0.001 secs (0.001u,0.s)
Chars 1867 - 1868 [-] 0. secs (0.u,0.s)
Chars 1869 - 1913 [(intros~u;~pose~(uc~u);~exact~...] 0.044 secs (0.031u,0.012s)
Chars 1916 - 1917 [-] 0. secs (0.u,0.s)
Chars 1918 - 1955 [(intros~f;~apply~path_arrow;~i...] 0.004 secs (0.004u,0.s)
Chars 1960 - 1996 [(pose~proof~(uc~u);~apply~path...] 0.006 secs (0.006u,0.s)
Chars 1620 - 1653 [(apply~lex_from_isconnected_pa...] 0. secs (0.u,0.s)
Chars 1656 - 1671 [(intros~A~?~x~y).] 0. secs (0.u,0.s)
Chars 1674 - 1701 [(assert~(uc~:~U~->~Contr~A)).] 0. secs (0.u,0.s)
Chars 1706 - 1715 [(intros~u).] 0. secs (0.u,0.s)
Chars 1720 - 1753 [(pose~(contr_inhabited_hprop~U...] 0. secs (0.u,0.s)
Chars 1758 - 1811 [refine~(contr_equiv~(U~->~A)~(...] 0. secs (0.u,0.s)
Chars 1816 - 1825 [(apply~Ac).] 0. secs (0.u,0.s)
Chars 1830 - 1864 [simple~refine~(Build_Contr~_~_...] 0. secs (0.u,0.s)
Chars 1869 - 1913 [(intros~u;~pose~(uc~u);~exact~...] 0.001 secs (0.001u,0.s)
Chars 1918 - 1955 [(intros~f;~apply~path_arrow;~i...] 0.002 secs (0.002u,0.s)
Chars 1960 - 1996 [(pose~proof~(uc~u);~apply~path...] 0.001 secs (0.001u,0.s)
Chars 1997 - 2005 [Defined.] 0.002 secs (0.002u,0.s)
Chars 2051 - 2123 [#[global]Instance~acc_open~~`{...] 0. secs (0.u,0.s)
Chars 2124 - 2130 [Proof.] 0. secs (0.u,0.s)
Chars 1114 - 1124 [(intros~?~?).] 40.071 secs (0.u,0.035s)
Chars 1129 - 1146 [(apply~path_hprop).] 0.001 secs (0.u,0.s)
Chars 1151 - 1173 [(apply~equiv_prod_symm).] 0. secs (0.u,0.s)
Chars 1114 - 1124 [(intros~?~?).] 0. secs (0.u,0.s)
Chars 1129 - 1146 [(apply~path_hprop).] 0. secs (0.u,0.s)
Chars 1151 - 1173 [(apply~equiv_prod_symm).] 0. secs (0.u,0.s)
Chars 1176 - 1184 [Defined.] 0. secs (0.u,0.s)
Chars 1188 - 1231 [Instance~associative_hor~:~(As...] 0. secs (0.u,0.s)
Chars 1234 - 1240 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 4616 - 4625 [(intros~a).] 40.143 secs (0.001u,0.027s)
Chars 4630 - 4681 [exact~(inO_equiv_inO~(B~a)~(hf...] 0.004 secs (0.003u,0.s)
Chars 4616 - 4625 [(intros~a).] 0. secs (0.u,0.s)
Chars 4630 - 4681 [exact~(inO_equiv_inO~(B~a)~(hf...] 0. secs (0.u,0.s)
Chars 4684 - 4692 [Defined.] 0. secs (0.u,0.s)
Chars 4787 - 4898 [Lemma~iff_forall_inO_mapinO_pr...] 0. secs (0.u,0.s)
Chars 4901 - 4907 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 36 [Require~Import~Basics~Types~Wi...] 3.408 secs (3.105u,0.295s)
Chars 7846 - 7857 [(destruct~c).] 40.187 secs (0.026u,0.033s)
Chars 7862 - 7880 [(apply~cu_fill_top).] 0.006 secs (0.005u,0.s)
Chars 7846 - 7857 [(destruct~c).] 0.002 secs (0.001u,0.s)
Chars 7862 - 7880 [(apply~cu_fill_top).] 0.002 secs (0.002u,0.s)
Chars 7883 - 7891 [Defined.] 0.007 secs (0.004u,0.002s)
Chars 7895 - 8273 [Definition~dc_fill_bottom~(t0i...] 0.017 secs (0.015u,0.001s)
Chars 8276 - 8282 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 36 [Require~Import~Basics~Types~Wi...] 3.364 secs (3.072u,0.283s)
Chars 5793 - 5802 [funext~i.] 40.194 secs (0.002u,0.035s)
Chars 5805 - 5828 [(apply~expand_cons_dom').] 0.004 secs (0.004u,0.s)
Chars 5793 - 5802 [funext~i.] 0. secs (0.u,0.s)
Chars 5805 - 5828 [(apply~expand_cons_dom').] 0. secs (0.u,0.s)
Chars 5829 - 5837 [Defined.] 0.002 secs (0.002u,0.s)
Chars 5839 - 6025 [Lemma~path_operation_curry_to_...] 0.003 secs (0.003u,0.s)
Chars 6026 - 6032 [Proof.] 0. secs (0.u,0.s)
Chars 37 - 71 [Require~Import~Algebra.Congrue...] 6.247 secs (5.93u,0.286s)
Chars 911 - 944 [snrapply~Build_GroupHomomorphism.] 40.151 secs (0.002u,0.027s)
Chars 947 - 948 [{] 0. secs (0.u,0.s)
Chars 949 - 957 [intro~x.] 0. secs (0.u,0.s)
Chars 962 - 975 [exists~(f~x).] 0.001 secs (0.001u,0.s)
Chars 980 - 991 [srapply~tr.] 0.002 secs (0.001u,0.s)
Chars 996 - 1005 [exists~x.] 0. secs (0.u,0.s)
Chars 1010 - 1022 [reflexivity.] 0. secs (0.u,0.s)
Chars 1023 - 1024 [}] 0. secs (0.u,0.s)
Chars 1027 - 1031 [(cbn).] 0.003 secs (0.002u,0.s)
Chars 1032 - 1041 [grp_auto.] 0.04 secs (0.032u,0.007s)
Chars 911 - 944 [snrapply~Build_GroupHomomorphism.] 0. secs (0.u,0.s)
Chars 949 - 957 [intro~x.] 0. secs (0.u,0.s)
Chars 962 - 975 [exists~(f~x).] 0. secs (0.u,0.s)
Chars 980 - 991 [srapply~tr.] 0. secs (0.u,0.s)
Chars 996 - 1005 [exists~x.] 0. secs (0.u,0.s)
Chars 1010 - 1022 [reflexivity.] 0. secs (0.u,0.s)
Chars 1027 - 1031 [(cbn).] 0. secs (0.u,0.s)
Chars 1032 - 1041 [grp_auto.] 0.002 secs (0.002u,0.s)
Chars 1042 - 1050 [Defined.] 0.01 secs (0.007u,0.002s)
Chars 1125 - 1214 [Definition~grp_image_embedding...] 0.001 secs (0.001u,0.s)
Chars 1215 - 1221 [Proof.] 0. secs (0.u,0.s)
Chars 2912 - 2969 [(apply~(istrunc_equiv_istrunc~...] 40.161 secs (0.011u,0.031s)
Chars 2912 - 2969 [(apply~(istrunc_equiv_istrunc~...] 0. secs (0.u,0.s)
Chars 2970 - 2974 [Qed.] 0.001 secs (0.u,0.s)
Chars 3169 - 3340 [Lemma~path_homomorphism~{σ}~{A...] 0.003 secs (0.003u,0.s)
Chars 3341 - 3347 [Proof.] 0. secs (0.u,0.s)
Chars 2045 - 2053 [intro~F.] 40.165 secs (0.002u,0.034s)
Chars 2054 - 2076 [(induction~w;~cbn~in~*).] 0.016 secs (0.013u,0.002s)
Chars 2081 - 2082 [-] 0. secs (0.u,0.s)
Chars 2083 - 2095 [constructor.] 0. secs (0.u,0.s)
Chars 2100 - 2101 [-] 0. secs (0.u,0.s)
Chars 2102 - 2146 [(destruct~a~as~[x~a],~b~as~[y~...] 0.011 secs (0.01u,0.s)
Chars 2153 - 2159 [split.] 0.002 secs (0.002u,0.s)
Chars 2166 - 2167 [+] 0. secs (0.u,0.s)
Chars 2168 - 2194 [(apply~Q;~cbn;~reflexivity).] 0.019 secs (0.018u,0.s)
Chars 2201 - 2202 [+] 0. secs (0.u,0.s)
Chars 2203 - 2216 [by~apply~IHw.] 0.003 secs (0.003u,0.s)
Chars 2045 - 2053 [intro~F.] 0.001 secs (0.001u,0.s)
Chars 2054 - 2076 [(induction~w;~cbn~in~*).] 0.003 secs (0.003u,0.s)
Chars 2083 - 2095 [constructor.] 0. secs (0.u,0.s)
Chars 2102 - 2146 [(destruct~a~as~[x~a],~b~as~[y~...] 0.001 secs (0.001u,0.s)
Chars 2153 - 2159 [split.] 0.001 secs (0.001u,0.s)
Chars 2168 - 2194 [(apply~Q;~cbn;~reflexivity).] 0.008 secs (0.007u,0.s)
Chars 2203 - 2216 [by~apply~IHw.] 0.001 secs (0.u,0.s)
Chars 2219 - 2223 [Qed.] 0.013 secs (0.013u,0.s)
Chars 2227 - 2317 [#[global]~Instance~ops_compati...] 0.001 secs (0.001u,0.s)
Chars 2320 - 2326 [Proof.] 0. secs (0.u,0.s)
Chars 9113 - 9127 [(intros~ext'~n).] 40.15 secs (0.001u,0.031s)
Chars 9130 - 9154 [revert~C~ext~D~r~s~ext'.] 0. secs (0.u,0.s)
Chars 9157 - 9207 [(simple_induction~n~n~IHn;~int...] 0.004 secs (0.004u,0.s)
Chars 9210 - 9221 [1:~exact~tt.] 0. secs (0.u,0.s)
Chars 9224 - 9230 [split.] 0.003 secs (0.003u,0.s)
Chars 9233 - 9234 [-] 0. secs (0.u,0.s)
Chars 9235 - 9247 [(intros~g~g').] 0.001 secs (0.001u,0.s)
Chars 9252 - 9279 [(simple~refine~(_;~_);~simpl).] 0.006 secs (0.004u,0.001s)
Chars 9284 - 9285 [+] 0. secs (0.u,0.s)
Chars 9286 - 9295 [(intros~b).] 0.001 secs (0.001u,0.s)
Chars 9302 - 9524 [refine~~(_~@~~~(fst~~~~~~(snd~...] 0.01 secs (0.007u,0.002s)
Chars 9531 - 9532 [*] 0. secs (0.u,0.s)
Chars 9533 - 9572 [refine~(transport2~(D~b)~(p:=1...] 0.003 secs (0.003u,0.s)
Chars 9581 - 9738 [(refine~~~((fst~~~~~~~(snd~(sn...] 0.01 secs (0.008u,0.001s)
Chars 9747 - 9808 [(symmetry;~refine~((fst~(snd~(...] 0.011 secs (0.007u,0.002s)
Chars 9815 - 9816 [*] 0. secs (0.u,0.s)
Chars 9817 - 9833 [(intros~a;~simpl).] 0.002 secs (0.002u,0.s)
Chars 9842 - 9996 [(refine~~~((_~@~ap~(transport~...] 0.016 secs (0.014u,0.s)
Chars 10001 - 10002 [+] 0. secs (0.u,0.s)
Chars 10003 - 10019 [(intros~a;~simpl).] 0.014 secs (0.014u,0.s)
Chars 10026 - 10058 [(set~(h~:=~(fst~(ext~n.+1)~g)....] 0.022 secs (0.017u,0.005s)
Chars 5701 - 5710 [revert~f.] 40.083 secs (0.u,0.015s)
Chars 5711 - 5756 [(equiv_intro~(equiv_path_unive...] 0.004 secs (0.004u,0.s)
Chars 5757 - 5763 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 5766 - 5784 [transitivity~p^.] 0.002 secs (0.002u,0.s)
Chars 5789 - 5848 [2:~exact~(inverse2~(eisretr~(e...] 0.005 secs (0.005u,0.s)
Chars 5851 - 5910 [transitivity~(path_universe_un...] 0.003 secs (0.003u,0.s)
Chars 5913 - 5914 [-] 0. secs (0.u,0.s)
Chars 5915 - 5954 [by~refine~(ap~_~(equiv_path_V~...] 0.002 secs (0.002u,0.s)
Chars 5957 - 5958 [-] 0. secs (0.u,0.s)
Chars 5959 - 5999 [by~refine~(eissect~(equiv_path...] 0.003 secs (0.003u,0.s)
Chars 5701 - 5710 [revert~f.] 0. secs (0.u,0.s)
Chars 5711 - 5756 [(equiv_intro~(equiv_path_unive...] 0. secs (0.u,0.s)
Chars 10065 - 10269 [(match~goal~with~~|~|-~context...] 0.028 secs (0.025u,0.002s)
Chars 5757 - 5763 [(simpl).] 0. secs (0.u,0.s)
Chars 5766 - 5784 [transitivity~p^.] 0. secs (0.u,0.s)
Chars 5789 - 5848 [2:~exact~(inverse2~(eisretr~(e...] 0. secs (0.u,0.s)
Chars 5851 - 5910 [transitivity~(path_universe_un...] 0. secs (0.u,0.s)
Chars 5915 - 5954 [by~refine~(ap~_~(equiv_path_V~...] 0. secs (0.u,0.s)
Chars 5959 - 5999 [by~refine~(eissect~(equiv_path...] 0. secs (0.u,0.s)
Chars 6000 - 6008 [Defined.] 0.002 secs (0.002u,0.s)
Chars 6010 - 6177 [Definition~path_universe_V~`{F...] 0.003 secs (0.003u,0.s)
Chars 6277 - 6451 [Definition~ap_equiv_path_unive...] 0.003 secs (0.003u,0.s)
Chars 6452 - 6458 [Proof.] 0. secs (0.u,0.s)
Chars 10276 - 10308 [(rewrite~transport_paths_Fl~in...] 0.024 secs (0.023u,0.001s)
Chars 10315 - 10335 [(apply~moveL_Mp~in~p).] 0.013 secs (0.012u,0.001s)
Chars 10342 - 10392 [(refine~(ap~(transport~_~_)~(1...] 0.022 secs (0.019u,0.003s)
Chars 10399 - 10438 [(unfold~transport2;~rewrite~co...] 0.021 secs (0.017u,0.003s)
Chars 10445 - 10610 [(match~goal~with~~|~|-~transpo...] 0.015 secs (0.013u,0.001s)
Chars 10617 - 10905 [(pose~~~(p~:=~~~~(fst~~~~~~~(s...] 0.021 secs (0.017u,0.003s)
Chars 10912 - 10979 [(refine~(ap~(transport~_~_)~(a...] 0.02 secs (0.017u,0.003s)
Chars 10986 - 11030 [(rewrite~concat_Vp;~simpl;~rew...] 0.029 secs (0.029u,0.s)
Chars 11037 - 11077 [refine~(transport_paths_FlFr_D...] 0.006 secs (0.005u,0.s)
Chars 11084 - 11111 [Open~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 11118 - 11144 [#[local]Opaque~transport_pV.] 0. secs (0.u,0.s)
Chars 11178 - 11238 [(rewrite~!ap_pp,~!concat_p_pp,...] 0.168 secs (0.14u,0.026s)
Chars 11245 - 11276 [#[local]Transparent~transport_pV.] 0. secs (0.u,0.s)
Chars 11310 - 11366 [refine~((((((_~@@~1)~@~concat_...] 0.011 secs (0.011u,0.s)
Chars 11373 - 11374 [*] 0. secs (0.u,0.s)
Chars 11375 - 11401 [(rewrite~ap_V,~concat_pp_p).] 0.015 secs (0.015u,0.s)
Chars 11410 - 11430 [(do~2~apply~moveR_Vp).] 0.006 secs (0.006u,0.s)
Chars 11439 - 11457 [(rewrite~concat_p1).] 0.015 secs (0.01u,0.004s)
Chars 11466 - 11498 [(symmetry;~apply~transport_pV_...] 0.01 secs (0.01u,0.s)
Chars 11505 - 11506 [*] 0. secs (0.u,0.s)
Chars 11507 - 11528 [(rewrite~!concat_pp_p).] 0.019 secs (0.019u,0.s)
Chars 11537 - 11571 [refine~((1~@@~_)~@~concat_p1~_).] 0.005 secs (0.005u,0.s)
Chars 11580 - 11614 [(apply~moveR_Vp;~rewrite~conca...] 0.012 secs (0.012u,0.s)
Chars 11623 - 11645 [(apply~transport_pV_ap).] 0.005 secs (0.005u,0.s)
Chars 11652 - 11680 [Close~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 11683 - 11684 [-] 0. secs (0.u,0.s)
Chars 11685 - 11702 [(intros~h~k~h'~k').] 0.001 secs (0.001u,0.s)
Chars 11707 - 11817 [refine~~(extendable_over_postc...] 0.006 secs (0.006u,0.s)
Chars 11822 - 11964 [refine~~(IHn~_~_~_~_~_~~~~~(fu...] 0.007 secs (0.007u,0.s)
Chars 9113 - 9127 [(intros~ext'~n).] 0. secs (0.u,0.s)
Chars 9130 - 9154 [revert~C~ext~D~r~s~ext'.] 0. secs (0.u,0.s)
Chars 9157 - 9207 [(simple_induction~n~n~IHn;~int...] 0.001 secs (0.001u,0.s)
Chars 9210 - 9221 [1:~exact~tt.] 0. secs (0.u,0.s)
Chars 9224 - 9230 [split.] 0. secs (0.u,0.s)
Chars 9235 - 9247 [(intros~g~g').] 0.001 secs (0.001u,0.s)
Chars 9252 - 9279 [(simple~refine~(_;~_);~simpl).] 0.003 secs (0.003u,0.s)
Chars 9286 - 9295 [(intros~b).] 0. secs (0.u,0.s)
Chars 9302 - 9524 [refine~~(_~@~~~(fst~~~~~~(snd~...] 0. secs (0.u,0.s)
Chars 9533 - 9572 [refine~(transport2~(D~b)~(p:=1...] 0.001 secs (0.001u,0.s)
Chars 9581 - 9738 [(refine~~~((fst~~~~~~~(snd~(sn...] 0.002 secs (0.002u,0.s)
Chars 9747 - 9808 [(symmetry;~refine~((fst~(snd~(...] 0.002 secs (0.002u,0.s)
Chars 9817 - 9833 [(intros~a;~simpl).] 0.002 secs (0.002u,0.s)
Chars 9842 - 9996 [(refine~~~((_~@~ap~(transport~...] 0.004 secs (0.004u,0.s)
Chars 10003 - 10019 [(intros~a;~simpl).] 0.006 secs (0.006u,0.s)
Chars 10026 - 10058 [(set~(h~:=~(fst~(ext~n.+1)~g)....] 0.003 secs (0.003u,0.s)
Chars 10065 - 10269 [(match~goal~with~~|~|-~context...] 0.002 secs (0.002u,0.s)
Chars 10276 - 10308 [(rewrite~transport_paths_Fl~in...] 0.005 secs (0.005u,0.s)
Chars 10315 - 10335 [(apply~moveL_Mp~in~p).] 0.005 secs (0.005u,0.s)
Chars 10342 - 10392 [(refine~(ap~(transport~_~_)~(1...] 0.01 secs (0.01u,0.s)
Chars 10399 - 10438 [(unfold~transport2;~rewrite~co...] 0.006 secs (0.006u,0.s)
Chars 10445 - 10610 [(match~goal~with~~|~|-~transpo...] 0.003 secs (0.003u,0.s)
Chars 10617 - 10905 [(pose~~~(p~:=~~~~(fst~~~~~~~(s...] 0.006 secs (0.006u,0.s)
Chars 10912 - 10979 [(refine~(ap~(transport~_~_)~(a...] 0.007 secs (0.007u,0.s)
Chars 10986 - 11030 [(rewrite~concat_Vp;~simpl;~rew...] 0.007 secs (0.007u,0.s)
Chars 11037 - 11077 [refine~(transport_paths_FlFr_D...] 0.002 secs (0.002u,0.s)
Chars 11084 - 11111 [Open~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 11118 - 11144 [#[local]Opaque~transport_pV.] 0. secs (0.u,0.s)
Chars 11178 - 11238 [(rewrite~!ap_pp,~!concat_p_pp,...] 0.002 secs (0.002u,0.s)
Chars 11245 - 11276 [#[local]Transparent~transport_pV.] 0. secs (0.u,0.s)
Chars 11310 - 11366 [refine~((((((_~@@~1)~@~concat_...] 0.002 secs (0.002u,0.s)
Chars 11375 - 11401 [(rewrite~ap_V,~concat_pp_p).] 0.002 secs (0.002u,0.s)
Chars 11410 - 11430 [(do~2~apply~moveR_Vp).] 0.002 secs (0.002u,0.s)
Chars 11439 - 11457 [(rewrite~concat_p1).] 0.002 secs (0.002u,0.s)
Chars 11466 - 11498 [(symmetry;~apply~transport_pV_...] 0.03 secs (0.023u,0.006s)
Chars 11507 - 11528 [(rewrite~!concat_pp_p).] 0.002 secs (0.002u,0.s)
Chars 11537 - 11571 [refine~((1~@@~_)~@~concat_p1~_).] 0.002 secs (0.002u,0.s)
Chars 11580 - 11614 [(apply~moveR_Vp;~rewrite~conca...] 0.003 secs (0.003u,0.s)
Chars 11623 - 11645 [(apply~transport_pV_ap).] 0.001 secs (0.001u,0.s)
Chars 11652 - 11680 [Close~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 11685 - 11702 [(intros~h~k~h'~k').] 0.001 secs (0.001u,0.s)
Chars 11707 - 11817 [refine~~(extendable_over_postc...] 0.001 secs (0.001u,0.s)
Chars 11822 - 11964 [refine~~(IHn~_~_~_~_~_~~~~~(fu...] 0.001 secs (0.001u,0.s)
Chars 11965 - 11969 [Qed.] 0.319 secs (0.31u,0.005s)
Chars 11994 - 12018 [Import~IsLocal_Internal.] 0. secs (0.u,0.s)
Chars 12020 - 12231 [Definition~islocal_equiv_isloc...] 0. secs (0.u,0.s)
Chars 12232 - 12238 [Proof.] 0. secs (0.u,0.s)
Chars 748 - 760 [(red;~apply~_).] 40.157 secs (0.004u,0.031s)
Chars 748 - 760 [(red;~apply~_).] 0. secs (0.u,0.s)
Chars 761 - 765 [Qed.] 0. secs (0.u,0.s)
Chars 767 - 848 [Lemma~preserves_join~`{IsJoinP...] 0.002 secs (0.002u,0.s)
Chars 849 - 855 [Proof.] 0. secs (0.u,0.s)
Chars 37 - 60 [Require~Import~Pointed.] 8.026 secs (7.671u,0.332s)
Chars 61 - 116 [Require~Import~Spaces.Int~Spac...] 0.701 secs (0.69u,0.009s)
Chars 72 - 104 [Require~Import~Algebra.AbGroups.] 8.948 secs (8.669u,0.268s)
Chars 746 - 762 [(split;~intros~E).] 40.101 secs (0.001u,0.025s)
Chars 763 - 764 [-] 0. secs (0.u,0.s)
Chars 765 - 808 [(destruct~(decompose_le~E)~as~...] 0.012 secs (0.01u,0.001s)
Chars 809 - 818 [exists~z.] 0. secs (0.u,0.s)
Chars 819 - 827 [trivial.] 0. secs (0.u,0.s)
Chars 828 - 829 [-] 0. secs (0.u,0.s)
Chars 830 - 851 [(destruct~E~as~[z~Ez]).] 0.001 secs (0.001u,0.s)
Chars 854 - 907 [(apply~compose_le~with~z;~[~so...] 0.017 secs (0.012u,0.001s)
Chars 746 - 762 [(split;~intros~E).] 0.001 secs (0.001u,0.s)
Chars 765 - 808 [(destruct~(decompose_le~E)~as~...] 0. secs (0.u,0.s)
Chars 809 - 818 [exists~z.] 0. secs (0.u,0.s)
Chars 819 - 827 [trivial.] 0. secs (0.u,0.s)
Chars 830 - 851 [(destruct~E~as~[z~Ez]).] 0. secs (0.u,0.s)
Chars 854 - 907 [(apply~compose_le~with~z;~[~so...] 0.001 secs (0.u,0.s)
Chars 908 - 912 [Qed.] 0.002 secs (0.001u,0.s)
Chars 914 - 945 [Lemma~nat_not_neg~x~:~~~(x~<~0).] 0. secs (0.u,0.s)
Chars 946 - 952 [Proof.] 0. secs (0.u,0.s)
Chars 105 - 140 [Require~Import~Algebra.Rings.C...] 0.35 secs (0.342u,0.007s)
Chars 141 - 176 [Require~Import~Algebra.Rings.I...] 0.205 secs (0.196u,0.008s)
Chars 177 - 219 [Require~Import~Algebra.Rings.Q...] 0.132 secs (0.132u,0.s)
Chars 257 - 279 [Import~Ideal.Notation.] 0. secs (0.u,0.s)
Chars 280 - 308 [#[local]Open~Scope~ring_scope.] 0. secs (0.u,0.s)
Chars 309 - 339 [#[local]Open~Scope~wc_iso_scope.] 0. secs (0.u,0.s)
Chars 341 - 373 [Section~ChineseRemainderTheorem.] 0. secs (0.u,0.s)
Chars 487 - 715 [Context~`{Univalence}~{R~:~CRi...] 0. secs (0.u,0.s)
Chars 950 - 1001 [Definition~rng_homo_crt~:~R~$-...] 0.001 secs (0.001u,0.s)
Chars 1004 - 1010 [Proof.] 0. secs (0.u,0.s)
Chars 1732 - 1743 [(intros~x~y).] 40.153 secs (0.001u,0.027s)
Chars 1748 - 1794 [(srapply~Quotient_ind_hprop;~i...] 0.057 secs (0.049u,0.007s)
Chars 1799 - 1845 [(srapply~Quotient_ind_hprop;~i...] 0.074 secs (0.062u,0.012s)
Chars 1850 - 1886 [(srapply~Quotient_ind_hprop;~i...] 0.061 secs (0.055u,0.004s)
Chars 1891 - 1923 [(simpl;~by~rewrite~associativi...] 0.02 secs (0.019u,0.s)
Chars 1732 - 1743 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 1748 - 1794 [(srapply~Quotient_ind_hprop;~i...] 0.001 secs (0.001u,0.s)
Chars 1799 - 1845 [(srapply~Quotient_ind_hprop;~i...] 0.001 secs (0.001u,0.s)
Chars 1850 - 1886 [(srapply~Quotient_ind_hprop;~i...] 0.001 secs (0.001u,0.s)
Chars 1891 - 1923 [(simpl;~by~rewrite~associativi...] 0.001 secs (0.001u,0.s)
Chars 1926 - 1930 [Qed.] 0.003 secs (0.001u,0.001s)
Chars 1934 - 2010 [#[global]~Instance~issemigroup...] 0.001 secs (0.001u,0.s)
Chars 2014 - 2103 [#[global]~Instance~congquot_le...] 0. secs (0.u,0.s)
Chars 2106 - 2112 [Proof.] 0. secs (0.u,0.s)
Chars 7538 - 7597 [(refine~(@contr_trunc_conn~(Tr...] 40.135 secs (0.008u,0.024s)
Chars 7600 - 7636 [refine~(contr_inhabited_hprop~...] 0.001 secs (0.001u,0.s)
Chars 7538 - 7597 [(refine~(@contr_trunc_conn~(Tr...] 0. secs (0.u,0.s)
Chars 7600 - 7636 [refine~(contr_inhabited_hprop~...] 0. secs (0.u,0.s)
Chars 7637 - 7645 [Defined.] 0. secs (0.u,0.s)
Chars 7793 - 7840 [Notation~IsSurjection~:=~(IsCo...] 0. secs (0.u,0.s)
Chars 7842 - 7944 [Definition~BuildIsSurjection~{...] 0. secs (0.u,0.s)
Chars 7945 - 7951 [Proof.] 0. secs (0.u,0.s)
Chars 117 - 149 [Require~Import~Algebra.AbGroups.] 7.102 secs (6.836u,0.248s)
Chars 150 - 188 [Require~Import~Homotopy.Homoto...] 0.49 secs (0.464u,0.025s)
Chars 189 - 216 [Require~Import~Truncations.] 0.004 secs (0.004u,0.s)
Chars 264 - 294 [#[local]Open~Scope~wc_iso_scope.] 0. secs (0.u,0.s)
Chars 296 - 310 [Section~Pi1S1.] 0. secs (0.u,0.s)
Chars 313 - 335 [Context~`{Univalence}.] 0. secs (0.u,0.s)
Chars 339 - 387 [#[local]Notation~"(~A~,~a~)"~:...] 0. secs (0.u,0.s)
Chars 391 - 418 [#[local]Open~Scope~int_scope.] 0. secs (0.u,0.s)
Chars 421 - 452 [#[local]Open~Scope~pointed_scope.] 0. secs (0.u,0.s)
Chars 456 - 510 [Theorem~Pi1Circle~:~Pi~1~(Circ...] 0.003 secs (0.003u,0.s)
Chars 513 - 519 [Proof.] 0. secs (0.u,0.s)
Chars 2493 - 2540 [snrapply~(equiv_path_ind~(fun~...] 40.112 secs (0.004u,0.022s)
Chars 2543 - 2551 [exact~r.] 0.001 secs (0.u,0.s)
Chars 2493 - 2540 [snrapply~(equiv_path_ind~(fun~...] 0. secs (0.u,0.s)
Chars 2543 - 2551 [exact~r.] 0. secs (0.u,0.s)
Chars 2552 - 2560 [Defined.] 0.001 secs (0.u,0.s)
Chars 2622 - 2828 [Definition~equiv_path_ind_lruc...] 0.003 secs (0.003u,0.s)
Chars 2829 - 2835 [Proof.] 0. secs (0.u,0.s)
Chars 6035 - 6043 [intro~a.] 19.159 secs (7.936u,0.078s)
Chars 2133 - 2155 [unshelve~econstructor.] 40.153 secs (0.001u,0.022s)
Chars 2158 - 2159 [-] 0. secs (0.u,0.s)
Chars 2160 - 2173 [econstructor.] 0. secs (0.u,0.s)
Chars 2178 - 2198 [exact~(unit_name~U).] 0. secs (0.u,0.s)
Chars 2201 - 2202 [-] 0. secs (0.u,0.s)
Chars 2203 - 2219 [(intros~X;~split).] 0.001 secs (0.001u,0.s)
Chars 2224 - 2225 [+] 0. secs (0.u,0.s)
Chars 2226 - 2241 [(intros~X_inO~u).] 0. secs (0.u,0.s)
Chars 2248 - 2303 [(apply~(equiv_inverse~(equiv_o...] 0.002 secs (0.001u,0.s)
Chars 2310 - 2357 [refine~(cancelR_isequiv~(fun~x...] 0.139 secs (0.114u,0.024s)
Chars 2364 - 2376 [(apply~X_inO).] 0.001 secs (0.001u,0.s)
Chars 2381 - 2382 [+] 0. secs (0.u,0.s)
Chars 2383 - 2415 [(intros~ext;~specialize~(ext~t...] 0.001 secs (0.u,0.s)
Chars 2422 - 2548 [refine~~(isequiv_compose~(f:=f...] 0.114 secs (0.096u,0.016s)
Chars 2555 - 2621 [refine~(isequiv_ooextendable~(...] 0.002 secs (0.002u,0.s)
Chars 2133 - 2155 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 2160 - 2173 [econstructor.] 0. secs (0.u,0.s)
Chars 2178 - 2198 [exact~(unit_name~U).] 0. secs (0.u,0.s)
Chars 2203 - 2219 [(intros~X;~split).] 0. secs (0.u,0.s)
Chars 2226 - 2241 [(intros~X_inO~u).] 0. secs (0.u,0.s)
Chars 2248 - 2303 [(apply~(equiv_inverse~(equiv_o...] 0. secs (0.u,0.s)
Chars 2310 - 2357 [refine~(cancelR_isequiv~(fun~x...] 0. secs (0.u,0.s)
Chars 2364 - 2376 [(apply~X_inO).] 0. secs (0.u,0.s)
Chars 2383 - 2415 [(intros~ext;~specialize~(ext~t...] 0. secs (0.u,0.s)
Chars 2422 - 2548 [refine~~(isequiv_compose~(f:=f...] 0. secs (0.u,0.s)
Chars 2555 - 2621 [refine~(isequiv_ooextendable~(...] 0. secs (0.u,0.s)
Chars 2622 - 2630 [Defined.] 0.004 secs (0.003u,0.s)
Chars 2910 - 2998 [Definition~Op'~(U~:~HProp)~:~M...] 0. secs (0.u,0.s)
Chars 1245 - 1256 [(intros~?~?~?).] 40.18 secs (0.u,0.034s)
Chars 1261 - 1376 [(apply~path_iff_hprop;~hor_int...] 0.534 secs (0.485u,0.048s)
Chars 1245 - 1256 [(intros~?~?~?).] 0. secs (0.u,0.s)
Chars 1261 - 1376 [(apply~path_iff_hprop;~hor_int...] 0.003 secs (0.003u,0.s)
Chars 1379 - 1387 [Defined.] 0.003 secs (0.003u,0.s)
Chars 1391 - 1436 [Instance~associative_hand~:~(A...] 0. secs (0.u,0.s)
Chars 1439 - 1445 [Proof.] 0. secs (0.u,0.s)
Chars 4912 - 4918 [split.] 40.169 secs (0.019u,0.037s)
Chars 4923 - 4924 [-] 0. secs (0.u,0.s)
Chars 4925 - 4933 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 4980 - 4981 [-] 0. secs (0.u,0.s)
Chars 4982 - 5016 [(rapply~functor_forall;~intros...] 0.002 secs (0.002u,0.s)
Chars 5023 - 5119 [exact~(inO_equiv_inO~(hfiber~p...] 0.004 secs (0.004u,0.s)
Chars 4912 - 4918 [split.] 0. secs (0.u,0.s)
Chars 4925 - 4933 [exact~_.] 0. secs (0.u,0.s)
Chars 4982 - 5016 [(rapply~functor_forall;~intros...] 0. secs (0.u,0.s)
Chars 5023 - 5119 [exact~(inO_equiv_inO~(hfiber~p...] 0. secs (0.u,0.s)
Chars 5122 - 5130 [Defined.] 0. secs (0.u,0.s)
Chars 5134 - 5257 [Lemma~equiv_forall_inO_mapinO_...] 0. secs (0.u,0.s)
Chars 5260 - 5266 [Proof.] 0. secs (0.u,0.s)
Chars 8287 - 8298 [(destruct~c).] 40.191 secs (0.03u,0.032s)
Chars 8303 - 8324 [(apply~cu_fill_bottom).] 0.006 secs (0.005u,0.s)
Chars 8287 - 8298 [(destruct~c).] 0.002 secs (0.002u,0.s)
Chars 8303 - 8324 [(apply~cu_fill_bottom).] 0.002 secs (0.002u,0.s)
Chars 8327 - 8335 [Defined.] 0.007 secs (0.006u,0.001s)
Chars 8339 - 8764 [Definition~dc_fill_front~(t0ii...] 0.016 secs (0.013u,0.002s)
Chars 8767 - 8773 [Proof.] 0. secs (0.u,0.s)
Chars 1450 - 1461 [(intros~?~?~?).] 7.914 secs (0.u,0.034s)
Chars 1466 - 1483 [(apply~path_hprop).] 0.001 secs (0.001u,0.s)
Chars 1488 - 1511 [(apply~equiv_prod_assoc).] 0. secs (0.u,0.s)
Chars 1450 - 1461 [(intros~?~?~?).] 0. secs (0.u,0.s)
Chars 1466 - 1483 [(apply~path_hprop).] 0. secs (0.u,0.s)
Chars 1488 - 1511 [(apply~equiv_prod_assoc).] 0. secs (0.u,0.s)
Chars 1514 - 1522 [Defined.] 0. secs (0.u,0.s)
Chars 1526 - 1573 [Instance~idempotent_hor~:~(Bin...] 0. secs (0.u,0.s)
Chars 1576 - 1582 [Proof.] 0. secs (0.u,0.s)
Chars 6035 - 6043 [intro~a.] 40.07 secs (0.u,0.036s)
Chars 6046 - 6071 [(induction~n~as~[|~n~IHn]).] 0.001 secs (0.001u,0.s)
Chars 6074 - 6075 [-] 0. secs (0.u,0.s)
Chars 6076 - 6085 [funext~d.] 0.001 secs (0.001u,0.s)
Chars 6086 - 6102 [refine~(ap~a~_).] 0.001 secs (0.001u,0.s)
Chars 6103 - 6120 [(apply~path_contr).] 0.003 secs (0.003u,0.s)
Chars 6123 - 6124 [-] 0. secs (0.u,0.s)
Chars 6125 - 6135 [funext~a'.] 0.001 secs (0.001u,0.s)
Chars 6140 - 6181 [refine~(ap~(fun~x~=>~x~_)~(IHn...] 0.004 secs (0.003u,0.s)
Chars 6186 - 6202 [refine~(ap~a~_).] 0.001 secs (0.001u,0.s)
Chars 6207 - 6229 [(apply~expand_cons_dom).] 0.003 secs (0.002u,0.s)
Chars 6035 - 6043 [intro~a.] 0. secs (0.u,0.s)
Chars 6046 - 6071 [(induction~n~as~[|~n~IHn]).] 0. secs (0.u,0.s)
Chars 6076 - 6085 [funext~d.] 0. secs (0.u,0.s)
Chars 6086 - 6102 [refine~(ap~a~_).] 0. secs (0.u,0.s)
Chars 6103 - 6120 [(apply~path_contr).] 0. secs (0.u,0.s)
Chars 6125 - 6135 [funext~a'.] 0. secs (0.u,0.s)
Chars 6140 - 6181 [refine~(ap~(fun~x~=>~x~_)~(IHn...] 0.001 secs (0.u,0.s)
Chars 6186 - 6202 [refine~(ap~a~_).] 0.001 secs (0.001u,0.s)
Chars 6207 - 6229 [(apply~expand_cons_dom).] 0.001 secs (0.001u,0.s)
Chars 6230 - 6234 [Qed.] 0.01 secs (0.009u,0.s)
Chars 6236 - 6422 [Lemma~path_operation_uncurry_t...] 0.003 secs (0.003u,0.s)
Chars 6423 - 6429 [Proof.] 0. secs (0.u,0.s)
Chars 1224 - 1263 [snrapply~(Build_Subgroup~_~(hf...] 40.153 secs (0.002u,0.027s)
Chars 1266 - 1279 [(repeat~split).] 0.002 secs (0.002u,0.s)
Chars 1282 - 1283 [-] 0. secs (0.u,0.s)
Chars 1284 - 1292 [exact~_.] 0.017 secs (0.016u,0.s)
Chars 1295 - 1296 [-] 0. secs (0.u,0.s)
Chars 1297 - 1331 [exact~(mon_unit;~grp_homo_unit...] 0.001 secs (0.001u,0.s)
Chars 1334 - 1335 [-] 0. secs (0.u,0.s)
Chars 1336 - 1361 [(intros~x~y~[a~[]]~[b~[]]).] 0.003 secs (0.003u,0.s)
Chars 1366 - 1381 [exists~(a~+~b).] 0.001 secs (0.001u,0.s)
Chars 1386 - 1404 [(apply~grp_homo_op).] 0.001 secs (0.001u,0.s)
Chars 1407 - 1408 [-] 0. secs (0.u,0.s)
Chars 1409 - 1425 [(intros~b~[a~[]]).] 0.002 secs (0.002u,0.s)
Chars 1430 - 1442 [exists~(-~a).] 0.001 secs (0.001u,0.s)
Chars 1447 - 1466 [(apply~grp_homo_inv).] 0.001 secs (0.001u,0.s)
Chars 1224 - 1263 [snrapply~(Build_Subgroup~_~(hf...] 0. secs (0.u,0.s)
Chars 1266 - 1279 [(repeat~split).] 0. secs (0.u,0.s)
Chars 1284 - 1292 [exact~_.] 0. secs (0.u,0.s)
Chars 1297 - 1331 [exact~(mon_unit;~grp_homo_unit...] 0. secs (0.u,0.s)
Chars 1336 - 1361 [(intros~x~y~[a~[]]~[b~[]]).] 0. secs (0.u,0.s)
Chars 1366 - 1381 [exists~(a~+~b).] 0. secs (0.u,0.s)
Chars 1386 - 1404 [(apply~grp_homo_op).] 0. secs (0.u,0.s)
Chars 1409 - 1425 [(intros~b~[a~[]]).] 0. secs (0.u,0.s)
Chars 1430 - 1442 [exists~(-~a).] 0. secs (0.u,0.s)
Chars 1447 - 1466 [(apply~grp_homo_inv).] 0. secs (0.u,0.s)
Chars 1467 - 1475 [Defined.] 0.002 secs (0.002u,0.s)
Chars 1477 - 1603 [Definition~grp_image_in_embedd...] 0.001 secs (0.001u,0.s)
Chars 1604 - 1610 [Proof.] 0. secs (0.u,0.s)
Chars 3350 - 3364 [(destruct~f,~g).] 40.17 secs (0.003u,0.03s)
Chars 3365 - 3376 [(simpl~in~*).] 0.001 secs (0.001u,0.s)
Chars 3377 - 3395 [by~path_induction.] 0.064 secs (0.037u,0.027s)
Chars 3350 - 3364 [(destruct~f,~g).] 0. secs (0.u,0.s)
Chars 3365 - 3376 [(simpl~in~*).] 0. secs (0.u,0.s)
Chars 3377 - 3395 [by~path_induction.] 0. secs (0.u,0.s)
Chars 3396 - 3404 [Defined.] 0.003 secs (0.003u,0.s)
Chars 3580 - 3730 [Lemma~path_hset_homomorphism~`...] 0.001 secs (0.001u,0.s)
Chars 3731 - 3737 [Proof.] 0. secs (0.u,0.s)
Chars 2331 - 2340 [(intros~u).] 40.162 secs (0.001u,0.034s)
Chars 2345 - 2393 [refine~(quotient_ind_prop_fami...] 0.126 secs (0.102u,0.022s)
Chars 2394 - 2402 [intro~a.] 0.001 secs (0.001u,0.s)
Chars 2407 - 2455 [refine~(quotient_ind_prop_fami...] 0.136 secs (0.117u,0.018s)
Chars 2456 - 2464 [intro~b.] 0.002 secs (0.002u,0.s)
Chars 2537 - 2686 [(destruct~~~(compute_op_quotie...] 0.026 secs (0.024u,0.001s)
Chars 2691 - 2840 [(destruct~~~(compute_op_quotie...] 0.026 secs (0.023u,0.001s)
Chars 2845 - 2862 [(intros~R~x~y~P~Q).] 0.002 secs (0.002u,0.s)
Chars 2867 - 2885 [(apply~subrel~in~P).] 0.002 secs (0.002u,0.s)
Chars 2890 - 2908 [(apply~subrel~in~Q).] 0.002 secs (0.002u,0.s)
Chars 2913 - 2948 [transitivity~(ap_operation~u.#...] 0.007 secs (0.006u,0.001s)
Chars 2953 - 2954 [-] 0. secs (0.u,0.s)
Chars 2955 - 2967 [by~symmetry.] 0.007 secs (0.006u,0.s)
Chars 2972 - 2973 [-] 0. secs (0.u,0.s)
Chars 2974 - 3025 [(transitivity~(ap_operation~u....] 0.01 secs (0.01u,0.s)
Chars 3032 - 3062 [(apply~(ops_compatible~A~Φ~u)).] 0.005 secs (0.005u,0.s)
Chars 3069 - 3104 [by~apply~for_all_relation_quot...] 0.004 secs (0.004u,0.s)
Chars 2331 - 2340 [(intros~u).] 0. secs (0.u,0.s)
Chars 2345 - 2393 [refine~(quotient_ind_prop_fami...] 0. secs (0.u,0.s)
Chars 2394 - 2402 [intro~a.] 0.001 secs (0.001u,0.s)
Chars 2407 - 2455 [refine~(quotient_ind_prop_fami...] 0.001 secs (0.001u,0.s)
Chars 2456 - 2464 [intro~b.] 0.001 secs (0.u,0.s)
Chars 2537 - 2686 [(destruct~~~(compute_op_quotie...] 0.001 secs (0.001u,0.s)
Chars 2691 - 2840 [(destruct~~~(compute_op_quotie...] 0.001 secs (0.001u,0.s)
Chars 6461 - 6470 [revert~f.] 40.106 secs (0.u,0.016s)
Chars 6471 - 6502 [(equiv_intro~(equiv_path~B~C)~f).] 0.003 secs (0.002u,0.001s)
Chars 6505 - 6581 [(rewrite~(eissect~(equiv_path~...] 0.005 secs (0.004u,0.s)
Chars 2845 - 2862 [(intros~R~x~y~P~Q).] 0.001 secs (0.001u,0.s)
Chars 6584 - 6602 [(destruct~f;~simpl).] 0.002 secs (0.002u,0.s)
Chars 2867 - 2885 [(apply~subrel~in~P).] 0.002 secs (0.001u,0.001s)
Chars 2890 - 2908 [(apply~subrel~in~Q).] 0.001 secs (0.001u,0.s)
Chars 6605 - 6645 [(apply~path_equiv,~path_forall...] 0.002 secs (0.002u,0.s)
Chars 2913 - 2948 [transitivity~(ap_operation~u.#...] 0.001 secs (0.001u,0.s)
Chars 6648 - 6688 [(apply~path_equiv,~path_forall...] 0.002 secs (0.002u,0.s)
Chars 6691 - 6703 [reflexivity.] 0.001 secs (0.u,0.s)
Chars 6461 - 6470 [revert~f.] 0. secs (0.u,0.s)
Chars 6471 - 6502 [(equiv_intro~(equiv_path~B~C)~f).] 0. secs (0.u,0.s)
Chars 6505 - 6581 [(rewrite~(eissect~(equiv_path~...] 0. secs (0.u,0.s)
Chars 6584 - 6602 [(destruct~f;~simpl).] 0. secs (0.u,0.s)
Chars 6605 - 6645 [(apply~path_equiv,~path_forall...] 0. secs (0.u,0.s)
Chars 6648 - 6688 [(apply~path_equiv,~path_forall...] 0. secs (0.u,0.s)
Chars 6691 - 6703 [reflexivity.] 0. secs (0.u,0.s)
Chars 2955 - 2967 [by~symmetry.] 0.012 secs (0.009u,0.002s)
Chars 6704 - 6712 [Defined.] 0.003 secs (0.002u,0.s)
Chars 2974 - 3025 [(transitivity~(ap_operation~u....] 0.002 secs (0.002u,0.s)
Chars 3032 - 3062 [(apply~(ops_compatible~A~Φ~u)).] 0.001 secs (0.001u,0.s)
Chars 6772 - 6931 [Definition~ap_prod_l_path_univ...] 0.003 secs (0.001u,0.002s)
Chars 6932 - 6938 [Proof.] 0. secs (0.u,0.s)
Chars 3069 - 3104 [by~apply~for_all_relation_quot...] 0.001 secs (0.u,0.s)
Chars 3107 - 3115 [Defined.] 0.034 secs (0.03u,0.004s)
Chars 3119 - 3262 [#[global]~Instance~is_congruen...] 0.078 secs (0.076u,0.002s)
Chars 3264 - 3282 [End~cong_quotient.] 0.087 secs (0.087u,0.s)
Chars 3284 - 3310 [Section~third_isomorphism.] 0. secs (0.u,0.s)
Chars 3313 - 3555 [Context~`{Univalence}~{σ~:~Sig...] 0.002 secs (0.002u,0.s)
Chars 3559 - 3679 [Lemma~third_surjecton_well_def...] 0.02 secs (0.019u,0.s)
Chars 3682 - 3688 [Proof.] 0. secs (0.u,0.s)
Chars 6941 - 6950 [revert~f.] 0.285 secs (0.001u,0.015s)
Chars 6951 - 6982 [(equiv_intro~(equiv_path~B~C)~f).] 0.003 secs (0.003u,0.s)
Chars 6985 - 7061 [(rewrite~(eissect~(equiv_path~...] 0.005 secs (0.003u,0.001s)
Chars 7064 - 7075 [(destruct~f).] 0.001 secs (0.001u,0.s)
Chars 7078 - 7130 [(apply~path_equiv,~path_arrow;...] 0.003 secs (0.003u,0.s)
Chars 6941 - 6950 [revert~f.] 0. secs (0.u,0.s)
Chars 6951 - 6982 [(equiv_intro~(equiv_path~B~C)~f).] 0. secs (0.u,0.s)
Chars 6985 - 7061 [(rewrite~(eissect~(equiv_path~...] 0. secs (0.u,0.s)
Chars 7064 - 7075 [(destruct~f).] 0. secs (0.u,0.s)
Chars 7078 - 7130 [(apply~path_equiv,~path_arrow;...] 0.001 secs (0.u,0.001s)
Chars 7131 - 7139 [Defined.] 0.002 secs (0.001u,0.001s)
Chars 7207 - 7374 [Definition~ap_prod_r_path_univ...] 0.003 secs (0.002u,0.s)
Chars 7375 - 7381 [Proof.] 0. secs (0.u,0.s)
Chars 7384 - 7393 [revert~f.] 0.113 secs (0.001u,0.015s)
Chars 7394 - 7425 [(equiv_intro~(equiv_path~B~C)~f).] 0.003 secs (0.002u,0.s)
Chars 7428 - 7504 [(rewrite~(eissect~(equiv_path~...] 0.006 secs (0.004u,0.001s)
Chars 7507 - 7518 [(destruct~f).] 0.001 secs (0.001u,0.s)
Chars 7521 - 7573 [(apply~path_equiv,~path_arrow;...] 0.003 secs (0.003u,0.s)
Chars 7384 - 7393 [revert~f.] 0. secs (0.u,0.s)
Chars 7394 - 7425 [(equiv_intro~(equiv_path~B~C)~f).] 0. secs (0.u,0.s)
Chars 7428 - 7504 [(rewrite~(eissect~(equiv_path~...] 0. secs (0.u,0.s)
Chars 7507 - 7518 [(destruct~f).] 0. secs (0.u,0.s)
Chars 7521 - 7573 [(apply~path_equiv,~path_arrow;...] 0.001 secs (0.001u,0.s)
Chars 7574 - 7582 [Defined.] 0.002 secs (0.002u,0.s)
Chars 7928 - 8087 [Definition~transport_path_univ...] 0.001 secs (0.001u,0.s)
Chars 8088 - 8094 [Proof.] 0. secs (0.u,0.s)
Chars 7954 - 8001 [(intros~H~b;~refine~(contr_inh...] 29.222 secs (19.638u,0.16s)
Chars 12241 - 12250 [(intros~i).] 40.152 secs (0.u,0.033s)
Chars 12504 - 12558 [(apply~lift_ooextendablealong@...] 0.001 secs (0.u,0.s)
Chars 12561 - 12654 [refine~~(ooextendable_postcomp...] 0.011 secs (0.008u,0.002s)
Chars 12657 - 12711 [(apply~lift_ooextendablealong@...] 0.001 secs (0.001u,0.s)
Chars 12714 - 12725 [(apply~Xloc).] 0. secs (0.u,0.s)
Chars 12241 - 12250 [(intros~i).] 0. secs (0.u,0.s)
Chars 12504 - 12558 [(apply~lift_ooextendablealong@...] 0. secs (0.u,0.s)
Chars 12561 - 12654 [refine~~(ooextendable_postcomp...] 0. secs (0.u,0.s)
Chars 12657 - 12711 [(apply~lift_ooextendablealong@...] 0. secs (0.u,0.s)
Chars 12714 - 12725 [(apply~Xloc).] 0. secs (0.u,0.s)
Chars 12726 - 12734 [Defined.] 0.001 secs (0.001u,0.s)
Chars 12769 - 12799 [Module~Export~LocalizationHIT.] 0. secs (0.u,0.s)
Chars 12803 - 12933 [#[universes(cumulative),~priva...] 0. secs (0.u,0.s)
Chars 12937 - 12959 [Arguments~loc~{f~X}~x.] 0. secs (0.u,0.s)
Chars 13275 - 13390 [Axiom~~~(islocal_localize~:~~~...] 0. secs (0.u,0.s)
Chars 13394 - 13922 [Definition~Localize_ind~(f~:~L...] 0.003 secs (0.001u,0.001s)
Chars 14156 - 14794 [Axiom~~~(Localize_ind_islocal_...] 0.004 secs (0.003u,0.001s)
Chars 14796 - 14816 [End~LocalizationHIT.] 0. secs (0.u,0.s)
Chars 14886 - 14907 [Section~Localization.] 0. secs (0.u,0.s)
Chars 14911 - 14941 [Context~(f~:~LocalGenerators).] 0. secs (0.u,0.s)
Chars 14997 - 15265 [Definition~ext_localize_ind~(X...] 0.002 secs (0.002u,0.s)
Chars 15268 - 15274 [Proof.] 0. secs (0.u,0.s)
Chars 856 - 878 [(apply~preserves_sg_op).] 40.149 secs (0.001u,0.031s)
Chars 856 - 878 [(apply~preserves_sg_op).] 0. secs (0.u,0.s)
Chars 879 - 883 [Qed.] 0. secs (0.u,0.s)
Chars 885 - 957 [Lemma~preserves_bottom~`{IsBou...] 0.001 secs (0.001u,0.s)
Chars 958 - 964 [Proof.] 0. secs (0.u,0.s)
Chars 965 - 990 [(apply~preserves_mon_unit).] 0.095 secs (0.002u,0.03s)
Chars 965 - 990 [(apply~preserves_mon_unit).] 0. secs (0.u,0.s)
Chars 991 - 995 [Qed.] 0. secs (0.u,0.s)
Chars 997 - 1078 [Lemma~preserves_meet~`{IsMeetP...] 0.001 secs (0.u,0.001s)
Chars 1079 - 1085 [Proof.] 0. secs (0.u,0.s)
Chars 3740 - 3772 [(apply~(path_homomorphism~f~g~...] 3.349 secs (-6.705u,-0.441s)
Chars 1086 - 1108 [(apply~preserves_sg_op).] 0.156 secs (0.002u,0.03s)
Chars 1086 - 1108 [(apply~preserves_sg_op).] 0. secs (0.u,0.s)
Chars 1109 - 1113 [Qed.] 0. secs (0.u,0.s)
Chars 1115 - 1145 [Section~bounded_join_sl_props.] 0. secs (0.u,0.s)
Chars 1148 - 1186 [Context~`{IsBoundedJoinSemiLat...] 0. secs (0.u,0.s)
Chars 1190 - 1242 [Instance~join_bottom_l~:~(Left...] 0.003 secs (0.002u,0.s)
Chars 1245 - 1298 [Instance~join_bottom_r~:~(Righ...] 0.003 secs (0.003u,0.s)
Chars 1299 - 1325 [End~bounded_join_sl_props.] 0. secs (0.u,0.s)
Chars 1327 - 1349 [Section~lattice_props.] 0. secs (0.u,0.s)
Chars 1352 - 1375 [Context~`{IsLattice~L}.] 0. secs (0.u,0.s)
Chars 1379 - 1455 [Definition~meet_join_absorptio...] 0.002 secs (0.002u,0.s)
Chars 1458 - 1534 [Definition~join_meet_absorptio...] 0.003 secs (0.003u,0.s)
Chars 1535 - 1553 [End~lattice_props.] 0. secs (0.u,0.s)
Chars 1555 - 1590 [Section~distributive_lattice_p...] 0. secs (0.u,0.s)
Chars 1593 - 1628 [Context~`{IsDistributiveLattic...] 0. secs (0.u,0.s)
Chars 1632 - 1687 [Instance~join_meet_distr_l~:~(...] 0. secs (0.u,0.s)
Chars 1690 - 1696 [Proof.] 0. secs (0.u,0.s)
Chars 1697 - 1725 [exact~(join_meet_distr_l~_).] 0.078 secs (0.001u,0.03s)
Chars 1697 - 1725 [exact~(join_meet_distr_l~_).] 0. secs (0.u,0.s)
Chars 1726 - 1730 [Qed.] 0. secs (0.u,0.s)
Chars 1734 - 1797 [#[global]Instance~join_meet_di...] 0. secs (0.u,0.s)
Chars 1800 - 1806 [Proof.] 0. secs (0.u,0.s)
Chars 8097 - 8106 [revert~f.] 5.312 secs (3.595u,0.118s)
Chars 953 - 986 [(apply~le_not_lt_flip,~nat_non...] 40.147 secs (0.004u,0.021s)
Chars 953 - 986 [(apply~le_not_lt_flip,~nat_non...] 0. secs (0.u,0.s)
Chars 987 - 991 [Qed.] 0. secs (0.u,0.s)
Chars 993 - 1032 [Lemma~nat_0_or_pos~x~:~x~=~0~|...] 0.001 secs (0.001u,0.s)
Chars 1033 - 1039 [Proof.] 0. secs (0.u,0.s)
Chars 1015 - 1041 [(apply~cring_product_corec).] 40.198 secs (0.002u,0.043s)
Chars 1046 - 1074 [1,~2:~(apply~rng_quotient_map).] 0.001 secs (0.001u,0.s)
Chars 1015 - 1041 [(apply~cring_product_corec).] 0. secs (0.u,0.s)
Chars 1046 - 1074 [1,~2:~(apply~rng_quotient_map).] 0. secs (0.u,0.s)
Chars 1077 - 1085 [Defined.] 0. secs (0.u,0.s)
Chars 1214 - 1257 [Notation~"[~x~]"~:=~(rng_quoti...] 0. secs (0.u,0.s)
Chars 1408 - 1549 [Lemma~issurjection_rng_homo_cr...] 0.007 secs (0.005u,0.001s)
Chars 1552 - 1558 [Proof.] 0. secs (0.u,0.s)
Chars 2117 - 2153 [(srapply~Quotient_ind_hprop;~i...] 40.194 secs (0.041u,0.041s)
Chars 2158 - 2190 [by~simpl;~rewrite~left_identity.] 0.011 secs (0.01u,0.s)
Chars 2117 - 2153 [(srapply~Quotient_ind_hprop;~i...] 0. secs (0.u,0.s)
Chars 2158 - 2190 [by~simpl;~rewrite~left_identity.] 0. secs (0.u,0.s)
Chars 2193 - 2197 [Qed.] 0.001 secs (0.001u,0.s)
Chars 2201 - 2292 [#[global]~Instance~congquot_ri...] 0. secs (0.u,0.s)
Chars 2295 - 2301 [Proof.] 0. secs (0.u,0.s)
Chars 7954 - 8001 [(intros~H~b;~refine~(contr_inh...] 40.054 secs (0.002u,0.024s)
Chars 8004 - 8012 [(apply~H).] 0. secs (0.u,0.s)
Chars 7954 - 8001 [(intros~H~b;~refine~(contr_inh...] 0. secs (0.u,0.s)
Chars 8004 - 8012 [(apply~H).] 0. secs (0.u,0.s)
Chars 8013 - 8021 [Defined.] 0. secs (0.u,0.s)
Chars 8136 - 8266 [Lemma~iff_merely_issurjection~...] 0.001 secs (0.001u,0.s)
Chars 8267 - 8273 [Proof.] 0. secs (0.u,0.s)
Chars 639 - 648 [symmetry.] 40.212 secs (0.001u,0.049s)
Chars 653 - 685 [srapply~Build_GroupIsomorphism'.] 0.044 secs (0.035u,0.008s)
Chars 690 - 691 [{] 0. secs (0.u,0.s)
Chars 692 - 716 [(equiv_via~(base~=~base)).] 0.001 secs (0.u,0.s)
Chars 723 - 768 [2:~exact~(equiv_tr~0~(loops~(C...] 0.028 secs (0.023u,0.004s)
Chars 775 - 784 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 791 - 818 [exact~equiv_loopCircle_int.] 0.001 secs (0.001u,0.s)
Chars 819 - 820 [}] 0. secs (0.u,0.s)
Chars 825 - 836 [(intros~a~b).] 0.001 secs (0.u,0.s)
Chars 841 - 855 [(cbn;~apply~ap).] 0.008 secs (0.008u,0.s)
Chars 860 - 878 [(apply~loopexp_add).] 0.007 secs (0.007u,0.s)
Chars 639 - 648 [symmetry.] 0. secs (0.u,0.s)
Chars 653 - 685 [srapply~Build_GroupIsomorphism'.] 0. secs (0.u,0.s)
Chars 692 - 716 [(equiv_via~(base~=~base)).] 0. secs (0.u,0.s)
Chars 723 - 768 [2:~exact~(equiv_tr~0~(loops~(C...] 0. secs (0.u,0.s)
Chars 775 - 784 [symmetry.] 0. secs (0.u,0.s)
Chars 791 - 818 [exact~equiv_loopCircle_int.] 0. secs (0.u,0.s)
Chars 825 - 836 [(intros~a~b).] 0. secs (0.u,0.s)
Chars 841 - 855 [(cbn;~apply~ap).] 0.001 secs (0.001u,0.s)
Chars 860 - 878 [(apply~loopexp_add).] 0. secs (0.u,0.s)
Chars 881 - 889 [Defined.] 0.011 secs (0.01u,0.s)
Chars 893 - 940 [Theorem~Pi1S1~:~Pi~1~(psphere~...] 0.003 secs (0.003u,0.s)
Chars 943 - 949 [Proof.] 0. secs (0.u,0.s)
Chars 2838 - 2885 [snrapply~(equiv_path_ind~(fun~...] 40.113 secs (0.006u,0.02s)
Chars 2888 - 2896 [exact~r.] 0.001 secs (0.001u,0.s)
Chars 2838 - 2885 [snrapply~(equiv_path_ind~(fun~...] 0. secs (0.u,0.s)
Chars 2888 - 2896 [exact~r.] 0. secs (0.u,0.s)
Chars 2897 - 2905 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2976 - 3158 [Definition~rlucancel_sVs_1_pp~...] 0.013 secs (0.013u,0.s)
Chars 3159 - 3165 [Proof.] 0. secs (0.u,0.s)
Chars 5271 - 5335 [exact~(equiv_iff_hprop_uncurri...] 40.158 secs (0.01u,0.028s)
Chars 5271 - 5335 [exact~(equiv_iff_hprop_uncurri...] 0. secs (0.u,0.s)
Chars 5338 - 5346 [Defined.] 0. secs (0.u,0.s)
Chars 5348 - 5364 [End~Subuniverse.] 0.006 secs (0.005u,0.s)
Chars 5453 - 5601 [Class~PreReflects@{i}~(O~:~Sub...] 0.002 secs (0.u,0.001s)
Chars 5603 - 5633 [Arguments~O_reflector~O~T~{_}.] 0. secs (0.u,0.s)
Chars 5634 - 5655 [Arguments~to~O~T~{_}.] 0. secs (0.u,0.s)
Chars 5656 - 5682 [Arguments~O_inO~{O}~T~{_}.] 0. secs (0.u,0.s)
Chars 5683 - 5714 [#[global]Existing~Instance~O_inO.] 0. secs (0.u,0.s)
Chars 5786 - 5984 [Class~Reflects@{i}~(O~:~Subuni...] 0.003 secs (0.003u,0.s)
Chars 5986 - 6030 [Arguments~extendable_to_O~O~{T...] 0. secs (0.u,0.s)
Chars 6160 - 6346 [Definition~extendable_to_O'@{i...] 0.001 secs (0.001u,0.s)
Chars 6347 - 6353 [Proof.] 0. secs (0.u,0.s)
Chars 8778 - 8789 [(destruct~c).] 40.199 secs (0.042u,0.042s)
Chars 8794 - 8814 [(apply~cu_fill_front).] 0.006 secs (0.005u,0.s)
Chars 8778 - 8789 [(destruct~c).] 0.002 secs (0.002u,0.s)
Chars 8794 - 8814 [(apply~cu_fill_front).] 0.002 secs (0.002u,0.s)
Chars 8817 - 8825 [Defined.] 0.006 secs (0.004u,0.002s)
Chars 8829 - 9205 [Definition~dc_fill_back~(t0ii~...] 0.017 secs (0.017u,0.s)
Chars 9208 - 9214 [Proof.] 0. secs (0.u,0.s)
Chars 1587 - 1596 [(intros~?).] 40.179 secs (0.001u,0.034s)
Chars 1597 - 1605 [(compute).] 0. secs (0.u,0.s)
Chars 1610 - 1649 [(apply~path_iff_hprop;~hor_int...] 0.121 secs (0.097u,0.023s)
Chars 1654 - 1671 [by~apply~tr,~inl.] 0.001 secs (0.u,0.s)
Chars 1587 - 1596 [(intros~?).] 0. secs (0.u,0.s)
Chars 1597 - 1605 [(compute).] 0. secs (0.u,0.s)
Chars 1610 - 1649 [(apply~path_iff_hprop;~hor_int...] 0.001 secs (0.001u,0.s)
Chars 1654 - 1671 [by~apply~tr,~inl.] 0. secs (0.u,0.s)
Chars 1674 - 1682 [Defined.] 0. secs (0.u,0.s)
Chars 1686 - 1735 [Instance~idempotent_hand~:~(Bi...] 0. secs (0.u,0.s)
Chars 1738 - 1744 [Proof.] 0. secs (0.u,0.s)
Chars 6432 - 6440 [intro~a.] 40.18 secs (0.001u,0.034s)
Chars 6443 - 6471 [(induction~n;~[~reflexivity~|~...] 0.002 secs (0.002u,0.s)
Chars 6474 - 6483 [funext~x.] 0.002 secs (0.002u,0.s)
Chars 6486 - 6521 [refine~(_~@~IHn~(fstail~ss)~(a...] 0.003 secs (0.003u,0.s)
Chars 6524 - 6572 [refine~(ap~(operation_curry~A~...] 0.003 secs (0.003u,0.s)
Chars 6575 - 6585 [funext~a'.] 0.002 secs (0.002u,0.s)
Chars 6588 - 6594 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 6597 - 6624 [(unfold~cons_dom,~cons_dom').] 0.001 secs (0.001u,0.s)
Chars 6627 - 6660 [(rewrite~compute_fin_ind_fin_z...] 0.044 secs (0.03u,0.013s)
Chars 6663 - 6719 [refine~(ap~(operation_uncurry~...] 0.004 secs (0.004u,0.s)
Chars 6722 - 6732 [funext~i'.] 0.003 secs (0.003u,0.s)
Chars 6735 - 6769 [now~rewrite~compute_fin_ind_fs...] 0.049 secs (0.043u,0.005s)
Chars 6432 - 6440 [intro~a.] 0. secs (0.u,0.s)
Chars 6443 - 6471 [(induction~n;~[~reflexivity~|~...] 0. secs (0.u,0.s)
Chars 6474 - 6483 [funext~x.] 0. secs (0.u,0.s)
Chars 6486 - 6521 [refine~(_~@~IHn~(fstail~ss)~(a...] 0.001 secs (0.001u,0.s)
Chars 6524 - 6572 [refine~(ap~(operation_curry~A~...] 0. secs (0.u,0.s)
Chars 6575 - 6585 [funext~a'.] 0. secs (0.u,0.s)
Chars 6588 - 6594 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 6597 - 6624 [(unfold~cons_dom,~cons_dom').] 0.001 secs (0.001u,0.s)
Chars 6627 - 6660 [(rewrite~compute_fin_ind_fin_z...] 0.002 secs (0.002u,0.s)
Chars 6663 - 6719 [refine~(ap~(operation_uncurry~...] 0.001 secs (0.001u,0.s)
Chars 6722 - 6732 [funext~i'.] 0.001 secs (0.001u,0.s)
Chars 6735 - 6769 [now~rewrite~compute_fin_ind_fs...] 0.001 secs (0.001u,0.s)
Chars 6770 - 6774 [Qed.] 0.065 secs (0.052u,0.011s)
Chars 6776 - 6938 [#[global]~Instance~isequiv_ope...] 0.001 secs (0.u,0.s)
Chars 6939 - 6945 [Proof.] 0. secs (0.u,0.s)
Chars 1613 - 1645 [snrapply~Build_GroupIsomorphism.] 40.16 secs (0.001u,0.028s)
Chars 1648 - 1649 [-] 0. secs (0.u,0.s)
Chars 1650 - 1683 [snrapply~Build_GroupHomomorphism.] 0.002 secs (0.002u,0.s)
Chars 1688 - 1689 [+] 0. secs (0.u,0.s)
Chars 1690 - 1698 [intro~x.] 0. secs (0.u,0.s)
Chars 1705 - 1718 [exists~(f~x).] 0.001 secs (0.001u,0.s)
Chars 1725 - 1734 [exists~x.] 0. secs (0.u,0.s)
Chars 1741 - 1753 [reflexivity.] 0. secs (0.u,0.s)
Chars 1758 - 1759 [+] 0. secs (0.u,0.s)
Chars 1760 - 1774 [(cbn;~grp_auto).] 0.051 secs (0.042u,0.008s)
Chars 1777 - 1778 [-] 0. secs (0.u,0.s)
Chars 1779 - 1802 [(apply~isequiv_surj_emb).] 0.006 secs (0.005u,0.s)
Chars 3740 - 3772 [(apply~(path_homomorphism~f~g~...] 40.064 secs (0.001u,0.032s)
Chars 3773 - 3792 [(apply~path_ishprop).] 0.006 secs (0.004u,0.001s)
Chars 3740 - 3772 [(apply~(path_homomorphism~f~g~...] 0. secs (0.u,0.s)
Chars 3773 - 3792 [(apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 3793 - 3801 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4184 - 4348 [Class~IsIsomorphism~{σ~:~Signa...] 0.003 secs (0.001u,0.001s)
Chars 4350 - 4395 [#[global]Existing~Instance~ise...] 0. secs (0.u,0.s)
Chars 4397 - 4550 [Definition~equiv_isomorphism~{...] 0.002 secs (0.u,0.001s)
Chars 4551 - 4557 [Proof.] 0. secs (0.u,0.s)
Chars 1807 - 1847 [2:~(apply~(cancelL_isembedding...] 0.206 secs (0.189u,0.016s)
Chars 1852 - 1874 [(intros~[b~[a~p]];~cbn).] 0.019 secs (0.017u,0.001s)
Chars 1879 - 1908 [rapply~contr_inhabited_hprop.] 0.03 secs (0.028u,0.001s)
Chars 1913 - 1932 [refine~(tr~(a;~_)).] 0.002 secs (0.002u,0.s)
Chars 1937 - 1957 [srapply~path_sigma'.] 0.004 secs (0.004u,0.s)
Chars 1962 - 1973 [1:~exact~p.] 0. secs (0.u,0.s)
Chars 1978 - 2012 [refine~(transport_sigma'~_~_~@...] 0.002 secs (0.001u,0.s)
Chars 2017 - 2043 [by~apply~path_sigma_hprop.] 0.044 secs (0.037u,0.006s)
Chars 1613 - 1645 [snrapply~Build_GroupIsomorphism.] 0. secs (0.u,0.s)
Chars 1650 - 1683 [snrapply~Build_GroupHomomorphism.] 0. secs (0.u,0.s)
Chars 1690 - 1698 [intro~x.] 0. secs (0.u,0.s)
Chars 1705 - 1718 [exists~(f~x).] 0. secs (0.u,0.s)
Chars 1725 - 1734 [exists~x.] 0. secs (0.u,0.s)
Chars 1741 - 1753 [reflexivity.] 0. secs (0.u,0.s)
Chars 1760 - 1774 [(cbn;~grp_auto).] 0.001 secs (0.001u,0.s)
Chars 1779 - 1802 [(apply~isequiv_surj_emb).] 0.003 secs (0.003u,0.s)
Chars 1807 - 1847 [2:~(apply~(cancelL_isembedding...] 0.002 secs (0.002u,0.s)
Chars 1852 - 1874 [(intros~[b~[a~p]];~cbn).] 0.004 secs (0.004u,0.s)
Chars 1879 - 1908 [rapply~contr_inhabited_hprop.] 0. secs (0.u,0.s)
Chars 1913 - 1932 [refine~(tr~(a;~_)).] 0. secs (0.u,0.s)
Chars 1937 - 1957 [srapply~path_sigma'.] 0. secs (0.u,0.s)
Chars 1962 - 1973 [1:~exact~p.] 0. secs (0.u,0.s)
Chars 1978 - 2012 [refine~(transport_sigma'~_~_~@...] 0. secs (0.u,0.s)
Chars 2017 - 2043 [by~apply~path_sigma_hprop.] 0.001 secs (0.001u,0.s)
Chars 2044 - 2052 [Defined.] 0.025 secs (0.023u,0.001s)
find_witness Control.TimeoutChars 3693 - 3718 [(apply~related_classes_eq).] 40.195 secs (0.001u,0.037s)
Chars 3719 - 3742 [exact~(subrel~s~x~y~P).] 0.001 secs (0.u,0.s)
Chars 3693 - 3718 [(apply~related_classes_eq).] 0. secs (0.u,0.s)
Chars 3719 - 3742 [exact~(subrel~s~x~y~P).] 0. secs (0.u,0.s)
Chars 3745 - 3753 [Defined.] 0. secs (0.u,0.s)
Chars 3757 - 3901 [Definition~def_third_surjectio...] 0.005 secs (0.005u,0.s)
Chars 3905 - 4170 [Lemma~oppreserving_third_surje...] 0.004 secs (0.003u,0.s)
Chars 4173 - 4179 [Proof.] 0. secs (0.u,0.s)
Chars 8097 - 8106 [revert~f.] 40.038 secs (0.u,0.015s)
Chars 8108 - 8139 [(equiv_intro~(equiv_path~A~B)~p).] 0.002 secs (0.001u,0.s)
Chars 8142 - 8198 [exact~(ap~(fun~s~=>~transport~...] 0.002 secs (0.002u,0.s)
Chars 8097 - 8106 [revert~f.] 0. secs (0.u,0.s)
Chars 8108 - 8139 [(equiv_intro~(equiv_path~A~B)~p).] 0. secs (0.u,0.s)
Chars 8142 - 8198 [exact~(ap~(fun~s~=>~transport~...] 0. secs (0.u,0.s)
Chars 8199 - 8207 [Defined.] 0. secs (0.u,0.s)
Chars 8209 - 8430 [Definition~transport_path_univ...] 0.002 secs (0.001u,0.001s)
Chars 8520 - 8741 [Definition~transport_path_univ...] 0.005 secs (0.005u,0.s)
Chars 8813 - 9092 [Definition~transport_path_univ...] 0.008 secs (0.008u,0.s)
Chars 9144 - 9319 [Definition~transport_path_univ...] 0.003 secs (0.u,0.001s)
Chars 9320 - 9326 [Proof.] 0. secs (0.u,0.s)
Chars 15279 - 15312 [(intros~n;~generalize~dependen...] 40.174 secs (0.001u,0.031s)
Chars 15317 - 15357 [(simple_induction~n~n~IHn;~int...] 0.003 secs (0.003u,0.s)
Chars 15362 - 15373 [1:~exact~tt.] 0. secs (0.u,0.s)
Chars 15378 - 15384 [split.] 0.001 secs (0.001u,0.s)
Chars 15389 - 15390 [-] 0. secs (0.u,0.s)
Chars 15391 - 15400 [(intros~g).] 0.001 secs (0.001u,0.s)
Chars 15407 - 15442 [exists~(Localize_ind~f~X~P~g~P...] 0.002 secs (0.002u,0.s)
Chars 15449 - 15471 [(intros~x;~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 15476 - 15477 [-] 0. secs (0.u,0.s)
Chars 15478 - 15512 [(intros~h~k;~apply~IHn;~intros...] 0.003 secs (0.003u,0.s)
Chars 15519 - 15552 [(apply~ooextendable_over_homot...] 0.002 secs (0.002u,0.s)
Chars 15559 - 15574 [exact~(Ploc~i).] 0.001 secs (0.001u,0.s)
Chars 15279 - 15312 [(intros~n;~generalize~dependen...] 0. secs (0.u,0.s)
Chars 15317 - 15357 [(simple_induction~n~n~IHn;~int...] 0.001 secs (0.001u,0.s)
Chars 15362 - 15373 [1:~exact~tt.] 0. secs (0.u,0.s)
Chars 15378 - 15384 [split.] 0. secs (0.u,0.s)
Chars 15391 - 15400 [(intros~g).] 0. secs (0.u,0.s)
Chars 15407 - 15442 [exists~(Localize_ind~f~X~P~g~P...] 0. secs (0.u,0.s)
Chars 15449 - 15471 [(intros~x;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 15478 - 15512 [(intros~h~k;~apply~IHn;~intros...] 0.002 secs (0.002u,0.s)
Chars 15519 - 15552 [(apply~ooextendable_over_homot...] 0.001 secs (0.001u,0.s)
Chars 15559 - 15574 [exact~(Ploc~i).] 0. secs (0.u,0.s)
Chars 15577 - 15585 [Defined.] 0.003 secs (0.003u,0.s)
Chars 15587 - 15604 [End~Localization.] 0.013 secs (0.013u,0.s)
Chars 15606 - 15681 [Definition~Loc@{a~i}~(f~:~Loca...] 0. secs (0.u,0.s)
Chars 15682 - 15688 [Proof.] 0. secs (0.u,0.s)
Chars 1809 - 1822 [(intros~x~y~z).] 40.157 secs (0.u,0.03s)
Chars 1823 - 1852 [(rewrite~!(commutativity~_~z)).] 0.021 secs (0.018u,0.002s)
Chars 1855 - 1874 [(apply~distribute_l).] 0.002 secs (0.002u,0.s)
Chars 1809 - 1822 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 1823 - 1852 [(rewrite~!(commutativity~_~z)).] 0. secs (0.u,0.s)
Chars 1855 - 1874 [(apply~distribute_l).] 0. secs (0.u,0.s)
Chars 1877 - 1881 [Qed.] 0.001 secs (0.u,0.s)
Chars 1885 - 1947 [#[global]Instance~meet_join_di...] 0. secs (0.u,0.s)
Chars 1950 - 1956 [Proof.] 0. secs (0.u,0.s)
Chars 4560 - 4568 [intro~s.] 7.353 secs (-2.861u,-0.342s)
Chars 1040 - 1089 [(destruct~(trichotomy~(<)~0~x)...] 40.227 secs (0.053u,0.044s)
Chars 1090 - 1091 [-] 0. secs (0.u,0.s)
Chars 1092 - 1114 [(left;~symmetry;~trivial).] 0.004 secs (0.003u,0.001s)
Chars 1115 - 1116 [-] 0. secs (0.u,0.s)
Chars 1117 - 1142 [(destruct~(nat_not_neg~x)).] 0.002 secs (0.002u,0.s)
Chars 1143 - 1151 [trivial.] 0.001 secs (0.001u,0.s)
Chars 1040 - 1089 [(destruct~(trichotomy~(<)~0~x)...] 0.002 secs (0.002u,0.s)
Chars 1092 - 1114 [(left;~symmetry;~trivial).] 0.001 secs (0.001u,0.s)
Chars 1117 - 1142 [(destruct~(nat_not_neg~x)).] 0. secs (0.u,0.s)
Chars 1143 - 1151 [trivial.] 0. secs (0.u,0.s)
Chars 1152 - 1156 [Qed.] 0.001 secs (0.001u,0.s)
Chars 1158 - 1200 [Lemma~nat_0_or_ge_1~x~:~x~=~0~...] 0.001 secs (0.u,0.s)
Chars 1201 - 1207 [Proof.] 0. secs (0.u,0.s)
Chars 1721 - 1734 [(intros~[a~b]).] 40.207 secs (0.006u,0.047s)
Chars 1739 - 1789 [(revert~a;~srapply~QuotientRin...] 0.071 secs (0.048u,0.021s)
Chars 1794 - 1844 [(revert~b;~srapply~QuotientRin...] 0.03 secs (0.03u,0.s)
Chars 2032 - 2105 [(snrapply~Build_Contr;~[~~|~in...] 0.12 secs (0.099u,0.019s)
Chars 2170 - 2203 [(apply~tr;~exists~(b~*~x~+~a~*...] 0.005 secs (0.005u,0.s)
Chars 2288 - 2310 [(rewrite~rng_homo_plus).] 0.004 secs (0.003u,0.001s)
Chars 2315 - 2339 [(rewrite~2!rng_homo_mult).] 0.006 secs (0.003u,0.002s)
Chars 2344 - 2359 [(rewrite~q1,~q2).] 0.009 secs (0.008u,0.s)
Chars 2364 - 2380 [(apply~path_prod).] 0.005 secs (0.004u,0.s)
Chars 2385 - 2386 [+] 0. secs (0.u,0.s)
Chars 2387 - 2429 [(change~([b]~*~0~+~[a]~*~1~=~[...] 0.008 secs (0.007u,0.s)
Chars 2436 - 2496 [by~rewrite~rng_mult_one_r,~rng...] 0.044 secs (0.03u,0.014s)
Chars 2501 - 2502 [+] 0. secs (0.u,0.s)
Chars 2503 - 2545 [(change~([b]~*~1~+~[a]~*~0~=~[...] 0.007 secs (0.007u,0.s)
Chars 2552 - 2612 [by~rewrite~rng_mult_one_r,~rng...] 0.006 secs (0.004u,0.001s)
Chars 2306 - 2342 [(srapply~Quotient_ind_hprop;~i...] 40.217 secs (0.052u,0.041s)
Chars 1721 - 1734 [(intros~[a~b]).] 0. secs (0.u,0.s)
Chars 1739 - 1789 [(revert~a;~srapply~QuotientRin...] 0.003 secs (0.003u,0.s)
Chars 1794 - 1844 [(revert~b;~srapply~QuotientRin...] 0.003 secs (0.003u,0.s)
Chars 2347 - 2380 [by~simpl;~rewrite~right_identity.] 0.011 secs (0.01u,0.s)
Chars 2306 - 2342 [(srapply~Quotient_ind_hprop;~i...] 0. secs (0.u,0.s)
Chars 2347 - 2380 [by~simpl;~rewrite~right_identity.] 0. secs (0.u,0.s)
Chars 2032 - 2105 [(snrapply~Build_Contr;~[~~|~in...] 0.004 secs (0.003u,0.001s)
Chars 2383 - 2387 [Qed.] 0.001 secs (0.001u,0.s)
Chars 2170 - 2203 [(apply~tr;~exists~(b~*~x~+~a~*...] 0.002 secs (0.002u,0.s)
Chars 2391 - 2466 [#[global]~Instance~ismonoid_qu...] 0.001 secs (0.001u,0.s)
Chars 2288 - 2310 [(rewrite~rng_homo_plus).] 0.001 secs (0.001u,0.s)
Chars 2470 - 2578 [#[global]~Instance~quotientgro...] 0. secs (0.u,0.s)
Chars 2581 - 2587 [Proof.] 0. secs (0.u,0.s)
Chars 2315 - 2339 [(rewrite~2!rng_homo_mult).] 0.001 secs (0.001u,0.s)
Chars 2344 - 2359 [(rewrite~q1,~q2).] 0.001 secs (0.001u,0.s)
Chars 2364 - 2380 [(apply~path_prod).] 0.001 secs (0.001u,0.s)
Chars 2387 - 2429 [(change~([b]~*~0~+~[a]~*~1~=~[...] 0.001 secs (0.u,0.001s)
Chars 2436 - 2496 [by~rewrite~rng_mult_one_r,~rng...] 0.001 secs (0.u,0.s)
Chars 2503 - 2545 [(change~([b]~*~1~+~[a]~*~0~=~[...] 0.001 secs (0.001u,0.s)
Chars 2552 - 2612 [by~rewrite~rng_mult_one_r,~rng...] 0.001 secs (0.u,0.s)
Chars 2615 - 2623 [Defined.] 0.099 secs (0.084u,0.013s)
Chars 2746 - 2772 [Section~rng_homo_crt_beta.] 0. secs (0.u,0.s)
Chars 2778 - 2834 [Context~(x~y~:~R)~(ix~:~I~x)~(...] 0.001 secs (0.001u,0.s)
Chars 2840 - 2895 [Lemma~rng_homo_crt_beta_left~:...] 0.003 secs (0.003u,0.s)
Chars 2900 - 2906 [Proof.] 0. secs (0.u,0.s)
Chars 8276 - 8338 [refine~(iff_compose~_~(iff_for...] 40.149 secs (0.002u,0.024s)
Chars 8341 - 8375 [(apply~iff_functor_forall;~int...] 0.001 secs (0.001u,0.s)
Chars 8378 - 8428 [(symmetry;~apply~(iff_contr_hp...] 0.004 secs (0.003u,0.s)
Chars 8276 - 8338 [refine~(iff_compose~_~(iff_for...] 0. secs (0.u,0.s)
Chars 8341 - 8375 [(apply~iff_functor_forall;~int...] 0. secs (0.u,0.s)
Chars 8378 - 8428 [(symmetry;~apply~(iff_contr_hp...] 0. secs (0.u,0.s)
Chars 8429 - 8437 [Defined.] 0.001 secs (0.001u,0.s)
Chars 8439 - 8581 [Lemma~equiv_merely_issurjectio...] 0.001 secs (0.001u,0.s)
Chars 8582 - 8588 [Proof.] 0. secs (0.u,0.s)
Chars 954 - 968 [etransitivity.] 40.209 secs (0.002u,0.047s)
Chars 973 - 992 [2:~(apply~Pi1Circle).] 0.004 secs (0.004u,0.s)
Chars 997 - 1023 [(apply~groupiso_pi_functor).] 0.001 secs (0.001u,0.s)
Chars 1028 - 1051 [(apply~pequiv_S1_Circle).] 0.001 secs (0.001u,0.s)
Chars 954 - 968 [etransitivity.] 0. secs (0.u,0.s)
Chars 973 - 992 [2:~(apply~Pi1Circle).] 0. secs (0.u,0.s)
Chars 997 - 1023 [(apply~groupiso_pi_functor).] 0. secs (0.u,0.s)
Chars 1028 - 1051 [(apply~pequiv_S1_Circle).] 0. secs (0.u,0.s)
Chars 1054 - 1062 [Defined.] 0.002 secs (0.002u,0.s)
Chars 1064 - 1074 [End~Pi1S1.] 0.009 secs (0.009u,0.s)
Chars 3168 - 3192 [by~destruct~theta,~p,~q.] 40.119 secs (0.012u,0.021s)
Chars 3168 - 3192 [by~destruct~theta,~p,~q.] 0.001 secs (0.001u,0.s)
Chars 3193 - 3201 [Defined.] 0.007 secs (0.007u,0.s)
Chars 3203 - 3385 [Definition~lrucancel_sHs_1_pp~...] 0.013 secs (0.01u,0.003s)
Chars 3386 - 3392 [Proof.] 0. secs (0.u,0.s)
Chars 3395 - 3419 [by~destruct~theta,~p,~q.] 0.099 secs (0.012u,0.021s)
Chars 3395 - 3419 [by~destruct~theta,~p,~q.] 0.001 secs (0.001u,0.s)
Chars 3420 - 3428 [Defined.] 0.007 secs (0.005u,0.001s)
Chars 3430 - 3540 [Definition~rlucancel_sHs_1~{X}...] 0.006 secs (0.006u,0.s)
Chars 3541 - 3547 [Proof.] 0. secs (0.u,0.s)
Chars 3550 - 3564 [by~destruct~p.] 0.118 secs (0.002u,0.022s)
Chars 3550 - 3564 [by~destruct~p.] 0. secs (0.u,0.s)
Chars 3565 - 3573 [Defined.] 0.002 secs (0.002u,0.s)
Chars 3575 - 3685 [Definition~lrucancel_sVs_1~{X}...] 0.006 secs (0.005u,0.s)
Chars 3686 - 3692 [Proof.] 0. secs (0.u,0.s)
Chars 3695 - 3709 [by~destruct~p.] 0.068 secs (0.004u,0.019s)
Chars 3695 - 3709 [by~destruct~p.] 0. secs (0.u,0.s)
Chars 3710 - 3718 [Defined.] 0.002 secs (0.002u,0.s)
Chars 3760 - 3866 [Definition~ulnat~{X}~{a~b~:~X}...] 0.002 secs (0.002u,0.s)
Chars 3867 - 3873 [Proof.] 0. secs (0.u,0.s)
Chars 3876 - 3887 [(destruct~p).] 0.458 secs (0.002u,0.02s)
Chars 3890 - 3910 [exact~(lrucancel~1).] 0.001 secs (0.001u,0.s)
Chars 3876 - 3887 [(destruct~p).] 0. secs (0.u,0.s)
Chars 3890 - 3910 [exact~(lrucancel~1).] 0. secs (0.u,0.s)
Chars 3911 - 3919 [Defined.] 0.001 secs (0.u,0.s)
Chars 3922 - 4028 [Definition~urnat~{X}~{a~b~:~X}...] 0.002 secs (0.002u,0.s)
Chars 4029 - 4035 [Proof.] 0. secs (0.u,0.s)
Chars 4038 - 4049 [(destruct~p).] 0.08 secs (0.002u,0.02s)
Chars 4052 - 4072 [exact~(lrucancel~1).] 0.001 secs (0.001u,0.s)
Chars 4038 - 4049 [(destruct~p).] 0. secs (0.u,0.s)
Chars 4052 - 4072 [exact~(lrucancel~1).] 0. secs (0.u,0.s)
Chars 4073 - 4081 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4147 - 4275 [Definition~wlrnat~{X}~{a~b~c~:...] 0.005 secs (0.004u,0.s)
Chars 4276 - 4282 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 4285 - 4302 [by~destruct~p,~q.] 0.088 secs (0.004u,0.022s)
Chars 4285 - 4302 [by~destruct~p,~q.] 0. secs (0.u,0.s)
Chars 4303 - 4311 [Defined.] 0.003 secs (0.002u,0.s)
Chars 4334 - 4403 [Theorem~eh~{X}~{a~:~X}~(p~q~:~...] 0.001 secs (0.001u,0.s)
Chars 4404 - 4410 [Proof.] 0. secs (0.u,0.s)
Chars 6356 - 6403 [(pose~proof~(@extendable_to_O~...] 28.227 secs (21.46u,0.312s)
find_witness Control.TimeoutChars 6356 - 6403 [(pose~proof~(@extendable_to_O~...] 40.057 secs (0.001u,0.026s)
Chars 6406 - 6461 [(apply~lift_ooextendablealong@...] 0. secs (0.u,0.s)
Chars 6464 - 6472 [exact~e.] 0. secs (0.u,0.s)
Chars 6356 - 6403 [(pose~proof~(@extendable_to_O~...] 0. secs (0.u,0.s)
Chars 6406 - 6461 [(apply~lift_ooextendablealong@...] 0. secs (0.u,0.s)
Chars 6464 - 6472 [exact~e.] 0. secs (0.u,0.s)
Chars 6473 - 6481 [Defined.] 0. secs (0.u,0.s)
Chars 6567 - 6650 [Definition~prereflects_in~(O~:...] 0. secs (0.u,0.s)
Chars 6651 - 6657 [Proof.] 0. secs (0.u,0.s)
Chars 9219 - 9230 [(destruct~c).] 40.176 secs (0.03u,0.029s)
Chars 9235 - 9254 [(apply~cu_fill_back).] 0.006 secs (0.004u,0.001s)
Chars 9219 - 9230 [(destruct~c).] 0.002 secs (0.001u,0.s)
Chars 9235 - 9254 [(apply~cu_fill_back).] 0.002 secs (0.001u,0.001s)
Chars 9257 - 9265 [Defined.] 0.006 secs (0.005u,0.s)
Chars 9267 - 9275 [End~Kan.] 0.055 secs (0.047u,0.007s)
Chars 1749 - 1758 [(intros~?).] 40.182 secs (0.u,0.034s)
Chars 1763 - 1784 [(apply~path_iff_hprop).] 0. secs (0.u,0.s)
Chars 1789 - 1790 [-] 0. secs (0.u,0.s)
Chars 1791 - 1814 [(intros~[a~_];~apply~a).] 0.001 secs (0.001u,0.s)
Chars 1819 - 1820 [-] 0. secs (0.u,0.s)
Chars 1821 - 1848 [(intros~a;~apply~(pair~a~a)).] 0.001 secs (0.001u,0.s)
Chars 1749 - 1758 [(intros~?).] 0. secs (0.u,0.s)
Chars 1763 - 1784 [(apply~path_iff_hprop).] 0. secs (0.u,0.s)
Chars 1791 - 1814 [(intros~[a~_];~apply~a).] 0. secs (0.u,0.s)
Chars 1821 - 1848 [(intros~a;~apply~(pair~a~a)).] 0. secs (0.u,0.s)
Chars 1851 - 1859 [Defined.] 0. secs (0.u,0.s)
Chars 1863 - 1917 [Instance~leftidentity_hor~:~(L...] 0. secs (0.u,0.s)
Chars 1920 - 1926 [Proof.] 0. secs (0.u,0.s)
Chars 6948 - 6975 [srapply~isequiv_adjointify.] 40.179 secs (0.001u,0.036s)
Chars 6978 - 6979 [-] 0. secs (0.u,0.s)
Chars 6980 - 7004 [(apply~operation_uncurry).] 0.001 secs (0.001u,0.s)
Chars 7007 - 7008 [-] 0. secs (0.u,0.s)
Chars 7009 - 7047 [(apply~path_operation_uncurry_...] 0.002 secs (0.002u,0.s)
Chars 7050 - 7051 [-] 0. secs (0.u,0.s)
Chars 7052 - 7090 [(apply~path_operation_curry_to...] 0.002 secs (0.002u,0.s)
Chars 6948 - 6975 [srapply~isequiv_adjointify.] 0. secs (0.u,0.s)
Chars 6980 - 7004 [(apply~operation_uncurry).] 0. secs (0.u,0.s)
Chars 7009 - 7047 [(apply~path_operation_uncurry_...] 0. secs (0.u,0.s)
Chars 7052 - 7090 [(apply~path_operation_curry_to...] 0. secs (0.u,0.s)
Chars 7091 - 7099 [Defined.] 0.002 secs (0.002u,0.s)
Chars 7101 - 7322 [Definition~equiv_operation_cur...] 0.016 secs (0.015u,0.s)
Chars 4560 - 4568 [intro~s.] 40.068 secs (0.u,0.032s)
Chars 4569 - 4600 [rapply~(Build_Equiv~_~_~(f~s)).] 0.015 secs (0.012u,0.003s)
Chars 4560 - 4568 [intro~s.] 0. secs (0.u,0.s)
Chars 4569 - 4600 [rapply~(Build_Equiv~_~_~(f~s)).] 0. secs (0.u,0.s)
Chars 4601 - 4609 [Defined.] 0. secs (0.u,0.s)
Chars 4611 - 4772 [#[global]~Instance~hprop_is_is...] 0.002 secs (0.002u,0.s)
Chars 4773 - 4779 [Proof.] 0. secs (0.u,0.s)
Chars 4782 - 4803 [(apply~istrunc_forall).] 0.304 secs (0.008u,0.034s)
Chars 4782 - 4803 [(apply~istrunc_forall).] 0. secs (0.u,0.s)
Chars 4804 - 4808 [Qed.] 0.001 secs (0.001u,0.s)
Chars 5233 - 5267 [Section~homomorphism_ap_operat...] 0. secs (0.u,0.s)
Chars 5270 - 5314 [Context~{σ~:~Signature}~{A~B~:...] 0. secs (0.u,0.s)
Chars 5318 - 5608 [Lemma~path_oppreserving_ap_ope...] 0.004 secs (0.003u,0.001s)
Chars 5611 - 5617 [Proof.] 0. secs (0.u,0.s)
Chars 9329 - 9338 [revert~f.] 40.077 secs (0.u,0.015s)
Chars 9339 - 9370 [(equiv_intro~(equiv_path~A~B)~p).] 0.003 secs (0.003u,0.s)
Chars 9373 - 9440 [exact~(ap~(fun~s~=>~transport~...] 0.002 secs (0.002u,0.s)
Chars 9329 - 9338 [revert~f.] 0. secs (0.u,0.s)
Chars 9339 - 9370 [(equiv_intro~(equiv_path~A~B)~p).] 0. secs (0.u,0.s)
Chars 9373 - 9440 [exact~(ap~(fun~s~=>~transport~...] 0. secs (0.u,0.s)
Chars 9441 - 9449 [Defined.] 0.002 secs (0.001u,0.s)
Chars 9451 - 9690 [Definition~transport_path_univ...] 0.002 secs (0.002u,0.s)
Chars 9795 - 10039 [Definition~transport_path_univ...] 0.009 secs (0.007u,0.001s)
Chars 4184 - 4196 [(induction~w).] 40.19 secs (0.003u,0.038s)
Chars 4201 - 4202 [-] 0. secs (0.u,0.s)
Chars 10076 - 10349 [Definition~transport_path_univ...] 0.007 secs (0.006u,0.s)
Chars 10350 - 10356 [Proof.] 0. secs (0.u,0.s)
Chars 4203 - 4241 [refine~(quotient_ind_prop~(Φ~t...] 0.069 secs (0.06u,0.008s)
Chars 4242 - 4256 [(intros~α~Qα).] 0.001 secs (0.001u,0.s)
Chars 4263 - 4301 [refine~(quotient_ind_prop~(Ψ~t...] 0.047 secs (0.042u,0.004s)
Chars 4302 - 4316 [(intros~β~Qβ).] 0.001 secs (0.001u,0.s)
Chars 4323 - 4348 [(apply~related_classes_eq).] 0.003 secs (0.003u,0.s)
Chars 4355 - 4370 [transitivity~f.] 0.005 secs (0.005u,0.s)
Chars 4377 - 4378 [+] 0. secs (0.u,0.s)
Chars 4379 - 4392 [(apply~subrel).] 0.001 secs (0.001u,0.s)
Chars 4393 - 4427 [(apply~(classes_eq_related~(Ψ~...] 0.024 secs (0.018u,0.005s)
Chars 4428 - 4443 [exact~(Qβ~tt).] 0.002 secs (0.002u,0.s)
Chars 4450 - 4451 [+] 0. secs (0.u,0.s)
Chars 4452 - 4486 [(apply~(classes_eq_related~(Φ~...] 0.026 secs (0.025u,0.s)
Chars 4487 - 4496 [symmetry.] 0.003 secs (0.003u,0.s)
Chars 4497 - 4512 [exact~(Qα~tt).] 0.016 secs (0.014u,0.001s)
Chars 4517 - 4518 [-] 0. secs (0.u,0.s)
Chars 4519 - 4540 [(intros~α~Qα~β~Qβ).] 0.002 secs (0.001u,0.s)
Chars 4547 - 4585 [refine~(quotient_ind_prop~(Ψ~t...] 0.033 secs (0.027u,0.006s)
Chars 4592 - 4600 [intro~x.] 0.002 secs (0.002u,0.s)
Chars 4607 - 4726 [exact~~(IHw~(f~x)~(α~(class_of...] 0.011 secs (0.011u,0.s)
Chars 4184 - 4196 [(induction~w).] 0.001 secs (0.001u,0.s)
Chars 4203 - 4241 [refine~(quotient_ind_prop~(Φ~t...] 0.001 secs (0.001u,0.s)
Chars 4242 - 4256 [(intros~α~Qα).] 0.001 secs (0.001u,0.s)
Chars 4263 - 4301 [refine~(quotient_ind_prop~(Ψ~t...] 0.001 secs (0.001u,0.s)
Chars 4302 - 4316 [(intros~β~Qβ).] 0.001 secs (0.001u,0.s)
Chars 4323 - 4348 [(apply~related_classes_eq).] 0.001 secs (0.001u,0.s)
Chars 4355 - 4370 [transitivity~f.] 0. secs (0.u,0.s)
Chars 4379 - 4392 [(apply~subrel).] 0. secs (0.u,0.s)
Chars 4393 - 4427 [(apply~(classes_eq_related~(Ψ~...] 0. secs (0.u,0.s)
Chars 4428 - 4443 [exact~(Qβ~tt).] 0.001 secs (0.001u,0.s)
Chars 4452 - 4486 [(apply~(classes_eq_related~(Φ~...] 0. secs (0.u,0.s)
Chars 4487 - 4496 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 4497 - 4512 [exact~(Qα~tt).] 0.001 secs (0.001u,0.s)
Chars 4519 - 4540 [(intros~α~Qα~β~Qβ).] 0.001 secs (0.001u,0.s)
Chars 4547 - 4585 [refine~(quotient_ind_prop~(Ψ~t...] 0.001 secs (0.001u,0.s)
Chars 4592 - 4600 [intro~x.] 0.002 secs (0.001u,0.s)
Chars 4607 - 4726 [exact~~(IHw~(f~x)~(α~(class_of...] 0.002 secs (0.002u,0.s)
Chars 4729 - 4737 [Defined.] 0.016 secs (0.013u,0.003s)
Chars 4740 - 4831 [#[global]~Instance~is_homomorp...] 0. secs (0.u,0.s)
Chars 4834 - 4840 [Proof.] 0. secs (0.u,0.s)
Chars 15691 - 15979 [simple~notypeclasses~refine~~(...] 40.183 secs (0.003u,0.033s)
Chars 15982 - 15983 [-] 0. secs (0.u,0.s)
Chars 16101 - 16128 [(intros~?~T;~unfold~IsLocal).] 0.001 secs (0.u,0.001s)
Chars 16133 - 16182 [(nrefine~istrunc_forall@{a~i~i...] 0.002 secs (0.002u,0.s)
Chars 16187 - 16196 [(intros~i).] 0. secs (0.u,0.s)
Chars 16239 - 16534 [(first~~[~apply~ishprop_ooexte...] 0.001 secs (0.001u,0.s)
Chars 16537 - 16538 [-] 0. secs (0.u,0.s)
Chars 16539 - 16567 [(apply~islocal_equiv_islocal).] 0. secs (0.u,0.s)
Chars 16570 - 16571 [-] 0. secs (0.u,0.s)
Chars 16572 - 16595 [(apply~islocal_localize).] 0.001 secs (0.001u,0.s)
Chars 16598 - 16599 [-] 0. secs (0.u,0.s)
Chars 16600 - 16604 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 16605 - 16620 [(intros~Q~Q_inO).] 0. secs (0.u,0.s)
Chars 16625 - 16658 [(apply~ext_localize_ind;~intro...] 0.001 secs (0.001u,0.s)
Chars 16663 - 16693 [(apply~ooextendable_over_const).] 0.004 secs (0.004u,0.s)
Chars 16698 - 16710 [(apply~Q_inO).] 0. secs (0.u,0.s)
Chars 15691 - 15979 [simple~notypeclasses~refine~~(...] 0. secs (0.u,0.s)
Chars 16101 - 16128 [(intros~?~T;~unfold~IsLocal).] 0. secs (0.u,0.s)
Chars 16133 - 16182 [(nrefine~istrunc_forall@{a~i~i...] 0. secs (0.u,0.s)
Chars 16187 - 16196 [(intros~i).] 0. secs (0.u,0.s)
Chars 16239 - 16534 [(first~~[~apply~ishprop_ooexte...] 0. secs (0.u,0.s)
Chars 16539 - 16567 [(apply~islocal_equiv_islocal).] 0. secs (0.u,0.s)
Chars 16572 - 16595 [(apply~islocal_localize).] 0. secs (0.u,0.s)
Chars 16600 - 16604 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 16605 - 16620 [(intros~Q~Q_inO).] 0. secs (0.u,0.s)
Chars 16625 - 16658 [(apply~ext_localize_ind;~intro...] 0. secs (0.u,0.s)
Chars 16663 - 16693 [(apply~ooextendable_over_const).] 0. secs (0.u,0.s)
Chars 16698 - 16710 [(apply~Q_inO).] 0. secs (0.u,0.s)
Chars 16711 - 16719 [Defined.] 0.004 secs (0.002u,0.001s)
Chars 16943 - 16978 [Notation~IsLocal~f:=~(In~(Loc~...] 0. secs (0.u,0.s)
Chars 16980 - 16999 [Section~LocalTypes.] 0. secs (0.u,0.s)
Chars 17002 - 17032 [Context~(f~:~LocalGenerators).] 0. secs (0.u,0.s)
Chars 17686 - 17852 [Definition~ooextendable_isloca...] 0.002 secs (0.002u,0.s)
Chars 17856 - 17950 [#[global]~Instance~islocal_loc...] 0.001 secs (0.001u,0.s)
Chars 17954 - 18142 [#[global]~Instance~isequiv_pre...] 0.005 secs (0.005u,0.s)
Chars 18184 - 18271 [Definition~Localize_rec~{X~Z~:...] 0. secs (0.u,0.s)
Chars 18274 - 18280 [Proof.] 0. secs (0.u,0.s)
Chars 1959 - 1972 [(intros~x~y~z).] 40.164 secs (0.u,0.03s)
Chars 1975 - 2015 [(rewrite~(simple_distribute_l~...] 0.003 secs (0.003u,0.s)
Chars 2018 - 2058 [(rewrite~(simple_distribute_r~...] 0.003 secs (0.003u,0.s)
Chars 2061 - 2091 [(rewrite~(idempotency~(⊔)~x)).] 0.007 secs (0.006u,0.s)
Chars 2094 - 2154 [(rewrite~(commutativity~(f:=jo...] 0.009 secs (0.006u,0.002s)
Chars 2157 - 2200 [(path_via~((x~⊓~(x~⊔~z))~⊓~(y~...] 0.007 secs (0.006u,0.s)
Chars 2203 - 2204 [-] 0. secs (0.u,0.s)
Chars 2205 - 2240 [(rewrite~(meet_join_absorption...] 0.002 secs (0.001u,0.001s)
Chars 2241 - 2253 [reflexivity.] 0. secs (0.u,0.s)
Chars 2256 - 2257 [-] 0. secs (0.u,0.s)
Chars 2258 - 2289 [(rewrite~<-~simple_associativi...] 0.008 secs (0.007u,0.001s)
Chars 2294 - 2317 [(rewrite~<-~distribute_r).] 0.003 secs (0.002u,0.001s)
Chars 2322 - 2334 [reflexivity.] 0. secs (0.u,0.s)
Chars 1959 - 1972 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 1975 - 2015 [(rewrite~(simple_distribute_l~...] 0. secs (0.u,0.s)
Chars 2018 - 2058 [(rewrite~(simple_distribute_r~...] 0. secs (0.u,0.s)
Chars 2061 - 2091 [(rewrite~(idempotency~(⊔)~x)).] 0. secs (0.u,0.s)
Chars 2094 - 2154 [(rewrite~(commutativity~(f:=jo...] 0. secs (0.u,0.s)
Chars 2157 - 2200 [(path_via~((x~⊓~(x~⊔~z))~⊓~(y~...] 0. secs (0.u,0.s)
Chars 2205 - 2240 [(rewrite~(meet_join_absorption...] 0. secs (0.u,0.s)
Chars 2241 - 2253 [reflexivity.] 0. secs (0.u,0.s)
Chars 2258 - 2289 [(rewrite~<-~simple_associativi...] 0. secs (0.u,0.s)
Chars 2294 - 2317 [(rewrite~<-~distribute_r).] 0. secs (0.u,0.s)
Chars 2322 - 2334 [reflexivity.] 0. secs (0.u,0.s)
Chars 2337 - 2341 [Qed.] 0.002 secs (0.002u,0.s)
Chars 2345 - 2408 [#[global]Instance~meet_join_di...] 0. secs (0.u,0.s)
Chars 2411 - 2417 [Proof.] 0. secs (0.u,0.s)
Chars 1208 - 1239 [(destruct~(nat_0_or_pos~x);~au...] 40.21 secs (0.042u,0.037s)
Chars 1240 - 1261 [(right;~apply~pos_ge_1).] 0.023 secs (0.015u,0.006s)
Chars 1262 - 1270 [trivial.] 0. secs (0.u,0.s)
Chars 1208 - 1239 [(destruct~(nat_0_or_pos~x);~au...] 0.001 secs (0.001u,0.s)
Chars 1240 - 1261 [(right;~apply~pos_ge_1).] 0.001 secs (0.001u,0.s)
Chars 1262 - 1270 [trivial.] 0. secs (0.u,0.s)
Chars 1271 - 1275 [Qed.] 0.001 secs (0.u,0.s)
Chars 1277 - 1317 [Lemma~nat_ne_0_pos~x~:~x~<>~0~...] 0.001 secs (0.001u,0.s)
Chars 1318 - 1324 [Proof.] 0. secs (0.u,0.s)
Chars 2592 - 2628 [(srapply~Quotient_ind_hprop;~i...] 40.206 secs (0.045u,0.036s)
Chars 2633 - 2664 [by~simpl;~rewrite~left_inverse.] 0.005 secs (0.004u,0.s)
Chars 2592 - 2628 [(srapply~Quotient_ind_hprop;~i...] 0. secs (0.u,0.s)
Chars 2633 - 2664 [by~simpl;~rewrite~left_inverse.] 0. secs (0.u,0.s)
Chars 2667 - 2671 [Qed.] 0.001 secs (0.001u,0.s)
Chars 2675 - 2785 [#[global]~Instance~quotientgro...] 0. secs (0.u,0.s)
Chars 2788 - 2794 [Proof.] 0. secs (0.u,0.s)
Chars 2913 - 2937 [(apply~rng_moveR_Mr~in~p).] 40.191 secs (0.001u,0.045s)
Chars 2944 - 2971 [(rewrite~rng_plus_comm~in~p).] 0.002 secs (0.002u,0.s)
Chars 2978 - 3007 [(apply~path_prod;~apply~qglue).] 0.011 secs (0.009u,0.001s)
Chars 3014 - 3015 [-] 0. secs (0.u,0.s)
Chars 3016 - 3036 [(change~(I~(-~x~+~0))).] 0.003 secs (0.003u,0.s)
Chars 3045 - 3072 [(apply~ideal_in_negate_plus).] 0.001 secs (0.001u,0.s)
Chars 3081 - 3095 [1:~assumption.] 0. secs (0.u,0.s)
Chars 3104 - 3124 [(apply~ideal_in_zero).] 0.001 secs (0.001u,0.s)
Chars 3131 - 3132 [-] 0. secs (0.u,0.s)
Chars 3133 - 3153 [(change~(J~(-~x~+~1))).] 0.003 secs (0.003u,0.s)
Chars 3162 - 3184 [(rewrite~rng_plus_comm).] 0.002 secs (0.001u,0.s)
Chars 3193 - 3209 [by~rewrite~<-~p.] 0.001 secs (0.001u,0.s)
Chars 2913 - 2937 [(apply~rng_moveR_Mr~in~p).] 0. secs (0.u,0.s)
Chars 2944 - 2971 [(rewrite~rng_plus_comm~in~p).] 0. secs (0.u,0.s)
Chars 2978 - 3007 [(apply~path_prod;~apply~qglue).] 0.002 secs (0.002u,0.s)
Chars 3016 - 3036 [(change~(I~(-~x~+~0))).] 0. secs (0.u,0.s)
Chars 3045 - 3072 [(apply~ideal_in_negate_plus).] 0. secs (0.u,0.s)
Chars 3081 - 3095 [1:~assumption.] 0. secs (0.u,0.s)
Chars 3104 - 3124 [(apply~ideal_in_zero).] 0. secs (0.u,0.s)
Chars 3133 - 3153 [(change~(J~(-~x~+~1))).] 0. secs (0.u,0.s)
Chars 3162 - 3184 [(rewrite~rng_plus_comm).] 0. secs (0.u,0.s)
Chars 3193 - 3209 [by~rewrite~<-~p.] 0. secs (0.u,0.s)
Chars 3214 - 3222 [Defined.] 0.004 secs (0.003u,0.s)
Chars 3228 - 3284 [Lemma~rng_homo_crt_beta_right~...] 0.003 secs (0.003u,0.s)
Chars 3289 - 3295 [Proof.] 0. secs (0.u,0.s)
Chars 8650 - 8712 [exact~(equiv_iff_hprop_uncurri...] 40.157 secs (0.008u,0.025s)
Chars 8650 - 8712 [exact~(equiv_iff_hprop_uncurri...] 0. secs (0.u,0.s)
Chars 8713 - 8721 [Defined.] 0. secs (0.u,0.s)
Chars 8723 - 8821 [Definition~isequiv_surj_emb~{A...] 0. secs (0.u,0.s)
Chars 8822 - 8828 [Proof.] 0. secs (0.u,0.s)
Chars 4413 - 4462 [refine~(_~@~rlucancel_inv~(urn...] 40.107 secs (0.004u,0.02s)
Chars 4465 - 4517 [refine~((rlucancel_inv~(ulnat~...] 0.045 secs (0.031u,0.014s)
Chars 4520 - 4539 [exact~(wlrnat~p~q).] 0.001 secs (0.001u,0.s)
Chars 4413 - 4462 [refine~(_~@~rlucancel_inv~(urn...] 0. secs (0.u,0.s)
Chars 4465 - 4517 [refine~((rlucancel_inv~(ulnat~...] 0. secs (0.u,0.s)
Chars 4520 - 4539 [exact~(wlrnat~p~q).] 0. secs (0.u,0.s)
Chars 4540 - 4548 [Defined.] 0.005 secs (0.002u,0.002s)
Chars 4587 - 4799 [#[local]~Definition~eh_1p_gen~...] 0.026 secs (0.017u,0.008s)
Chars 4800 - 4806 [Proof.] 0. secs (0.u,0.s)
Chars 2420 - 2433 [(intros~x~y~z).] 16.68 secs (0.u,0.03s)
Chars 2434 - 2463 [(rewrite~!(commutativity~_~z)).] 0.047 secs (0.034u,0.013s)
Chars 2466 - 2485 [(apply~distribute_l).] 0.001 secs (0.001u,0.s)
Chars 2420 - 2433 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 2434 - 2463 [(rewrite~!(commutativity~_~z)).] 0. secs (0.u,0.s)
Chars 2466 - 2485 [(apply~distribute_l).] 0. secs (0.u,0.s)
Chars 2488 - 2492 [Qed.] 0.001 secs (0.001u,0.s)
Chars 2496 - 2607 [Lemma~distribute_alt~x~y~z~:~~...] 0.004 secs (0.003u,0.s)
Chars 2610 - 2616 [Proof.] 0. secs (0.u,0.s)
Chars 2799 - 2835 [(srapply~Quotient_ind_hprop;~i...] 15.42 secs (0.048u,0.036s)
Chars 2840 - 2872 [by~simpl;~rewrite~right_inverse.] 0.005 secs (0.004u,0.s)
Chars 2799 - 2835 [(srapply~Quotient_ind_hprop;~i...] 0. secs (0.u,0.s)
Chars 2840 - 2872 [by~simpl;~rewrite~right_inverse.] 0. secs (0.u,0.s)
Chars 2875 - 2879 [Qed.] 0.001 secs (0.001u,0.s)
Chars 2883 - 2956 [#[global]~Instance~isgroup_quo...] 0.001 secs (0.001u,0.s)
Chars 2958 - 2986 [End~GroupCongruenceQuotient.] 0.04 secs (0.034u,0.005s)
Chars 3055 - 3077 [Section~QuotientGroup.] 0. secs (0.u,0.s)
Chars 3081 - 3124 [Context~(G~:~Group)~(N~:~Norma...] 0. secs (0.u,0.s)
Chars 3128 - 3196 [#[global]Instance~iscongruence...] 0. secs (0.u,0.s)
Chars 3199 - 3205 [Proof.] 0. secs (0.u,0.s)
Chars 6660 - 6682 [unshelve~econstructor.] 40.145 secs (0.001u,0.028s)
Chars 6685 - 6686 [-] 0. secs (0.u,0.s)
Chars 6687 - 6695 [exact~T.] 0. secs (0.u,0.s)
Chars 6698 - 6699 [-] 0. secs (0.u,0.s)
Chars 6700 - 6711 [assumption.] 0. secs (0.u,0.s)
Chars 6714 - 6715 [-] 0. secs (0.u,0.s)
Chars 6716 - 6728 [exact~idmap.] 0. secs (0.u,0.s)
Chars 6660 - 6682 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 6687 - 6695 [exact~T.] 0. secs (0.u,0.s)
Chars 6700 - 6711 [assumption.] 0. secs (0.u,0.s)
Chars 6716 - 6728 [exact~idmap.] 0. secs (0.u,0.s)
Chars 6729 - 6737 [Defined.] 0. secs (0.u,0.s)
Chars 6739 - 6838 [Definition~reflects_in~(O~:~Su...] 0. secs (0.u,0.s)
Chars 6839 - 6845 [Proof.] 0. secs (0.u,0.s)
Chars 6848 - 6895 [(constructor;~intros;~rapply~o...] 1.182 secs (0.005u,0.026s)
Chars 6848 - 6895 [(constructor;~intros;~rapply~o...] 0. secs (0.u,0.s)
Chars 6896 - 6904 [Defined.] 0. secs (0.u,0.s)
Chars 6984 - 7194 [Record~ReflectiveSubuniverse@{...] 0.002 secs (0.001u,0.s)
Chars 7196 - 7257 [Coercion~rsu_subuniv~:~Reflect...] 0. secs (0.u,0.s)
Chars 7258 - 7299 [#[global]Existing~Instance~rsu...] 0. secs (0.u,0.s)
Chars 7300 - 7338 [#[global]Existing~Instance~rsu...] 0. secs (0.u,0.s)
Chars 7717 - 7809 [Definition~rsu_reflector~(O~:~...] 0. secs (0.u,0.s)
Chars 7811 - 7871 [Coercion~rsu_reflector~:~Refle...] 0. secs (0.u,0.s)
Chars 8003 - 8022 [Section~ORecursion.] 0. secs (0.u,0.s)
Chars 8025 - 8097 [Context~{O~:~Subuniverse}~{P~Q...] 0. secs (0.u,0.s)
Chars 8101 - 8201 [Definition~O_rec~(f~:~P~->~Q)~...] 0.002 secs (0.002u,0.s)
Chars 8205 - 8324 [Definition~O_rec_beta~(f~:~P~-...] 0.002 secs (0.002u,0.s)
Chars 8328 - 8485 [Definition~O_indpaths~(g~h~:~O...] 0.006 secs (0.005u,0.s)
Chars 8489 - 8692 [Definition~O_indpaths_beta~(g~...] 0.007 secs (0.006u,0.001s)
Chars 8696 - 8885 [Definition~O_ind2paths~{g~h~:~...] 0.009 secs (0.007u,0.002s)
Chars 8889 - 9121 [Definition~O_ind2paths_beta~{g...] 0.009 secs (0.007u,0.001s)
Chars 9181 - 9196 [End~ORecursion.] 0.002 secs (0.002u,0.s)
Chars 9244 - 9274 [Arguments~O_rec~:~simpl~never.] 0. secs (0.u,0.s)
Chars 9275 - 9310 [Arguments~O_rec_beta~:~simpl~n...] 0. secs (0.u,0.s)
Chars 9311 - 9346 [Arguments~O_indpaths~:~simpl~n...] 0. secs (0.u,0.s)
Chars 9347 - 9387 [Arguments~O_indpaths_beta~:~si...] 0. secs (0.u,0.s)
Chars 9388 - 9424 [Arguments~O_ind2paths~:~simpl~...] 0. secs (0.u,0.s)
Chars 9425 - 9466 [Arguments~O_ind2paths_beta~:~s...] 0. secs (0.u,0.s)
Chars 9749 - 10179 [Ltac~~strip_reflections~:=~~~p...] 0. secs (0.u,0.s)
Chars 10267 - 10457 [#[global]~Instance~isequiv_o_t...] 0.005 secs (0.004u,0.s)
Chars 10459 - 10635 [Definition~equiv_o_to_O~`{Fune...] 0.008 secs (0.008u,0.s)
Chars 10761 - 10949 [#[global]~Instance~isequiv_O_r...] 0.041 secs (0.034u,0.007s)
Chars 11081 - 11112 [Section~Reflective_Subuniverse.] 0. secs (0.u,0.s)
Chars 11115 - 11151 [Context~(O~:~ReflectiveSubuniv...] 0. secs (0.u,0.s)
Chars 11200 - 11310 [Definition~O_rec_homotopy~{P~Q...] 0.002 secs (0.002u,0.s)
Chars 11313 - 11319 [Proof.] 0. secs (0.u,0.s)
Chars 1931 - 1940 [(intros~?).] 40.178 secs (0.001u,0.033s)
Chars 1945 - 2011 [(apply~path_iff_hprop;~hor_int...] 0.141 secs (0.12u,0.02s)
Chars 2016 - 2033 [by~apply~tr,~inr.] 0.001 secs (0.001u,0.s)
Chars 1931 - 1940 [(intros~?).] 0. secs (0.u,0.s)
Chars 1945 - 2011 [(apply~path_iff_hprop;~hor_int...] 0. secs (0.u,0.s)
Chars 2016 - 2033 [by~apply~tr,~inr.] 0. secs (0.u,0.s)
Chars 2036 - 2044 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2048 - 2104 [Instance~rightidentity_hor~:~(...] 0. secs (0.u,0.s)
Chars 2107 - 2113 [Proof.] 0. secs (0.u,0.s)
Chars 2118 - 2127 [(intros~?).] 3.636 secs (0.u,0.034s)
Chars 2132 - 2198 [(apply~path_iff_hprop;~hor_int...] 0.132 secs (0.109u,0.022s)
Chars 2203 - 2220 [by~apply~tr,~inl.] 0.001 secs (0.001u,0.s)
Chars 2118 - 2127 [(intros~?).] 0. secs (0.u,0.s)
Chars 2132 - 2198 [(apply~path_iff_hprop;~hor_int...] 0. secs (0.u,0.s)
Chars 2203 - 2220 [by~apply~tr,~inl.] 0. secs (0.u,0.s)
Chars 2223 - 2231 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2235 - 2290 [Instance~leftidentity_hand~:~(...] 0. secs (0.u,0.s)
Chars 2293 - 2299 [Proof.] 0. secs (0.u,0.s)
Chars 5622 - 5634 [(induction~w).] 40.149 secs (0.002u,0.032s)
Chars 5639 - 5640 [-] 0. secs (0.u,0.s)
Chars 5641 - 5652 [assumption.] 0.001 secs (0.001u,0.s)
Chars 5657 - 5658 [-] 0. secs (0.u,0.s)
Chars 5659 - 5679 [(destruct~a~as~[x~a]).] 0.004 secs (0.003u,0.s)
Chars 5680 - 5690 [(apply~IHw).] 0.004 secs (0.004u,0.s)
Chars 5691 - 5699 [(apply~P).] 0.002 secs (0.002u,0.s)
Chars 5622 - 5634 [(induction~w).] 0. secs (0.u,0.s)
Chars 5641 - 5652 [assumption.] 0. secs (0.u,0.s)
Chars 5659 - 5679 [(destruct~a~as~[x~a]).] 0.001 secs (0.001u,0.s)
Chars 5680 - 5690 [(apply~IHw).] 0.001 secs (0.u,0.s)
Chars 5691 - 5699 [(apply~P).] 0.001 secs (0.u,0.s)
Chars 5702 - 5710 [Defined.] 0.003 secs (0.002u,0.s)
Chars 6010 - 6269 [Lemma~path_homomorphism_ap_ope...] 0.003 secs (0.002u,0.s)
Chars 6272 - 6278 [Proof.] 0. secs (0.u,0.s)
Chars 10359 - 10369 [(pattern~f).] 40.078 secs (0.003u,0.015s)
Chars 10372 - 10424 [(refine~(equiv_ind~(equiv_path...] 0.005 secs (0.005u,0.s)
Chars 10629 - 10744 [refine~~(_~@~~~ap_transport_Vp...] 0.009 secs (0.009u,0.s)
Chars 10747 - 10762 [(apply~whiskerR).] 0.008 secs (0.005u,0.002s)
Chars 10763 - 10777 [(apply~concat2).] 0.007 secs (0.007u,0.s)
Chars 10780 - 10781 [-] 0. secs (0.u,0.s)
Chars 10782 - 10791 [(apply~ap).] 0.004 secs (0.004u,0.s)
Chars 10792 - 10833 [(apply~transport_path_universe...] 0.004 secs (0.004u,0.s)
Chars 10836 - 10837 [-] 0. secs (0.u,0.s)
Chars 10838 - 10881 [(apply~transport_path_universe...] 0.006 secs (0.005u,0.s)
Chars 10359 - 10369 [(pattern~f).] 0.001 secs (0.001u,0.s)
Chars 10372 - 10424 [(refine~(equiv_ind~(equiv_path...] 0.002 secs (0.002u,0.s)
Chars 10629 - 10744 [refine~~(_~@~~~ap_transport_Vp...] 0.001 secs (0.u,0.001s)
Chars 10747 - 10762 [(apply~whiskerR).] 0.002 secs (0.002u,0.s)
Chars 10763 - 10777 [(apply~concat2).] 0.001 secs (0.001u,0.s)
Chars 10782 - 10791 [(apply~ap).] 0.001 secs (0.u,0.s)
Chars 10792 - 10833 [(apply~transport_path_universe...] 0. secs (0.u,0.s)
Chars 10838 - 10881 [(apply~transport_path_universe...] 0.001 secs (0.001u,0.s)
Chars 10882 - 10890 [Defined.] 0.034 secs (0.031u,0.001s)
Chars 10892 - 11240 [Definition~transport_path_univ...] 0.008 secs (0.006u,0.001s)
Chars 11295 - 11475 [Theorem~transport_arrow_tocons...] 0.004 secs (0.004u,0.s)
Chars 11476 - 11482 [Proof.] 0. secs (0.u,0.s)
Chars 4845 - 4853 [intro~u.] 40.17 secs (0.001u,0.035s)
Chars 4858 - 4922 [(eapply~oppreserving_third_sur...] 0.004 secs (0.004u,0.s)
Chars 4845 - 4853 [intro~u.] 0. secs (0.u,0.s)
Chars 4858 - 4922 [(eapply~oppreserving_third_sur...] 0.001 secs (0.001u,0.s)
Chars 4925 - 4933 [Defined.] 0. secs (0.u,0.s)
Chars 4937 - 5044 [Definition~hom_third_surjectio...] 0.003 secs (0.001u,0.001s)
Chars 5048 - 5150 [#[global]~Instance~surjection_...] 0.001 secs (0.001u,0.s)
Chars 5153 - 5159 [Proof.] 0. secs (0.u,0.s)
Chars 18285 - 18338 [(refine~(Localize_ind~f~X~(fun...] 40.178 secs (0.001u,0.033s)
Chars 18343 - 18373 [(apply~ooextendable_over_const).] 0.001 secs (0.001u,0.s)
Chars 18378 - 18405 [(apply~ooextendable_islocal).] 0.001 secs (0.001u,0.s)
Chars 18285 - 18338 [(refine~(Localize_ind~f~X~(fun...] 0. secs (0.u,0.s)
Chars 18343 - 18373 [(apply~ooextendable_over_const).] 0. secs (0.u,0.s)
Chars 18378 - 18405 [(apply~ooextendable_islocal).] 0. secs (0.u,0.s)
Chars 18408 - 18416 [Defined.] 0. secs (0.u,0.s)
Chars 18420 - 18564 [Definition~local_rec~{X}~`{IsL...] 0.003 secs (0.003u,0.s)
Chars 18568 - 18726 [Definition~local_rec_beta~{X}~...] 0.003 secs (0.002u,0.s)
Chars 18730 - 18913 [Definition~local_indpaths~{X}~...] 0.007 secs (0.005u,0.001s)
Chars 18917 - 19133 [Definition~local_indpaths_beta...] 0.009 secs (0.008u,0.s)
Chars 19135 - 19150 [End~LocalTypes.] 0.005 secs (0.004u,0.001s)
Chars 19152 - 19186 [Arguments~local_rec~:~simpl~ne...] 0. secs (0.u,0.s)
Chars 19187 - 19226 [Arguments~local_rec_beta~:~sim...] 0. secs (0.u,0.s)
Chars 19227 - 19266 [Arguments~local_indpaths~:~sim...] 0. secs (0.u,0.s)
Chars 19267 - 19311 [Arguments~local_indpaths_beta~...] 0. secs (0.u,0.s)
Chars 19493 - 19583 [#[global]~Instance~accrsu_loc@...] 0. secs (0.u,0.s)
Chars 19584 - 19590 [Proof.] 0. secs (0.u,0.s)
Chars 4809 - 4824 [revert~q~theta.] 28.366 secs (25.592u,0.159s)
Chars 2304 - 2313 [(intros~?).] 6.373 secs (-4.237u,-0.615s)
Chars 1325 - 1331 [split.] 40.154 secs (0.001u,0.023s)
Chars 1332 - 1333 [-] 0. secs (0.u,0.s)
Chars 1334 - 1366 [(destruct~(nat_0_or_pos~x);~au...] 0.005 secs (0.004u,0.s)
Chars 1369 - 1397 [(intros~E;~destruct~E;~trivial).] 0.003 secs (0.003u,0.s)
Chars 1398 - 1399 [-] 0. secs (0.u,0.s)
Chars 1400 - 1413 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 1414 - 1431 [(rewrite~E2~in~E1).] 0.001 secs (0.001u,0.s)
Chars 1432 - 1463 [(destruct~(irreflexivity~(<)~0)).] 0.007 secs (0.006u,0.s)
Chars 1464 - 1472 [trivial.] 0. secs (0.u,0.s)
Chars 1325 - 1331 [split.] 0. secs (0.u,0.s)
Chars 1334 - 1366 [(destruct~(nat_0_or_pos~x);~au...] 0.001 secs (0.001u,0.s)
Chars 1369 - 1397 [(intros~E;~destruct~E;~trivial).] 0.001 secs (0.001u,0.s)
Chars 1400 - 1413 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 1414 - 1431 [(rewrite~E2~in~E1).] 0. secs (0.u,0.s)
Chars 1432 - 1463 [(destruct~(irreflexivity~(<)~0)).] 0. secs (0.u,0.s)
Chars 1464 - 1472 [trivial.] 0. secs (0.u,0.s)
Chars 1473 - 1477 [Qed.] 0.001 secs (0.001u,0.s)
Chars 1479 - 1522 [Lemma~nat_ne_0_ge_1~x~:~x~<>~0...] 0.001 secs (0.001u,0.s)
Chars 1523 - 1529 [Proof.] 0. secs (0.u,0.s)
Chars 3302 - 3326 [(apply~rng_moveR_rM~in~p).] 40.183 secs (0.003u,0.044s)
Chars 3333 - 3360 [(rewrite~rng_plus_comm~in~p).] 0.002 secs (0.002u,0.s)
Chars 3367 - 3396 [(apply~path_prod;~apply~qglue).] 0.011 secs (0.009u,0.001s)
Chars 3403 - 3404 [-] 0. secs (0.u,0.s)
Chars 3405 - 3425 [(change~(I~(-~y~+~1))).] 0.003 secs (0.003u,0.s)
Chars 3434 - 3450 [by~rewrite~<-~p.] 0.001 secs (0.001u,0.s)
Chars 3457 - 3458 [-] 0. secs (0.u,0.s)
Chars 3459 - 3479 [(change~(J~(-~y~+~0))).] 0.003 secs (0.003u,0.s)
Chars 3488 - 3515 [(apply~ideal_in_negate_plus).] 0.001 secs (0.001u,0.s)
Chars 3524 - 3538 [1:~assumption.] 0. secs (0.u,0.s)
Chars 3547 - 3567 [(apply~ideal_in_zero).] 0.001 secs (0.001u,0.s)
Chars 3302 - 3326 [(apply~rng_moveR_rM~in~p).] 0. secs (0.u,0.s)
Chars 3333 - 3360 [(rewrite~rng_plus_comm~in~p).] 0. secs (0.u,0.s)
Chars 3367 - 3396 [(apply~path_prod;~apply~qglue).] 0.002 secs (0.002u,0.s)
Chars 3405 - 3425 [(change~(I~(-~y~+~1))).] 0. secs (0.u,0.s)
Chars 3434 - 3450 [by~rewrite~<-~p.] 0. secs (0.u,0.s)
Chars 3459 - 3479 [(change~(J~(-~y~+~0))).] 0. secs (0.u,0.s)
Chars 3488 - 3515 [(apply~ideal_in_negate_plus).] 0. secs (0.u,0.s)
Chars 3524 - 3538 [1:~assumption.] 0. secs (0.u,0.s)
Chars 3547 - 3567 [(apply~ideal_in_zero).] 0. secs (0.u,0.s)
Chars 3572 - 3580 [Defined.] 0.018 secs (0.014u,0.003s)
Chars 3584 - 3606 [End~rng_homo_crt_beta.] 0.018 secs (0.016u,0.001s)
Chars 3690 - 3779 [#[global]~Instance~issurjectio...] 0.001 secs (0.001u,0.s)
Chars 3782 - 3788 [Proof.] 0. secs (0.u,0.s)
Chars 8831 - 8883 [(apply~(@isequiv_conn_ino_map~...] 40.153 secs (0.002u,0.024s)
Chars 8831 - 8883 [(apply~(@isequiv_conn_ino_map~...] 0. secs (0.u,0.s)
Chars 8884 - 8892 [Defined.] 0. secs (0.u,0.s)
Chars 9076 - 9417 [Ltac~~strip_truncations~:=~~~p...] 0. secs (0.u,0.s)
Chars 9711 - 9794 [Definition~O_leq_Tr_leq~{n~m~:...] 0. secs (0.u,0.s)
Chars 9795 - 9801 [Proof.] 0. secs (0.u,0.s)
Chars 4809 - 4824 [revert~q~theta.] 40.052 secs (0.004u,0.023s)
Chars 4827 - 4861 [snrapply~equiv_path_ind_rlucan...] 0.028 secs (0.02u,0.008s)
Chars 4864 - 4878 [by~destruct~p.] 0.026 secs (0.018u,0.007s)
Chars 4809 - 4824 [revert~q~theta.] 0.003 secs (0.003u,0.s)
Chars 4827 - 4861 [snrapply~equiv_path_ind_rlucan...] 0.004 secs (0.003u,0.s)
Chars 4864 - 4878 [by~destruct~p.] 0.004 secs (0.004u,0.s)
Chars 4879 - 4887 [Defined.] 0.031 secs (0.024u,0.006s)
Chars 4889 - 4983 [Definition~eh_1p~{X}~{a~:~X}~(...] 0.003 secs (0.002u,0.s)
Chars 4984 - 4990 [Proof.] 0. secs (0.u,0.s)
Chars 2619 - 2678 [(rewrite~(distribute_r~x~y~(x~...] 40.173 secs (0.005u,0.03s)
Chars 2681 - 2718 [(rewrite~(distribute_r~_~_~(y~...] 0.004 secs (0.003u,0.s)
Chars 2721 - 2750 [(rewrite~(distribute_l~x~y~z)).] 0.003 secs (0.003u,0.s)
Chars 2753 - 2819 [(rewrite~(commutativity~y~(x~⊓...] 0.016 secs (0.014u,0.001s)
Chars 2822 - 2851 [(rewrite~join_meet_absorption).] 0.003 secs (0.003u,0.s)
Chars 2854 - 2883 [(rewrite~(distribute_r~x~z~y)).] 0.004 secs (0.004u,0.s)
Chars 2886 - 2924 [(rewrite~(commutativity~(f:=jo...] 0.008 secs (0.008u,0.s)
Chars 2927 - 2971 [(rewrite~(commutativity~(x~⊔~y...] 0.005 secs (0.005u,0.s)
Chars 2974 - 3039 [(rewrite~simple_associativity,...] 0.014 secs (0.012u,0.002s)
Chars 3042 - 3068 [(rewrite~(idempotency~_~_)).] 0.005 secs (0.004u,0.001s)
Chars 3071 - 3115 [(rewrite~(commutativity~(x~⊔~z...] 0.006 secs (0.003u,0.002s)
Chars 3118 - 3130 [reflexivity.] 0. secs (0.u,0.s)
Chars 2619 - 2678 [(rewrite~(distribute_r~x~y~(x~...] 0. secs (0.u,0.s)
Chars 2681 - 2718 [(rewrite~(distribute_r~_~_~(y~...] 0. secs (0.u,0.s)
Chars 2721 - 2750 [(rewrite~(distribute_l~x~y~z)).] 0. secs (0.u,0.s)
Chars 2753 - 2819 [(rewrite~(commutativity~y~(x~⊓...] 0. secs (0.u,0.s)
Chars 2822 - 2851 [(rewrite~join_meet_absorption).] 0. secs (0.u,0.s)
Chars 2854 - 2883 [(rewrite~(distribute_r~x~z~y)).] 0. secs (0.u,0.s)
Chars 2886 - 2924 [(rewrite~(commutativity~(f:=jo...] 0. secs (0.u,0.s)
Chars 2927 - 2971 [(rewrite~(commutativity~(x~⊔~y...] 0. secs (0.u,0.s)
Chars 2974 - 3039 [(rewrite~simple_associativity,...] 0. secs (0.u,0.s)
Chars 3042 - 3068 [(rewrite~(idempotency~_~_)).] 0. secs (0.u,0.s)
Chars 3071 - 3115 [(rewrite~(commutativity~(x~⊔~z...] 0. secs (0.u,0.s)
Chars 3118 - 3130 [reflexivity.] 0. secs (0.u,0.s)
Chars 3133 - 3137 [Qed.] 0.006 secs (0.006u,0.s)
Chars 3138 - 3169 [End~distributive_lattice_props.] 0.014 secs (0.014u,0.s)
Chars 3171 - 3201 [Section~lower_bounded_lattice.] 0. secs (0.u,0.s)
Chars 3204 - 3270 [Context~`{IsLattice~L}~`{Botto...] 0.001 secs (0.u,0.s)
Chars 3274 - 3326 [#[global]Instance~meet_bottom_...] 0. secs (0.u,0.s)
Chars 3329 - 3335 [Proof.] 0. secs (0.u,0.s)
Chars 3210 - 3237 [srapply~Build_IsCongruence.] 40.154 secs (0.002u,0.028s)
Chars 3242 - 3274 [(intros;~by~apply~in_cosetL_co...] 0.002 secs (0.002u,0.s)
Chars 3210 - 3237 [srapply~Build_IsCongruence.] 0. secs (0.u,0.s)
Chars 3242 - 3274 [(intros;~by~apply~in_cosetL_co...] 0. secs (0.u,0.s)
Chars 3277 - 3285 [Defined.] 0.013 secs (0.011u,0.001s)
Chars 3289 - 3356 [#[global]Instance~iscongruence...] 0. secs (0.u,0.s)
Chars 3359 - 3365 [Proof.] 0. secs (0.u,0.s)
Chars 11324 - 11350 [(apply~O_indpaths;~intro~x).] 40.121 secs (0.003u,0.026s)
Chars 11355 - 11369 [etransitivity.] 0.002 secs (0.002u,0.s)
Chars 11374 - 11375 [{] 0. secs (0.u,0.s)
Chars 11376 - 11393 [(apply~O_rec_beta).] 0.001 secs (0.001u,0.s)
Chars 11394 - 11395 [}] 0. secs (0.u,0.s)
Chars 11400 - 11401 [{] 0. secs (0.u,0.s)
Chars 11402 - 11416 [etransitivity.] 0.001 secs (0.001u,0.s)
Chars 11423 - 11424 [{] 0. secs (0.u,0.s)
Chars 11425 - 11438 [exact~(pi~_).] 0. secs (0.u,0.s)
Chars 11439 - 11440 [}] 0. secs (0.u,0.s)
Chars 11447 - 11448 [{] 0. secs (0.u,0.s)
Chars 11449 - 11476 [(symmetry;~apply~O_rec_beta).] 0.003 secs (0.002u,0.s)
Chars 11477 - 11478 [}] 0. secs (0.u,0.s)
Chars 11479 - 11480 [}] 0. secs (0.u,0.s)
Chars 11324 - 11350 [(apply~O_indpaths;~intro~x).] 0.001 secs (0.001u,0.s)
Chars 11355 - 11369 [etransitivity.] 0. secs (0.u,0.s)
Chars 11376 - 11393 [(apply~O_rec_beta).] 0. secs (0.u,0.s)
Chars 11402 - 11416 [etransitivity.] 0. secs (0.u,0.s)
Chars 11425 - 11438 [exact~(pi~_).] 0. secs (0.u,0.s)
Chars 11449 - 11476 [(symmetry;~apply~O_rec_beta).] 0. secs (0.u,0.s)
Chars 11483 - 11491 [Defined.] 0.001 secs (0.u,0.s)
Chars 11567 - 11635 [Definition~isequiv_to_O_inO~(T...] 0. secs (0.u,0.s)
Chars 11638 - 11644 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 2304 - 2313 [(intros~?).] 40.07 secs (0.u,0.034s)
Chars 2318 - 2352 [(apply~path_trunctype,~prod_un...] 0.001 secs (0.001u,0.s)
Chars 2304 - 2313 [(intros~?).] 0. secs (0.u,0.s)
Chars 2318 - 2352 [(apply~path_trunctype,~prod_un...] 0. secs (0.u,0.s)
Chars 2355 - 2363 [Defined.] 0. secs (0.u,0.s)
Chars 2367 - 2424 [Instance~rightidentity_hand~:~...] 0. secs (0.u,0.s)
Chars 2427 - 2433 [Proof.] 0. secs (0.u,0.s)
Chars 6283 - 6294 [(intros~u~a).] 40.147 secs (0.u,0.031s)
Chars 6295 - 6335 [by~apply~path_oppreserving_ap_...] 0.002 secs (0.002u,0.s)
Chars 6283 - 6294 [(intros~u~a).] 0. secs (0.u,0.s)
Chars 6295 - 6335 [by~apply~path_oppreserving_ap_...] 0. secs (0.u,0.s)
Chars 6338 - 6346 [Defined.] 0. secs (0.u,0.s)
Chars 6347 - 6377 [End~homomorphism_ap_operation.] 0.01 secs (0.009u,0.s)
Chars 6484 - 6499 [Section~hom_id.] 0. secs (0.u,0.s)
Chars 6502 - 6532 [Context~{σ}~(A~:~Algebra~σ).] 0. secs (0.u,0.s)
Chars 6536 - 6612 [#[global]Instance~is_homomorph...] 0. secs (0.u,0.s)
Chars 6615 - 6621 [Proof.] 0. secs (0.u,0.s)
Chars 11485 - 11494 [(intros~f).] 40.102 secs (0.001u,0.015s)
Chars 11495 - 11504 [funext~y.] 0.001 secs (0.001u,0.s)
Chars 11507 - 11550 [refine~(transport_arrow_tocons...] 0.002 secs (0.001u,0.s)
Chars 11553 - 11562 [(apply~ap).] 0.001 secs (0.001u,0.s)
Chars 11565 - 11597 [(apply~transport_path_universe...] 0.001 secs (0.001u,0.s)
Chars 11485 - 11494 [(intros~f).] 0. secs (0.u,0.s)
Chars 11495 - 11504 [funext~y.] 0. secs (0.u,0.s)
Chars 11507 - 11550 [refine~(transport_arrow_tocons...] 0. secs (0.u,0.s)
Chars 11553 - 11562 [(apply~ap).] 0. secs (0.u,0.s)
Chars 11565 - 11597 [(apply~transport_path_universe...] 0. secs (0.u,0.s)
Chars 11598 - 11606 [Defined.] 0.001 secs (0.001u,0.s)
Chars 11627 - 11760 [Definition~equiv_path2_univers...] 0.005 secs (0.004u,0.s)
Chars 11761 - 11767 [Proof.] 0. secs (0.u,0.s)
Chars 2438 - 2447 [(intros~?).] 2.111 secs (0.u,0.034s)
Chars 2452 - 2486 [(apply~path_trunctype,~prod_un...] 0.001 secs (0.001u,0.s)
Chars 2438 - 2447 [(intros~?).] 0. secs (0.u,0.s)
Chars 2452 - 2486 [(apply~path_trunctype,~prod_un...] 0. secs (0.u,0.s)
Chars 2489 - 2497 [Defined.] 0. secs (0.u,0.s)
Chars 2501 - 2552 [Instance~absorption_hor_hand~:...] 0.001 secs (0.001u,0.s)
Chars 2555 - 2561 [Proof.] 0. secs (0.u,0.s)
Chars 5164 - 5188 [(apply~BuildIsSurjection).] 40.192 secs (0.001u,0.037s)
Chars 5193 - 5231 [refine~(quotient_ind_prop~(Φ~s...] 0.009 secs (0.008u,0.s)
Chars 5236 - 5244 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 5249 - 5258 [(apply~tr).] 0.002 secs (0.002u,0.s)
Chars 5263 - 5293 [by~exists~(class_of~(Ψ~s)~x).] 0.003 secs (0.002u,0.s)
Chars 5164 - 5188 [(apply~BuildIsSurjection).] 0. secs (0.u,0.s)
Chars 5193 - 5231 [refine~(quotient_ind_prop~(Φ~s...] 0. secs (0.u,0.s)
Chars 5236 - 5244 [intro~x.] 0. secs (0.u,0.s)
Chars 5249 - 5258 [(apply~tr).] 0. secs (0.u,0.s)
Chars 5263 - 5293 [by~exists~(class_of~(Ψ~s)~x).] 0. secs (0.u,0.s)
Chars 5296 - 5300 [Qed.] 0.004 secs (0.004u,0.s)
Chars 5304 - 5354 [#[local]Notation~Θ~:=~(cong_qu...] 0. secs (0.u,0.s)
Chars 5358 - 5459 [Lemma~path_quotient_algebras_t...] 0.01 secs (0.009u,0.s)
Chars 5462 - 5468 [Proof.] 0. secs (0.u,0.s)
Chars 19593 - 19615 [unshelve~econstructor.] 40.177 secs (0.u,0.032s)
Chars 19618 - 19619 [-] 0. secs (0.u,0.s)
Chars 19620 - 19628 [exact~f.] 0. secs (0.u,0.s)
Chars 19631 - 19632 [-] 0. secs (0.u,0.s)
Chars 19633 - 19660 [(intros;~split;~apply~idmap).] 0.002 secs (0.001u,0.s)
Chars 19593 - 19615 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 19620 - 19628 [exact~f.] 0. secs (0.u,0.s)
Chars 19633 - 19660 [(intros;~split;~apply~idmap).] 0. secs (0.u,0.s)
Chars 19661 - 19669 [Defined.] 0. secs (0.u,0.s)
Chars 20055 - 20186 [Definition~lift_accrsu@{a~i~j}...] 0. secs (0.u,0.s)
Chars 20291 - 20419 [#[global]~Instance~O_eq_lift_a...] 0. secs (0.u,0.s)
Chars 20420 - 20426 [Proof.] 0. secs (0.u,0.s)
Chars 1530 - 1544 [etransitivity.] 40.184 secs (0.018u,0.028s)
Chars 1545 - 1546 [-] 0. secs (0.u,0.s)
Chars 1547 - 1566 [(apply~nat_ne_0_pos).] 0.001 secs (0.001u,0.s)
Chars 1567 - 1568 [-] 0. secs (0.u,0.s)
Chars 1569 - 1584 [(apply~pos_ge_1).] 0.018 secs (0.016u,0.001s)
Chars 1530 - 1544 [etransitivity.] 0. secs (0.u,0.s)
Chars 1547 - 1566 [(apply~nat_ne_0_pos).] 0. secs (0.u,0.s)
Chars 1569 - 1584 [(apply~pos_ge_1).] 0. secs (0.u,0.s)
Chars 1585 - 1589 [Qed.] 0.001 secs (0.001u,0.s)
Chars 1591 - 1669 [#[global]~Instance:~(forall~z~...] 0.001 secs (0.u,0.s)
Chars 1670 - 1676 [Proof.] 0. secs (0.u,0.s)
Chars 3793 - 3802 [(intros~c).] 40.197 secs (0.u,0.044s)
Chars 3962 - 3991 [(apply~equiv_coprime_sum~in~c).] 0.003 secs (0.003u,0.s)
Chars 4063 - 4081 [strip_truncations.] 0.06 secs (0.05u,0.009s)
Chars 4146 - 4209 [(destruct~c~as~[[[x~ix]~[y~jy]...] 0.012 secs (0.011u,0.s)
Chars 4262 - 4301 [(apply~(issurjection_rng_homo_...] 0.002 secs (0.002u,0.s)
Chars 4306 - 4352 [1:~exact~(rng_homo_crt_beta_le...] 0.002 secs (0.002u,0.s)
Chars 4357 - 4401 [exact~(rng_homo_crt_beta_right...] 0.002 secs (0.002u,0.s)
Chars 3793 - 3802 [(intros~c).] 0. secs (0.u,0.s)
Chars 3962 - 3991 [(apply~equiv_coprime_sum~in~c).] 0. secs (0.u,0.s)
Chars 4063 - 4081 [strip_truncations.] 0.001 secs (0.001u,0.s)
Chars 4146 - 4209 [(destruct~c~as~[[[x~ix]~[y~jy]...] 0.002 secs (0.001u,0.s)
Chars 4262 - 4301 [(apply~(issurjection_rng_homo_...] 0. secs (0.u,0.s)
Chars 4306 - 4352 [1:~exact~(rng_homo_crt_beta_le...] 0. secs (0.u,0.s)
Chars 4357 - 4401 [exact~(rng_homo_crt_beta_right...] 0. secs (0.u,0.s)
Chars 4404 - 4412 [Defined.] 0.006 secs (0.006u,0.s)
Chars 4462 - 4488 [Context~(c~:~Coprime~I~J).] 0. secs (0.u,0.s)
Chars 4531 - 4602 [Theorem~chinese_remainder~:~R~...] 0.003 secs (0.003u,0.s)
Chars 4605 - 4611 [Proof.] 0. secs (0.u,0.s)
Chars 9804 - 9833 [(intros~A;~rapply~istrunc_leq).] 40.129 secs (0.002u,0.026s)
Chars 9804 - 9833 [(intros~A;~rapply~istrunc_leq).] 0. secs (0.u,0.s)
Chars 9834 - 9842 [Defined.] 0. secs (0.u,0.s)
Chars 9844 - 9918 [Definition~Trunc_min~n~m~X~:~T...] 0.001 secs (0.u,0.s)
Chars 9919 - 9925 [Proof.] 0. secs (0.u,0.s)
Chars 4993 - 5023 [exact~(eh_1p_gen~p~(urnat~p)).] 40.1 secs (0.007u,0.02s)
Chars 4993 - 5023 [exact~(eh_1p_gen~p~(urnat~p)).] 0. secs (0.u,0.s)
Chars 5024 - 5032 [Defined.] 0.004 secs (0.003u,0.s)
Chars 5034 - 5246 [#[local]~Definition~eh_p1_gen~...] 0.024 secs (0.018u,0.005s)
Chars 5247 - 5253 [Proof.] 0. secs (0.u,0.s)
Chars 5256 - 5271 [revert~q~theta.] 0.265 secs (0.006u,0.02s)
Chars 5274 - 5308 [snrapply~equiv_path_ind_rlucan...] 0.059 secs (0.042u,0.017s)
Chars 5311 - 5325 [by~destruct~p.] 0.029 secs (0.024u,0.005s)
Chars 5256 - 5271 [revert~q~theta.] 0.004 secs (0.002u,0.002s)
Chars 5274 - 5308 [snrapply~equiv_path_ind_rlucan...] 0.004 secs (0.003u,0.s)
Chars 5311 - 5325 [by~destruct~p.] 0.004 secs (0.001u,0.002s)
Chars 5326 - 5334 [Defined.] 0.031 secs (0.024u,0.006s)
Chars 5336 - 5430 [Definition~eh_p1~{X}~{a~:~X}~(...] 0.002 secs (0.001u,0.s)
Chars 5431 - 5437 [Proof.] 0. secs (0.u,0.s)
Chars 3338 - 3347 [(intros~x).] 39.276 secs (28.708u,-0.14s)
Chars 3338 - 3347 [(intros~x).] 40.068 secs (0.u,0.031s)
Chars 3348 - 3388 [(rewrite~<-~(join_bottom_l~x),...] 0.004 secs (0.004u,0.s)
Chars 3391 - 3399 [trivial.] 0. secs (0.u,0.s)
Chars 3338 - 3347 [(intros~x).] 0. secs (0.u,0.s)
Chars 3348 - 3388 [(rewrite~<-~(join_bottom_l~x),...] 0. secs (0.u,0.s)
Chars 3391 - 3399 [trivial.] 0. secs (0.u,0.s)
Chars 3402 - 3406 [Qed.] 0. secs (0.u,0.s)
Chars 3410 - 3463 [#[global]Instance~meet_bottom_...] 0.001 secs (0.u,0.s)
Chars 3466 - 3472 [Proof.] 0. secs (0.u,0.s)
Chars 3370 - 3397 [srapply~Build_IsCongruence.] 40.159 secs (0.002u,0.028s)
Chars 3402 - 3434 [(intros;~by~apply~in_cosetR_co...] 0.002 secs (0.001u,0.s)
Chars 3370 - 3397 [srapply~Build_IsCongruence.] 0. secs (0.u,0.s)
Chars 3402 - 3434 [(intros;~by~apply~in_cosetR_co...] 0. secs (0.u,0.s)
Chars 3437 - 3445 [Defined.] 0. secs (0.u,0.s)
Chars 3635 - 3715 [Definition~QuotientGroup~:~Gro...] 0.006 secs (0.005u,0.s)
Chars 3719 - 3769 [Definition~grp_quotient_map~:~...] 0. secs (0.u,0.s)
Chars 3772 - 3778 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 11649 - 11684 [(pose~(g~:=~O_rec~idmap~:~O~T~...] 40.123 secs (0.001u,0.029s)
Chars 11689 - 11732 [refine~(isequiv_adjointify~(to...] 0.001 secs (0.u,0.001s)
Chars 11737 - 11738 [-] 0. secs (0.u,0.s)
Chars 11739 - 11780 [refine~(O_indpaths~(to~O~T~o~g...] 0.003 secs (0.003u,0.s)
Chars 11787 - 11796 [(intros~x).] 0. secs (0.u,0.s)
Chars 11803 - 11812 [(apply~ap).] 0.001 secs (0.001u,0.s)
Chars 11819 - 11836 [(apply~O_rec_beta).] 0.001 secs (0.001u,0.s)
Chars 11841 - 11842 [-] 0. secs (0.u,0.s)
Chars 11843 - 11852 [(intros~x).] 0. secs (0.u,0.s)
Chars 11859 - 11876 [(apply~O_rec_beta).] 0.001 secs (0.001u,0.s)
Chars 11649 - 11684 [(pose~(g~:=~O_rec~idmap~:~O~T~...] 0. secs (0.u,0.s)
Chars 11689 - 11732 [refine~(isequiv_adjointify~(to...] 0. secs (0.u,0.s)
Chars 11739 - 11780 [refine~(O_indpaths~(to~O~T~o~g...] 0. secs (0.u,0.s)
Chars 11787 - 11796 [(intros~x).] 0. secs (0.u,0.s)
Chars 11803 - 11812 [(apply~ap).] 0. secs (0.u,0.s)
Chars 11819 - 11836 [(apply~O_rec_beta).] 0. secs (0.u,0.s)
Chars 11843 - 11852 [(intros~x).] 0. secs (0.u,0.s)
Chars 11859 - 11876 [(apply~O_rec_beta).] 0. secs (0.u,0.s)
Chars 11879 - 11887 [Defined.] 0.001 secs (0.001u,0.s)
Chars 11890 - 11932 [#[global]Existing~Instance~ise...] 0. secs (0.u,0.s)
Chars 11936 - 12029 [Definition~equiv_to_O~(T~:~Typ...] 0.003 secs (0.002u,0.s)
Chars 12033 - 12049 [Section~Functor.] 0. secs (0.u,0.s)
Chars 12114 - 12202 [Definition~O_functor~{A~B~:~Ty...] 0.002 secs (0.002u,0.s)
Chars 12240 - 12359 [Definition~to_O_natural~{A~B~:...] 0.003 secs (0.003u,0.s)
Chars 12405 - 12534 [Definition~O_functor_compose~{...] 0.002 secs (0.002u,0.s)
Chars 12539 - 12545 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 6626 - 6634 [intro~u.] 40.159 secs (0.u,0.031s)
Chars 6635 - 6651 [(generalize~u.#A).] 0.001 secs (0.u,0.s)
Chars 6652 - 6660 [intro~w.] 0. secs (0.u,0.s)
Chars 6661 - 6678 [(induction~(σ~u)).] 0.003 secs (0.003u,0.s)
Chars 6683 - 6684 [-] 0. secs (0.u,0.s)
Chars 6685 - 6697 [reflexivity.] 0.001 secs (0.u,0.s)
Chars 6702 - 6703 [-] 0. secs (0.u,0.s)
Chars 6704 - 6716 [now~intro~x.] 0.005 secs (0.004u,0.s)
Chars 6626 - 6634 [intro~u.] 0. secs (0.u,0.s)
Chars 6635 - 6651 [(generalize~u.#A).] 0. secs (0.u,0.s)
Chars 6652 - 6660 [intro~w.] 0. secs (0.u,0.s)
Chars 6661 - 6678 [(induction~(σ~u)).] 0. secs (0.u,0.s)
Chars 6685 - 6697 [reflexivity.] 0. secs (0.u,0.s)
Chars 6704 - 6716 [now~intro~x.] 0. secs (0.u,0.s)
Chars 6719 - 6727 [Defined.] 0.001 secs (0.001u,0.s)
Chars 6731 - 6805 [#[global]Instance~is_isomorphi...] 0. secs (0.u,0.s)
Chars 6808 - 6814 [Proof.] 0. secs (0.u,0.s)
Chars 6819 - 6827 [intro~s.] 0.583 secs (0.001u,0.03s)
Chars 6828 - 6836 [exact~_.] 0.007 secs (0.005u,0.001s)
Chars 6819 - 6827 [intro~s.] 0. secs (0.u,0.s)
Chars 6828 - 6836 [exact~_.] 0. secs (0.u,0.s)
Chars 6839 - 6843 [Qed.] 0. secs (0.u,0.s)
Chars 6847 - 6921 [Definition~hom_id~:~Homomorphi...] 0.001 secs (0.u,0.s)
Chars 6923 - 6934 [End~hom_id.] 0.003 secs (0.003u,0.s)
Chars 7106 - 7122 [Section~hom_inv.] 0. secs (0.u,0.s)
Chars 7125 - 7216 [Context~{σ}~{A~B~:~Algebra~σ}~...] 0.002 secs (0.001u,0.s)
Chars 7220 - 7290 [#[global]Instance~is_homomorph...] 0.011 secs (0.008u,0.002s)
Chars 7293 - 7299 [Proof.] 0. secs (0.u,0.s)
Chars 11770 - 11805 [refine~(_~oE~equiv_path_arrow~...] 40.122 secs (0.002u,0.015s)
Chars 11808 - 11843 [refine~(_~oE~equiv_path_equiv~...] 0.001 secs (0.001u,0.s)
Chars 11846 - 11887 [exact~(equiv_ap~(equiv_path~A~...] 0.002 secs (0.002u,0.s)
Chars 11770 - 11805 [refine~(_~oE~equiv_path_arrow~...] 0. secs (0.u,0.s)
Chars 11808 - 11843 [refine~(_~oE~equiv_path_equiv~...] 0. secs (0.u,0.s)
Chars 11846 - 11887 [exact~(equiv_ap~(equiv_path~A~...] 0. secs (0.u,0.s)
Chars 11888 - 11896 [Defined.] 0.032 secs (0.022u,0.009s)
Chars 11898 - 12054 [Definition~path2_universe~`{Fu...] 0.005 secs (0.005u,0.s)
Chars 12056 - 12182 [Definition~equiv_path2_univers...] 0.001 secs (0.001u,0.s)
Chars 12183 - 12189 [Proof.] 0. secs (0.u,0.s)
Chars 2566 - 2576 [(intros~?~?).] 40.177 secs (0.u,0.035s)
Chars 2581 - 2602 [(apply~path_iff_hprop).] 0.001 secs (0.001u,0.s)
Chars 2607 - 2608 [-] 0. secs (0.u,0.s)
Chars 2609 - 2637 [(intros~X;~strip_truncations).] 0.036 secs (0.031u,0.004s)
Chars 2644 - 2682 [(destruct~X~as~[?|~[?~_]];~ass...] 0.002 secs (0.001u,0.001s)
Chars 2687 - 2688 [-] 0. secs (0.u,0.s)
Chars 2689 - 2698 [(intros~?).] 0. secs (0.u,0.s)
Chars 2699 - 2716 [by~apply~tr,~inl.] 0.001 secs (0.001u,0.s)
Chars 2566 - 2576 [(intros~?~?).] 0. secs (0.u,0.s)
Chars 2581 - 2602 [(apply~path_iff_hprop).] 0. secs (0.u,0.s)
Chars 2609 - 2637 [(intros~X;~strip_truncations).] 0. secs (0.u,0.s)
Chars 2644 - 2682 [(destruct~X~as~[?|~[?~_]];~ass...] 0. secs (0.u,0.s)
Chars 2689 - 2698 [(intros~?).] 0. secs (0.u,0.s)
Chars 2699 - 2716 [by~apply~tr,~inl.] 0. secs (0.u,0.s)
Chars 2719 - 2727 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2731 - 2782 [Instance~absorption_hand_hor~:...] 0.001 secs (0.001u,0.s)
Chars 2785 - 2791 [Proof.] 0. secs (0.u,0.s)
Chars 5473 - 5505 [(apply~path_quotient_algebra_i...] 40.189 secs (0.004u,0.036s)
Chars 5506 - 5519 [(intros~s~x~y).] 0.001 secs (0.001u,0.s)
Chars 5524 - 5696 [(split;~generalize~dependent~y...] 0.213 secs (0.183u,0.029s)
Chars 5701 - 5702 [-] 0. secs (0.u,0.s)
Chars 5703 - 5724 [(intros~K~x'~y'~Cx~Cy).] 0.001 secs (0.001u,0.s)
Chars 5731 - 5750 [(apply~subrel~in~Cx).] 0.002 secs (0.002u,0.s)
Chars 5751 - 5770 [(apply~subrel~in~Cy).] 0.001 secs (0.001u,0.s)
Chars 5777 - 5816 [(apply~(classes_eq_related~(Φ~...] 0.014 secs (0.012u,0.002s)
Chars 5823 - 5838 [transitivity~x.] 0.004 secs (0.004u,0.s)
Chars 5845 - 5846 [+] 0. secs (0.u,0.s)
Chars 5847 - 5859 [by~symmetry.] 0.005 secs (0.004u,0.s)
Chars 5866 - 5867 [+] 0. secs (0.u,0.s)
Chars 5868 - 5886 [by~transitivity~y.] 0.005 secs (0.004u,0.s)
Chars 5891 - 5892 [-] 0. secs (0.u,0.s)
Chars 5893 - 5901 [intro~T.] 0.001 secs (0.001u,0.s)
Chars 5908 - 5933 [(apply~related_classes_eq).] 0.005 secs (0.005u,0.s)
Chars 5940 - 6000 [exact~(T~x~y~(EquivRel_Reflexi...] 0.007 secs (0.006u,0.s)
Chars 5473 - 5505 [(apply~path_quotient_algebra_i...] 0.001 secs (0.001u,0.s)
Chars 5506 - 5519 [(intros~s~x~y).] 0. secs (0.u,0.s)
Chars 5524 - 5696 [(split;~generalize~dependent~y...] 0.011 secs (0.011u,0.s)
Chars 5703 - 5724 [(intros~K~x'~y'~Cx~Cy).] 0.001 secs (0.u,0.s)
Chars 5731 - 5750 [(apply~subrel~in~Cx).] 0.001 secs (0.u,0.001s)
Chars 5751 - 5770 [(apply~subrel~in~Cy).] 0.001 secs (0.001u,0.s)
Chars 5777 - 5816 [(apply~(classes_eq_related~(Φ~...] 0. secs (0.u,0.s)
Chars 5823 - 5838 [transitivity~x.] 0. secs (0.u,0.s)
Chars 5847 - 5859 [by~symmetry.] 0. secs (0.u,0.s)
Chars 5868 - 5886 [by~transitivity~y.] 0. secs (0.u,0.s)
Chars 5893 - 5901 [intro~T.] 0.001 secs (0.u,0.s)
Chars 5908 - 5933 [(apply~related_classes_eq).] 0.001 secs (0.u,0.s)
Chars 5940 - 6000 [exact~(T~x~y~(EquivRel_Reflexi...] 0. secs (0.u,0.s)
Chars 6003 - 6011 [Defined.] 0.013 secs (0.01u,0.003s)
Chars 6015 - 6243 [Definition~hom_third_isomorphi...] 0.013 secs (0.011u,0.002s)
Chars 6247 - 6330 [Theorem~is_isomorphism_third_i...] 0.02 secs (0.018u,0.001s)
Chars 6333 - 6339 [Proof.] 0. secs (0.u,0.s)
Chars 20509 - 20531 [(split;~intros~A~A_inO).] 40.18 secs (0.001u,0.033s)
Chars 20535 - 20536 [-] 0. secs (0.u,0.s)
Chars 20537 - 20546 [(intros~i).] 0. secs (0.u,0.s)
Chars 20551 - 20599 [(pose~proof~(fst~(inO_iff_islo...] 0.001 secs (0.001u,0.s)
Chars 20604 - 20687 [(apply~~~(lift_ooextendablealo...] 0.001 secs (0.001u,0.s)
Chars 20692 - 20700 [exact~e.] 0. secs (0.u,0.s)
Chars 20703 - 20704 [-] 0. secs (0.u,0.s)
Chars 20705 - 20731 [(apply~(inO_iff_islocal~O)).] 0.002 secs (0.002u,0.s)
Chars 20736 - 20745 [(intros~i).] 0. secs (0.u,0.s)
Chars 20750 - 20770 [(pose~(e~:=~A_inO~i)).] 0.001 secs (0.001u,0.s)
Chars 20775 - 20858 [(apply~~~(lift_ooextendablealo...] 0.001 secs (0.001u,0.s)
Chars 20863 - 20871 [exact~e.] 0. secs (0.u,0.s)
Chars 20509 - 20531 [(split;~intros~A~A_inO).] 0. secs (0.u,0.s)
Chars 20537 - 20546 [(intros~i).] 0. secs (0.u,0.s)
Chars 20551 - 20599 [(pose~proof~(fst~(inO_iff_islo...] 0. secs (0.u,0.s)
Chars 20604 - 20687 [(apply~~~(lift_ooextendablealo...] 0. secs (0.u,0.s)
Chars 20692 - 20700 [exact~e.] 0. secs (0.u,0.s)
Chars 20705 - 20731 [(apply~(inO_iff_islocal~O)).] 0. secs (0.u,0.s)
Chars 20736 - 20745 [(intros~i).] 0. secs (0.u,0.s)
Chars 20750 - 20770 [(pose~(e~:=~A_inO~i)).] 0. secs (0.u,0.s)
Chars 20775 - 20858 [(apply~~~(lift_ooextendablealo...] 0. secs (0.u,0.s)
Chars 20863 - 20871 [exact~e.] 0. secs (0.u,0.s)
Chars 20872 - 20880 [Defined.] 0.001 secs (0.001u,0.s)
Chars 20882 - 21110 [Definition~O_leq_lift_accrsu@{...] 0. secs (0.u,0.s)
Chars 21111 - 21117 [Proof.] 0. secs (0.u,0.s)
Chars 1677 - 1688 [(intros~z~?).] 40.156 secs (0.001u,0.024s)
Chars 1689 - 1693 [(red).] 0. secs (0.u,0.s)
Chars 1694 - 1731 [(apply~(order_reflecting_pos~(...] 0.131 secs (0.109u,0.02s)
Chars 1732 - 1751 [(apply~nat_ne_0_pos).] 0.001 secs (0.001u,0.s)
Chars 1752 - 1760 [trivial.] 0.001 secs (0.001u,0.s)
Chars 1677 - 1688 [(intros~z~?).] 0. secs (0.u,0.s)
Chars 1689 - 1693 [(red).] 0. secs (0.u,0.s)
Chars 1694 - 1731 [(apply~(order_reflecting_pos~(...] 0. secs (0.u,0.s)
Chars 1732 - 1751 [(apply~nat_ne_0_pos).] 0. secs (0.u,0.s)
Chars 1752 - 1760 [trivial.] 0. secs (0.u,0.s)
Chars 1761 - 1765 [Qed.] 0.001 secs (0.001u,0.s)
Chars 1767 - 1840 [#[global]Instance~slow_nat_le_...] 0. secs (0.u,0.s)
Chars 1841 - 1847 [Proof.] 0. secs (0.u,0.s)
Chars 4753 - 4777 [snrapply~rng_first_iso'.] 40.222 secs (0.005u,0.046s)
Chars 4782 - 4805 [1:~rapply~rng_homo_crt.] 0.001 secs (0.001u,0.s)
Chars 4810 - 4821 [1:~exact~_.] 0.011 secs (0.01u,0.001s)
Chars 4901 - 4929 [(apply~ideal_subset_antisymm).] 0.001 secs (0.001u,0.s)
Chars 4934 - 4935 [-] 0. secs (0.u,0.s)
Chars 4936 - 4951 [(intros~r~[i~j]).] 0.001 secs (0.001u,0.s)
Chars 4958 - 4987 [(apply~path_prod;~apply~qglue).] 0.017 secs (0.016u,0.001s)
Chars 4994 - 5018 [1:~(change~(I~(-~r~+~0))).] 0.003 secs (0.002u,0.s)
Chars 5025 - 5049 [2:~(change~(J~(-~r~+~0))).] 0.003 secs (0.003u,0.s)
Chars 5056 - 5083 [1,~2:~(rewrite~rng_plus_comm).] 0.004 secs (0.004u,0.s)
Chars 5090 - 5122 [1,~2:~(apply~ideal_in_plus_neg...] 0.002 secs (0.002u,0.s)
Chars 5129 - 5154 [1,~3:~(apply~ideal_in_zero).] 0.001 secs (0.001u,0.s)
Chars 5161 - 5177 [1,~2:~assumption.] 0. secs (0.u,0.s)
Chars 5182 - 5183 [-] 0. secs (0.u,0.s)
Chars 5184 - 5195 [(intros~i~p).] 0. secs (0.u,0.s)
Chars 5202 - 5229 [(apply~equiv_path_prod~in~p).] 0.012 secs (0.009u,0.002s)
Chars 5236 - 5256 [(destruct~p~as~[p~q]).] 0.012 secs (0.01u,0.002s)
Chars 5263 - 5286 [(apply~ideal_in_negate').] 0.001 secs (0.001u,0.s)
Chars 5293 - 5320 [(rewrite~<-~rng_plus_zero_r).] 0.002 secs (0.001u,0.001s)
Chars 5438 - 5444 [split.] 0.001 secs (0.001u,0.s)
Chars 5451 - 5493 [1:~exact~(related_quotient_pat...] 0.045 secs (0.035u,0.01s)
Chars 5500 - 5542 [1:~exact~(related_quotient_pat...] 0.029 secs (0.027u,0.001s)
Chars 4753 - 4777 [snrapply~rng_first_iso'.] 0. secs (0.u,0.s)
Chars 4782 - 4805 [1:~rapply~rng_homo_crt.] 0. secs (0.u,0.s)
Chars 4810 - 4821 [1:~exact~_.] 0. secs (0.u,0.s)
Chars 4901 - 4929 [(apply~ideal_subset_antisymm).] 0. secs (0.u,0.s)
Chars 4936 - 4951 [(intros~r~[i~j]).] 0. secs (0.u,0.s)
Chars 4958 - 4987 [(apply~path_prod;~apply~qglue).] 0.001 secs (0.001u,0.s)
Chars 4994 - 5018 [1:~(change~(I~(-~r~+~0))).] 0. secs (0.u,0.s)
Chars 5025 - 5049 [2:~(change~(J~(-~r~+~0))).] 0. secs (0.u,0.s)
Chars 5056 - 5083 [1,~2:~(rewrite~rng_plus_comm).] 0.001 secs (0.001u,0.s)
Chars 5090 - 5122 [1,~2:~(apply~ideal_in_plus_neg...] 0. secs (0.u,0.s)
Chars 5129 - 5154 [1,~3:~(apply~ideal_in_zero).] 0. secs (0.u,0.s)
Chars 5161 - 5177 [1,~2:~assumption.] 0. secs (0.u,0.s)
Chars 5184 - 5195 [(intros~i~p).] 0. secs (0.u,0.s)
Chars 5202 - 5229 [(apply~equiv_path_prod~in~p).] 0. secs (0.u,0.s)
Chars 5236 - 5256 [(destruct~p~as~[p~q]).] 0. secs (0.u,0.s)
Chars 5263 - 5286 [(apply~ideal_in_negate').] 0. secs (0.u,0.s)
Chars 5293 - 5320 [(rewrite~<-~rng_plus_zero_r).] 0. secs (0.u,0.s)
Chars 5438 - 5444 [split.] 0. secs (0.u,0.s)
Chars 5451 - 5493 [1:~exact~(related_quotient_pat...] 0. secs (0.u,0.s)
Chars 5500 - 5542 [1:~exact~(related_quotient_pat...] 0. secs (0.u,0.s)
Chars 5545 - 5553 [Defined.] 0.019 secs (0.016u,0.002s)
Chars 5612 - 5688 [Theorem~chinese_remainder_prod...] 0.002 secs (0.002u,0.s)
Chars 5691 - 5697 [Proof.] 0. secs (0.u,0.s)
Chars 9928 - 9973 [(destruct~(trunc_index_min_pat...] 40.155 secs (0.002u,0.025s)
Chars 9976 - 9977 [+] 0. secs (0.u,0.s)
Chars 9978 - 10022 [(pose~proof~(trunc_index_min_l...] 0. secs (0.u,0.s)
Chars 10027 - 10048 [(destruct~p^;~clear~p).] 0.002 secs (0.002u,0.s)
Chars 10053 - 10101 [snrapply~(Build_Equiv~_~_~(Tru...] 0.002 secs (0.001u,0.s)
Chars 10106 - 10133 [nrapply~O_inverts_conn_map.] 0.003 secs (0.003u,0.s)
Chars 10138 - 10171 [rapply~(conn_map_O_leq~_~(Tr~m)).] 0.042 secs (0.027u,0.014s)
Chars 10176 - 10196 [rapply~O_leq_Tr_leq.] 0.001 secs (0.u,0.s)
Chars 10199 - 10200 [+] 0. secs (0.u,0.s)
Chars 10201 - 10244 [(pose~proof~(trunc_index_min_l...] 0. secs (0.u,0.s)
Chars 10249 - 10270 [(destruct~q^;~clear~q).] 0.002 secs (0.002u,0.s)
Chars 10275 - 10292 [srapply~equiv_tr.] 0.004 secs (0.003u,0.s)
Chars 10297 - 10317 [srapply~istrunc_leq.] 0.002 secs (0.002u,0.s)
Chars 9928 - 9973 [(destruct~(trunc_index_min_pat...] 0. secs (0.u,0.s)
Chars 9978 - 10022 [(pose~proof~(trunc_index_min_l...] 0. secs (0.u,0.s)
Chars 10027 - 10048 [(destruct~p^;~clear~p).] 0. secs (0.u,0.s)
Chars 10053 - 10101 [snrapply~(Build_Equiv~_~_~(Tru...] 0. secs (0.u,0.s)
Chars 10106 - 10133 [nrapply~O_inverts_conn_map.] 0. secs (0.u,0.s)
Chars 10138 - 10171 [rapply~(conn_map_O_leq~_~(Tr~m)).] 0. secs (0.u,0.s)
Chars 10176 - 10196 [rapply~O_leq_Tr_leq.] 0. secs (0.u,0.s)
Chars 10201 - 10244 [(pose~proof~(trunc_index_min_l...] 0. secs (0.u,0.s)
Chars 10249 - 10270 [(destruct~q^;~clear~q).] 0. secs (0.u,0.s)
Chars 10275 - 10292 [srapply~equiv_tr.] 0. secs (0.u,0.s)
Chars 10297 - 10317 [srapply~istrunc_leq.] 0. secs (0.u,0.s)
Chars 10318 - 10326 [Defined.] 0.002 secs (0.002u,0.s)
Chars 10328 - 10390 [Definition~Trunc_swap~n~m~X~:~...] 0.001 secs (0.001u,0.s)
Chars 10391 - 10397 [Proof.] 0. secs (0.u,0.s)
Chars 5440 - 5470 [exact~(eh_p1_gen~p~(ulnat~p)).] 40.128 secs (0.007u,0.021s)
Chars 5440 - 5470 [exact~(eh_p1_gen~p~(ulnat~p)).] 0. secs (0.u,0.s)
Chars 5471 - 5479 [Defined.] 0.004 secs (0.001u,0.003s)
Chars 5517 - 5641 [Definition~ehlnat~{X}~{a~:~X}~...] 0.005 secs (0.003u,0.001s)
Chars 5642 - 5648 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 3475 - 3484 [(intros~x).] 40.167 secs (0.u,0.03s)
Chars 3487 - 3534 [(rewrite~(commutativity~(f:=me...] 0.006 secs (0.005u,0.s)
Chars 3537 - 3545 [trivial.] 0. secs (0.u,0.s)
Chars 3475 - 3484 [(intros~x).] 0. secs (0.u,0.s)
Chars 3487 - 3534 [(rewrite~(commutativity~(f:=me...] 0. secs (0.u,0.s)
Chars 3537 - 3545 [trivial.] 0. secs (0.u,0.s)
Chars 3548 - 3552 [Qed.] 0. secs (0.u,0.s)
Chars 3553 - 3579 [End~lower_bounded_lattice.] 0.003 secs (0.003u,0.s)
Chars 3581 - 3605 [Section~from_another_sl.] 0. secs (0.u,0.s)
Chars 3608 - 3638 [#[local]Open~Scope~mc_add_scope.] 0. secs (0.u,0.s)
Chars 3641 - 3782 [Context~`{IsSemiLattice~A}~`{I...] 0.002 secs (0.002u,0.s)
Chars 3786 - 3822 [Lemma~projected_sl~:~IsSemiLat...] 0. secs (0.u,0.s)
Chars 3825 - 3831 [Proof.] 0. secs (0.u,0.s)
Chars 3783 - 3816 [snrapply~Build_GroupHomomorphism.] 40.156 secs (0.u,0.029s)
Chars 3821 - 3843 [1:~exact~(class_of~_).] 0. secs (0.u,0.s)
Chars 3848 - 3871 [(intros~?~?;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 3783 - 3816 [snrapply~Build_GroupHomomorphism.] 0. secs (0.u,0.s)
Chars 3821 - 3843 [1:~exact~(class_of~_).] 0. secs (0.u,0.s)
Chars 3848 - 3871 [(intros~?~?;~reflexivity).] 0. secs (0.u,0.s)
Chars 3874 - 3882 [Defined.] 0. secs (0.u,0.s)
Chars 3886 - 4021 [Definition~grp_quotient_rec~{A...] 0.002 secs (0.002u,0.s)
Chars 4024 - 4030 [Proof.] 0. secs (0.u,0.s)
Chars 12552 - 12581 [(srapply~O_indpaths;~intros~x).] 40.157 secs (0.008u,0.026s)
Chars 12588 - 12624 [refine~(to_O_natural~(g~o~f)~x...] 0.002 secs (0.002u,0.s)
Chars 12631 - 12673 [transitivity~(O_functor~g~(to~...] 0.003 secs (0.003u,0.s)
Chars 12680 - 12681 [-] 0. secs (0.u,0.s)
Chars 12682 - 12691 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 12692 - 12721 [exact~(to_O_natural~g~(f~x)).] 0.001 secs (0.001u,0.s)
Chars 12728 - 12729 [-] 0. secs (0.u,0.s)
Chars 12730 - 12749 [(apply~ap;~symmetry).] 0.003 secs (0.002u,0.001s)
Chars 12758 - 12783 [exact~(to_O_natural~f~x).] 0.001 secs (0.001u,0.s)
Chars 12552 - 12581 [(srapply~O_indpaths;~intros~x).] 0.001 secs (0.001u,0.s)
Chars 12588 - 12624 [refine~(to_O_natural~(g~o~f)~x...] 0. secs (0.u,0.s)
Chars 12631 - 12673 [transitivity~(O_functor~g~(to~...] 0. secs (0.u,0.s)
Chars 12682 - 12691 [symmetry.] 0. secs (0.u,0.s)
Chars 12692 - 12721 [exact~(to_O_natural~g~(f~x)).] 0. secs (0.u,0.s)
Chars 12730 - 12749 [(apply~ap;~symmetry).] 0. secs (0.u,0.s)
Chars 12758 - 12783 [exact~(to_O_natural~f~x).] 0. secs (0.u,0.s)
Chars 12788 - 12796 [Defined.] 0.001 secs (0.001u,0.s)
Chars 12859 - 12964 [Definition~O_functor_homotopy~...] 0.001 secs (0.001u,0.s)
Chars 12969 - 12975 [Proof.] 0. secs (0.u,0.s)
Chars 7303 - 7311 [intro~u.] 40.15 secs (0.u,0.032s)
Chars 7315 - 7359 [(generalize~u.#A,~u.#B,~(oppre...] 0.002 secs (0.002u,0.s)
Chars 7363 - 7376 [(intros~a~b~P).] 0. secs (0.u,0.s)
Chars 7380 - 7397 [(induction~(σ~u)).] 0.003 secs (0.003u,0.s)
Chars 7401 - 7402 [-] 0. secs (0.u,0.s)
Chars 7403 - 7414 [(destruct~P).] 0.002 secs (0.002u,0.s)
Chars 7415 - 7437 [(apply~(eissect~(f~t))).] 0.001 secs (0.001u,0.s)
Chars 7441 - 7442 [-] 0. secs (0.u,0.s)
Chars 7443 - 7449 [intro.] 0.001 secs (0.u,0.s)
Chars 7450 - 7460 [(apply~IHs).] 0.001 secs (0.001u,0.s)
Chars 7466 - 7560 [exact~~(transport~(λ~y,~OpPres...] 0.005 secs (0.004u,0.s)
Chars 7303 - 7311 [intro~u.] 0. secs (0.u,0.s)
Chars 7315 - 7359 [(generalize~u.#A,~u.#B,~(oppre...] 0. secs (0.u,0.s)
Chars 7363 - 7376 [(intros~a~b~P).] 0. secs (0.u,0.s)
Chars 7380 - 7397 [(induction~(σ~u)).] 0. secs (0.u,0.s)
Chars 7403 - 7414 [(destruct~P).] 0. secs (0.u,0.s)
Chars 7415 - 7437 [(apply~(eissect~(f~t))).] 0. secs (0.u,0.s)
Chars 7443 - 7449 [intro.] 0.001 secs (0.001u,0.s)
Chars 7450 - 7460 [(apply~IHs).] 0.001 secs (0.001u,0.s)
Chars 7466 - 7560 [exact~~(transport~(λ~y,~OpPres...] 0. secs (0.u,0.s)
Chars 7563 - 7571 [Defined.] 0.003 secs (0.003u,0.s)
Chars 7575 - 7643 [#[global]Instance~is_isomorphi...] 0.012 secs (0.011u,0.001s)
Chars 7646 - 7652 [Proof.] 0. secs (0.u,0.s)
Chars 12192 - 12198 [(simpl).] 40.123 secs (0.011u,0.017s)
Chars 12201 - 12265 [(rewrite~concat_1p,~concat_p1,...] 0.014 secs (0.009u,0.005s)
Chars 12268 - 12280 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 12192 - 12198 [(simpl).] 0. secs (0.u,0.s)
Chars 12201 - 12265 [(rewrite~concat_1p,~concat_p1,...] 0.001 secs (0.u,0.s)
Chars 12268 - 12280 [reflexivity.] 0. secs (0.u,0.s)
Chars 12281 - 12285 [Qed.] 0.01 secs (0.01u,0.s)
Chars 12287 - 12438 [Definition~path2_universe_1~`{...] 0.002 secs (0.002u,0.s)
Chars 13648 - 13676 [Section~PathEquivSimplNever.] 0. secs (0.u,0.s)
Chars 13679 - 13726 [#[local]Arguments~equiv_path_e...] 0. secs (0.u,0.s)
Chars 13730 - 14158 [Definition~path2_universe_post...] 0.012 secs (0.01u,0.002s)
Chars 14161 - 14167 [Proof.] 0. secs (0.u,0.s)
Chars 7657 - 7665 [intro~s.] 0.896 secs (0.001u,0.031s)
Chars 7666 - 7674 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 7657 - 7665 [intro~s.] 0. secs (0.u,0.s)
Chars 7666 - 7674 [exact~_.] 0. secs (0.u,0.s)
Chars 7677 - 7681 [Qed.] 0. secs (0.u,0.s)
Chars 7685 - 7765 [Definition~hom_inv~:~Homomorph...] 0.011 secs (0.011u,0.s)
Chars 7767 - 7779 [End~hom_inv.] 0.011 secs (0.009u,0.002s)
Chars 8042 - 8062 [Section~hom_compose.] 0. secs (0.u,0.s)
Chars 8065 - 8099 [Context~{σ}~{A~B~C~:~Algebra~σ}.] 0. secs (0.u,0.s)
Chars 8103 - 8414 [Lemma~oppreserving_compose~(g~...] 0.005 secs (0.002u,0.002s)
Chars 8417 - 8423 [Proof.] 0. secs (0.u,0.s)
Chars 2796 - 2806 [(intros~?~?).] 40.176 secs (0.002u,0.033s)
Chars 2811 - 2832 [(apply~path_iff_hprop).] 0.001 secs (0.001u,0.s)
Chars 2837 - 2838 [-] 0. secs (0.u,0.s)
Chars 2839 - 2864 [(intros~[?~_];~assumption).] 0.001 secs (0.001u,0.s)
Chars 2869 - 2870 [-] 0. secs (0.u,0.s)
Chars 2871 - 2880 [(intros~?).] 0. secs (0.u,0.s)
Chars 2887 - 2893 [split.] 0. secs (0.u,0.s)
Chars 2900 - 2901 [*] 0. secs (0.u,0.s)
Chars 2902 - 2913 [assumption.] 0. secs (0.u,0.s)
Chars 2920 - 2921 [*] 0. secs (0.u,0.s)
Chars 2922 - 2939 [by~apply~tr,~inl.] 0.001 secs (0.001u,0.s)
Chars 2796 - 2806 [(intros~?~?).] 0. secs (0.u,0.s)
Chars 2811 - 2832 [(apply~path_iff_hprop).] 0. secs (0.u,0.s)
Chars 2839 - 2864 [(intros~[?~_];~assumption).] 0. secs (0.u,0.s)
Chars 2871 - 2880 [(intros~?).] 0. secs (0.u,0.s)
Chars 2887 - 2893 [split.] 0. secs (0.u,0.s)
Chars 2902 - 2913 [assumption.] 0. secs (0.u,0.s)
Chars 2922 - 2939 [by~apply~tr,~inl.] 0. secs (0.u,0.s)
Chars 2942 - 2950 [Defined.] 0. secs (0.u,0.s)
Chars 2954 - 3016 [#[global]Instance~boundedlatti...] 0.001 secs (0.u,0.s)
Chars 3019 - 3025 [Proof.] 0. secs (0.u,0.s)
Chars 6344 - 6373 [(unfold~hom_third_isomorphism).] 40.203 secs (0.001u,0.037s)
Chars 6378 - 6427 [(destruct~path_quotient_algebr...] 0.014 secs (0.013u,0.s)
Chars 6432 - 6440 [exact~_.] 0.024 secs (0.02u,0.003s)
Chars 6344 - 6373 [(unfold~hom_third_isomorphism).] 0. secs (0.u,0.s)
Chars 6378 - 6427 [(destruct~path_quotient_algebr...] 0.001 secs (0.001u,0.s)
Chars 6432 - 6440 [exact~_.] 0.002 secs (0.002u,0.s)
Chars 6443 - 6447 [Qed.] 0.017 secs (0.014u,0.002s)
Chars 6451 - 6509 [#[global]Existing~Instance~is_...] 0. secs (0.u,0.s)
Chars 6554 - 6612 [Corollary~isomorphic_third_iso...] 0.005 secs (0.004u,0.001s)
Chars 6615 - 6621 [Proof.] 0. secs (0.u,0.s)
Chars 21120 - 21136 [(intros~B~B_inO1).] 40.165 secs (0.001u,0.033s)
Chars 21139 - 21172 [(apply~(inO_leq@{i1~i2~i2}~O1~...] 0.001 secs (0.001u,0.s)
Chars 21175 - 21210 [(apply~(snd~(inO_iff_islocal~O...] 0.003 secs (0.001u,0.s)
Chars 21213 - 21222 [(intros~i).] 0. secs (0.u,0.s)
Chars 21223 - 21245 [specialize~(B_inO1~i).] 0.001 secs (0.001u,0.s)
Chars 21248 - 21337 [(apply~~~(lift_ooextendablealo...] 0.001 secs (0.001u,0.s)
Chars 21340 - 21353 [exact~B_inO1.] 0. secs (0.u,0.s)
Chars 21120 - 21136 [(intros~B~B_inO1).] 0. secs (0.u,0.s)
Chars 21139 - 21172 [(apply~(inO_leq@{i1~i2~i2}~O1~...] 0. secs (0.u,0.s)
Chars 21175 - 21210 [(apply~(snd~(inO_iff_islocal~O...] 0. secs (0.u,0.s)
Chars 21213 - 21222 [(intros~i).] 0. secs (0.u,0.s)
Chars 21223 - 21245 [specialize~(B_inO1~i).] 0. secs (0.u,0.s)
Chars 21248 - 21337 [(apply~~~(lift_ooextendablealo...] 0. secs (0.u,0.s)
Chars 21340 - 21353 [exact~B_inO1.] 0. secs (0.u,0.s)
Chars 21354 - 21362 [Defined.] 0.001 secs (0.u,0.s)
Chars 21624 - 22028 [Definition~isconnected_O_leq'@...] 0. secs (0.u,0.s)
Chars 22029 - 22035 [Proof.] 0. secs (0.u,0.s)
Chars 22118 - 22178 [srefine~(isconnected_O_leq~O1~...] 0.122 secs (0.008u,0.032s)
Chars 22181 - 22193 [1-2:~exact~_.] 0.003 secs (0.003u,0.s)
Chars 22196 - 22257 [(change~(Contr@{i1}~(Localize@...] 0.001 secs (0.001u,0.s)
Chars 22381 - 22421 [refine~(contr_equiv'@{i2~i1}~_...] 0.003 secs (0.002u,0.s)
Chars 22424 - 22479 [(change~(IsConnected@{i2}~(lif...] 0.001 secs (0.001u,0.s)
Chars 22482 - 22515 [srapply~(isconnected_O_leq~_~O2).] 0.007 secs (0.004u,0.001s)
Chars 22518 - 22543 [rapply~O_leq_lift_accrsu.] 0.002 secs (0.002u,0.s)
Chars 22118 - 22178 [srefine~(isconnected_O_leq~O1~...] 0. secs (0.u,0.s)
Chars 22181 - 22193 [1-2:~exact~_.] 0. secs (0.u,0.s)
Chars 22196 - 22257 [(change~(Contr@{i1}~(Localize@...] 0. secs (0.u,0.s)
Chars 22381 - 22421 [refine~(contr_equiv'@{i2~i1}~_...] 0. secs (0.u,0.s)
Chars 22424 - 22479 [(change~(IsConnected@{i2}~(lif...] 0. secs (0.u,0.s)
Chars 22482 - 22515 [srapply~(isconnected_O_leq~_~O2).] 0. secs (0.u,0.s)
Chars 22518 - 22543 [rapply~O_leq_lift_accrsu.] 0. secs (0.u,0.s)
Chars 22544 - 22552 [Defined.] 0.001 secs (0.001u,0.s)
Chars 22595 - 22853 [Definition~conn_map_O_leq'@{a~...] 0. secs (0.u,0.s)
Chars 22854 - 22860 [Proof.] 0. secs (0.u,0.s)
Chars 22943 - 22952 [(intros~b).] 0.161 secs (0.u,0.033s)
Chars 22955 - 23006 [(apply~(isconnected_equiv'~O1~...] 0.001 secs (0.u,0.001s)
Chars 23009 - 23010 [-] 0. secs (0.u,0.s)
Chars 23011 - 23036 [srapply~equiv_adjointify.] 0.002 secs (0.002u,0.s)
Chars 23041 - 23071 [1-2:~(intros~[u~p];~exact~(u;~...] 0.003 secs (0.002u,0.s)
Chars 23076 - 23106 [all:~(intros~[u~p];~reflexivity).] 0.005 secs (0.003u,0.002s)
Chars 23109 - 23110 [-] 0. secs (0.u,0.s)
Chars 23111 - 23144 [(apply~(isconnected_O_leq'~O1~...] 0.001 secs (0.001u,0.s)
Chars 23149 - 23183 [(apply~isconnected_hfiber_conn...] 0.001 secs (0.001u,0.s)
Chars 22943 - 22952 [(intros~b).] 0. secs (0.u,0.s)
Chars 22955 - 23006 [(apply~(isconnected_equiv'~O1~...] 0. secs (0.u,0.s)
Chars 23011 - 23036 [srapply~equiv_adjointify.] 0. secs (0.u,0.s)
Chars 23041 - 23071 [1-2:~(intros~[u~p];~exact~(u;~...] 0.001 secs (0.001u,0.s)
Chars 23076 - 23106 [all:~(intros~[u~p];~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 23111 - 23144 [(apply~(isconnected_O_leq'~O1~...] 0. secs (0.u,0.s)
Chars 23149 - 23183 [(apply~isconnected_hfiber_conn...] 0. secs (0.u,0.s)
Chars 23184 - 23192 [Defined.] 0.002 secs (0.002u,0.s)
Chars 23242 - 23497 [Definition~O_inverts_O_leq'@{a...] 0.001 secs (0.001u,0.s)
Chars 23498 - 23504 [Proof.] 0. secs (0.u,0.s)
Chars 23507 - 23548 [(pose~proof~(O_leq_lift_accrsu...] 1.978 secs (0.u,0.033s)
Chars 23551 - 23625 [(pose~proof~(O_inverts_O_leq~(...] 0.003 secs (0.003u,0.s)
Chars 23628 - 23686 [nrapply~(O_inverts_O_leq~O1~(l...] 0.002 secs (0.002u,0.s)
Chars 23689 - 23699 [1:~exact~_.] 0.003 secs (0.003u,0.s)
Chars 23944 - 23984 [refine~(@isequiv_homotopic~_~_...] 0.002 secs (0.002u,0.s)
Chars 23987 - 24027 [(apply~O_indpaths;~intros~x;~r...] 0.006 secs (0.006u,0.s)
Chars 23507 - 23548 [(pose~proof~(O_leq_lift_accrsu...] 0. secs (0.u,0.s)
Chars 23551 - 23625 [(pose~proof~(O_inverts_O_leq~(...] 0. secs (0.u,0.s)
Chars 23628 - 23686 [nrapply~(O_inverts_O_leq~O1~(l...] 0. secs (0.u,0.s)
Chars 23689 - 23699 [1:~exact~_.] 0. secs (0.u,0.s)
Chars 23944 - 23984 [refine~(@isequiv_homotopic~_~_...] 0. secs (0.u,0.s)
Chars 23987 - 24027 [(apply~O_indpaths;~intros~x;~r...] 0.001 secs (0.u,0.s)
Chars 24028 - 24036 [Defined.] 0.004 secs (0.004u,0.s)
find_witness Control.TimeoutChars 1848 - 1859 [(intros~x~y).] 40.158 secs (0.u,0.025s)
Chars 1860 - 1955 [(destruct~~~(nat_le_dec~(natur...] 0.02 secs (0.015u,0.005s)
Chars 1956 - 1957 [-] 0. secs (0.u,0.s)
Chars 1958 - 1963 [left.] 0.001 secs (0.001u,0.s)
Chars 1966 - 2020 [(apply~(order_reflecting~(natu...] 0.062 secs (0.055u,0.006s)
Chars 2021 - 2029 [exact~E.] 0.001 secs (0.001u,0.s)
Chars 2030 - 2031 [-] 0. secs (0.u,0.s)
Chars 2032 - 2038 [right.] 0.001 secs (0.001u,0.s)
Chars 2039 - 2049 [(intros~E').] 0.001 secs (0.001u,0.s)
Chars 2050 - 2058 [(apply~E).] 0.001 secs (0.u,0.s)
Chars 2061 - 2092 [(apply~order_preserving;~trivi...] 0.004 secs (0.004u,0.s)
Chars 2093 - 2101 [(apply~_).] 0.068 secs (0.058u,0.008s)
Chars 1848 - 1859 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 1860 - 1955 [(destruct~~~(nat_le_dec~(natur...] 0. secs (0.u,0.s)
Chars 1958 - 1963 [left.] 0. secs (0.u,0.s)
Chars 1966 - 2020 [(apply~(order_reflecting~(natu...] 0. secs (0.u,0.s)
Chars 2021 - 2029 [exact~E.] 0. secs (0.u,0.s)
Chars 2032 - 2038 [right.] 0. secs (0.u,0.s)
Chars 2039 - 2049 [(intros~E').] 0. secs (0.u,0.s)
Chars 2050 - 2058 [(apply~E).] 0. secs (0.u,0.s)
Chars 2061 - 2092 [(apply~order_preserving;~trivi...] 0.002 secs (0.002u,0.s)
Chars 2093 - 2101 [(apply~_).] 0. secs (0.u,0.s)
Chars 2102 - 2106 [Qed.] 0.005 secs (0.004u,0.s)
Chars 2108 - 2129 [Section~another_ring.] 0. secs (0.u,0.s)
Chars 2132 - 2248 [Context~`{IsRing~R}~`{Apart~R}...] 0.008 secs (0.008u,0.s)
Chars 2252 - 2295 [Lemma~negate_to_ring_nonpos~n~...] 0.001 secs (0.001u,0.s)
Chars 2298 - 2304 [Proof.] 0. secs (0.u,0.s)
Chars 5702 - 5716 [etransitivity.] 40.202 secs (0.002u,0.044s)
Chars 5721 - 5722 [{] 0. secs (0.u,0.s)
Chars 5723 - 5749 [rapply~rng_quotient_invar.] 0.002 secs (0.002u,0.s)
Chars 5756 - 5765 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 5772 - 5809 [rapply~ideal_intersection_is_p...] 0.005 secs (0.004u,0.001s)
Chars 5810 - 5811 [}] 0. secs (0.u,0.s)
Chars 5816 - 5841 [rapply~chinese_remainder.] 0.002 secs (0.002u,0.s)
Chars 5702 - 5716 [etransitivity.] 0. secs (0.u,0.s)
Chars 5723 - 5749 [rapply~rng_quotient_invar.] 0. secs (0.u,0.s)
Chars 5756 - 5765 [symmetry.] 0. secs (0.u,0.s)
Chars 5772 - 5809 [rapply~ideal_intersection_is_p...] 0. secs (0.u,0.s)
Chars 5816 - 5841 [rapply~chinese_remainder.] 0. secs (0.u,0.s)
Chars 5844 - 5852 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5854 - 5882 [End~ChineseRemainderTheorem.] 0.11 secs (0.099u,0.01s)
Chars 10400 - 10488 [refine~~(Trunc_min~m~n~_~oE~eq...] 40.15 secs (0.004u,0.025s)
Chars 10491 - 10518 [(apply~trunc_index_min_swap).] 0. secs (0.u,0.s)
Chars 10400 - 10488 [refine~~(Trunc_min~m~n~_~oE~eq...] 0. secs (0.u,0.s)
Chars 10491 - 10518 [(apply~trunc_index_min_swap).] 0. secs (0.u,0.s)
Chars 10519 - 10527 [Defined.] 0.001 secs (0.001u,0.s)
Chars 10585 - 10608 [Section~SeparatedTrunc.] 0. secs (0.u,0.s)
Chars 10610 - 10645 [#[local]Open~Scope~subuniverse...] 0. secs (0.u,0.s)
Chars 10750 - 10819 [#[global]Instance~O_eq_Tr~~(n~...] 0. secs (0.u,0.s)
Chars 10820 - 10826 [Proof.] 0. secs (0.u,0.s)
Chars 5651 - 5662 [(destruct~p).] 40.116 secs (0.003u,0.023s)
Chars 5665 - 5685 [exact~(lrucancel~1).] 0.002 secs (0.002u,0.s)
Chars 5651 - 5662 [(destruct~p).] 0. secs (0.u,0.s)
Chars 5665 - 5685 [exact~(lrucancel~1).] 0. secs (0.u,0.s)
Chars 5686 - 5694 [Defined.] 0.004 secs (0.002u,0.002s)
Chars 5696 - 5820 [Definition~ehrnat~{X}~{a~:~X}~...] 0.005 secs (0.003u,0.002s)
Chars 5821 - 5827 [Proof.] 0. secs (0.u,0.s)
Chars 5830 - 5841 [(destruct~p).] 0.087 secs (0.003u,0.021s)
Chars 5844 - 5864 [exact~(lrucancel~1).] 0.002 secs (0.002u,0.s)
Chars 5830 - 5841 [(destruct~p).] 0.001 secs (0.001u,0.s)
Chars 5844 - 5864 [exact~(lrucancel~1).] 0. secs (0.u,0.s)
Chars 5865 - 5873 [Defined.] 0.004 secs (0.004u,0.s)
Chars 5936 - 6094 [Definition~ehlnat_1p~{X}~{a~:~...] 0.027 secs (0.023u,0.003s)
Chars 6095 - 6101 [Proof.] 0. secs (0.u,0.s)
Chars 3834 - 3840 [split.] 40.17 secs (0.u,0.031s)
Chars 3843 - 3844 [-] 0. secs (0.u,0.s)
Chars 3845 - 3872 [(apply~(projected_com_sg~f)).] 0.002 secs (0.001u,0.s)
Chars 3873 - 3884 [assumption.] 0. secs (0.u,0.s)
Chars 3887 - 3888 [-] 0. secs (0.u,0.s)
Chars 3889 - 3923 [(repeat~intro;~apply~(injectiv...] 0.002 secs (0.002u,0.s)
Chars 3924 - 3965 [(rewrite~!op_correct,~(idempot...] 0.004 secs (0.002u,0.001s)
Chars 3970 - 3982 [reflexivity.] 0. secs (0.u,0.s)
Chars 3834 - 3840 [split.] 0. secs (0.u,0.s)
Chars 3845 - 3872 [(apply~(projected_com_sg~f)).] 0. secs (0.u,0.s)
Chars 3873 - 3884 [assumption.] 0. secs (0.u,0.s)
Chars 3889 - 3923 [(repeat~intro;~apply~(injectiv...] 0. secs (0.u,0.s)
Chars 3924 - 3965 [(rewrite~!op_correct,~(idempot...] 0. secs (0.u,0.s)
Chars 3970 - 3982 [reflexivity.] 0. secs (0.u,0.s)
Chars 3985 - 3989 [Qed.] 0. secs (0.u,0.s)
Chars 3990 - 4010 [End~from_another_sl.] 0.004 secs (0.004u,0.s)
Chars 4012 - 4044 [Section~from_another_bounded_sl.] 0. secs (0.u,0.s)
Chars 4047 - 4077 [#[local]Open~Scope~mc_add_scope.] 0. secs (0.u,0.s)
Chars 4080 - 4291 [Context~`{IsBoundedSemiLattice...] 0.003 secs (0.001u,0.001s)
Chars 4295 - 4346 [Lemma~projected_bounded_sl~:~I...] 0. secs (0.u,0.s)
Chars 4349 - 4355 [Proof.] 0. secs (0.u,0.s)
Chars 4035 - 4068 [snrapply~Build_GroupHomomorphism.] 40.161 secs (0.001u,0.029s)
Chars 4073 - 4074 [-] 0. secs (0.u,0.s)
Chars 4075 - 4096 [srapply~Quotient_rec.] 0.058 secs (0.051u,0.007s)
Chars 4103 - 4104 [+] 0. secs (0.u,0.s)
Chars 4105 - 4113 [exact~f.] 0. secs (0.u,0.s)
Chars 4120 - 4121 [+] 0. secs (0.u,0.s)
Chars 4122 - 4140 [(cbn;~intros~x~y~n).] 0.001 secs (0.001u,0.s)
Chars 4149 - 4158 [symmetry.] 0.002 secs (0.002u,0.s)
Chars 4167 - 4186 [(apply~grp_moveL_M1).] 0.001 secs (0.001u,0.s)
Chars 4195 - 4219 [(rewrite~<-~grp_homo_inv).] 0.002 secs (0.001u,0.s)
Chars 4228 - 4251 [(rewrite~<-~grp_homo_op).] 0.002 secs (0.002u,0.s)
Chars 4260 - 4280 [(apply~h;~assumption).] 0.002 secs (0.002u,0.s)
Chars 4285 - 4286 [-] 0. secs (0.u,0.s)
Chars 4287 - 4295 [intro~x.] 0.002 secs (0.002u,0.s)
Chars 4302 - 4336 [refine~(Quotient_ind_hprop~_~_...] 0.063 secs (0.053u,0.009s)
Chars 4343 - 4351 [intro~y.] 0.003 secs (0.002u,0.s)
Chars 4352 - 4361 [revert~x.] 0.003 secs (0.003u,0.s)
Chars 4369 - 4403 [refine~(Quotient_ind_hprop~_~_...] 0.076 secs (0.07u,0.005s)
Chars 4410 - 4425 [(intro~x;~simpl).] 0.007 secs (0.006u,0.s)
Chars 4432 - 4450 [(apply~grp_homo_op).] 0.001 secs (0.001u,0.s)
Chars 4035 - 4068 [snrapply~Build_GroupHomomorphism.] 0. secs (0.u,0.s)
Chars 4075 - 4096 [srapply~Quotient_rec.] 0. secs (0.u,0.s)
Chars 4105 - 4113 [exact~f.] 0. secs (0.u,0.s)
Chars 4122 - 4140 [(cbn;~intros~x~y~n).] 0. secs (0.u,0.s)
Chars 4149 - 4158 [symmetry.] 0. secs (0.u,0.s)
Chars 4167 - 4186 [(apply~grp_moveL_M1).] 0. secs (0.u,0.s)
Chars 4195 - 4219 [(rewrite~<-~grp_homo_inv).] 0. secs (0.u,0.s)
Chars 4228 - 4251 [(rewrite~<-~grp_homo_op).] 0. secs (0.u,0.s)
Chars 4260 - 4280 [(apply~h;~assumption).] 0.001 secs (0.001u,0.s)
Chars 4287 - 4295 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 4302 - 4336 [refine~(Quotient_ind_hprop~_~_...] 0.002 secs (0.002u,0.s)
Chars 4343 - 4351 [intro~y.] 0.002 secs (0.002u,0.s)
Chars 4352 - 4361 [revert~x.] 0.002 secs (0.002u,0.s)
Chars 4369 - 4403 [refine~(Quotient_ind_hprop~_~_...] 0.002 secs (0.002u,0.s)
Chars 4410 - 4425 [(intro~x;~simpl).] 0.005 secs (0.004u,0.s)
Chars 4432 - 4450 [(apply~grp_homo_op).] 0. secs (0.u,0.s)
Chars 4453 - 4461 [Defined.] 0.018 secs (0.015u,0.002s)
Chars 4463 - 4481 [End~QuotientGroup.] 0.04 secs (0.036u,0.004s)
Chars 4483 - 4516 [Arguments~grp_quotient_map~{_~_}.] 0. secs (0.u,0.s)
Chars 4518 - 4572 [Notation~"G~/~N"~:=~(QuotientG...] 0. secs (0.u,0.s)
Chars 4634 - 4764 [Definition~QuotientGroup'~(G~:...] 0. secs (0.u,0.s)
Chars 4766 - 4795 [#[local]Open~Scope~group_scope.] 0. secs (0.u,0.s)
Chars 4843 - 5087 [Corollary~grp_quotient_rec_bet...] 0.004 secs (0.004u,0.s)
Chars 5088 - 5094 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 5097 - 5145 [(apply~equiv_path_grouphomomor...] 5.316 secs (0.004u,0.029s)
Chars 5097 - 5145 [(apply~equiv_path_grouphomomor...] 0.001 secs (0.001u,0.s)
Chars 5146 - 5154 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5202 - 5458 [Definition~grp_quotient_rec_be...] 0.006 secs (0.006u,0.s)
Chars 5580 - 5725 [Definition~grp_iso_quotient_no...] 0.003 secs (0.003u,0.s)
Chars 5726 - 5732 [Proof.] 0. secs (0.u,0.s)
Chars 12982 - 13018 [(refine~(O_indpaths~_~_~_);~in...] 40.161 secs (0.002u,0.027s)
Chars 13025 - 13055 [refine~(to_O_natural~f~x~@~_).] 0.001 secs (0.001u,0.s)
Chars 13062 - 13095 [refine~(_~@~(to_O_natural~g~x)^).] 0.001 secs (0.001u,0.s)
Chars 13102 - 13115 [(apply~ap,~pi).] 0.002 secs (0.001u,0.s)
Chars 12982 - 13018 [(refine~(O_indpaths~_~_~_);~in...] 0. secs (0.u,0.s)
Chars 13025 - 13055 [refine~(to_O_natural~f~x~@~_).] 0. secs (0.u,0.s)
Chars 13062 - 13095 [refine~(_~@~(to_O_natural~g~x)^).] 0. secs (0.u,0.s)
Chars 13102 - 13115 [(apply~ap,~pi).] 0. secs (0.u,0.s)
Chars 13120 - 13128 [Defined.] 0.001 secs (0.001u,0.s)
Chars 13186 - 13372 [Definition~O_functor_homotopy_...] 0.003 secs (0.002u,0.s)
Chars 13377 - 13383 [Proof.] 0. secs (0.u,0.s)
Chars 3026 - 3048 [(repeat~split;~apply~_).] 39.263 secs (28.011u,-0.255s)
Chars 14172 - 14510 [transitivity~~(((eta_path_univ...] 40.122 secs (0.012u,0.018s)
Chars 14515 - 14516 [-] 0. secs (0.u,0.s)
Chars 14517 - 14679 [refine~~((apD~(fun~g'~=>~equiv...] 0.008 secs (0.007u,0.s)
Chars 14686 - 14751 [refine~(transport_paths_FlFr~(...] 0.008 secs (0.006u,0.001s)
Chars 14758 - 14772 [(apply~concat2).] 0.015 secs (0.008u,0.007s)
Chars 14779 - 14780 [+] 0. secs (0.u,0.s)
Chars 14781 - 14796 [(apply~whiskerR).] 0.029 secs (0.009u,0.019s)
Chars 14805 - 14830 [(apply~inverse2,~symmetry).] 0.007 secs (0.003u,0.004s)
Chars 14839 - 14877 [refine~(eisadj~(equiv_path~A~C...] 0.009 secs (0.005u,0.003s)
Chars 14884 - 14885 [+] 0. secs (0.u,0.s)
Chars 14886 - 14934 [(symmetry;~refine~(eisadj~(equ...] 0.008 secs (0.007u,0.s)
Chars 14939 - 14940 [-] 0. secs (0.u,0.s)
Chars 14941 - 14970 [(generalize~(path_universe~g)).] 0.009 secs (0.008u,0.s)
Chars 14977 - 14986 [(intros~h).] 0.002 secs (0.002u,0.s)
Chars 14987 - 14998 [(destruct~h).] 0.021 secs (0.006u,0.015s)
Chars 14999 - 15003 [(cbn).] 0.005 secs (0.005u,0.s)
Chars 15010 - 15041 [(rewrite~!concat_1p,~!concat_p1).] 0.046 secs (0.042u,0.003s)
Chars 15048 - 15107 [refine~(_~@~whiskerR~(whiskerR...] 0.006 secs (0.006u,0.s)
Chars 15114 - 15159 [refine~(_~@~whiskerR_pp~1~_~pa...] 0.004 secs (0.004u,0.s)
Chars 15166 - 15198 [refine~(_~@~(whiskerR_p1_1~_)^).] 0.004 secs (0.004u,0.s)
Chars 15205 - 15242 [(apply~whiskerR,~whiskerL,~ap,...] 0.052 secs (0.038u,0.013s)
Chars 15249 - 15293 [(apply~path_forall;~intros~x;~...] 0.003 secs (0.003u,0.s)
Chars 14172 - 14510 [transitivity~~(((eta_path_univ...] 0.001 secs (0.001u,0.s)
Chars 14517 - 14679 [refine~~((apD~(fun~g'~=>~equiv...] 0.001 secs (0.001u,0.s)
Chars 14686 - 14751 [refine~(transport_paths_FlFr~(...] 0.001 secs (0.001u,0.s)
Chars 14758 - 14772 [(apply~concat2).] 0.001 secs (0.001u,0.s)
Chars 14781 - 14796 [(apply~whiskerR).] 0.001 secs (0.u,0.s)
Chars 14805 - 14830 [(apply~inverse2,~symmetry).] 0. secs (0.u,0.s)
Chars 14839 - 14877 [refine~(eisadj~(equiv_path~A~C...] 0. secs (0.u,0.s)
Chars 3026 - 3048 [(repeat~split;~apply~_).] 40.093 secs (0.02u,0.037s)
Chars 14886 - 14934 [(symmetry;~refine~(eisadj~(equ...] 0.001 secs (0.001u,0.s)
Chars 14941 - 14970 [(generalize~(path_universe~g)).] 0.002 secs (0.u,0.001s)
Chars 3026 - 3048 [(repeat~split;~apply~_).] 0.003 secs (0.003u,0.s)
Chars 14977 - 14986 [(intros~h).] 0.001 secs (0.001u,0.s)
Chars 3049 - 3057 [Defined.] 0.002 secs (0.002u,0.s)
Chars 14987 - 14998 [(destruct~h).] 0.001 secs (0.u,0.s)
Chars 14999 - 15003 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 15010 - 15041 [(rewrite~!concat_1p,~!concat_p1).] 0.001 secs (0.001u,0.s)
Chars 15048 - 15107 [refine~(_~@~whiskerR~(whiskerR...] 0.001 secs (0.001u,0.s)
Chars 15114 - 15159 [refine~(_~@~whiskerR_pp~1~_~pa...] 0.001 secs (0.001u,0.s)
Chars 15166 - 15198 [refine~(_~@~(whiskerR_p1_1~_)^).] 0.001 secs (0.001u,0.s)
Chars 15205 - 15242 [(apply~whiskerR,~whiskerL,~ap,...] 0.001 secs (0.001u,0.s)
Chars 15249 - 15293 [(apply~path_forall;~intros~x;~...] 0.001 secs (0.u,0.s)
Chars 8428 - 8452 [(induction~w;~simpl~in~*).] 40.18 secs (0.013u,0.041s)
Chars 8457 - 8458 [-] 0. secs (0.u,0.s)
Chars 8459 - 8477 [by~path_induction.] 0.003 secs (0.003u,0.s)
Chars 8482 - 8483 [-] 0. secs (0.u,0.s)
Chars 8484 - 8492 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 3058 - 3071 [End~contents.] 0.033 secs (0.03u,0.002s)
Chars 8493 - 8524 [now~apply~(IHw~_~(β~(f~_~x))).] 0.013 secs (0.012u,0.s)
Chars 8428 - 8452 [(induction~w;~simpl~in~*).] 0.002 secs (0.001u,0.s)
Chars 8459 - 8477 [by~path_induction.] 0. secs (0.u,0.s)
Chars 8484 - 8492 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 8493 - 8524 [now~apply~(IHw~_~(β~(f~_~x))).] 0.001 secs (0.001u,0.s)
Chars 8527 - 8535 [Defined.] 0.003 secs (0.003u,0.s)
Chars 8539 - 8718 [#[global]~Instance~is_homomorp...] 0.003 secs (0.003u,0.s)
Chars 8721 - 8727 [Proof.] 0. secs (0.u,0.s)
Chars 15296 - 15304 [Defined.] 0.079 secs (0.068u,0.01s)
Chars 15308 - 15738 [Definition~path2_universe_prec...] 0.012 secs (0.01u,0.001s)
Chars 15741 - 15747 [Proof.] 0. secs (0.u,0.s)
Chars 6626 - 6672 [exact~(BuildIsomorphic~hom_thi...] 40.194 secs (0.007u,0.038s)
Chars 6626 - 6672 [exact~(BuildIsomorphic~hom_thi...] 0. secs (0.u,0.s)
Chars 6675 - 6683 [Defined.] 0.001 secs (0.001u,0.s)
Chars 6687 - 6735 [Corollary~id_third_isomorphism...] 0.005 secs (0.004u,0.s)
Chars 6738 - 6744 [Proof.] 0. secs (0.u,0.s)
Chars 2305 - 2330 [(apply~flip_nonneg_negate).] 40.134 secs (0.006u,0.027s)
Chars 2331 - 2356 [(apply~to_semiring_nonneg).] 0.01 secs (0.009u,0.001s)
Chars 2305 - 2330 [(apply~flip_nonneg_negate).] 0. secs (0.u,0.s)
Chars 2331 - 2356 [(apply~to_semiring_nonneg).] 0. secs (0.u,0.s)
Chars 2357 - 2361 [Qed.] 0.001 secs (0.001u,0.s)
Chars 2365 - 2404 [Lemma~between_to_ring~n~:~-~f~...] 0.001 secs (0.u,0.s)
Chars 2407 - 2413 [Proof.] 0. secs (0.u,0.s)
Chars 10829 - 10851 [(split;~intros~A~A_inO).] 40.16 secs (0.001u,0.026s)
Chars 10854 - 10855 [-] 0. secs (0.u,0.s)
Chars 10856 - 10876 [(intros~x~y;~exact~_).] 0.006 secs (0.006u,0.s)
Chars 10879 - 10880 [-] 0. secs (0.u,0.s)
Chars 10881 - 10889 [exact~_.] 0.201 secs (0.168u,0.032s)
Chars 10829 - 10851 [(split;~intros~A~A_inO).] 0. secs (0.u,0.s)
Chars 10856 - 10876 [(intros~x~y;~exact~_).] 0. secs (0.u,0.s)
Chars 10881 - 10889 [exact~_.] 0. secs (0.u,0.s)
Chars 10890 - 10898 [Defined.] 0.164 secs (0.148u,0.014s)
Chars 11023 - 11086 [#[global]Instance~O_leq_Tr~~(n...] 0. secs (0.u,0.s)
Chars 11087 - 11093 [Proof.] 0. secs (0.u,0.s)
Chars 11096 - 11116 [(intros~A~?;~exact~_).] 0.092 secs (0.004u,0.028s)
Chars 11096 - 11116 [(intros~A~?;~exact~_).] 0. secs (0.u,0.s)
Chars 11117 - 11125 [Defined.] 0. secs (0.u,0.s)
Chars 11127 - 11197 [#[global]Instance~O_strong_leq...] 0. secs (0.u,0.s)
Chars 11198 - 11204 [Proof.] 0. secs (0.u,0.s)
Chars 11207 - 11236 [srapply~O_strong_leq_trans_l.] 1.938 secs (0.002u,0.027s)
Chars 11207 - 11236 [srapply~O_strong_leq_trans_l.] 0. secs (0.u,0.s)
Chars 11237 - 11245 [Defined.] 0. secs (0.u,0.s)
Chars 11309 - 11390 [#[local]~Instance~O_lex_leq_Tr...] 0. secs (0.u,0.s)
Chars 11391 - 11397 [Proof.] 0. secs (0.u,0.s)
Chars 6104 - 6115 [(destruct~p).] 40.136 secs (0.02u,0.025s)
Chars 6118 - 6143 [(apply~lrucancel_sHs_1_pp).] 0.012 secs (0.012u,0.s)
Chars 6104 - 6115 [(destruct~p).] 0.021 secs (0.014u,0.006s)
Chars 6118 - 6143 [(apply~lrucancel_sHs_1_pp).] 0.003 secs (0.003u,0.s)
Chars 6144 - 6152 [Defined.] 0.02 secs (0.017u,0.002s)
Chars 6154 - 6312 [Definition~ehrnat_p1~{X}~{a~:~...] 0.021 secs (0.018u,0.002s)
Chars 6313 - 6319 [Proof.] 0. secs (0.u,0.s)
normalized :
(fun ab : AB =>
 if match ab with
    | AA _ => true
    | BB _ => false
    end then true else false)
normalized :
(fun ab : AB =>
 if match ab with
    | AA _ => true
    | BB _ => false
    end then false else true)
normalized :
(fun ab : AB =>
 if match ab with
    | AA _ => true
    | BB _ => false
    end then false else true)
normalized : (fun _ : AB => bA)
normalized : (fun _ : AB => bA)
normalized : (fun _ : AB => bA)
Chars 4358 - 4364 [split.] 40.17 secs (0.u,0.032s)
Chars 4367 - 4368 [-] 0. secs (0.u,0.s)
Chars 4369 - 4408 [(apply~(projected_com_monoid~f...] 0.006 secs (0.005u,0.s)
Chars 4411 - 4412 [-] 0. secs (0.u,0.s)
Chars 4413 - 4447 [(repeat~intro;~apply~(injectiv...] 0.002 secs (0.002u,0.s)
Chars 4452 - 4492 [(rewrite~op_correct,~(idempote...] 0.012 secs (0.007u,0.004s)
Chars 4497 - 4505 [trivial.] 0.001 secs (0.u,0.s)
Chars 4358 - 4364 [split.] 0. secs (0.u,0.s)
Chars 4369 - 4408 [(apply~(projected_com_monoid~f...] 0.001 secs (0.001u,0.s)
Chars 4413 - 4447 [(repeat~intro;~apply~(injectiv...] 0.001 secs (0.u,0.001s)
Chars 4452 - 4492 [(rewrite~op_correct,~(idempote...] 0. secs (0.u,0.s)
Chars 4497 - 4505 [trivial.] 0. secs (0.u,0.s)
Chars 4508 - 4512 [Qed.] 0.001 secs (0.u,0.s)
Chars 4513 - 4541 [End~from_another_bounded_sl.] 0.006 secs (0.005u,0.s)
Chars 4543 - 4637 [#[global]~Instance~id_join_sl_...] 0.002 secs (0.002u,0.s)
Chars 4639 - 4733 [#[global]~Instance~id_meet_sl_...] 0.002 secs (0.002u,0.s)
Chars 4735 - 4853 [#[global]~Instance~id_bounded_...] 0.002 secs (0.002u,0.s)
Chars 4855 - 4944 [#[global]~Instance~id_lattice_...] 0.005 secs (0.002u,0.002s)
Chars 4946 - 4975 [Section~morphism_composition.] 0. secs (0.u,0.s)
Chars 4978 - 5120 [Context~`{Join~A}~`{Meet~A}~`{...] 0.001 secs (0.001u,0.s)
Chars 5124 - 5238 [Instance~compose_join_sl_morph...] 0.002 secs (0.002u,0.s)
Chars 5241 - 5247 [Proof.] 0. secs (0.u,0.s)
Chars 5250 - 5263 [(red;~apply~_).] 1.23 secs (0.025u,0.033s)
Chars 5250 - 5263 [(red;~apply~_).] 0.001 secs (0.001u,0.s)
Chars 5266 - 5270 [Qed.] 0. secs (0.u,0.s)
Chars 5274 - 5388 [Instance~compose_meet_sl_morph...] 0.002 secs (0.002u,0.s)
Chars 5391 - 5397 [Proof.] 0. secs (0.u,0.s)
Chars 5400 - 5412 [(red;~apply~_).] 0.153 secs (0.022u,0.034s)
Chars 5400 - 5412 [(red;~apply~_).] 0. secs (0.u,0.s)
Chars 5415 - 5419 [Qed.] 0. secs (0.u,0.s)
Chars 5423 - 5566 [Instance~compose_bounded_join_...] 0.003 secs (0.002u,0.s)
Chars 5569 - 5575 [Proof.] 0. secs (0.u,0.s)
Chars 5578 - 5591 [(red;~apply~_).] 0.112 secs (0.007u,0.032s)
Chars 5578 - 5591 [(red;~apply~_).] 0.001 secs (0.001u,0.s)
Chars 5594 - 5598 [Qed.] 0.001 secs (0.001u,0.s)
Chars 5602 - 5721 [Instance~compose_lattice_morph...] 0.003 secs (0.002u,0.001s)
Chars 5724 - 5730 [Proof.] 0. secs (0.u,0.s)
Chars 5733 - 5748 [(split;~apply~_).] 1.177 secs (0.009u,0.031s)
Chars 5733 - 5748 [(split;~apply~_).] 0.001 secs (0.u,0.001s)
Chars 5751 - 5755 [Qed.] 0. secs (0.u,0.s)
Chars 5759 - 5869 [Instance~invert_join_sl_morphi...] 0.003 secs (0.002u,0.s)
Chars 5872 - 5878 [Proof.] 0. secs (0.u,0.s)
normalized : (fun _ : AB => bA)
Chars 5881 - 5894 [(red;~apply~_).] 0.149 secs (0.02u,0.035s)
Chars 5881 - 5894 [(red;~apply~_).] 0. secs (0.u,0.s)
Chars 5897 - 5901 [Qed.] 0. secs (0.u,0.s)
Chars 5905 - 6015 [Instance~invert_meet_sl_morphi...] 0.002 secs (0.002u,0.s)
Chars 6018 - 6024 [Proof.] 0. secs (0.u,0.s)
Chars 6027 - 6040 [(red;~apply~_).] 0.146 secs (0.022u,0.031s)
Chars 6027 - 6040 [(red;~apply~_).] 0. secs (0.u,0.s)
Chars 6043 - 6047 [Qed.] 0. secs (0.u,0.s)
Chars 6051 - 6183 [Instance~invert_bounded_join_s...] 0.003 secs (0.002u,0.001s)
Chars 6186 - 6192 [Proof.] 0. secs (0.u,0.s)
Chars 6195 - 6208 [(red;~apply~_).] 0.109 secs (0.006u,0.031s)
Chars 6195 - 6208 [(red;~apply~_).] 0. secs (0.u,0.s)
Chars 6211 - 6215 [Qed.] 0. secs (0.u,0.s)
Chars 6219 - 6331 [Instance~invert_lattice_morphi...] 0.003 secs (0.002u,0.001s)
Chars 6334 - 6340 [Proof.] 0. secs (0.u,0.s)
Chars 6343 - 6358 [(split;~apply~_).] 0.114 secs (0.006u,0.031s)
Chars 6343 - 6358 [(split;~apply~_).] 0.001 secs (0.001u,0.s)
Chars 6361 - 6365 [Qed.] 0. secs (0.u,0.s)
Chars 6366 - 6391 [End~morphism_composition.] 0.009 secs (0.009u,0.s)
Chars 6393 - 6511 [#[export]~Hint~Extern~4~(IsJoi...] 0. secs (0.u,0.s)
Chars 6512 - 6630 [#[export]~Hint~Extern~4~(IsMee...] 0. secs (0.u,0.s)
Chars 6631 - 6764 [#[export]~Hint~Extern~4~(IsBou...] 0. secs (0.u,0.s)
Chars 6765 - 6886 [#[export]~Hint~Extern~4~(IsLat...] 0. secs (0.u,0.s)
Chars 6887 - 7001 [#[export]~Hint~Extern~4~(IsJoi...] 0. secs (0.u,0.s)
Chars 7002 - 7116 [#[export]~Hint~Extern~4~(IsMee...] 0. secs (0.u,0.s)
Chars 7117 - 7246 [#[export]~Hint~Extern~4~(IsBou...] 0. secs (0.u,0.s)
Chars 7247 - 7364 [#[export]~Hint~Extern~4~(IsLat...] 0. secs (0.u,0.s)
normalized : (fun _ : AB => bA)
normalized : (fun _ : AB => bA)
Chars 5735 - 5768 [snrapply~Build_GroupIsomorphism'.] 40.142 secs (0.003u,0.029s)
Chars 5771 - 5786 [1:~reflexivity.] 0.001 secs (0.u,0.s)
Chars 5789 - 5797 [intro~x.] 0. secs (0.u,0.s)
Chars 5800 - 5846 [(srapply~Quotient_ind_hprop;~i...] 0.056 secs (0.049u,0.005s)
Chars 5849 - 5885 [(srapply~Quotient_ind_hprop;~i...] 0.068 secs (0.055u,0.012s)
Chars 5888 - 5900 [reflexivity.] 0.031 secs (0.027u,0.003s)
Chars 5735 - 5768 [snrapply~Build_GroupIsomorphism'.] 0. secs (0.u,0.s)
Chars 5771 - 5786 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 5789 - 5797 [intro~x.] 0. secs (0.u,0.s)
Chars 5800 - 5846 [(srapply~Quotient_ind_hprop;~i...] 0.002 secs (0.002u,0.s)
Chars 5849 - 5885 [(srapply~Quotient_ind_hprop;~i...] 0.001 secs (0.001u,0.s)
Chars 5888 - 5900 [reflexivity.] 0. secs (0.u,0.s)
Chars 5901 - 5909 [Defined.] 0.034 secs (0.027u,0.006s)
Chars 5960 - 6131 [Theorem~equiv_grp_quotient_ump...] 0.003 secs (0.003u,0.s)
Chars 6132 - 6138 [Proof.] 0. secs (0.u,0.s)
Chars 13390 - 13427 [(refine~(O_ind2paths~_~_~_);~i...] 40.16 secs (0.002u,0.029s)
Chars 13434 - 13470 [(unfold~composeD,~O_functor_ho...] 0.001 secs (0.001u,0.s)
Chars 13477 - 13539 [(rewrite~!O_indpaths_beta,~!ap...] 0.049 secs (0.036u,0.012s)
Chars 13546 - 13558 [reflexivity.] 0.002 secs (0.001u,0.001s)
Chars 13390 - 13427 [(refine~(O_ind2paths~_~_~_);~i...] 0.001 secs (0.001u,0.s)
Chars 13434 - 13470 [(unfold~composeD,~O_functor_ho...] 0. secs (0.u,0.s)
Chars 13477 - 13539 [(rewrite~!O_indpaths_beta,~!ap...] 0.001 secs (0.001u,0.s)
Chars 13546 - 13558 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 13563 - 13567 [Qed.] 0.027 secs (0.021u,0.005s)
Chars 13627 - 13862 [Definition~O_functor_square~{A...] 0.004 secs (0.003u,0.s)
Chars 13867 - 13873 [Proof.] 0. secs (0.u,0.s)
normalized : (fun _ : AB => bA)
Chars 8732 - 8740 [intro~u.] 40.155 secs (0.001u,0.031s)
Chars 8745 - 8796 [by~apply~(oppreserving_compose...] 0.003 secs (0.003u,0.s)
Chars 8732 - 8740 [intro~u.] 0. secs (0.u,0.s)
Chars 8745 - 8796 [by~apply~(oppreserving_compose...] 0. secs (0.u,0.s)
Chars 8799 - 8807 [Defined.] 0.001 secs (0.001u,0.s)
Chars 15750 - 16071 [transitivity~~(((eta_path_univ...] 40.118 secs (0.011u,0.019s)
Chars 16074 - 16075 [-] 0. secs (0.u,0.s)
Chars 8811 - 8998 [#[global]~Instance~is_isomorph...] 0.005 secs (0.005u,0.s)
Chars 9001 - 9007 [Proof.] 0. secs (0.u,0.s)
Chars 16076 - 16228 [refine~~((apD~(fun~g'~=>~equiv...] 0.008 secs (0.008u,0.s)
Chars 16233 - 16298 [refine~(transport_paths_FlFr~(...] 0.007 secs (0.007u,0.s)
Chars 16303 - 16317 [(apply~concat2).] 0.008 secs (0.006u,0.s)
Chars 16322 - 16323 [+] 0. secs (0.u,0.s)
Chars 16324 - 16339 [(apply~whiskerR).] 0.01 secs (0.008u,0.001s)
Chars 16346 - 16371 [(apply~inverse2,~symmetry).] 0.004 secs (0.003u,0.001s)
Chars 16378 - 16416 [refine~(eisadj~(equiv_path~A~B...] 0.006 secs (0.006u,0.s)
Chars 16421 - 16422 [+] 0. secs (0.u,0.s)
Chars 16423 - 16471 [(symmetry;~refine~(eisadj~(equ...] 0.032 secs (0.02u,0.011s)
Chars 16474 - 16475 [-] 0. secs (0.u,0.s)
Chars 16476 - 16505 [(generalize~(path_universe~g)).] 0.008 secs (0.007u,0.s)
Chars 16510 - 16519 [(intros~h).] 0.002 secs (0.002u,0.s)
Chars 16520 - 16531 [(destruct~h).] 0.009 secs (0.008u,0.s)
Chars 16532 - 16536 [(cbn).] 0.006 secs (0.005u,0.001s)
Chars 16541 - 16560 [(rewrite~!concat_p1).] 0.028 secs (0.018u,0.008s)
Chars 16565 - 16635 [refine~(_~@~(((concat_1p~(whis...] 0.01 secs (0.007u,0.002s)
Chars 16640 - 16699 [refine~(_~@~whiskerR~(whiskerL...] 0.007 secs (0.006u,0.s)
Chars 16704 - 16749 [refine~(_~@~whiskerL_pp~1~_~pa...] 0.005 secs (0.003u,0.001s)
Chars 16754 - 16781 [exact~(whiskerL_1p_1~_)^.] 0.005 secs (0.005u,0.s)
Chars 15750 - 16071 [transitivity~~(((eta_path_univ...] 0.001 secs (0.001u,0.s)
Chars 16076 - 16228 [refine~~((apD~(fun~g'~=>~equiv...] 0.001 secs (0.u,0.s)
Chars 16233 - 16298 [refine~(transport_paths_FlFr~(...] 0.001 secs (0.001u,0.s)
Chars 16303 - 16317 [(apply~concat2).] 0.001 secs (0.001u,0.s)
Chars 16324 - 16339 [(apply~whiskerR).] 0.001 secs (0.001u,0.s)
Chars 16346 - 16371 [(apply~inverse2,~symmetry).] 0. secs (0.u,0.s)
Chars 16378 - 16416 [refine~(eisadj~(equiv_path~A~B...] 0. secs (0.u,0.s)
Chars 16423 - 16471 [(symmetry;~refine~(eisadj~(equ...] 0.001 secs (0.001u,0.s)
Chars 16476 - 16505 [(generalize~(path_universe~g)).] 0.002 secs (0.002u,0.s)
Chars 16510 - 16519 [(intros~h).] 0.001 secs (0.u,0.s)
Chars 16520 - 16531 [(destruct~h).] 0.001 secs (0.001u,0.s)
Chars 16532 - 16536 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 16541 - 16560 [(rewrite~!concat_p1).] 0.002 secs (0.001u,0.s)
Chars 16565 - 16635 [refine~(_~@~(((concat_1p~(whis...] 0.001 secs (0.001u,0.s)
Chars 16640 - 16699 [refine~(_~@~whiskerR~(whiskerL...] 0.001 secs (0.001u,0.s)
Chars 16704 - 16749 [refine~(_~@~whiskerL_pp~1~_~pa...] 0.001 secs (0.001u,0.s)
Chars 16754 - 16781 [exact~(whiskerL_1p_1~_)^.] 0.001 secs (0.001u,0.s)
Chars 16784 - 16792 [Defined.] 0.084 secs (0.057u,0.021s)
Chars 16794 - 16818 [End~PathEquivSimplNever.] 0.093 secs (0.079u,0.013s)
Chars 16839 - 16989 [Definition~equiv_path3_univers...] 0.003 secs (0.003u,0.s)
Chars 16990 - 16996 [Proof.] 0. secs (0.u,0.s)
Chars 6749 - 6800 [exact~(id_isomorphic~isomorphi...] 40.181 secs (0.001u,0.039s)
Chars 6749 - 6800 [exact~(id_isomorphic~isomorphi...] 0. secs (0.u,0.s)
Chars 6803 - 6811 [Defined.] 0.001 secs (0.001u,0.s)
Chars 6812 - 6834 [End~third_isomorphism.] 0.098 secs (0.084u,0.013s)
find_witness Control.Timeout[DEBUG] All good, a was instantiated with b's type (tFalse)
Chars 2414 - 2435 [(apply~between_nonneg).] 40.149 secs (0.006u,0.025s)
Chars 2436 - 2461 [(apply~to_semiring_nonneg).] 0.011 secs (0.007u,0.003s)
Chars 2414 - 2435 [(apply~between_nonneg).] 0. secs (0.u,0.s)
Chars 2436 - 2461 [(apply~to_semiring_nonneg).] 0. secs (0.u,0.s)
Chars 2462 - 2466 [Qed.] 0.001 secs (0.u,0.s)
Chars 2467 - 2484 [End~another_ring.] 0.004 secs (0.002u,0.001s)
Chars 9012 - 9020 [intro~s.] 6.954 secs (0.001u,0.03s)
Chars 9021 - 9043 [(apply~isequiv_compose).] 0.025 secs (0.018u,0.006s)
Chars 9012 - 9020 [intro~s.] 0. secs (0.u,0.s)
Chars 9021 - 9043 [(apply~isequiv_compose).] 0. secs (0.u,0.s)
Chars 9046 - 9050 [Qed.] 0.001 secs (0.001u,0.s)
Chars 9054 - 9193 [Definition~hom_compose~(g~:~Ho...] 0.006 secs (0.005u,0.s)
Chars 2485 - 2504 [End~naturals_order.] 0.051 secs (0.05u,0.s)
Chars 2506 - 2597 [#[export]~Hint~Extern~20~(Prop...] 0. secs (0.u,0.s)
Chars 9195 - 9211 [End~hom_compose.] 0.012 secs (0.012u,0.s)
Chars 9303 - 9328 [Section~path_isomorphism.] 0. secs (0.u,0.s)
Chars 9331 - 9389 [Context~`{Univalence}~{σ~:~Sig...] 0. secs (0.u,0.s)
Chars 9576 - 9664 [#[local]~Notation~path_equiv_f...] 0. secs (0.u,0.s)
Chars 10057 - 10315 [Lemma~path_operations_equiv~{w...] 0.012 secs (0.011u,0.s)
Chars 10318 - 10324 [Proof.] 0. secs (0.u,0.s)
[DEBUG] {|
  case_ind := nat;
  case_val := 3;
  case_return := Dyn (fun _ : nat => bool);
  case_branches := [m: Dyn true
                     | Dyn (fun _ : nat => false)]
|}
find_witness Control.TimeoutChars 11400 - 11500 [(intros~A;~unshelve~econstruct...] 40.159 secs (0.01u,0.025s)
Chars 11503 - 11504 [-] 0. secs (0.u,0.s)
Chars 11505 - 11526 [refine~(Trunc_rec~P).] 0.001 secs (0.001u,0.s)
Chars 11529 - 11530 [-] 0. secs (0.u,0.s)
Chars 11531 - 11554 [(intros;~simpl;~exact~_).] 0.004 secs (0.003u,0.s)
Chars 11557 - 11558 [-] 0. secs (0.u,0.s)
Chars 11559 - 11571 [(intros;~cbn).] 0.002 secs (0.002u,0.s)
Chars 11572 - 11584 [reflexivity.] 0.001 secs (0.u,0.s)
Chars 11400 - 11500 [(intros~A;~unshelve~econstruct...] 0.002 secs (0.002u,0.s)
Chars 11505 - 11526 [refine~(Trunc_rec~P).] 0. secs (0.u,0.s)
Chars 11531 - 11554 [(intros;~simpl;~exact~_).] 0.002 secs (0.002u,0.s)
Chars 11559 - 11571 [(intros;~cbn).] 0.001 secs (0.001u,0.s)
Chars 11572 - 11584 [reflexivity.] 0. secs (0.u,0.s)
Chars 11585 - 11593 [Defined.] 0.001 secs (0.001u,0.s)
Chars 11595 - 11711 [Definition~path_Tr~{n}~{A}~(x~...] 0.004 secs (0.003u,0.s)
Chars 11713 - 11856 [Definition~equiv_path_Tr~`{Uni...] 0.004 secs (0.003u,0.001s)
Chars 11858 - 11877 [End~SeparatedTrunc.] 0.012 secs (0.012u,0.s)
Chars 6322 - 6333 [(destruct~p).] 40.135 secs (0.018u,0.021s)
Chars 6336 - 6361 [(apply~lrucancel_sHs_1_pp).] 0.18 secs (0.165u,0.014s)
Chars 6322 - 6333 [(destruct~p).] 0.003 secs (0.001u,0.001s)
Chars 6336 - 6361 [(apply~lrucancel_sHs_1_pp).] 0.003 secs (0.002u,0.001s)
Chars 6362 - 6370 [Defined.] 0.017 secs (0.017u,0.s)
Chars 6439 - 6573 [#[local]~Definition~concat_p_p...] 0.002 secs (0.001u,0.001s)
Chars 6574 - 6580 [Proof.] 0. secs (0.u,0.s)
Chars 6583 - 6603 [by~destruct~p,~q,~r.] 0.184 secs (0.004u,0.022s)
Chars 6583 - 6603 [by~destruct~p,~q,~r.] 0. secs (0.u,0.s)
Chars 6604 - 6612 [Defined.] 0.002 secs (0.002u,0.s)
Chars 6614 - 6748 [#[local]~Definition~concat_pp_...] 0.002 secs (0.001u,0.s)
Chars 6749 - 6755 [Proof.] 0. secs (0.u,0.s)
Chars 6758 - 6778 [by~destruct~p,~q,~r.] 0.072 secs (0.005u,0.022s)
Chars 6758 - 6778 [by~destruct~p,~q,~r.] 0. secs (0.u,0.s)
Chars 6779 - 6787 [Defined.] 0.002 secs (0.002u,0.s)
Chars 6866 - 7016 [#[local]~Definition~whiskerL_p...] 0.002 secs (0.002u,0.s)
Chars 7017 - 7023 [Proof.] 0. secs (0.u,0.s)
Chars 7026 - 7043 [by~destruct~p,~q.] 0.077 secs (0.005u,0.02s)
Chars 7026 - 7043 [by~destruct~p,~q.] 0. secs (0.u,0.s)
Chars 7044 - 7052 [Defined.] 0.002 secs (0.002u,0.s)
Chars 7054 - 7204 [#[local]~Definition~whiskerR_p...] 0.002 secs (0.002u,0.s)
Chars 7205 - 7211 [Proof.] 0. secs (0.u,0.s)
Chars 7214 - 7231 [by~destruct~p,~q.] 0.072 secs (0.002u,0.023s)
Chars 7214 - 7231 [by~destruct~p,~q.] 0. secs (0.u,0.s)
Chars 7232 - 7240 [Defined.] 0.002 secs (0.001u,0.001s)
Chars 7327 - 7475 [Definition~ulnat_pp~{X}~{a~b~:...] 0.014 secs (0.01u,0.003s)
Chars 7476 - 7482 [Proof.] 0. secs (0.u,0.s)
Chars 6141 - 6166 [srapply~equiv_adjointify.] 40.162 secs (0.001u,0.029s)
Chars 6169 - 6170 [-] 0. secs (0.u,0.s)
Chars 6171 - 6184 [(intros~[f~p]).] 0.001 secs (0.001u,0.s)
Chars 6189 - 6222 [exact~(grp_quotient_rec~_~_~f~p).] 0.001 secs (0.001u,0.s)
Chars 6225 - 6226 [-] 0. secs (0.u,0.s)
Chars 6227 - 6235 [intro~f.] 0. secs (0.u,0.s)
Chars 6240 - 6271 [exists~(f~$o~grp_quotient_map).] 0.002 secs (0.002u,0.s)
Chars 6276 - 6292 [(intros~n~h;~cbn).] 0.001 secs (0.001u,0.s)
Chars 6297 - 6326 [refine~(_~@~grp_homo_unit~f).] 0.001 secs (0.001u,0.s)
Chars 6331 - 6340 [(apply~ap).] 0.001 secs (0.001u,0.s)
Chars 6345 - 6362 [(apply~qglue;~cbn).] 0.002 secs (0.002u,0.s)
Chars 6367 - 6424 [(rewrite~right_identity;~by~ap...] 0.011 secs (0.009u,0.001s)
Chars 6427 - 6428 [-] 0. secs (0.u,0.s)
Chars 6429 - 6438 [(intros~f).] 0.003 secs (0.003u,0.s)
Chars 6443 - 6479 [rapply~equiv_path_grouphomomor...] 0.004 secs (0.002u,0.001s)
Chars 6486 - 6516 [by~srapply~Quotient_ind_hprop.] 0.103 secs (0.086u,0.017s)
Chars 6519 - 6520 [-] 0. secs (0.u,0.s)
Chars 6521 - 6534 [(intros~[f~p]).] 0.008 secs (0.006u,0.001s)
Chars 6539 - 6571 [(srapply~path_sigma_hprop;~sim...] 0.093 secs (0.084u,0.007s)
Chars 6576 - 6614 [exact~(grp_quotient_rec_beta~N...] 0.002 secs (0.001u,0.s)
Chars 6141 - 6166 [srapply~equiv_adjointify.] 0. secs (0.u,0.s)
Chars 6171 - 6184 [(intros~[f~p]).] 0. secs (0.u,0.s)
Chars 6189 - 6222 [exact~(grp_quotient_rec~_~_~f~p).] 0. secs (0.u,0.s)
Chars 6227 - 6235 [intro~f.] 0. secs (0.u,0.s)
Chars 6240 - 6271 [exists~(f~$o~grp_quotient_map).] 0. secs (0.u,0.s)
Chars 6276 - 6292 [(intros~n~h;~cbn).] 0. secs (0.u,0.s)
Chars 6297 - 6326 [refine~(_~@~grp_homo_unit~f).] 0. secs (0.u,0.s)
Chars 6331 - 6340 [(apply~ap).] 0. secs (0.u,0.s)
Chars 6345 - 6362 [(apply~qglue;~cbn).] 0. secs (0.u,0.s)
Chars 6367 - 6424 [(rewrite~right_identity;~by~ap...] 0. secs (0.u,0.s)
Chars 6429 - 6438 [(intros~f).] 0.002 secs (0.002u,0.s)
Chars 6443 - 6479 [rapply~equiv_path_grouphomomor...] 0.001 secs (0.001u,0.s)
Chars 6486 - 6516 [by~srapply~Quotient_ind_hprop.] 0.001 secs (0.001u,0.s)
Chars 6521 - 6534 [(intros~[f~p]).] 0.002 secs (0.002u,0.s)
Chars 6539 - 6571 [(srapply~path_sigma_hprop;~sim...] 0.004 secs (0.004u,0.s)
Chars 6576 - 6614 [exact~(grp_quotient_rec_beta~N...] 0. secs (0.u,0.s)
Chars 6615 - 6623 [Defined.] 0.022 secs (0.018u,0.003s)
Chars 6625 - 6642 [Section~FirstIso.] 0. secs (0.u,0.s)
Chars 6646 - 6694 [Context~`{Funext}~{A~B~:~Group...] 0. secs (0.u,0.s)
Chars 6790 - 6863 [Definition~grp_image_quotient~...] 0.001 secs (0.001u,0.s)
Chars 6866 - 6872 [Proof.] 0. secs (0.u,0.s)
Chars 13880 - 13889 [(intros~x).] 40.145 secs (0.001u,0.027s)
Chars 13896 - 13933 [transitivity~(O_functor~(f~o~p...] 0.003 secs (0.002u,0.s)
Chars 13940 - 13941 [-] 0. secs (0.u,0.s)
Chars 13942 - 13977 [(symmetry;~rapply~O_functor_co...] 0.005 secs (0.004u,0.s)
Chars 13984 - 13985 [-] 0. secs (0.u,0.s)
Chars 13986 - 14023 [transitivity~(O_functor~(g~o~p...] 0.003 secs (0.003u,0.s)
Chars 14032 - 14033 [*] 0. secs (0.u,0.s)
Chars 14034 - 14065 [(apply~O_functor_homotopy,~comm).] 0.001 secs (0.001u,0.s)
Chars 14074 - 14075 [*] 0. secs (0.u,0.s)
Chars 14076 - 14101 [rapply~O_functor_compose.] 0.002 secs (0.001u,0.001s)
Chars 13880 - 13889 [(intros~x).] 0. secs (0.u,0.s)
Chars 13896 - 13933 [transitivity~(O_functor~(f~o~p...] 0. secs (0.u,0.s)
Chars 13942 - 13977 [(symmetry;~rapply~O_functor_co...] 0.001 secs (0.001u,0.s)
Chars 13986 - 14023 [transitivity~(O_functor~(g~o~p...] 0. secs (0.u,0.s)
Chars 14034 - 14065 [(apply~O_functor_homotopy,~comm).] 0. secs (0.u,0.s)
Chars 14076 - 14101 [rapply~O_functor_compose.] 0. secs (0.u,0.s)
Chars 14106 - 14114 [Defined.] 0.001 secs (0.001u,0.s)
Chars 14159 - 14233 [Definition~O_functor_idmap~(A~...] 0. secs (0.u,0.s)
Chars 14238 - 14244 [Proof.] 0. secs (0.u,0.s)
Chars 14251 - 14287 [(refine~(O_indpaths~_~_~_);~in...] 0.46 secs (0.002u,0.027s)
Chars 14294 - 14311 [(apply~O_rec_beta).] 0.001 secs (0.001u,0.s)
Chars 14251 - 14287 [(refine~(O_indpaths~_~_~_);~in...] 0. secs (0.u,0.s)
Chars 14294 - 14311 [(apply~O_rec_beta).] 0. secs (0.u,0.s)
Chars 14316 - 14324 [Defined.] 0. secs (0.u,0.s)
Chars 14393 - 14554 [Definition~O_functor_2homotopy...] 0.002 secs (0.002u,0.s)
Chars 14559 - 14565 [Proof.] 0. secs (0.u,0.s)
Chars 16999 - 17035 [refine~(_~oE~equiv_path_forall...] 40.103 secs (0.001u,0.018s)
Chars 17038 - 17088 [refine~(_~oE~equiv_ap~(equiv_p...] 0.004 secs (0.003u,0.001s)
Chars 17091 - 17141 [refine~(_~oE~equiv_ap~(equiv_p...] 0.021 secs (0.018u,0.002s)
Chars 17144 - 17188 [(unfold~path2_universe,~equiv_...] 0.001 secs (0.001u,0.s)
Chars 17191 - 17197 [(simpl).] 0.031 secs (0.027u,0.003s)
Chars 17198 - 17245 [refine~(equiv_ap~(ap~(equiv_pa...] 0.03 secs (0.025u,0.004s)
Chars 16999 - 17035 [refine~(_~oE~equiv_path_forall...] 0. secs (0.u,0.s)
Chars 17038 - 17088 [refine~(_~oE~equiv_ap~(equiv_p...] 0. secs (0.u,0.s)
Chars 17091 - 17141 [refine~(_~oE~equiv_ap~(equiv_p...] 0. secs (0.u,0.s)
Chars 17144 - 17188 [(unfold~path2_universe,~equiv_...] 0. secs (0.u,0.s)
Chars 17191 - 17197 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 17198 - 17245 [refine~(equiv_ap~(ap~(equiv_pa...] 0.002 secs (0.001u,0.s)
Chars 17246 - 17254 [Defined.] 0.01 secs (0.009u,0.s)
Chars 17256 - 17429 [Definition~path3_universe~`{Fu...] 0.006 secs (0.005u,0.001s)
Chars 17431 - 17702 [Definition~transport_path_univ...] 0.008 secs (0.005u,0.002s)
Chars 17703 - 17709 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 10329 - 10353 [(induction~w;~simpl~in~*).] 40.157 secs (0.007u,0.031s)
Chars 10358 - 10359 [-] 0. secs (0.u,0.s)
Chars 10360 - 10389 [transport_path_forall_hammer.] 0.008 secs (0.008u,0.s)
Chars 10396 - 10454 [exact~(ap10~(transport_idmap_p...] 0.002 secs (0.002u,0.s)
Chars 10459 - 10460 [-] 0. secs (0.u,0.s)
Chars 10461 - 10470 [funext~y.] 0.003 secs (0.003u,0.s)
Chars 10477 - 10506 [transport_path_forall_hammer.] 0.01 secs (0.008u,0.001s)
Chars 10513 - 10547 [(rewrite~transport_forall_cons...] 0.005 secs (0.005u,0.s)
Chars 10554 - 10586 [(rewrite~transport_arrow_tocon...] 0.005 secs (0.005u,0.s)
Chars 10593 - 10635 [(rewrite~(transport_path_unive...] 0.006 secs (0.006u,0.s)
Chars 10642 - 10652 [(apply~IHw).] 0.002 secs (0.002u,0.s)
Chars 10659 - 10687 [specialize~(P~((f~t)^-1~y)).] 0.01 secs (0.01u,0.s)
Chars 10694 - 10728 [by~rewrite~(eisretr~(f~t)~y)~i...] 0.004 secs (0.004u,0.s)
Chars 10329 - 10353 [(induction~w;~simpl~in~*).] 0.003 secs (0.002u,0.001s)
Chars 10360 - 10389 [transport_path_forall_hammer.] 0. secs (0.u,0.s)
Chars 10396 - 10454 [exact~(ap10~(transport_idmap_p...] 0. secs (0.u,0.s)
Chars 10461 - 10470 [funext~y.] 0.001 secs (0.001u,0.s)
Chars 10477 - 10506 [transport_path_forall_hammer.] 0.001 secs (0.u,0.s)
Chars 10513 - 10547 [(rewrite~transport_forall_cons...] 0.001 secs (0.u,0.s)
Chars 10554 - 10586 [(rewrite~transport_arrow_tocon...] 0.001 secs (0.u,0.s)
Chars 10593 - 10635 [(rewrite~(transport_path_unive...] 0.001 secs (0.u,0.s)
Chars 10642 - 10652 [(apply~IHw).] 0.001 secs (0.u,0.s)
Chars 10659 - 10687 [specialize~(P~((f~t)^-1~y)).] 0.001 secs (0.001u,0.s)
Chars 10694 - 10728 [by~rewrite~(eisretr~(f~t)~y)~i...] 0.001 secs (0.u,0.001s)
Chars 10731 - 10735 [Qed.] 0.021 secs (0.019u,0.001s)
Chars 11363 - 11593 [Lemma~path_operations_isomorph...] 0.048 secs (0.033u,0.014s)
Chars 11596 - 11602 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 6877 - 6902 [srapply~grp_quotient_rec.] 23.37 secs (9.568u,-0.481s)
Chars 7485 - 7505 [by~destruct~p,~q,~u.] 40.135 secs (0.024u,0.025s)
Chars 7485 - 7505 [by~destruct~p,~q,~u.] 0.002 secs (0.001u,0.001s)
Chars 7506 - 7514 [Defined.] 0.019 secs (0.015u,0.004s)
Chars 7601 - 7749 [Definition~urnat_pp~{X}~{a~b~:...] 0.015 secs (0.009u,0.005s)
Chars 7750 - 7756 [Proof.] 0. secs (0.u,0.s)
Chars 7759 - 7779 [by~destruct~p,~q,~u.] 0.191 secs (0.033u,0.027s)
Chars 7759 - 7779 [by~destruct~p,~q,~u.] 0.001 secs (0.001u,0.s)
Chars 7780 - 7788 [Defined.] 0.018 secs (0.018u,0.s)
Chars 7884 - 8118 [Definition~ehlnat_pp~{X}~{a~:~...] 0.043 secs (0.041u,0.001s)
Chars 8119 - 8125 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 6877 - 6902 [srapply~grp_quotient_rec.] 40.061 secs (0.001u,0.029s)
Chars 6907 - 6908 [+] 0. secs (0.u,0.s)
Chars 6909 - 6930 [srapply~grp_image_in.] 0.001 secs (0.001u,0.s)
Chars 6935 - 6936 [+] 0. secs (0.u,0.s)
Chars 6937 - 6948 [(intros~n~x).] 0. secs (0.u,0.s)
Chars 6955 - 6981 [by~apply~path_sigma_hprop.] 0.028 secs (0.021u,0.006s)
Chars 6877 - 6902 [srapply~grp_quotient_rec.] 0. secs (0.u,0.s)
Chars 6909 - 6930 [srapply~grp_image_in.] 0. secs (0.u,0.s)
Chars 6937 - 6948 [(intros~n~x).] 0. secs (0.u,0.s)
Chars 6955 - 6981 [by~apply~path_sigma_hprop.] 0. secs (0.u,0.s)
Chars 6984 - 6992 [Defined.] 0.001 secs (0.001u,0.s)
Chars 7063 - 7139 [#[global]Instance~isequiv_grp_...] 0. secs (0.u,0.s)
Chars 7142 - 7148 [Proof.] 0. secs (0.u,0.s)
Chars 14572 - 14609 [(refine~(O_ind2paths~_~_~_);~i...] 40.129 secs (0.003u,0.028s)
Chars 14616 - 14652 [(unfold~O_functor_homotopy,~co...] 0.001 secs (0.u,0.s)
Chars 14659 - 14688 [(do~2~rewrite~O_indpaths_beta).] 0.012 secs (0.011u,0.s)
Chars 14695 - 14727 [(apply~whiskerL,~whiskerR,~ap,...] 0.004 secs (0.004u,0.s)
Chars 14572 - 14609 [(refine~(O_ind2paths~_~_~_);~i...] 0.001 secs (0.001u,0.s)
Chars 14616 - 14652 [(unfold~O_functor_homotopy,~co...] 0. secs (0.u,0.s)
Chars 14659 - 14688 [(do~2~rewrite~O_indpaths_beta).] 0.001 secs (0.001u,0.s)
Chars 14695 - 14727 [(apply~whiskerL,~whiskerR,~ap,...] 0.001 secs (0.001u,0.s)
Chars 14829 - 14833 [Qed.] 0.013 secs (0.012u,0.s)
Chars 14908 - 15131 [Definition~O_functor_homotopy_...] 0.003 secs (0.002u,0.s)
Chars 15136 - 15142 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 17712 - 17722 [(pattern~f).] 40.085 secs (0.004u,0.015s)
Chars 17725 - 17777 [(refine~(equiv_ind~(equiv_path...] 0.006 secs (0.006u,0.s)
Chars 17780 - 17895 [refine~~(_~@~~~ap_transport_pV...] 0.01 secs (0.009u,0.001s)
Chars 17898 - 17913 [(apply~whiskerR).] 0.01 secs (0.009u,0.s)
Chars 17916 - 17946 [refine~((concat_Ap~_~_)^~@~_).] 0.008 secs (0.008u,0.s)
Chars 17949 - 17963 [(apply~concat2).] 0.006 secs (0.004u,0.001s)
Chars 17966 - 17967 [-] 0. secs (0.u,0.s)
Chars 17968 - 17977 [(apply~ap).] 0.005 secs (0.005u,0.s)
Chars 17982 - 18036 [refine~(transport_path_univers...] 0.005 secs (0.005u,0.s)
Chars 18041 - 18057 [(unfold~inverse2).] 0.001 secs (0.001u,0.s)
Chars 18058 - 18126 [(symmetry;~apply~(ap_compose~i...] 0.009 secs (0.007u,0.002s)
Chars 18129 - 18130 [-] 0. secs (0.u,0.s)
Chars 18131 - 18172 [(apply~transport_path_universe...] 0.004 secs (0.003u,0.s)
Chars 17712 - 17722 [(pattern~f).] 0.001 secs (0.001u,0.s)
Chars 17725 - 17777 [(refine~(equiv_ind~(equiv_path...] 0.002 secs (0.002u,0.s)
Chars 17780 - 17895 [refine~~(_~@~~~ap_transport_pV...] 0.001 secs (0.001u,0.s)
Chars 17898 - 17913 [(apply~whiskerR).] 0.002 secs (0.002u,0.s)
Chars 17916 - 17946 [refine~((concat_Ap~_~_)^~@~_).] 0.001 secs (0.001u,0.s)
Chars 17949 - 17963 [(apply~concat2).] 0.001 secs (0.001u,0.s)
Chars 17968 - 17977 [(apply~ap).] 0.001 secs (0.001u,0.s)
Chars 17982 - 18036 [refine~(transport_path_univers...] 0. secs (0.u,0.s)
Chars 18041 - 18057 [(unfold~inverse2).] 0. secs (0.u,0.s)
Chars 18058 - 18126 [(symmetry;~apply~(ap_compose~i...] 0.001 secs (0.001u,0.s)
Chars 18131 - 18172 [(apply~transport_path_universe...] 0. secs (0.u,0.s)
Chars 18173 - 18181 [Defined.] 0.084 secs (0.058u,0.025s)
Chars 18183 - 18528 [Definition~transport_path_univ...] 0.008 secs (0.006u,0.001s)
Chars 18591 - 18719 [Theorem~equiv_induction~{U~:~T...] 0. secs (0.u,0.s)
Chars 18720 - 18726 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 11607 - 11638 [by~apply~path_operations_equiv.] 40.159 secs (0.003u,0.031s)
Chars 11607 - 11638 [by~apply~path_operations_equiv.] 0. secs (0.u,0.s)
Chars 11641 - 11649 [Defined.] 0. secs (0.u,0.s)
Chars 11727 - 11815 [Theorem~path_isomorphism~(f~:~...] 0.001 secs (0.001u,0.s)
Chars 11818 - 11824 [Proof.] 0. secs (0.u,0.s)
Chars 8128 - 8139 [revert~v~p.] 40.12 secs (0.003u,0.024s)
Chars 8142 - 8191 [snrapply~(equiv_path_ind~(equi...] 0.021 secs (0.016u,0.004s)
Chars 8194 - 8205 [(destruct~q).] 0.04 secs (0.032u,0.007s)
Chars 8208 - 8241 [(apply~rlucancel,~lrucancel_sV...] 0.034 secs (0.029u,0.004s)
Chars 8128 - 8139 [revert~v~p.] 0.005 secs (0.004u,0.s)
Chars 8142 - 8191 [snrapply~(equiv_path_ind~(equi...] 0.004 secs (0.003u,0.s)
Chars 8194 - 8205 [(destruct~q).] 0.005 secs (0.005u,0.s)
Chars 8208 - 8241 [(apply~rlucancel,~lrucancel_sV...] 0.008 secs (0.006u,0.001s)
Chars 8242 - 8250 [Defined.] 0.088 secs (0.077u,0.01s)
Chars 8346 - 8580 [Definition~ehrnat_pp~{X}~{a~:~...] 0.04 secs (0.032u,0.008s)
Chars 8581 - 8587 [Proof.] 0. secs (0.u,0.s)
Chars 7153 - 7179 [snrapply~isequiv_surj_emb.] 40.151 secs (0.003u,0.028s)
Chars 7184 - 7212 [1:~srapply~cancelR_conn_map.] 0.022 secs (0.018u,0.002s)
Chars 7217 - 7248 [srapply~isembedding_isinj_hset.] 0.1 secs (0.077u,0.022s)
Chars 7253 - 7296 [(refine~(Quotient_ind_hprop~_~...] 0.039 secs (0.033u,0.005s)
Chars 7301 - 7344 [(refine~(Quotient_ind_hprop~_~...] 0.03 secs (0.029u,0.s)
Chars 7349 - 7370 [(intros~h;~simpl~in~h).] 0.005 secs (0.004u,0.001s)
Chars 7375 - 7392 [(apply~qglue;~cbn).] 0.012 secs (0.009u,0.002s)
Chars 7397 - 7456 [(apply~((equiv_path_sigma_hpro...] 0.011 secs (0.01u,0.001s)
Chars 7461 - 7465 [(cbn).] 0. secs (0.u,0.s)
Chars 7466 - 7503 [(rewrite~grp_homo_op,~grp_homo...] 0.003 secs (0.003u,0.s)
Chars 7508 - 7525 [srapply~negate_l.] 0.006 secs (0.006u,0.s)
Chars 7153 - 7179 [snrapply~isequiv_surj_emb.] 0. secs (0.u,0.s)
Chars 7184 - 7212 [1:~srapply~cancelR_conn_map.] 0. secs (0.u,0.s)
Chars 7217 - 7248 [srapply~isembedding_isinj_hset.] 0. secs (0.u,0.s)
Chars 7253 - 7296 [(refine~(Quotient_ind_hprop~_~...] 0. secs (0.u,0.s)
Chars 7301 - 7344 [(refine~(Quotient_ind_hprop~_~...] 0.001 secs (0.001u,0.s)
Chars 7349 - 7370 [(intros~h;~simpl~in~h).] 0.001 secs (0.001u,0.s)
Chars 7375 - 7392 [(apply~qglue;~cbn).] 0.001 secs (0.001u,0.s)
Chars 7397 - 7456 [(apply~((equiv_path_sigma_hpro...] 0.001 secs (0.001u,0.s)
Chars 7461 - 7465 [(cbn).] 0. secs (0.u,0.s)
Chars 7466 - 7503 [(rewrite~grp_homo_op,~grp_homo...] 0. secs (0.u,0.s)
Chars 7508 - 7525 [srapply~negate_l.] 0. secs (0.u,0.s)
Chars 7528 - 7536 [Defined.] 0.01 secs (0.009u,0.s)
Chars 7586 - 7647 [Theorem~grp_first_iso~:~A~/~gr...] 0.002 secs (0.002u,0.s)
Chars 7650 - 7656 [Proof.] 0. secs (0.u,0.s)
Chars 15149 - 15189 [(unfold~O_functor_homotopy,~to...] 40.148 secs (0.002u,0.027s)
Chars 15196 - 15233 [refine~(O_indpaths_beta~_~_~_~...] 0.004 secs (0.004u,0.s)
Chars 15240 - 15267 [refine~(concat_p_pp~_~_~_).] 0.003 secs (0.002u,0.s)
Chars 15149 - 15189 [(unfold~O_functor_homotopy,~to...] 0.001 secs (0.001u,0.s)
Chars 15196 - 15233 [refine~(O_indpaths_beta~_~_~_~...] 0.001 secs (0.001u,0.s)
Chars 15240 - 15267 [refine~(concat_p_pp~_~_~_).] 0.001 secs (0.u,0.s)
Chars 15272 - 15280 [Defined.] 0.036 secs (0.022u,0.014s)
Chars 15350 - 15433 [Definition~O_functor_wellpoint...] 0.001 secs (0.001u,0.s)
Chars 15438 - 15444 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 18729 - 18741 [(intros~H0~V).] 40.07 secs (0.u,0.016s)
Chars 18744 - 18779 [(apply~(equiv_ind~(equiv_path~...] 0.002 secs (0.002u,0.s)
Chars 18782 - 18813 [(intro~p;~induction~p;~exact~H0).] 0.002 secs (0.001u,0.s)
Chars 18729 - 18741 [(intros~H0~V).] 0. secs (0.u,0.s)
Chars 18744 - 18779 [(apply~(equiv_ind~(equiv_path~...] 0. secs (0.u,0.s)
Chars 18782 - 18813 [(intro~p;~induction~p;~exact~H0).] 0. secs (0.u,0.s)
Chars 18814 - 18822 [Defined.] 0. secs (0.u,0.s)
Chars 18824 - 19020 [Definition~equiv_induction_com...] 0.004 secs (0.004u,0.s)
Chars 19046 - 19182 [Theorem~equiv_induction'~(P~:~...] 0. secs (0.u,0.s)
Chars 19183 - 19189 [Proof.] 0. secs (0.u,0.s)
Chars 11829 - 11896 [(apply~(path_algebra~_~_~(path...] 40.164 secs (0.009u,0.034s)
Chars 12097 - 12218 [(abstract~(funext~u;~exact~~~~...] 0.009 secs (0.008u,0.s)
Chars 11829 - 11896 [(apply~(path_algebra~_~_~(path...] 0. secs (0.u,0.s)
Chars 12097 - 12218 [(abstract~(funext~u;~exact~~~~...] 0. secs (0.u,0.s)
Chars 12221 - 12229 [Defined.] 0.001 secs (0.u,0.s)
Chars 12230 - 12251 [End~path_isomorphism.] 0.022 secs (0.022u,0.s)
Chars 7661 - 7717 [exact~(Build_GroupIsomorphism~...] 18.492 secs (4.529u,-0.674s)
find_witness Control.TimeoutChars 8590 - 8601 [revert~u~p.] 40.13 secs (0.013u,0.027s)
Chars 8604 - 8653 [snrapply~(equiv_path_ind~(equi...] 0.021 secs (0.016u,0.005s)
Chars 8656 - 8667 [(destruct~q).] 0.036 secs (0.029u,0.007s)
Chars 8670 - 8674 [(cbn).] 0.105 secs (0.095u,0.008s)
Chars 8677 - 8710 [(apply~rlucancel,~lrucancel_sV...] 0.364 secs (0.323u,0.04s)
Chars 8590 - 8601 [revert~u~p.] 0.003 secs (0.003u,0.s)
Chars 8604 - 8653 [snrapply~(equiv_path_ind~(equi...] 0.003 secs (0.003u,0.s)
Chars 8656 - 8667 [(destruct~q).] 0.003 secs (0.003u,0.s)
Chars 8670 - 8674 [(cbn).] 0.005 secs (0.005u,0.s)
Chars 8677 - 8710 [(apply~rlucancel,~lrucancel_sV...] 0.004 secs (0.004u,0.s)
Chars 15451 - 15487 [(refine~(O_indpaths~_~_~_);~in...] 26.156 secs (18.938u,-0.086s)
Chars 8711 - 8719 [Defined.] 0.22 secs (0.208u,0.011s)
Chars 8815 - 9041 [Definition~wlrnat_p_pp~{X}~{a~...] 0.021 secs (0.021u,0.s)
Chars 9042 - 9048 [Proof.] 0. secs (0.u,0.s)
Chars 9051 - 9071 [by~destruct~p,~q,~r.] 0.633 secs (0.035u,0.027s)
Chars 9051 - 9071 [by~destruct~p,~q,~r.] 0.003 secs (0.002u,0.001s)
Chars 9072 - 9080 [Defined.] 0.026 secs (0.021u,0.005s)
Chars 9176 - 9402 [Definition~wlrnat_pp_p~{X}~{a~...] 0.035 secs (0.028u,0.006s)
Chars 9403 - 9409 [Proof.] 0. secs (0.u,0.s)
Chars 9412 - 9432 [by~destruct~p,~q,~r.] 0.197 secs (0.034u,0.025s)
Chars 9412 - 9432 [by~destruct~p,~q,~r.] 0.002 secs (0.u,0.001s)
Chars 9433 - 9441 [Defined.] 0.025 secs (0.021u,0.004s)
Chars 9514 - 9713 [Definition~wlrnat_V~{X}~{a~:~X...] 0.053 secs (0.042u,0.01s)
Chars 9714 - 9720 [Proof.] 0. secs (0.u,0.s)
Chars 9723 - 9737 [(destruct~p,~q).] 6.41 secs (0.094u,0.048s)
Chars 9740 - 9760 [exact~(lrucancel~1).] 0.181 secs (0.12u,0.06s)
Chars 9723 - 9737 [(destruct~p,~q).] 0.006 secs (0.005u,0.s)
Chars 9740 - 9760 [exact~(lrucancel~1).] 0.006 secs (0.004u,0.001s)
Chars 9761 - 9769 [Defined.] 0.196 secs (0.16u,0.034s)
Chars 9867 - 9883 [Section~eh_p_pp.] 0. secs (0.u,0.s)
Chars 9887 - 9906 [Context~{X~:~Type}.] 0. secs (0.u,0.s)
Chars 9926 - 9952 [Context~{a~b~c~d~e~f~:~X}.] 0. secs (0.u,0.s)
Chars 9972 - 9998 [Context~{wlx0~x0~:~a~=~b}.] 0. secs (0.u,0.s)
Chars 10001 - 10027 [Context~{wlx1~x1~:~c~=~d}.] 0. secs (0.u,0.s)
Chars 10030 - 10056 [Context~{wlx2~x2~:~e~=~f}.] 0. secs (0.u,0.s)
Chars 10060 - 10086 [Context~{wry0~y0~:~b~=~d}.] 0. secs (0.u,0.s)
Chars 10089 - 10115 [Context~{wry1~y1~:~a~=~c}.] 0. secs (0.u,0.s)
Chars 10119 - 10145 [Context~{wrz0~z0~:~d~=~f}.] 0. secs (0.u,0.s)
Chars 10148 - 10174 [Context~{wrz1~z1~:~c~=~e}.] 0. secs (0.u,0.s)
Chars 10178 - 10202 [Context~{wryz0~:~b~=~f}.] 0. secs (0.u,0.s)
Chars 10205 - 10229 [Context~{wryz1~:~a~=~e}.] 0. secs (0.u,0.s)
Chars 10249 - 10288 [Context~{ulnat_x0~:~wlx0~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 10291 - 10330 [Context~{ulnat_x1~:~wlx1~@~1~=...] 0.001 secs (0.u,0.s)
Chars 10333 - 10372 [Context~{ulnat_x2~:~wlx2~@~1~=...] 0.001 secs (0.u,0.001s)
Chars 10376 - 10415 [Context~{urnat_y0~:~wry0~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 10418 - 10457 [Context~{urnat_y1~:~wry1~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 10461 - 10500 [Context~{urnat_z0~:~wrz0~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 10503 - 10542 [Context~{urnat_z1~:~wrz1~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 10546 - 10594 [Context~{urnat_yz0~:~wryz0~@~1...] 0.002 secs (0.001u,0.s)
Chars 10597 - 10645 [Context~{urnat_yz1~:~wryz1~@~1...] 0.002 secs (0.u,0.002s)
Chars 10649 - 10698 [Context~{wlrnat_x_y~:~wlx0~@~w...] 0. secs (0.u,0.s)
Chars 10701 - 10750 [Context~{wlrnat_x_z~:~wlx1~@~w...] 0. secs (0.u,0.s)
Chars 10753 - 10805 [Context~{wlrnat_x_yz~:~wlx0~@~...] 0. secs (0.u,0.s)
Chars 10809 - 10850 [Context~{wrpp_yz0~:~wry0~@~wrz...] 0. secs (0.u,0.s)
Chars 10853 - 10894 [Context~{wrpp_yz1~:~wry1~@~wrz...] 0. secs (0.u,0.s)
Chars 10914 - 11001 [Hypothesis~~~(H_urnat_yz0~:~ur...] 0.003 secs (0.002u,0.s)
Chars 11005 - 11092 [Hypothesis~~~(H_urnat_yz1~:~ur...] 0.003 secs (0.002u,0.s)
Chars 11096 - 11217 [Hypothesis~~~(H_wlrnat_x_yz~:~...] 0.004 secs (0.003u,0.s)
Chars 11243 - 11754 [Definition~eh_p_pp_gen~:~~~let...] 0.097 secs (0.095u,0.002s)
Chars 11757 - 11763 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 7661 - 7717 [exact~(Build_GroupIsomorphism~...] 40.062 secs (0.002u,0.029s)
Chars 7661 - 7717 [exact~(Build_GroupIsomorphism~...] 0. secs (0.u,0.s)
Chars 7720 - 7728 [Defined.] 0. secs (0.u,0.s)
Chars 7730 - 7743 [End~FirstIso.] 0.021 secs (0.02u,0.s)
Chars 7928 - 8088 [#[global]~Instance~finite_quot...] 0.001 secs (0.u,0.s)
Chars 8089 - 8095 [Proof.] 0. secs (0.u,0.s)
Chars 15451 - 15487 [(refine~(O_indpaths~_~_~_);~in...] 40.061 secs (0.001u,0.028s)
Chars 15494 - 15513 [(apply~to_O_natural).] 0.001 secs (0.u,0.s)
Chars 15451 - 15487 [(refine~(O_indpaths~_~_~_);~in...] 0. secs (0.u,0.s)
Chars 15494 - 15513 [(apply~to_O_natural).] 0. secs (0.u,0.s)
Chars 15518 - 15526 [Defined.] 0. secs (0.u,0.s)
Chars 15617 - 15859 [Definition~to_O_natural_compos...] 0.006 secs (0.005u,0.s)
Chars 15864 - 15870 [Proof.] 0. secs (0.u,0.s)
Chars 19192 - 19208 [(intros~H0~U~V~w).] 40.112 secs (0.u,0.016s)
Chars 19211 - 19246 [(apply~(equiv_ind~(equiv_path~...] 0.002 secs (0.002u,0.s)
Chars 19249 - 19280 [(intro~p;~induction~p;~apply~H0).] 0.002 secs (0.002u,0.s)
Chars 19192 - 19208 [(intros~H0~U~V~w).] 0. secs (0.u,0.s)
Chars 19211 - 19246 [(apply~(equiv_ind~(equiv_path~...] 0. secs (0.u,0.s)
Chars 19249 - 19280 [(intro~p;~induction~p;~apply~H0).] 0. secs (0.u,0.s)
Chars 19281 - 19289 [Defined.] 0. secs (0.u,0.s)
Chars 19291 - 19509 [Definition~equiv_induction'_co...] 0.004 secs (0.003u,0.s)
Chars 19511 - 19643 [Theorem~equiv_induction_inv~{U...] 0. secs (0.u,0.s)
Chars 19644 - 19650 [Proof.] 0. secs (0.u,0.s)
Chars 11768 - 11826 [(apply~moveR_Vp~in~H_urnat_yz0...] 40.132 secs (0.01u,0.024s)
Chars 11831 - 11880 [(destruct~H_urnat_yz0,~H_urnat...] 0.101 secs (0.083u,0.017s)
Chars 11885 - 11929 [clear~H_urnat_yz0~H_urnat_yz1~...] 0.008 secs (0.008u,0.s)
Chars 11934 - 11962 [(destruct~wrpp_yz0,~wrpp_yz1).] 0.074 secs (0.062u,0.011s)
Chars 11967 - 11991 [clear~wrpp_yz0~wrpp_yz1.] 0.007 secs (0.007u,0.s)
Chars 11996 - 12015 [revert~x0~ulnat_x0.] 0.007 secs (0.007u,0.s)
Chars 12020 - 12054 [snrapply~equiv_path_ind_rlucan...] 0.027 secs (0.026u,0.s)
Chars 12059 - 12078 [revert~x1~ulnat_x1.] 0.007 secs (0.006u,0.s)
Chars 12083 - 12117 [snrapply~equiv_path_ind_rlucan...] 0.027 secs (0.02u,0.006s)
Chars 12122 - 12141 [revert~x2~ulnat_x2.] 0.007 secs (0.005u,0.001s)
Chars 12146 - 12180 [snrapply~equiv_path_ind_rlucan...] 0.026 secs (0.025u,0.s)
Chars 12185 - 12204 [revert~y0~urnat_y0.] 0.007 secs (0.005u,0.001s)
Chars 12209 - 12243 [snrapply~equiv_path_ind_rlucan...] 0.032 secs (0.023u,0.008s)
Chars 12248 - 12267 [revert~y1~urnat_y1.] 0.007 secs (0.007u,0.s)
Chars 12272 - 12306 [snrapply~equiv_path_ind_rlucan...] 0.02 secs (0.018u,0.001s)
Chars 12311 - 12330 [revert~z0~urnat_z0.] 0.006 secs (0.006u,0.s)
Chars 12335 - 12369 [snrapply~equiv_path_ind_rlucan...] 0.02 secs (0.02u,0.s)
Chars 12374 - 12393 [revert~z1~urnat_z1.] 0.006 secs (0.006u,0.s)
Chars 12398 - 12432 [snrapply~equiv_path_ind_rlucan...] 0.02 secs (0.02u,0.s)
Chars 12437 - 12469 [(destruct~wry0,~wry1,~wrz0,~wr...] 0.097 secs (0.097u,0.s)
Chars 12474 - 12500 [clear~wry0~wry1~wrz0~wrz1.] 0.005 secs (0.005u,0.s)
Chars 12505 - 12528 [revert~wlx2~wlrnat_x_z.] 0.005 secs (0.005u,0.s)
Chars 12533 - 12567 [snrapply~equiv_path_ind_rlucan...] 0.02 secs (0.02u,0.s)
Chars 12572 - 12595 [revert~wlx1~wlrnat_x_y.] 0.005 secs (0.005u,0.s)
Chars 12600 - 12634 [snrapply~equiv_path_ind_rlucan...] 0.02 secs (0.02u,0.s)
Chars 12639 - 12653 [(destruct~wlx0).] 0.037 secs (0.037u,0.s)
Chars 12658 - 12669 [clear~wlx0.] 0.004 secs (0.004u,0.s)
Chars 12674 - 12686 [reflexivity.] 0.007 secs (0.007u,0.s)
Chars 11768 - 11826 [(apply~moveR_Vp~in~H_urnat_yz0...] 0.005 secs (0.005u,0.s)
Chars 11831 - 11880 [(destruct~H_urnat_yz0,~H_urnat...] 0.005 secs (0.005u,0.s)
Chars 11885 - 11929 [clear~H_urnat_yz0~H_urnat_yz1~...] 0.006 secs (0.006u,0.s)
Chars 11934 - 11962 [(destruct~wrpp_yz0,~wrpp_yz1).] 0.004 secs (0.004u,0.s)
Chars 11967 - 11991 [clear~wrpp_yz0~wrpp_yz1.] 0.005 secs (0.004u,0.s)
Chars 11996 - 12015 [revert~x0~ulnat_x0.] 0.005 secs (0.005u,0.s)
Chars 12020 - 12054 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 12059 - 12078 [revert~x1~ulnat_x1.] 0.005 secs (0.005u,0.s)
Chars 12083 - 12117 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 12122 - 12141 [revert~x2~ulnat_x2.] 0.004 secs (0.004u,0.s)
Chars 12146 - 12180 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 12185 - 12204 [revert~y0~urnat_y0.] 0.005 secs (0.005u,0.s)
Chars 12209 - 12243 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 12248 - 12267 [revert~y1~urnat_y1.] 0.005 secs (0.005u,0.s)
Chars 12272 - 12306 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 12311 - 12330 [revert~z0~urnat_z0.] 0.005 secs (0.005u,0.s)
Chars 12335 - 12369 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 12374 - 12393 [revert~z1~urnat_z1.] 0.005 secs (0.005u,0.s)
Chars 12398 - 12432 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 12437 - 12469 [(destruct~wry0,~wry1,~wrz0,~wr...] 0.005 secs (0.005u,0.s)
Chars 12474 - 12500 [clear~wry0~wry1~wrz0~wrz1.] 0.016 secs (0.011u,0.004s)
Chars 12505 - 12528 [revert~wlx2~wlrnat_x_z.] 0.004 secs (0.004u,0.s)
Chars 12533 - 12567 [snrapply~equiv_path_ind_rlucan...] 0.004 secs (0.004u,0.s)
Chars 12572 - 12595 [revert~wlx1~wlrnat_x_y.] 0.004 secs (0.003u,0.s)
Chars 12600 - 12634 [snrapply~equiv_path_ind_rlucan...] 0.004 secs (0.004u,0.s)
Chars 12639 - 12653 [(destruct~wlx0).] 0.004 secs (0.004u,0.s)
Chars 12658 - 12669 [clear~wlx0.] 0.004 secs (0.004u,0.s)
Chars 12674 - 12686 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 12689 - 12697 [Defined.] 0.12 secs (0.119u,0.s)
Chars 12699 - 12711 [End~eh_p_pp.] 0.269 secs (0.259u,0.009s)
Chars 12713 - 12897 [Theorem~eh_p_pp~{X}~{a~:~X}~(p...] 0.008 secs (0.008u,0.s)
Chars 12898 - 12904 [Proof.] 0. secs (0.u,0.s)
Chars 8098 - 8122 [nrapply~finite_quotient.] 40.182 secs (0.014u,0.03s)
Chars 8125 - 8138 [1-5:~exact~_.] 0.016 secs (0.012u,0.003s)
Chars 8141 - 8152 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 8155 - 8198 [(pose~(dec_H~:=~detachable_fin...] 0.011 secs (0.011u,0.s)
Chars 8201 - 8213 [(apply~dec_H).] 0.001 secs (0.001u,0.s)
Chars 8098 - 8122 [nrapply~finite_quotient.] 0. secs (0.u,0.s)
Chars 8125 - 8138 [1-5:~exact~_.] 0.001 secs (0.001u,0.s)
Chars 8141 - 8152 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 8155 - 8198 [(pose~(dec_H~:=~detachable_fin...] 0. secs (0.u,0.s)
Chars 8201 - 8213 [(apply~dec_H).] 0. secs (0.u,0.s)
Chars 8214 - 8222 [Defined.] 0.004 secs (0.002u,0.001s)
Chars 8224 - 8368 [Definition~grp_kernel_quotient...] 0.001 secs (0.001u,0.s)
Chars 8369 - 8375 [Proof.] 0. secs (0.u,0.s)
Chars 15877 - 15916 [(unfold~O_functor_compose,~to_...] 40.156 secs (0.002u,0.027s)
Chars 15923 - 15947 [(rewrite~O_indpaths_beta).] 0.011 secs (0.007u,0.003s)
Chars 15954 - 15998 [(rewrite~!inv_pp,~ap_V,~!inv_V...] 0.069 secs (0.058u,0.009s)
Chars 16005 - 16047 [(rewrite~concat_Vp,~concat_p1;...] 0.014 secs (0.013u,0.s)
Chars 15877 - 15916 [(unfold~O_functor_compose,~to_...] 0.001 secs (0.001u,0.s)
Chars 15923 - 15947 [(rewrite~O_indpaths_beta).] 0.002 secs (0.002u,0.s)
Chars 15954 - 15998 [(rewrite~!inv_pp,~ap_V,~!inv_V...] 0.002 secs (0.002u,0.s)
Chars 16005 - 16047 [(rewrite~concat_Vp,~concat_p1;...] 0.002 secs (0.002u,0.s)
Chars 16052 - 16056 [Qed.] 0.054 secs (0.041u,0.012s)
Chars 16103 - 16409 [Definition~O_functor_compose_c...] 0.006 secs (0.005u,0.001s)
Chars 16414 - 16420 [Proof.] 0. secs (0.u,0.s)
Chars 19653 - 19665 [(intros~H0~V).] 40.117 secs (0.u,0.017s)
Chars 19668 - 19703 [(apply~(equiv_ind~(equiv_path~...] 0.003 secs (0.002u,0.s)
Chars 19773 - 19812 [(revert~V;~rapply~paths_ind_r;...] 0.003 secs (0.003u,0.s)
Chars 19653 - 19665 [(intros~H0~V).] 0. secs (0.u,0.s)
Chars 19668 - 19703 [(apply~(equiv_ind~(equiv_path~...] 0. secs (0.u,0.s)
Chars 19773 - 19812 [(revert~V;~rapply~paths_ind_r;...] 0. secs (0.u,0.s)
Chars 19813 - 19821 [Defined.] 0. secs (0.u,0.s)
Chars 19823 - 20027 [Definition~equiv_induction_inv...] 0.008 secs (0.003u,0.s)
Chars 20064 - 20151 [#[global]~Instance~contr_based...] 0. secs (0.u,0.s)
Chars 20152 - 20158 [Proof.] 0. secs (0.u,0.s)
Chars 12907 - 12927 [nrapply~eh_p_pp_gen.] 40.147 secs (0.02u,0.024s)
Chars 12930 - 12931 [-] 0. secs (0.u,0.s)
Chars 12932 - 12953 [exact~(urnat_pp~q~r).] 0.004 secs (0.004u,0.s)
Chars 12956 - 12957 [-] 0. secs (0.u,0.s)
Chars 12958 - 12979 [exact~(urnat_pp~q~r).] 0.004 secs (0.004u,0.s)
Chars 12982 - 12983 [-] 0. secs (0.u,0.s)
Chars 12984 - 13010 [exact~(wlrnat_p_pp~p~q~r).] 0.007 secs (0.007u,0.s)
Chars 12907 - 12927 [nrapply~eh_p_pp_gen.] 0.001 secs (0.001u,0.s)
Chars 12932 - 12953 [exact~(urnat_pp~q~r).] 0.001 secs (0.u,0.s)
Chars 12958 - 12979 [exact~(urnat_pp~q~r).] 0.001 secs (0.001u,0.s)
Chars 12984 - 13010 [exact~(wlrnat_p_pp~p~q~r).] 0.002 secs (0.002u,0.s)
Chars 13011 - 13019 [Defined.] 0.017 secs (0.014u,0.003s)
Chars 13117 - 13133 [Section~eh_pp_p.] 0. secs (0.u,0.s)
Chars 13137 - 13156 [Context~{X~:~Type}.] 0. secs (0.u,0.s)
Chars 13176 - 13202 [Context~{a~b~c~d~e~f~:~X}.] 0. secs (0.u,0.s)
Chars 13222 - 13248 [Context~{wlx0~x0~:~a~=~b}.] 0. secs (0.u,0.s)
Chars 13251 - 13277 [Context~{wlx1~x1~:~d~=~e}.] 0. secs (0.u,0.s)
Chars 13281 - 13307 [Context~{wly0~y0~:~b~=~c}.] 0. secs (0.u,0.s)
Chars 13310 - 13336 [Context~{wly1~y1~:~e~=~f}.] 0. secs (0.u,0.s)
Chars 13340 - 13366 [Context~{wrz0~z0~:~c~=~f}.] 0. secs (0.u,0.s)
Chars 13369 - 13395 [Context~{wrz1~z1~:~b~=~e}.] 0. secs (0.u,0.s)
Chars 13398 - 13424 [Context~{wrz2~z2~:~a~=~d}.] 0. secs (0.u,0.s)
Chars 13428 - 13452 [Context~{wlxy0~:~a~=~c}.] 0. secs (0.u,0.s)
Chars 13455 - 13479 [Context~{wlxy1~:~d~=~f}.] 0. secs (0.u,0.s)
Chars 13499 - 13538 [Context~{ulnat_x0~:~wlx0~@~1~=...] 0.001 secs (0.u,0.s)
Chars 13541 - 13580 [Context~{ulnat_x1~:~wlx1~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 13584 - 13623 [Context~{ulnat_y0~:~wly0~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 13626 - 13665 [Context~{ulnat_y1~:~wly1~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 13669 - 13708 [Context~{urnat_z0~:~wrz0~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 13711 - 13750 [Context~{urnat_z1~:~wrz1~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 13753 - 13792 [Context~{urnat_z2~:~wrz2~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 13796 - 13844 [Context~{ulnat_xy0~:~wlxy0~@~1...] 0.002 secs (0.002u,0.s)
Chars 13847 - 13895 [Context~{ulnat_xy1~:~wlxy1~@~1...] 0.002 secs (0.001u,0.001s)
Chars 13899 - 13948 [Context~{wlrnat_x_z~:~wlx0~@~w...] 0. secs (0.u,0.s)
Chars 13951 - 14000 [Context~{wlrnat_y_z~:~wly0~@~w...] 0. secs (0.u,0.s)
Chars 14003 - 14055 [Context~{wlrnat_xy_z~:~wlxy0~@...] 0. secs (0.u,0.s)
Chars 14059 - 14100 [Context~{wlpp_xy0~:~wlx0~@~wly...] 0. secs (0.u,0.s)
Chars 14103 - 14144 [Context~{wlpp_xy1~:~wlx1~@~wly...] 0. secs (0.u,0.s)
Chars 14164 - 14251 [Hypothesis~~~(H_ulnat_xy0~:~ul...] 0.003 secs (0.002u,0.s)
Chars 14255 - 14342 [Hypothesis~~~(H_ulnat_xy1~:~ul...] 0.003 secs (0.003u,0.s)
Chars 14346 - 14467 [Hypothesis~~~(H_wlrnat_xy_z~:~...] 0.004 secs (0.003u,0.s)
Chars 14493 - 15004 [Definition~eh_pp_p_gen~:~~~let...] 0.119 secs (0.093u,0.026s)
Chars 15007 - 15013 [Proof.] 0. secs (0.u,0.s)
Chars 8378 - 8409 [srapply~Build_GroupIsomorphism.] 40.245 secs (0.058u,0.04s)
Chars 8412 - 8413 [-] 0. secs (0.u,0.s)
Chars 8414 - 8462 [srapply~(grp_kernel_corec~(g:=...] 0.002 secs (0.002u,0.s)
Chars 8467 - 8480 [(intro~x;~cbn).] 0.002 secs (0.002u,0.s)
Chars 8485 - 8497 [(apply~qglue).] 0.002 secs (0.002u,0.s)
Chars 8502 - 8525 [(apply~issubgroup_in_op).] 0.001 secs (0.001u,0.s)
Chars 8530 - 8531 [+] 0. secs (0.u,0.s)
Chars 8532 - 8564 [exact~(issubgroup_in_inv~_~x.2).] 0.002 secs (0.002u,0.s)
Chars 8569 - 8570 [+] 0. secs (0.u,0.s)
Chars 8571 - 8596 [exact~issubgroup_in_unit.] 0.001 secs (0.001u,0.s)
Chars 8599 - 8600 [-] 0. secs (0.u,0.s)
Chars 8601 - 8624 [(apply~isequiv_surj_emb).] 0.002 secs (0.001u,0.s)
Chars 8629 - 8669 [2:~(apply~(cancelL_isembedding...] 0.138 secs (0.109u,0.027s)
Chars 8674 - 8687 [(intros~[g~p]).] 0.006 secs (0.005u,0.s)
Chars 8692 - 8721 [rapply~contr_inhabited_hprop.] 0.035 secs (0.03u,0.004s)
Chars 8726 - 8751 [srefine~(tr~((g;~_);~_)).] 0.003 secs (0.003u,0.s)
Chars 8756 - 8757 [+] 0. secs (0.u,0.s)
Chars 8758 - 8800 [(rewrite~<-~grp_unit_l,~<-~neg...] 0.003 secs (0.003u,0.s)
Chars 8807 - 8862 [(apply~(related_quotient_paths...] 0.019 secs (0.017u,0.001s)
Chars 8869 - 8878 [exact~p^.] 0.002 secs (0.002u,0.s)
Chars 8883 - 8884 [+] 0. secs (0.u,0.s)
Chars 8885 - 8910 [srapply~path_sigma_hprop.] 0.044 secs (0.04u,0.003s)
Chars 8917 - 8929 [reflexivity.] 0.003 secs (0.002u,0.s)
Chars 8378 - 8409 [srapply~Build_GroupIsomorphism.] 0. secs (0.u,0.s)
Chars 8414 - 8462 [srapply~(grp_kernel_corec~(g:=...] 0. secs (0.u,0.s)
Chars 8467 - 8480 [(intro~x;~cbn).] 0.013 secs (0.01u,0.002s)
Chars 8485 - 8497 [(apply~qglue).] 0. secs (0.u,0.s)
Chars 8502 - 8525 [(apply~issubgroup_in_op).] 0. secs (0.u,0.s)
Chars 8532 - 8564 [exact~(issubgroup_in_inv~_~x.2).] 0. secs (0.u,0.s)
Chars 8571 - 8596 [exact~issubgroup_in_unit.] 0. secs (0.u,0.s)
Chars 8601 - 8624 [(apply~isequiv_surj_emb).] 0.001 secs (0.001u,0.s)
Chars 8629 - 8669 [2:~(apply~(cancelL_isembedding...] 0.001 secs (0.001u,0.s)
Chars 8674 - 8687 [(intros~[g~p]).] 0. secs (0.u,0.s)
Chars 8692 - 8721 [rapply~contr_inhabited_hprop.] 0.001 secs (0.001u,0.s)
Chars 8726 - 8751 [srefine~(tr~((g;~_);~_)).] 0.001 secs (0.001u,0.s)
Chars 8758 - 8800 [(rewrite~<-~grp_unit_l,~<-~neg...] 0. secs (0.u,0.s)
Chars 8807 - 8862 [(apply~(related_quotient_paths...] 0. secs (0.u,0.s)
Chars 8869 - 8878 [exact~p^.] 0. secs (0.u,0.s)
Chars 8885 - 8910 [srapply~path_sigma_hprop.] 0.002 secs (0.002u,0.s)
Chars 8917 - 8929 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 8930 - 8938 [Defined.] 0.021 secs (0.018u,0.002s)
Chars 16427 - 16464 [(revert~a;~refine~(O_ind2paths...] 40.16 secs (0.002u,0.029s)
Chars 16471 - 16521 [(intros~a;~unfold~composeD,~O_...] 0.036 secs (0.021u,0.015s)
Chars 16528 - 16555 [Open~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 16562 - 16616 [(rewrite~!O_indpaths_beta,~!ap...] 0.23 secs (0.194u,0.031s)
Chars 16623 - 16676 [refine~(whiskerL~_~(apD~_~(to_...] 0.008 secs (0.006u,0.001s)
Chars 16683 - 16707 [(rewrite~O_indpaths_beta).] 0.018 secs (0.014u,0.003s)
Chars 16714 - 16757 [(rewrite~transport_paths_FlFr,...] 0.125 secs (0.097u,0.026s)
Chars 16764 - 16785 [(rewrite~!ap_V,~inv_V).] 0.055 secs (0.055u,0.s)
Chars 16792 - 16813 [(rewrite~!concat_pV_p).] 0.041 secs (0.04u,0.s)
Chars 16820 - 16835 [(apply~whiskerL).] 0.004 secs (0.003u,0.s)
Chars 16836 - 16851 [(apply~inverse2).] 0.002 secs (0.002u,0.s)
Chars 16858 - 16875 [(apply~ap_compose).] 0.002 secs (0.002u,0.s)
Chars 16882 - 16910 [Close~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 16427 - 16464 [(revert~a;~refine~(O_ind2paths...] 0.001 secs (0.001u,0.s)
Chars 16471 - 16521 [(intros~a;~unfold~composeD,~O_...] 0.004 secs (0.004u,0.s)
Chars 16528 - 16555 [Open~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 16562 - 16616 [(rewrite~!O_indpaths_beta,~!ap...] 0.002 secs (0.002u,0.s)
Chars 16623 - 16676 [refine~(whiskerL~_~(apD~_~(to_...] 0.002 secs (0.002u,0.s)
Chars 16683 - 16707 [(rewrite~O_indpaths_beta).] 0.003 secs (0.003u,0.s)
Chars 16714 - 16757 [(rewrite~transport_paths_FlFr,...] 0.002 secs (0.002u,0.s)
Chars 16764 - 16785 [(rewrite~!ap_V,~inv_V).] 0.002 secs (0.002u,0.s)
Chars 16792 - 16813 [(rewrite~!concat_pV_p).] 0.002 secs (0.002u,0.s)
Chars 16820 - 16835 [(apply~whiskerL).] 0.001 secs (0.001u,0.s)
Chars 16836 - 16851 [(apply~inverse2).] 0. secs (0.u,0.s)
Chars 16858 - 16875 [(apply~ap_compose).] 0. secs (0.u,0.s)
Chars 16882 - 16910 [Close~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 16915 - 16919 [Qed.] 0.248 secs (0.244u,0.003s)
Chars 16965 - 17070 [#[global]~Instance~isequiv_O_f...] 0. secs (0.u,0.s)
Chars 17075 - 17081 [Proof.] 0. secs (0.u,0.s)
Chars 20161 - 20185 [exists~(X;~equiv_idmap).] 40.126 secs (0.001u,0.016s)
Chars 20188 - 20213 [(intros~[Y~f];~revert~Y~f).] 0.001 secs (0.u,0.001s)
Chars 20216 - 20249 [exact~(equiv_induction~_~idpath).] 0.001 secs (0.001u,0.s)
Chars 20161 - 20185 [exists~(X;~equiv_idmap).] 0. secs (0.u,0.s)
Chars 20188 - 20213 [(intros~[Y~f];~revert~Y~f).] 0. secs (0.u,0.s)
Chars 20216 - 20249 [exact~(equiv_induction~_~idpath).] 0. secs (0.u,0.s)
Chars 20250 - 20258 [Defined.] 0. secs (0.u,0.s)
Chars 20260 - 20348 [#[global]~Instance~contr_based...] 0. secs (0.u,0.s)
Chars 20349 - 20355 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 15018 - 15076 [(apply~moveR_Vp~in~H_ulnat_xy0...] 40.142 secs (0.011u,0.024s)
Chars 15081 - 15130 [(destruct~H_ulnat_xy0,~H_ulnat...] 0.115 secs (0.093u,0.022s)
Chars 15135 - 15179 [clear~H_ulnat_xy0~H_ulnat_xy1~...] 0.008 secs (0.008u,0.s)
Chars 15184 - 15212 [(destruct~wlpp_xy0,~wlpp_xy1).] 0.057 secs (0.047u,0.009s)
Chars 15217 - 15241 [clear~wlpp_xy0~wlpp_xy1.] 0.006 secs (0.005u,0.s)
Chars 15246 - 15265 [revert~x0~ulnat_x0.] 0.006 secs (0.005u,0.001s)
Chars 15270 - 15304 [snrapply~equiv_path_ind_rlucan...] 0.025 secs (0.024u,0.s)
Chars 15309 - 15328 [revert~x1~ulnat_x1.] 0.006 secs (0.005u,0.s)
Chars 15333 - 15367 [snrapply~equiv_path_ind_rlucan...] 0.092 secs (0.078u,0.013s)
Chars 15372 - 15391 [revert~y0~ulnat_y0.] 0.007 secs (0.007u,0.s)
Chars 15396 - 15430 [snrapply~equiv_path_ind_rlucan...] 0.025 secs (0.021u,0.003s)
Chars 15435 - 15454 [revert~y1~ulnat_y1.] 0.007 secs (0.006u,0.s)
Chars 15459 - 15493 [snrapply~equiv_path_ind_rlucan...] 0.024 secs (0.02u,0.004s)
Chars 15498 - 15517 [revert~z0~urnat_z0.] 0.007 secs (0.005u,0.001s)
Chars 15522 - 15556 [snrapply~equiv_path_ind_rlucan...] 0.02 secs (0.02u,0.s)
Chars 15561 - 15580 [revert~z1~urnat_z1.] 0.005 secs (0.005u,0.s)
Chars 15585 - 15619 [snrapply~equiv_path_ind_rlucan...] 0.019 secs (0.019u,0.s)
Chars 15624 - 15643 [revert~z2~urnat_z2.] 0.006 secs (0.006u,0.s)
Chars 15648 - 15682 [snrapply~equiv_path_ind_rlucan...] 0.02 secs (0.02u,0.s)
Chars 15687 - 15719 [(destruct~wlx0,~wlx1,~wly0,~wl...] 0.096 secs (0.095u,0.001s)
Chars 15724 - 15750 [clear~wlx0~wlx1~wly0~wly1.] 0.004 secs (0.004u,0.s)
Chars 15755 - 15778 [revert~wrz2~wlrnat_x_z.] 0.005 secs (0.005u,0.s)
Chars 15783 - 15817 [snrapply~equiv_path_ind_lrucan...] 0.053 secs (0.05u,0.002s)
Chars 15822 - 15845 [revert~wrz1~wlrnat_y_z.] 0.005 secs (0.005u,0.s)
Chars 15850 - 15884 [snrapply~equiv_path_ind_lrucan...] 0.02 secs (0.02u,0.s)
Chars 15889 - 15903 [(destruct~wrz0).] 0.028 secs (0.028u,0.s)
Chars 15908 - 15919 [clear~wrz0.] 0.004 secs (0.004u,0.s)
Chars 15924 - 15936 [reflexivity.] 0.007 secs (0.007u,0.s)
Chars 15018 - 15076 [(apply~moveR_Vp~in~H_ulnat_xy0...] 0.004 secs (0.004u,0.s)
Chars 15081 - 15130 [(destruct~H_ulnat_xy0,~H_ulnat...] 0.004 secs (0.004u,0.s)
Chars 15135 - 15179 [clear~H_ulnat_xy0~H_ulnat_xy1~...] 0.005 secs (0.005u,0.s)
Chars 15184 - 15212 [(destruct~wlpp_xy0,~wlpp_xy1).] 0.004 secs (0.004u,0.s)
Chars 15217 - 15241 [clear~wlpp_xy0~wlpp_xy1.] 0.004 secs (0.004u,0.s)
Chars 15246 - 15265 [revert~x0~ulnat_x0.] 0.004 secs (0.004u,0.s)
Chars 15270 - 15304 [snrapply~equiv_path_ind_rlucan...] 0.004 secs (0.004u,0.s)
Chars 15309 - 15328 [revert~x1~ulnat_x1.] 0.005 secs (0.005u,0.s)
Chars 15333 - 15367 [snrapply~equiv_path_ind_rlucan...] 0.015 secs (0.013u,0.001s)
Chars 15372 - 15391 [revert~y0~ulnat_y0.] 0.005 secs (0.005u,0.s)
Chars 15396 - 15430 [snrapply~equiv_path_ind_rlucan...] 0.004 secs (0.004u,0.s)
Chars 15435 - 15454 [revert~y1~ulnat_y1.] 0.005 secs (0.005u,0.s)
Chars 15459 - 15493 [snrapply~equiv_path_ind_rlucan...] 0.004 secs (0.004u,0.s)
Chars 15498 - 15517 [revert~z0~urnat_z0.] 0.005 secs (0.005u,0.s)
Chars 15522 - 15556 [snrapply~equiv_path_ind_rlucan...] 0.004 secs (0.004u,0.s)
Chars 15561 - 15580 [revert~z1~urnat_z1.] 0.005 secs (0.005u,0.s)
Chars 15585 - 15619 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 15624 - 15643 [revert~z2~urnat_z2.] 0.005 secs (0.005u,0.s)
Chars 15648 - 15682 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 15687 - 15719 [(destruct~wlx0,~wlx1,~wly0,~wl...] 0.005 secs (0.004u,0.s)
Chars 15724 - 15750 [clear~wlx0~wlx1~wly0~wly1.] 0.004 secs (0.004u,0.s)
Chars 15755 - 15778 [revert~wrz2~wlrnat_x_z.] 0.004 secs (0.004u,0.s)
Chars 15783 - 15817 [snrapply~equiv_path_ind_lrucan...] 0.004 secs (0.004u,0.s)
Chars 15822 - 15845 [revert~wrz1~wlrnat_y_z.] 0.004 secs (0.004u,0.s)
Chars 15850 - 15884 [snrapply~equiv_path_ind_lrucan...] 0.004 secs (0.004u,0.s)
Chars 15889 - 15903 [(destruct~wrz0).] 0.004 secs (0.004u,0.s)
Chars 15908 - 15919 [clear~wrz0.] 0.003 secs (0.003u,0.s)
Chars 15924 - 15936 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 15939 - 15947 [Defined.] 0.101 secs (0.1u,0.s)
Chars 15949 - 15961 [End~eh_pp_p.] 0.253 secs (0.247u,0.005s)
Chars 15963 - 16147 [Theorem~eh_pp_p~{X}~{a~:~X}~(p...] 0.008 secs (0.008u,0.s)
Chars 16148 - 16154 [Proof.] 0. secs (0.u,0.s)
Chars 17088 - 17151 [refine~(isequiv_adjointify~(O_...] 40.16 secs (0.u,0.028s)
Chars 17158 - 17159 [-] 0. secs (0.u,0.s)
Chars 17160 - 17169 [(intros~x).] 0. secs (0.u,0.s)
Chars 17178 - 17218 [refine~((O_functor_compose~_~_...] 0.001 secs (0.u,0.s)
Chars 17227 - 17271 [refine~(O_functor_homotopy~_~i...] 0.001 secs (0.001u,0.s)
Chars 17280 - 17281 [+] 0. secs (0.u,0.s)
Chars 17282 - 17306 [(intros~y;~apply~eisretr).] 0.001 secs (0.001u,0.s)
Chars 17315 - 17316 [+] 0. secs (0.u,0.s)
Chars 17317 - 17339 [(apply~O_functor_idmap).] 0. secs (0.u,0.s)
Chars 17346 - 17347 [-] 0. secs (0.u,0.s)
Chars 17348 - 17357 [(intros~x).] 0. secs (0.u,0.s)
Chars 17366 - 17406 [refine~((O_functor_compose~_~_...] 0.002 secs (0.001u,0.s)
Chars 17415 - 17459 [refine~(O_functor_homotopy~_~i...] 0.001 secs (0.001u,0.s)
Chars 17468 - 17469 [+] 0. secs (0.u,0.s)
Chars 17470 - 17494 [(intros~y;~apply~eissect).] 0.001 secs (0.001u,0.s)
Chars 17503 - 17504 [+] 0. secs (0.u,0.s)
Chars 17505 - 17527 [(apply~O_functor_idmap).] 0. secs (0.u,0.s)
Chars 17088 - 17151 [refine~(isequiv_adjointify~(O_...] 0. secs (0.u,0.s)
Chars 17160 - 17169 [(intros~x).] 0. secs (0.u,0.s)
Chars 17178 - 17218 [refine~((O_functor_compose~_~_...] 0. secs (0.u,0.s)
Chars 17227 - 17271 [refine~(O_functor_homotopy~_~i...] 0. secs (0.u,0.s)
Chars 17282 - 17306 [(intros~y;~apply~eisretr).] 0. secs (0.u,0.s)
Chars 17317 - 17339 [(apply~O_functor_idmap).] 0. secs (0.u,0.s)
Chars 17348 - 17357 [(intros~x).] 0. secs (0.u,0.s)
Chars 17366 - 17406 [refine~((O_functor_compose~_~_...] 0. secs (0.u,0.s)
Chars 17415 - 17459 [refine~(O_functor_homotopy~_~i...] 0. secs (0.u,0.s)
Chars 17470 - 17494 [(intros~y;~apply~eissect).] 0. secs (0.u,0.s)
Chars 17505 - 17527 [(apply~O_functor_idmap).] 0. secs (0.u,0.s)
Chars 17532 - 17540 [Defined.] 0.002 secs (0.002u,0.s)
Chars 17546 - 17657 [Definition~equiv_O_functor~{A~...] 0.01 secs (0.009u,0.s)
Chars 17762 - 17887 [Definition~to_O_equiv_natural~...] 0.003 secs (0.001u,0.001s)
Chars 17948 - 18126 [Definition~ap_O_path_universe'...] 0.001 secs (0.001u,0.s)
Chars 18131 - 18137 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 20445 - 20465 [srapply~Build_Contr.] 40.125 secs (0.001u,0.017s)
Chars 20468 - 20469 [-] 0. secs (0.u,0.s)
Chars 20470 - 20493 [exact~(X;~equiv_idmap).] 0. secs (0.u,0.s)
Chars 20496 - 20497 [-] 0. secs (0.u,0.s)
Chars 20498 - 20523 [(intros~[Y~f];~revert~Y~f).] 0.001 secs (0.001u,0.s)
Chars 20528 - 20566 [refine~(equiv_induction_inv~_~...] 0.001 secs (0.001u,0.s)
Chars 20445 - 20465 [srapply~Build_Contr.] 0. secs (0.u,0.s)
Chars 20470 - 20493 [exact~(X;~equiv_idmap).] 0. secs (0.u,0.s)
Chars 20498 - 20523 [(intros~[Y~f];~revert~Y~f).] 0. secs (0.u,0.s)
Chars 20528 - 20566 [refine~(equiv_induction_inv~_~...] 0. secs (0.u,0.s)
Chars 20567 - 20575 [Defined.] 0. secs (0.u,0.s)
Chars 20751 - 20875 [#[global]~Instance~istrunc_pat...] 0. secs (0.u,0.s)
Chars 20876 - 20882 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 16157 - 16177 [nrapply~eh_pp_p_gen.] 40.158 secs (0.024u,0.024s)
Chars 16180 - 16181 [-] 0. secs (0.u,0.s)
Chars 16182 - 16203 [exact~(ulnat_pp~p~q).] 0.005 secs (0.005u,0.s)
Chars 16206 - 16207 [-] 0. secs (0.u,0.s)
Chars 16208 - 16229 [exact~(ulnat_pp~p~q).] 0.005 secs (0.004u,0.s)
Chars 16232 - 16233 [-] 0. secs (0.u,0.s)
Chars 16234 - 16260 [exact~(wlrnat_pp_p~p~q~r).] 0.007 secs (0.006u,0.001s)
Chars 16157 - 16177 [nrapply~eh_pp_p_gen.] 0.001 secs (0.001u,0.s)
Chars 16182 - 16203 [exact~(ulnat_pp~p~q).] 0.001 secs (0.001u,0.s)
Chars 16208 - 16229 [exact~(ulnat_pp~p~q).] 0.001 secs (0.001u,0.s)
Chars 16234 - 16260 [exact~(wlrnat_pp_p~p~q~r).] 0.002 secs (0.001u,0.s)
Chars 16261 - 16269 [Defined.] 0.021 secs (0.018u,0.002s)
Chars 16348 - 16361 [Section~eh_V.] 0. secs (0.u,0.s)
Chars 16365 - 16384 [Context~{X~:~Type}.] 0. secs (0.u,0.s)
Chars 16404 - 16426 [Context~{a~b~c~d~:~X}.] 0. secs (0.u,0.s)
Chars 16446 - 16477 [Context~{wlx0~x0~wrx0~:~a~=~b}.] 0. secs (0.u,0.s)
Chars 16480 - 16511 [Context~{wlx1~x1~wrx1~:~c~=~d}.] 0. secs (0.u,0.s)
Chars 16517 - 16548 [Context~{wly0~y0~wry0~:~b~=~d}.] 0. secs (0.u,0.s)
Chars 16551 - 16582 [Context~{wly1~y1~wry1~:~a~=~c}.] 0. secs (0.u,0.s)
Chars 16602 - 16641 [Context~{ulnat_x0~:~wlx0~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 16644 - 16683 [Context~{urnat_x0~:~wrx0~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 16686 - 16725 [Context~{ulnat_x1~:~wlx1~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 16728 - 16767 [Context~{urnat_x1~:~wrx1~@~1~=...] 0.001 secs (0.u,0.s)
Chars 16771 - 16810 [Context~{ulnat_y0~:~wly0~@~1~=...] 0.001 secs (0.u,0.s)
Chars 16813 - 16852 [Context~{urnat_y0~:~wry0~@~1~=...] 0.001 secs (0.u,0.s)
Chars 16855 - 16894 [Context~{ulnat_y1~:~wly1~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 16897 - 16936 [Context~{urnat_y1~:~wry1~@~1~=...] 0.001 secs (0.001u,0.s)
Chars 16940 - 16982 [Context~{ehlnat_x0~:~wlx0~@~1~...] 0.001 secs (0.001u,0.s)
Chars 16985 - 17027 [Context~{ehlnat_x1~:~wlx1~@~1~...] 0.001 secs (0.001u,0.s)
Chars 17031 - 17073 [Context~{ehrnat_y0~:~wry0~@~1~...] 0.001 secs (0.001u,0.s)
Chars 17076 - 17118 [Context~{ehrnat_y1~:~wry1~@~1~...] 0.001 secs (0.001u,0.s)
Chars 17122 - 17171 [Context~{wlrnat_x_y~:~wlx0~@~w...] 0. secs (0.u,0.s)
Chars 17174 - 17223 [Context~{wlrnat_y_x~:~wly1~@~w...] 0. secs (0.u,0.s)
Chars 17243 - 17318 [Hypothesis~(ehlnat_1p_x0~:~(eh...] 0.004 secs (0.003u,0.s)
Chars 17322 - 17396 [Hypothesis~(ehlnat_1p_x1~:~(eh...] 0.004 secs (0.004u,0.s)
Chars 17400 - 17474 [Hypothesis~(ehrnat_p1_y0~:~(eh...] 0.004 secs (0.003u,0.s)
Chars 17478 - 17552 [Hypothesis~(ehrnat_p1_y1~:~(eh...] 0.004 secs (0.004u,0.s)
Chars 17556 - 17693 [Hypothesis~~~(wlrnat_V_x_y~:~~...] 0.006 secs (0.006u,0.s)
Chars 17719 - 18007 [Definition~eh_V_gen~:~~~let~EH...] 0.013 secs (0.012u,0.s)
Chars 18010 - 18016 [Proof.] 0. secs (0.u,0.s)
Chars 18144 - 18153 [revert~f.] 40.174 secs (0.u,0.027s)
Chars 18160 - 18191 [(equiv_intro~(equiv_path~A~B)~p).] 0.005 secs (0.005u,0.s)
Chars 18198 - 18243 [refine~(ap~(ap~O)~(eta_path_un...] 0.002 secs (0.002u,0.s)
Chars 18250 - 18268 [(destruct~p;~simpl).] 0.002 secs (0.001u,0.s)
Chars 18275 - 18295 [(apply~moveL_equiv_V).] 0.001 secs (0.001u,0.s)
Chars 18302 - 18353 [(apply~path_equiv,~path_arrow,...] 0.004 secs (0.004u,0.s)
Chars 18360 - 18389 [(symmetry;~apply~to_O_natural).] 0.003 secs (0.003u,0.s)
Chars 18144 - 18153 [revert~f.] 0. secs (0.u,0.s)
Chars 18160 - 18191 [(equiv_intro~(equiv_path~A~B)~p).] 0. secs (0.u,0.s)
Chars 18198 - 18243 [refine~(ap~(ap~O)~(eta_path_un...] 0. secs (0.u,0.s)
Chars 18250 - 18268 [(destruct~p;~simpl).] 0. secs (0.u,0.s)
Chars 18275 - 18295 [(apply~moveL_equiv_V).] 0. secs (0.u,0.s)
Chars 18302 - 18353 [(apply~path_equiv,~path_arrow,...] 0. secs (0.u,0.s)
Chars 18360 - 18389 [(symmetry;~apply~to_O_natural).] 0. secs (0.u,0.s)
Chars 18394 - 18402 [Defined.] 0.003 secs (0.003u,0.s)
Chars 18408 - 18618 [Definition~ap_O_path_universe~...] 0.01 secs (0.008u,0.001s)
Chars 18668 - 18837 [Definition~O_rec_postcompose~{...] 0.004 secs (0.003u,0.001s)
Chars 18842 - 18848 [Proof.] 0. secs (0.u,0.s)
Chars 20885 - 20944 [refine~(istrunc_isequiv_istrun...] 40.099 secs (0.008u,0.018s)
Chars 20885 - 20944 [refine~(istrunc_isequiv_istrun...] 0. secs (0.u,0.s)
Chars 20945 - 20953 [Defined.] 0. secs (0.u,0.s)
Chars 21017 - 21060 [Definition~not_hset_Type~:~~~I...] 0. secs (0.u,0.s)
Chars 21061 - 21067 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 21070 - 21079 [intro~HT.] 22.251 secs (18.59u,-0.114s)
Chars 18021 - 18110 [(pose~~~(H_whiskerR_wlrnat_x_y...] 40.143 secs (0.009u,0.024s)
Chars 18115 - 18146 [(apply~moveL_pV~in~wlrnat_V_x_y).] 0.008 secs (0.008u,0.s)
Chars 18151 - 18205 [(apply~(concat~H_whiskerR_wlrn...] 0.009 secs (0.007u,0.002s)
Chars 18210 - 18251 [(apply~moveL_Vp,~moveL_pV~in~w...] 0.011 secs (0.01u,0.s)
Chars 18256 - 18287 [(apply~symmetry~in~wlrnat_V_x_y).] 0.014 secs (0.01u,0.004s)
Chars 18292 - 18314 [(destruct~wlrnat_V_x_y).] 0.067 secs (0.059u,0.007s)
Chars 18319 - 18338 [clear~wlrnat_V_x_y.] 0.012 secs (0.011u,0.s)
Chars 18343 - 18371 [clear~H_whiskerR_wlrnat_x_y.] 0.01 secs (0.008u,0.001s)
Chars 18376 - 18405 [revert~ulnat_x0~ehlnat_1p_x0.] 0.006 secs (0.006u,0.s)
Chars 18410 - 18444 [snrapply~equiv_path_ind_rlucan...] 0.028 secs (0.026u,0.002s)
Chars 18449 - 18478 [revert~ulnat_x1~ehlnat_1p_x1.] 0.007 secs (0.004u,0.002s)
Chars 18483 - 18517 [snrapply~equiv_path_ind_rlucan...] 0.026 secs (0.023u,0.002s)
Chars 18522 - 18551 [revert~urnat_y0~ehrnat_p1_y0.] 0.007 secs (0.006u,0.s)
Chars 18556 - 18590 [snrapply~equiv_path_ind_rlucan...] 0.029 secs (0.027u,0.001s)
Chars 18595 - 18624 [revert~urnat_y1~ehrnat_p1_y1.] 0.008 secs (0.006u,0.002s)
Chars 18629 - 18663 [snrapply~equiv_path_ind_rlucan...] 0.034 secs (0.03u,0.003s)
Chars 18669 - 18688 [revert~x0~urnat_x0.] 0.009 secs (0.009u,0.s)
Chars 18693 - 18727 [snrapply~equiv_path_ind_rlucan...] 0.027 secs (0.024u,0.002s)
Chars 18732 - 18751 [revert~x1~urnat_x1.] 0.008 secs (0.008u,0.s)
Chars 18756 - 18790 [snrapply~equiv_path_ind_rlucan...] 0.028 secs (0.024u,0.003s)
Chars 18795 - 18814 [revert~y0~ulnat_y0.] 0.007 secs (0.007u,0.s)
Chars 18819 - 18853 [snrapply~equiv_path_ind_rlucan...] 0.021 secs (0.021u,0.s)
Chars 18858 - 18877 [revert~y1~ulnat_y1.] 0.007 secs (0.007u,0.s)
Chars 18882 - 18916 [snrapply~equiv_path_ind_rlucan...] 0.021 secs (0.021u,0.s)
Chars 18922 - 18940 [revert~wlrnat_y_x.] 0.007 secs (0.007u,0.s)
Chars 18945 - 18967 [revert~wrx0~ehlnat_x0.] 0.007 secs (0.007u,0.s)
Chars 18972 - 19006 [snrapply~equiv_path_ind_rlucan...] 0.026 secs (0.024u,0.002s)
Chars 19011 - 19033 [revert~wrx1~ehlnat_x1.] 0.007 secs (0.007u,0.s)
Chars 19038 - 19072 [snrapply~equiv_path_ind_rlucan...] 0.02 secs (0.02u,0.s)
Chars 19077 - 19099 [revert~wly0~ehrnat_y0.] 0.007 secs (0.007u,0.s)
Chars 19104 - 19138 [snrapply~equiv_path_ind_rlucan...] 0.022 secs (0.022u,0.s)
Chars 19143 - 19165 [revert~wly1~ehrnat_y1.] 0.007 secs (0.007u,0.s)
Chars 19170 - 19204 [snrapply~equiv_path_ind_rlucan...] 0.022 secs (0.022u,0.s)
Chars 19210 - 19236 [(destruct~wry0,~wry1,~wlx1).] 0.058 secs (0.057u,0.s)
Chars 19241 - 19262 [clear~wry0~wry1~wlx1.] 0.003 secs (0.003u,0.s)
Chars 19267 - 19279 [revert~wlx0.] 0.003 secs (0.003u,0.s)
Chars 19284 - 19318 [snrapply~equiv_path_ind_lrucan...] 0.016 secs (0.016u,0.s)
Chars 19323 - 19335 [reflexivity.] 0.005 secs (0.005u,0.s)
Chars 18021 - 18110 [(pose~~~(H_whiskerR_wlrnat_x_y...] 0.004 secs (0.004u,0.s)
Chars 18115 - 18146 [(apply~moveL_pV~in~wlrnat_V_x_y).] 0.004 secs (0.004u,0.s)
Chars 18151 - 18205 [(apply~(concat~H_whiskerR_wlrn...] 0.004 secs (0.004u,0.s)
Chars 18210 - 18251 [(apply~moveL_Vp,~moveL_pV~in~w...] 0.004 secs (0.004u,0.s)
Chars 18256 - 18287 [(apply~symmetry~in~wlrnat_V_x_y).] 0.004 secs (0.004u,0.s)
Chars 18292 - 18314 [(destruct~wlrnat_V_x_y).] 0.005 secs (0.005u,0.s)
Chars 18319 - 18338 [clear~wlrnat_V_x_y.] 0.008 secs (0.008u,0.s)
Chars 18343 - 18371 [clear~H_whiskerR_wlrnat_x_y.] 0.008 secs (0.007u,0.s)
Chars 18376 - 18405 [revert~ulnat_x0~ehlnat_1p_x0.] 0.004 secs (0.004u,0.s)
Chars 18410 - 18444 [snrapply~equiv_path_ind_rlucan...] 0.004 secs (0.004u,0.s)
Chars 18449 - 18478 [revert~ulnat_x1~ehlnat_1p_x1.] 0.004 secs (0.004u,0.s)
Chars 18483 - 18517 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 18522 - 18551 [revert~urnat_y0~ehrnat_p1_y0.] 0.014 secs (0.012u,0.001s)
Chars 18556 - 18590 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 18595 - 18624 [revert~urnat_y1~ehrnat_p1_y1.] 0.005 secs (0.005u,0.s)
Chars 18629 - 18663 [snrapply~equiv_path_ind_rlucan...] 0.006 secs (0.006u,0.s)
Chars 18669 - 18688 [revert~x0~urnat_x0.] 0.006 secs (0.006u,0.s)
Chars 18693 - 18727 [snrapply~equiv_path_ind_rlucan...] 0.006 secs (0.006u,0.s)
Chars 18732 - 18751 [revert~x1~urnat_x1.] 0.006 secs (0.006u,0.s)
Chars 18756 - 18790 [snrapply~equiv_path_ind_rlucan...] 0.006 secs (0.006u,0.s)
Chars 18795 - 18814 [revert~y0~ulnat_y0.] 0.006 secs (0.006u,0.s)
Chars 18819 - 18853 [snrapply~equiv_path_ind_rlucan...] 0.006 secs (0.006u,0.s)
Chars 18858 - 18877 [revert~y1~ulnat_y1.] 0.006 secs (0.006u,0.s)
Chars 18882 - 18916 [snrapply~equiv_path_ind_rlucan...] 0.006 secs (0.006u,0.s)
Chars 18922 - 18940 [revert~wlrnat_y_x.] 0.006 secs (0.006u,0.s)
Chars 18945 - 18967 [revert~wrx0~ehlnat_x0.] 0.006 secs (0.006u,0.s)
Chars 18972 - 19006 [snrapply~equiv_path_ind_rlucan...] 0.006 secs (0.006u,0.s)
Chars 19011 - 19033 [revert~wrx1~ehlnat_x1.] 0.006 secs (0.006u,0.s)
Chars 19038 - 19072 [snrapply~equiv_path_ind_rlucan...] 0.006 secs (0.006u,0.s)
Chars 19077 - 19099 [revert~wly0~ehrnat_y0.] 0.006 secs (0.006u,0.s)
Chars 19104 - 19138 [snrapply~equiv_path_ind_rlucan...] 0.006 secs (0.006u,0.s)
Chars 19143 - 19165 [revert~wly1~ehrnat_y1.] 0.006 secs (0.006u,0.s)
Chars 19170 - 19204 [snrapply~equiv_path_ind_rlucan...] 0.006 secs (0.006u,0.s)
Chars 19210 - 19236 [(destruct~wry0,~wry1,~wlx1).] 0.006 secs (0.006u,0.s)
Chars 19241 - 19262 [clear~wry0~wry1~wlx1.] 0.002 secs (0.002u,0.s)
Chars 19267 - 19279 [revert~wlx0.] 0.002 secs (0.002u,0.s)
Chars 19284 - 19318 [snrapply~equiv_path_ind_lrucan...] 0.002 secs (0.002u,0.s)
Chars 19323 - 19335 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 19338 - 19346 [Defined.] 0.102 secs (0.1u,0.001s)
find_witness Control.TimeoutChars 19348 - 19357 [End~eh_V.] 0.379 secs (0.367u,0.012s)
Chars 19359 - 19454 [Theorem~eh_V~{X}~{a~:~X}~(p~q~...] 0.003 secs (0.003u,0.s)
Chars 19455 - 19461 [Proof.] 0. secs (0.u,0.s)
Chars 18855 - 18891 [(refine~(O_indpaths~_~_~_);~in...] 40.165 secs (0.003u,0.027s)
Chars 18898 - 18921 [transitivity~(g~(f~x)).] 0.002 secs (0.001u,0.s)
Chars 18928 - 18929 [-] 0. secs (0.u,0.s)
Chars 18930 - 18939 [(apply~ap).] 0.001 secs (0.001u,0.s)
Chars 18940 - 18957 [(apply~O_rec_beta).] 0.001 secs (0.001u,0.s)
Chars 18964 - 18965 [-] 0. secs (0.u,0.s)
Chars 18966 - 18975 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 18976 - 19005 [exact~(O_rec_beta~(g~o~f)~x).] 0.002 secs (0.001u,0.s)
Chars 18855 - 18891 [(refine~(O_indpaths~_~_~_);~in...] 0.001 secs (0.001u,0.s)
Chars 18898 - 18921 [transitivity~(g~(f~x)).] 0. secs (0.u,0.s)
Chars 18930 - 18939 [(apply~ap).] 0. secs (0.u,0.s)
Chars 18940 - 18957 [(apply~O_rec_beta).] 0. secs (0.u,0.s)
Chars 18966 - 18975 [symmetry.] 0. secs (0.u,0.s)
Chars 18976 - 19005 [exact~(O_rec_beta~(g~o~f)~x).] 0. secs (0.u,0.s)
Chars 19010 - 19018 [Defined.] 0.001 secs (0.001u,0.s)
Chars 19022 - 19034 [End~Functor.] 0.205 secs (0.185u,0.019s)
Chars 19038 - 19054 [Section~Replete.] 0. secs (0.u,0.s)
Chars 19194 - 19312 [Definition~inO_isequiv_to_O~(T...] 0.002 secs (0.002u,0.s)
Chars 19460 - 19527 [#[local]Hint~Immediate~inO_ise...] 0. secs (0.u,0.s)
Chars 19533 - 19608 [Definition~inO_iff_isequiv_to_...] 0. secs (0.u,0.s)
Chars 19613 - 19619 [Proof.] 0. secs (0.u,0.s)
Chars 21070 - 21079 [intro~HT.] 40.04 secs (0.u,0.017s)
Chars 21082 - 21102 [(apply~true_ne_false).] 0. secs (0.u,0.s)
Chars 21105 - 21159 [(pose~(r~:=~path_ishprop~(path...] 0.004 secs (0.003u,0.s)
Chars 21162 - 21217 [refine~(_~@~ap~(fun~q~=>~trans...] 0.002 secs (0.002u,0.s)
Chars 21220 - 21260 [(symmetry;~apply~transport_pat...] 0.003 secs (0.002u,0.s)
Chars 21070 - 21079 [intro~HT.] 0. secs (0.u,0.s)
Chars 21082 - 21102 [(apply~true_ne_false).] 0. secs (0.u,0.s)
Chars 21105 - 21159 [(pose~(r~:=~path_ishprop~(path...] 0. secs (0.u,0.s)
Chars 21162 - 21217 [refine~(_~@~ap~(fun~q~=>~trans...] 0. secs (0.u,0.s)
Chars 21220 - 21260 [(symmetry;~apply~transport_pat...] 0. secs (0.u,0.s)
Chars 21261 - 21269 [Defined.] 0.001 secs (0.001u,0.s)
Chars 21271 - 21286 [End~Univalence.] 0.219 secs (0.197u,0.019s)
Chars 19626 - 19641 [(split;~exact~_).] 12.209 secs (4.148u,-0.616s)
find_witness Control.TimeoutChars 19464 - 19481 [nrapply~eh_V_gen.] 40.164 secs (0.031u,0.029s)
Chars 19484 - 19485 [-] 0. secs (0.u,0.s)
Chars 19486 - 19506 [exact~(ehlnat_1p~p).] 0.044 secs (0.034u,0.009s)
Chars 19509 - 19510 [-] 0. secs (0.u,0.s)
Chars 19511 - 19531 [exact~(ehlnat_1p~p).] 0.014 secs (0.012u,0.001s)
Chars 19534 - 19535 [-] 0. secs (0.u,0.s)
Chars 19536 - 19556 [exact~(ehrnat_p1~q).] 0.013 secs (0.013u,0.s)
Chars 19559 - 19560 [-] 0. secs (0.u,0.s)
Chars 19561 - 19581 [exact~(ehrnat_p1~q).] 0.014 secs (0.013u,0.001s)
Chars 19584 - 19585 [-] 0. secs (0.u,0.s)
Chars 19586 - 19607 [exact~(wlrnat_V~p~q).] 0.018 secs (0.016u,0.002s)
Chars 19464 - 19481 [nrapply~eh_V_gen.] 0. secs (0.u,0.s)
Chars 19486 - 19506 [exact~(ehlnat_1p~p).] 0.001 secs (0.001u,0.s)
Chars 19511 - 19531 [exact~(ehlnat_1p~p).] 0.002 secs (0.002u,0.s)
Chars 19536 - 19556 [exact~(ehrnat_p1~q).] 0.002 secs (0.002u,0.s)
Chars 19561 - 19581 [exact~(ehrnat_p1~q).] 0.002 secs (0.002u,0.s)
Chars 19586 - 19607 [exact~(wlrnat_V~p~q).] 0.004 secs (0.003u,0.s)
Chars 19608 - 19616 [Defined.] 0.049 secs (0.04u,0.009s)
Chars 19712 - 19733 [Section~Ehrnat_p1_pp.] 0. secs (0.u,0.s)
Chars 19737 - 19756 [Context~{X~:~Type}.] 0. secs (0.u,0.s)
Chars 19776 - 19799 [Context~{a0~a1~a2~:~X}.] 0. secs (0.u,0.s)
Chars 19802 - 19825 [Context~{b0~b1~b2~:~X}.] 0. secs (0.u,0.s)
Chars 19828 - 19851 [Context~{c0~c1~c2~:~X}.] 0. secs (0.u,0.s)
Chars 19871 - 19895 [Context~{wry~:~a0~=~b0}.] 0. secs (0.u,0.s)
Chars 19898 - 19922 [Context~{wrz~:~b0~=~c0}.] 0. secs (0.u,0.s)
Chars 19926 - 19950 [Context~{wly~:~a1~=~b1}.] 0. secs (0.u,0.s)
Chars 19953 - 19977 [Context~{wlz~:~b1~=~c1}.] 0. secs (0.u,0.s)
Chars 19981 - 20003 [Context~{y~:~a2~=~b2}.] 0. secs (0.u,0.s)
Chars 20006 - 20028 [Context~{z~:~b2~=~c2}.] 0. secs (0.u,0.s)
Chars 20032 - 20057 [Context~{wryz~:~a0~=~c0}.] 0. secs (0.u,0.s)
Chars 20060 - 20085 [Context~{wlyz~:~a1~=~c1}.] 0. secs (0.u,0.s)
Chars 20089 - 20113 [Context~{a01~:~a0~=~a1}.] 0. secs (0.u,0.s)
Chars 20116 - 20140 [Context~{a12~:~a1~=~a2}.] 0. secs (0.u,0.s)
Chars 20144 - 20168 [Context~{b01~:~b0~=~b1}.] 0. secs (0.u,0.s)
Chars 20171 - 20195 [Context~{b12~:~b1~=~b2}.] 0. secs (0.u,0.s)
Chars 20199 - 20223 [Context~{c01~:~c0~=~c1}.] 0. secs (0.u,0.s)
Chars 20226 - 20250 [Context~{c12~:~c1~=~c2}.] 0. secs (0.u,0.s)
Chars 20254 - 20278 [Context~{a02~:~a0~=~a2}.] 0. secs (0.u,0.s)
Chars 20281 - 20305 [Context~{c02~:~c0~=~c2}.] 0. secs (0.u,0.s)
Chars 20327 - 20370 [Context~{ehrnat_y~:~wry~@~b01~...] 0. secs (0.u,0.s)
Chars 20373 - 20416 [Context~{ehrnat_z~:~wrz~@~c01~...] 0. secs (0.u,0.s)
Chars 20419 - 20465 [Context~{ehrnat_yz~:~wryz~@~c0...] 0. secs (0.u,0.s)
Chars 20469 - 20509 [Context~{ulnat_y~:~wly~@~b12~=...] 0. secs (0.u,0.s)
Chars 20512 - 20552 [Context~{ulnat_z~:~wlz~@~c12~=...] 0. secs (0.u,0.s)
Chars 20555 - 20603 [Context~{ulnat_yz~:~wlyz~@~c12...] 0.001 secs (0.001u,0.s)
Chars 20607 - 20655 [Context~{urnat_y~:~wry~@~(b01~...] 0.001 secs (0.001u,0.s)
Chars 20658 - 20706 [Context~{urnat_z~:~wrz~@~c02~=...] 0.001 secs (0.001u,0.s)
Chars 20709 - 20757 [Context~{urnat_yz~:~wryz~@~c02...] 0.01 secs (0.004u,0.006s)
Chars 20761 - 20798 [Context~{wrpp_yz~:~wry~@~wrz~=...] 0. secs (0.u,0.s)
Chars 20801 - 20838 [Context~{wlpp_yz~:~wly~@~wlz~=...] 0. secs (0.u,0.s)
Chars 20842 - 20876 [Context~(H_a02~:~a01~@~a12~=~a...] 0. secs (0.u,0.s)
Chars 20879 - 20913 [Context~(H_c02~:~c01~@~c12~=~c...] 0. secs (0.u,0.s)
Chars 20933 - 21044 [Hypothesis~~~(H_ehrnat_yz~:~~~...] 0.004 secs (0.004u,0.s)
Chars 21048 - 21130 [Hypothesis~(H_ulnat_yz~:~ulnat...] 0.003 secs (0.003u,0.s)
Chars 21134 - 21216 [Hypothesis~(H_urnat_yz~:~urnat...] 0.003 secs (0.002u,0.s)
Chars 21220 - 21303 [Variable~~~(ehrnat_p1_y~:~(ehr...] 0.005 secs (0.003u,0.001s)
Chars 21307 - 21390 [Variable~~~(ehrnat_p1_z~:~(ehr...] 0.004 secs (0.002u,0.002s)
Chars 21420 - 21528 [Definition~Ehrnat_p1_pp~:~~~(e...] 0.004 secs (0.004u,0.s)
Chars 21531 - 21537 [Proof.] 0. secs (0.u,0.s)
Chars 19626 - 19641 [(split;~exact~_).] 40.069 secs (0.006u,0.028s)
Chars 19626 - 19641 [(split;~exact~_).] 0. secs (0.u,0.s)
Chars 19646 - 19654 [Defined.] 0. secs (0.u,0.s)
Chars 19742 - 19834 [Definition~inO_to_O_retract~(T...] 0.001 secs (0.001u,0.s)
Chars 19839 - 19845 [Proof.] 0. secs (0.u,0.s)
Chars 19852 - 19861 [(intros~H).] 8.945 secs (0.978u,-0.683s)
H10C_SAT_RA_UNIV_HALT
     : H10C_SAT ⪯ RA_UNIV_HALT
Chars 21542 - 21596 [(apply~moveR_Vp~in~H_urnat_yz,...] 40.14 secs (0.01u,0.023s)
Chars 21601 - 21646 [(destruct~H_urnat_yz,~H_ulnat_...] 0.064 secs (0.048u,0.015s)
Chars 21651 - 21691 [clear~H_urnat_yz~H_ulnat_yz~H_...] 0.009 secs (0.007u,0.001s)
Chars 21696 - 21739 [(apply~moveR_Vp~in~ehrnat_p1_y...] 0.009 secs (0.006u,0.002s)
Chars 21744 - 21778 [(destruct~ehrnat_p1_y,~ehrnat_...] 0.063 secs (0.049u,0.013s)
Chars 21783 - 21813 [clear~ehrnat_p1_y~ehrnat_p1_z.] 0.006 secs (0.004u,0.001s)
Chars 21818 - 21840 [(destruct~H_a02,~H_c02).] 0.043 secs (0.035u,0.007s)
Chars 21845 - 21863 [clear~H_a02~H_c02.] 0.005 secs (0.004u,0.s)
Chars 21868 - 21894 [(destruct~wrpp_yz,~wlpp_yz).] 0.044 secs (0.039u,0.004s)
Chars 21899 - 21921 [clear~wrpp_yz~wlpp_yz.] 0.005 secs (0.005u,0.s)
Chars 21926 - 21964 [(destruct~a01,~a12,~b01,~b12,~...] 0.137 secs (0.122u,0.014s)
Chars 21969 - 21999 [clear~a01~a12~b01~b12~c01~c12.] 0.003 secs (0.003u,0.s)
Chars 22004 - 22021 [revert~y~ulnat_y.] 0.003 secs (0.003u,0.s)
Chars 22026 - 22060 [snrapply~equiv_path_ind_rlucan...] 0.015 secs (0.015u,0.s)
Chars 22065 - 22082 [revert~z~ulnat_z.] 0.003 secs (0.003u,0.s)
Chars 22087 - 22121 [snrapply~equiv_path_ind_rlucan...] 0.023 secs (0.023u,0.s)
Chars 22126 - 22146 [revert~wly~ehrnat_y.] 0.003 secs (0.003u,0.s)
Chars 22151 - 22185 [snrapply~equiv_path_ind_rlucan...] 0.016 secs (0.015u,0.s)
Chars 22190 - 22210 [revert~wlz~ehrnat_z.] 0.003 secs (0.003u,0.s)
Chars 22215 - 22249 [snrapply~equiv_path_ind_rlucan...] 0.016 secs (0.016u,0.s)
Chars 22254 - 22272 [(destruct~wry,~wrz).] 0.044 secs (0.044u,0.s)
Chars 22277 - 22291 [clear~wry~wrz.] 0.003 secs (0.003u,0.s)
Chars 22296 - 22308 [reflexivity.] 0.005 secs (0.005u,0.s)
Chars 21542 - 21596 [(apply~moveR_Vp~in~H_urnat_yz,...] 0.003 secs (0.003u,0.s)
Chars 21601 - 21646 [(destruct~H_urnat_yz,~H_ulnat_...] 0.003 secs (0.003u,0.s)
Chars 21651 - 21691 [clear~H_urnat_yz~H_ulnat_yz~H_...] 0.004 secs (0.004u,0.s)
Chars 21696 - 21739 [(apply~moveR_Vp~in~ehrnat_p1_y...] 0.003 secs (0.003u,0.s)
Chars 21744 - 21778 [(destruct~ehrnat_p1_y,~ehrnat_...] 0.003 secs (0.003u,0.s)
Chars 21783 - 21813 [clear~ehrnat_p1_y~ehrnat_p1_z.] 0.004 secs (0.004u,0.s)
Chars 21818 - 21840 [(destruct~H_a02,~H_c02).] 0.006 secs (0.004u,0.001s)
Chars 21845 - 21863 [clear~H_a02~H_c02.] 0.003 secs (0.003u,0.s)
Chars 21868 - 21894 [(destruct~wrpp_yz,~wlpp_yz).] 0.003 secs (0.003u,0.s)
Chars 21899 - 21921 [clear~wrpp_yz~wlpp_yz.] 0.003 secs (0.003u,0.s)
Chars 21926 - 21964 [(destruct~a01,~a12,~b01,~b12,~...] 0.003 secs (0.003u,0.s)
Chars 21969 - 21999 [clear~a01~a12~b01~b12~c01~c12.] 0.002 secs (0.002u,0.s)
Chars 22004 - 22021 [revert~y~ulnat_y.] 0.002 secs (0.002u,0.s)
Chars 22026 - 22060 [snrapply~equiv_path_ind_rlucan...] 0.002 secs (0.002u,0.s)
Chars 22065 - 22082 [revert~z~ulnat_z.] 0.002 secs (0.002u,0.s)
Chars 22087 - 22121 [snrapply~equiv_path_ind_rlucan...] 0.002 secs (0.002u,0.s)
Chars 22126 - 22146 [revert~wly~ehrnat_y.] 0.003 secs (0.003u,0.s)
Chars 22151 - 22185 [snrapply~equiv_path_ind_rlucan...] 0.003 secs (0.003u,0.s)
Chars 22190 - 22210 [revert~wlz~ehrnat_z.] 0.003 secs (0.003u,0.s)
Chars 22215 - 22249 [snrapply~equiv_path_ind_rlucan...] 0.003 secs (0.003u,0.s)
Chars 22254 - 22272 [(destruct~wry,~wrz).] 0.003 secs (0.003u,0.s)
Chars 22277 - 22291 [clear~wry~wrz.] 0.002 secs (0.002u,0.s)
Chars 22296 - 22308 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 22311 - 22319 [Defined.] 0.094 secs (0.09u,0.003s)
Chars 22321 - 22338 [End~Ehrnat_p1_pp.] 0.155 secs (0.153u,0.002s)
Chars 22340 - 22567 [Definition~ehrnat_p1_pp~{X}~{a...] 0.093 secs (0.089u,0.004s)
Chars 22568 - 22574 [Proof.] 0. secs (0.u,0.s)
Chars 19852 - 19861 [(intros~H).] 40.057 secs (0.002u,0.026s)
Chars 19868 - 19891 [(apply~inO_isequiv_to_O).] 0. secs (0.u,0.s)
Chars 19898 - 19936 [(apply~isequiv_adjointify~with...] 0.001 secs (0.u,0.001s)
Chars 19943 - 19944 [-] 0. secs (0.u,0.s)
Chars 19945 - 19987 [refine~(O_indpaths~(to~O~T~o~m...] 0.003 secs (0.003u,0.s)
Chars 19996 - 20032 [(intros~x;~exact~(ap~(to~O~T)~...] 0.002 secs (0.002u,0.s)
Chars 20039 - 20040 [-] 0. secs (0.u,0.s)
Chars 20041 - 20049 [exact~H.] 0.001 secs (0.u,0.s)
Chars 19852 - 19861 [(intros~H).] 0. secs (0.u,0.s)
Chars 19868 - 19891 [(apply~inO_isequiv_to_O).] 0. secs (0.u,0.s)
Chars 19898 - 19936 [(apply~isequiv_adjointify~with...] 0. secs (0.u,0.s)
Chars 19945 - 19987 [refine~(O_indpaths~(to~O~T~o~m...] 0. secs (0.u,0.s)
Chars 19996 - 20032 [(intros~x;~exact~(ap~(to~O~T)~...] 0. secs (0.u,0.s)
Chars 20041 - 20049 [exact~H.] 0. secs (0.u,0.s)
Chars 20054 - 20062 [Defined.] 0. secs (0.u,0.s)
Chars 20066 - 20078 [End~Replete.] 0.004 secs (0.004u,0.s)
Chars 20327 - 20381 [#[local]Notation~O_inverts~f:=...] 0. secs (0.u,0.s)
Chars 20385 - 20402 [Section~OInverts.] 0. secs (0.u,0.s)
Chars 20408 - 20477 [#[global]Instance~O_inverts_O_...] 0. secs (0.u,0.s)
Chars 20482 - 20488 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutH10UC_SAT_RA_UNIV_AD_HALT
     : H10UC_SAT ⪯ RA_UNIV_AD_HALT
Chars 22577 - 22588 [revert~u~q.] 40.136 secs (0.008u,0.026s)
Chars 22591 - 22640 [snrapply~(equiv_path_ind~(equi...] 0.027 secs (0.02u,0.006s)
Chars 22643 - 22657 [by~destruct~r.] 0.134 secs (0.112u,0.021s)
Chars 22577 - 22588 [revert~u~q.] 0.007 secs (0.005u,0.001s)
Chars 22591 - 22640 [snrapply~(equiv_path_ind~(equi...] 0.007 secs (0.007u,0.s)
Chars 22643 - 22657 [by~destruct~r.] 0.007 secs (0.006u,0.s)
Chars 22658 - 22666 [Defined.] 0.175 secs (0.146u,0.029s)
Chars 22765 - 22787 [Section~wlrnat_V_p_pp.] 0. secs (0.u,0.s)
Chars 22791 - 22810 [Context~{X~:~Type}.] 0. secs (0.u,0.s)
Chars 22830 - 22862 [Context~{a0~b0~c0~d0~e0~f0~:~X}.] 0. secs (0.u,0.s)
Chars 22865 - 22897 [Context~{a1~b1~c1~d1~e1~f1~:~X}.] 0. secs (0.u,0.s)
Chars 22917 - 22942 [Context~{wlx0~:~a0~=~b0}.] 0. secs (0.u,0.s)
Chars 22945 - 22970 [Context~{wlx1~:~c0~=~d0}.] 0. secs (0.u,0.s)
Chars 22973 - 22998 [Context~{wlx2~:~e0~=~f0}.] 0. secs (0.u,0.s)
Chars 23002 - 23027 [Context~{wrx0~:~a1~=~b1}.] 0. secs (0.u,0.s)
Chars 23030 - 23055 [Context~{wrx1~:~c1~=~d1}.] 0. secs (0.u,0.s)
Chars 23058 - 23083 [Context~{wrx2~:~e1~=~f1}.] 0. secs (0.u,0.s)
Chars 23087 - 23112 [Context~{wry0~:~b0~=~d0}.] 0. secs (0.u,0.s)
Chars 23115 - 23140 [Context~{wly0~:~b1~=~d1}.] 0. secs (0.u,0.s)
Chars 23143 - 23168 [Context~{wry1~:~a0~=~c0}.] 0. secs (0.u,0.s)
Chars 23171 - 23196 [Context~{wly1~:~a1~=~c1}.] 0. secs (0.u,0.s)
Chars 23200 - 23225 [Context~{wrz0~:~d0~=~f0}.] 0. secs (0.u,0.s)
Chars 23228 - 23253 [Context~{wlz0~:~d1~=~f1}.] 0. secs (0.u,0.s)
Chars 23256 - 23281 [Context~{wrz1~:~c0~=~e0}.] 0. secs (0.u,0.s)
Chars 23284 - 23309 [Context~{wlz1~:~c1~=~e1}.] 0. secs (0.u,0.s)
Chars 23313 - 23337 [Context~{a01~:~a0~=~a1}.] 0. secs (0.u,0.s)
Chars 23340 - 23364 [Context~{b01~:~b0~=~b1}.] 0. secs (0.u,0.s)
Chars 23367 - 23391 [Context~{c01~:~c0~=~c1}.] 0. secs (0.u,0.s)
Chars 23394 - 23418 [Context~{d01~:~d0~=~d1}.] 0. secs (0.u,0.s)
Chars 23421 - 23445 [Context~{e01~:~e0~=~e1}.] 0. secs (0.u,0.s)
Chars 23448 - 23472 [Context~{f01~:~f0~=~f1}.] 0. secs (0.u,0.s)
Chars 23476 - 23502 [Context~{wryz0~:~b0~=~f0}.] 0. secs (0.u,0.s)
Chars 23505 - 23531 [Context~{wlyz0~:~b1~=~f1}.] 0. secs (0.u,0.s)
Chars 23534 - 23560 [Context~{wryz1~:~a0~=~e0}.] 0. secs (0.u,0.s)
Chars 23563 - 23589 [Context~{wlyz1~:~a1~=~e1}.] 0. secs (0.u,0.s)
Chars 23609 - 23655 [Context~{ehlnat_x0~:~wlx0~@~b0...] 0. secs (0.u,0.s)
Chars 23658 - 23704 [Context~{ehlnat_x1~:~wlx1~@~d0...] 0. secs (0.u,0.s)
Chars 23707 - 23753 [Context~{ehlnat_x2~:~wlx2~@~f0...] 0. secs (0.u,0.s)
Chars 23757 - 23803 [Context~{ehrnat_y0~:~wry0~@~d0...] 0. secs (0.u,0.s)
Chars 23806 - 23852 [Context~{ehrnat_y1~:~wry1~@~c0...] 0. secs (0.u,0.s)
Chars 23856 - 23902 [Context~{ehrnat_z0~:~wrz0~@~f0...] 0. secs (0.u,0.s)
Chars 23905 - 23951 [Context~{ehrnat_z1~:~wrz1~@~e0...] 0. secs (0.u,0.s)
Chars 23955 - 24004 [Context~{ehrnat_yz0~:~wryz0~@~...] 0. secs (0.u,0.s)
Chars 24007 - 24056 [Context~{ehrnat_yz1~:~wryz1~@~...] 0. secs (0.u,0.s)
Chars 24060 - 24109 [Context~{wlrnat_x_y~:~wlx0~@~w...] 0. secs (0.u,0.s)
Chars 24112 - 24161 [Context~{wlrnat_y_x~:~wly1~@~w...] 0. secs (0.u,0.s)
Chars 24165 - 24214 [Context~{wlrnat_x_z~:~wlx1~@~w...] 0. secs (0.u,0.s)
Chars 24217 - 24266 [Context~{wlrnat_z_x~:~wlz1~@~w...] 0. secs (0.u,0.s)
Chars 24270 - 24322 [Context~{wlrnat_x_yz~:~wlx0~@~...] 0. secs (0.u,0.s)
Chars 24325 - 24377 [Context~{wlrnat_yz_x~:~wlyz1~@...] 0. secs (0.u,0.s)
Chars 24381 - 24422 [Context~{wrpp_yz0~:~wry0~@~wrz...] 0. secs (0.u,0.s)
Chars 24425 - 24466 [Context~{wlpp_yz0~:~wly0~@~wlz...] 0. secs (0.u,0.s)
Chars 24469 - 24510 [Context~{wrpp_yz1~:~wry1~@~wrz...] 0. secs (0.u,0.s)
Chars 24513 - 24554 [Context~{wlpp_yz1~:~wly1~@~wlz...] 0. secs (0.u,0.s)
Chars 24574 - 24691 [Hypothesis~~~(H_ehrnat_yz0~:~~...] 0.004 secs (0.004u,0.s)
Chars 24695 - 24812 [Hypothesis~~~(H_ehrnat_yz1~:~~...] 0.004 secs (0.004u,0.s)
Chars 24816 - 24937 [Hypothesis~~~(H_wlrnat_x_yz~:~...] 0.004 secs (0.004u,0.s)
Chars 24941 - 25062 [Hypothesis~~~(H_wlrnat_yz_x~:~...] 0.033 secs (0.029u,0.003s)
Chars 25066 - 25201 [Variable~~~(wlrnat_V_x_y~:~~~~...] 0.007 secs (0.007u,0.s)
Chars 25205 - 25340 [Variable~~~(wlrnat_V_x_z~:~~~~...] 0.007 secs (0.007u,0.s)
Chars 25373 - 25515 [Definition~Wlrnat_V_p_pp~:~~~w...] 0.007 secs (0.007u,0.s)
Chars 25518 - 25524 [Proof.] 0. secs (0.u,0.s)
Chars 20495 - 20537 [refine~(isequiv_homotopic~(to~...] 40.16 secs (0.007u,0.031s)
Chars 20544 - 20592 [(intros~x;~symmetry;~apply~O_f...] 0.003 secs (0.001u,0.001s)
Chars 20495 - 20537 [refine~(isequiv_homotopic~(to~...] 0. secs (0.u,0.s)
Chars 20544 - 20592 [(intros~x;~symmetry;~apply~O_f...] 0. secs (0.u,0.s)
Chars 20597 - 20605 [Defined.] 0.001 secs (0.001u,0.s)
Chars 20812 - 20924 [Definition~isequiv_O_inverts~{...] 0.001 secs (0.u,0.s)
Chars 20929 - 20935 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutMM_FRACTRAN_REG_HALTING
     : Halt_MM ⪯ FRACTRAN_REG_HALTING
find_witness Control.TimeoutChars 25529 - 25574 [(apply~moveR_Vp~in~H_ehrnat_yz...] 40.137 secs (0.009u,0.027s)
Chars 25579 - 25615 [(destruct~H_ehrnat_yz0,~H_ehrn...] 0.058 secs (0.045u,0.012s)
Chars 25620 - 25652 [clear~H_ehrnat_yz0~H_ehrnat_yz1.] 0.007 secs (0.006u,0.s)
Chars 25657 - 25704 [(apply~moveR_Vp~in~H_wlrnat_x_...] 0.011 secs (0.01u,0.s)
Chars 25709 - 25747 [(destruct~H_wlrnat_x_yz,~H_wlr...] 0.07 secs (0.056u,0.013s)
Chars 25752 - 25786 [clear~H_wlrnat_x_yz~H_wlrnat_y...] 0.007 secs (0.007u,0.s)
Chars 25791 - 25829 [(destruct~a01,~b01,~c01,~d01,~...] 0.178 secs (0.158u,0.02s)
Chars 25834 - 25864 [clear~a01~b01~c01~d01~e01~f01.] 0.005 secs (0.005u,0.s)
Chars 25869 - 25958 [(pose~~~(H_whiskerR_wlrnat_x_y...] 0.007 secs (0.007u,0.s)
Chars 25963 - 26052 [(pose~~~(H_whiskerR_wlrnat_x_z...] 0.009 secs (0.009u,0.s)
Chars 26057 - 26088 [(apply~moveL_pV~in~wlrnat_V_x_y).] 0.008 secs (0.008u,0.s)
Chars 26093 - 26147 [(apply~(concat~H_whiskerR_wlrn...] 0.009 secs (0.009u,0.s)
Chars 26152 - 26193 [(apply~moveL_Vp,~moveL_pV~in~w...] 0.01 secs (0.01u,0.s)
Chars 26198 - 26229 [(apply~symmetry~in~wlrnat_V_x_y).] 0.011 secs (0.011u,0.s)
Chars 26234 - 26256 [(destruct~wlrnat_V_x_y).] 0.051 secs (0.048u,0.002s)
Chars 26261 - 26280 [clear~wlrnat_V_x_y.] 0.011 secs (0.011u,0.s)
Chars 26285 - 26316 [(apply~moveL_pV~in~wlrnat_V_x_z).] 0.012 secs (0.012u,0.s)
Chars 26321 - 26375 [(apply~(concat~H_whiskerR_wlrn...] 0.012 secs (0.012u,0.s)
Chars 26380 - 26421 [(apply~moveL_Vp,~moveL_pV~in~w...] 0.014 secs (0.014u,0.s)
Chars 26426 - 26457 [(apply~symmetry~in~wlrnat_V_x_z).] 0.018 secs (0.018u,0.s)
Chars 26462 - 26484 [(destruct~wlrnat_V_x_z).] 0.087 secs (0.083u,0.003s)
Chars 26489 - 26508 [clear~wlrnat_V_x_z.] 0.015 secs (0.015u,0.s)
Chars 26513 - 26563 [clear~H_whiskerR_wlrnat_x_y~H_...] 0.014 secs (0.014u,0.s)
Chars 26568 - 26616 [(destruct~wrpp_yz0,~wlpp_yz0,~...] 0.111 secs (0.111u,0.s)
Chars 26621 - 26663 [clear~wrpp_yz0~wlpp_yz0~wrpp_y...] 0.005 secs (0.005u,0.s)
Chars 26668 - 26697 [revert~wlrnat_y_x~wlrnat_z_x.] 0.005 secs (0.005u,0.s)
Chars 26702 - 26724 [revert~wrx0~ehlnat_x0.] 0.006 secs (0.006u,0.s)
Chars 26729 - 26763 [snrapply~equiv_path_ind_rlucan...] 0.023 secs (0.023u,0.s)
Chars 26768 - 26790 [revert~wrx1~ehlnat_x1.] 0.01 secs (0.01u,0.s)
Chars 26795 - 26829 [snrapply~equiv_path_ind_rlucan...] 0.022 secs (0.021u,0.s)
Chars 26834 - 26856 [revert~wrx2~ehlnat_x2.] 0.005 secs (0.005u,0.s)
Chars 26861 - 26895 [snrapply~equiv_path_ind_rlucan...] 0.024 secs (0.024u,0.s)
Chars 26900 - 26922 [revert~wly0~ehrnat_y0.] 0.006 secs (0.005u,0.s)
Chars 26927 - 26961 [snrapply~equiv_path_ind_rlucan...] 0.025 secs (0.025u,0.s)
Chars 26966 - 26988 [revert~wly1~ehrnat_y1.] 0.006 secs (0.006u,0.s)
Chars 26993 - 27027 [snrapply~equiv_path_ind_rlucan...] 0.025 secs (0.025u,0.s)
Chars 27032 - 27054 [revert~wlz0~ehrnat_z0.] 0.006 secs (0.006u,0.s)
Chars 27059 - 27093 [snrapply~equiv_path_ind_rlucan...] 0.027 secs (0.026u,0.s)
Chars 27098 - 27120 [revert~wlz1~ehrnat_z1.] 0.006 secs (0.006u,0.s)
Chars 27125 - 27159 [snrapply~equiv_path_ind_rlucan...] 0.022 secs (0.021u,0.001s)
Chars 27164 - 27196 [(destruct~wry0,~wry1,~wrz0,~wr...] 0.127 secs (0.126u,0.s)
Chars 27201 - 27227 [clear~wry0~wry1~wrz0~wrz1.] 0.005 secs (0.005u,0.s)
Chars 27232 - 27244 [revert~wlx0.] 0.004 secs (0.004u,0.s)
Chars 27249 - 27283 [snrapply~equiv_path_ind_lrucan...] 0.024 secs (0.024u,0.s)
Chars 27288 - 27300 [revert~wlx1.] 0.005 secs (0.005u,0.s)
Chars 27305 - 27339 [snrapply~equiv_path_ind_lrucan...] 0.032 secs (0.031u,0.001s)
Chars 20942 - 21003 [refine~(isequiv_commsq'~f~(O_f...] 40.156 secs (0.007u,0.028s)
Chars 21010 - 21029 [(apply~to_O_natural).] 0.001 secs (0.001u,0.s)
Chars 20942 - 21003 [refine~(isequiv_commsq'~f~(O_f...] 0. secs (0.u,0.s)
Chars 21010 - 21029 [(apply~to_O_natural).] 0. secs (0.u,0.s)
Chars 21034 - 21042 [Defined.] 0. secs (0.u,0.s)
Chars 21180 - 21335 [Definition~equiv_O_inverts~{A~...] 0.002 secs (0.001u,0.s)
Chars 21341 - 21471 [Definition~isequiv_O_rec_O_inv...] 0.001 secs (0.001u,0.s)
Chars 21476 - 21482 [Proof.] 0. secs (0.u,0.s)
Chars 27344 - 27358 [(destruct~wlx2).] 0.033 secs (0.033u,0.s)
Chars 27363 - 27374 [clear~wlx2.] 0.004 secs (0.004u,0.s)
Chars 27379 - 27391 [reflexivity.] 0.007 secs (0.007u,0.s)
Chars 25529 - 25574 [(apply~moveR_Vp~in~H_ehrnat_yz...] 0.004 secs (0.004u,0.s)
Chars 25579 - 25615 [(destruct~H_ehrnat_yz0,~H_ehrn...] 0.004 secs (0.004u,0.s)
Chars 25620 - 25652 [clear~H_ehrnat_yz0~H_ehrnat_yz1.] 0.005 secs (0.005u,0.s)
Chars 25657 - 25704 [(apply~moveR_Vp~in~H_wlrnat_x_...] 0.004 secs (0.004u,0.s)
Chars 25709 - 25747 [(destruct~H_wlrnat_x_yz,~H_wlr...] 0.004 secs (0.004u,0.s)
Chars 25752 - 25786 [clear~H_wlrnat_x_yz~H_wlrnat_y...] 0.005 secs (0.005u,0.s)
Chars 25791 - 25829 [(destruct~a01,~b01,~c01,~d01,~...] 0.004 secs (0.004u,0.s)
Chars 25834 - 25864 [clear~a01~b01~c01~d01~e01~f01.] 0.004 secs (0.004u,0.s)
Chars 25869 - 25958 [(pose~~~(H_whiskerR_wlrnat_x_y...] 0.004 secs (0.004u,0.s)
Chars 25963 - 26052 [(pose~~~(H_whiskerR_wlrnat_x_z...] 0.005 secs (0.005u,0.s)
Chars 26057 - 26088 [(apply~moveL_pV~in~wlrnat_V_x_y).] 0.005 secs (0.005u,0.s)
Chars 26093 - 26147 [(apply~(concat~H_whiskerR_wlrn...] 0.009 secs (0.008u,0.001s)
Chars 26152 - 26193 [(apply~moveL_Vp,~moveL_pV~in~w...] 0.005 secs (0.005u,0.s)
Chars 26198 - 26229 [(apply~symmetry~in~wlrnat_V_x_y).] 0.006 secs (0.005u,0.s)
Chars 26234 - 26256 [(destruct~wlrnat_V_x_y).] 0.005 secs (0.005u,0.s)
Chars 26261 - 26280 [clear~wlrnat_V_x_y.] 0.01 secs (0.01u,0.s)
Chars 26285 - 26316 [(apply~moveL_pV~in~wlrnat_V_x_z).] 0.009 secs (0.009u,0.s)
Chars 26321 - 26375 [(apply~(concat~H_whiskerR_wlrn...] 0.009 secs (0.008u,0.s)
Chars 26380 - 26421 [(apply~moveL_Vp,~moveL_pV~in~w...] 0.01 secs (0.009u,0.s)
Chars 26426 - 26457 [(apply~symmetry~in~wlrnat_V_x_z).] 0.009 secs (0.009u,0.s)
Chars 26462 - 26484 [(destruct~wlrnat_V_x_z).] 0.009 secs (0.009u,0.s)
Chars 26489 - 26508 [clear~wlrnat_V_x_z.] 0.013 secs (0.013u,0.s)
Chars 26513 - 26563 [clear~H_whiskerR_wlrnat_x_y~H_...] 0.012 secs (0.012u,0.s)
Chars 26568 - 26616 [(destruct~wrpp_yz0,~wlpp_yz0,~...] 0.005 secs (0.005u,0.s)
Chars 26621 - 26663 [clear~wrpp_yz0~wlpp_yz0~wrpp_y...] 0.005 secs (0.005u,0.s)
Chars 26668 - 26697 [revert~wlrnat_y_x~wlrnat_z_x.] 0.004 secs (0.004u,0.s)
Chars 26702 - 26724 [revert~wrx0~ehlnat_x0.] 0.021 secs (0.018u,0.003s)
Chars 26729 - 26763 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 26768 - 26790 [revert~wrx1~ehlnat_x1.] 0.005 secs (0.005u,0.s)
Chars 26795 - 26829 [snrapply~equiv_path_ind_rlucan...] 0.004 secs (0.004u,0.s)
Chars 26834 - 26856 [revert~wrx2~ehlnat_x2.] 0.005 secs (0.005u,0.s)
Chars 26861 - 26895 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 26900 - 26922 [revert~wly0~ehrnat_y0.] 0.005 secs (0.005u,0.s)
Chars 26927 - 26961 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 26966 - 26988 [revert~wly1~ehrnat_y1.] 0.005 secs (0.005u,0.s)
Chars 26993 - 27027 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 27032 - 27054 [revert~wlz0~ehrnat_z0.] 0.005 secs (0.004u,0.s)
Chars 27059 - 27093 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 27098 - 27120 [revert~wlz1~ehrnat_z1.] 0.005 secs (0.005u,0.s)
Chars 27125 - 27159 [snrapply~equiv_path_ind_rlucan...] 0.005 secs (0.005u,0.s)
Chars 27164 - 27196 [(destruct~wry0,~wry1,~wrz0,~wr...] 0.005 secs (0.005u,0.s)
Chars 27201 - 27227 [clear~wry0~wry1~wrz0~wrz1.] 0.004 secs (0.004u,0.s)
Chars 27232 - 27244 [revert~wlx0.] 0.004 secs (0.004u,0.s)
Chars 27249 - 27283 [snrapply~equiv_path_ind_lrucan...] 0.003 secs (0.003u,0.s)
Chars 27288 - 27300 [revert~wlx1.] 0.003 secs (0.003u,0.s)
Chars 27305 - 27339 [snrapply~equiv_path_ind_lrucan...] 0.004 secs (0.004u,0.s)
Chars 27344 - 27358 [(destruct~wlx2).] 0.004 secs (0.004u,0.s)
Chars 27363 - 27374 [clear~wlx2.] 0.003 secs (0.003u,0.s)
Chars 27379 - 27391 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 27394 - 27402 [Defined.] 0.251 secs (0.239u,0.011s)
Chars 27404 - 27422 [End~wlrnat_V_p_pp.] 0.77 secs (0.705u,0.065s)
Chars 27424 - 27678 [Definition~wlrnat_V_p_pp~{X}~{...] 0.178 secs (0.167u,0.01s)
Chars 27679 - 27685 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutFRACTRAN_REG_FRACTRAN_HALTING
     : FRACTRAN_REG_HALTING ⪯ Halt_FRACTRAN
Chars 21489 - 21513 [(apply~isequiv_O_inverts).] 40.15 secs (0.002u,0.027s)
Chars 21520 - 21582 [(nrefine~(cancelR_isequiv~(O_f...] 0.005 secs (0.004u,0.001s)
Chars 21589 - 21704 [nrefine~~(isequiv_homotopic~(O...] 0.005 secs (0.004u,0.s)
Chars 21711 - 21821 [refine~~(isequiv_homotopic~(O_...] 0.004 secs (0.004u,0.s)
Chars 21489 - 21513 [(apply~isequiv_O_inverts).] 0. secs (0.u,0.s)
Chars 21520 - 21582 [(nrefine~(cancelR_isequiv~(O_f...] 0. secs (0.u,0.s)
Chars 21589 - 21704 [nrefine~~(isequiv_homotopic~(O...] 0. secs (0.u,0.s)
Chars 21711 - 21821 [refine~~(isequiv_homotopic~(O_...] 0. secs (0.u,0.s)
Chars 21826 - 21834 [Defined.] 0.001 secs (0.001u,0.s)
Chars 21840 - 22008 [Definition~equiv_O_rec_O_inver...] 0.002 secs (0.002u,0.s)
Chars 22365 - 22577 [Definition~ooextendable_O_inve...] 0.001 secs (0.u,0.s)
Chars 22582 - 22588 [Proof.] 0. secs (0.u,0.s)
Chars 27688 - 27699 [revert~u~q.] 40.159 secs (0.011u,0.031s)
Chars 27702 - 27751 [snrapply~(equiv_path_ind~(equi...] 0.05 secs (0.04u,0.009s)
Chars 27754 - 27771 [by~destruct~p,~r.] 0.391 secs (0.352u,0.039s)
Chars 27688 - 27699 [revert~u~q.] 0.006 secs (0.006u,0.s)
Chars 27702 - 27751 [snrapply~(equiv_path_ind~(equi...] 0.007 secs (0.007u,0.s)
Chars 27754 - 27771 [by~destruct~p,~r.] 0.007 secs (0.007u,0.s)
Chars 27772 - 27780 [Defined.] 0.243 secs (0.239u,0.003s)
Chars 28426 - 29219 [Ltac~~apply_P~ty~P~:=~~~lazyma...] 0. secs (0.u,0.s)
Chars 29221 - 29351 [Ltac~~make_P_and_evar~ty~:=~le...] 0. secs (0.u,0.s)
Chars 29353 - 29455 [Ltac~~generalize_goal~X~:=~~~m...] 0. secs (0.u,0.s)
Chars 29501 - 29681 [#[local]~Lemma~equiv_helper~{X...] 0.003 secs (0.003u,0.s)
Chars 29682 - 29688 [Proof.] 0. secs (0.u,0.s)
Chars 29691 - 29730 [snrapply~(_~oE~equiv_path_inve...] 2.179 secs (-11.453u,-2.107s)
Chars 22595 - 22662 [refine~(cancelL_ooextendable@{...] 40.136 secs (0.002u,0.028s)
Chars 22669 - 22708 [1:~exact~(extendable_to_O'@{i~...] 0.001 secs (0.u,0.s)
Chars 22715 - 22776 [refine~(ooextendable_homotopic...] 0.002 secs (0.001u,0.s)
Chars 22783 - 22804 [1:~(apply~to_O_natural).] 0.001 secs (0.001u,0.s)
Chars 22811 - 22870 [refine~(ooextendable_compose~_...] 0.002 secs (0.002u,0.s)
Chars 22877 - 22878 [-] 0. secs (0.u,0.s)
Chars 22879 - 22906 [srapply~ooextendable_equiv.] 0.003 secs (0.002u,0.s)
Chars 22913 - 22914 [-] 0. secs (0.u,0.s)
Chars 22915 - 22952 [exact~(extendable_to_O'@{i~a~z...] 0.001 secs (0.001u,0.s)
Chars 22595 - 22662 [refine~(cancelL_ooextendable@{...] 0. secs (0.u,0.s)
Chars 22669 - 22708 [1:~exact~(extendable_to_O'@{i~...] 0. secs (0.u,0.s)
Chars 22715 - 22776 [refine~(ooextendable_homotopic...] 0. secs (0.u,0.s)
Chars 22783 - 22804 [1:~(apply~to_O_natural).] 0. secs (0.u,0.s)
Chars 22811 - 22870 [refine~(ooextendable_compose~_...] 0. secs (0.u,0.s)
Chars 22879 - 22906 [srapply~ooextendable_equiv.] 0. secs (0.u,0.s)
Chars 22915 - 22952 [exact~(extendable_to_O'@{i~a~z...] 0. secs (0.u,0.s)
Chars 22957 - 22965 [Defined.] 0.001 secs (0.001u,0.s)
Chars 23009 - 23189 [Definition~isequiv_precompose_...] 0.002 secs (0.002u,0.s)
Chars 23194 - 23200 [Proof.] 0. secs (0.u,0.s)
Chars 29691 - 29730 [snrapply~(_~oE~equiv_path_inve...] 40.061 secs (0.004u,0.027s)
Chars 29733 - 29770 [snrapply~(_~oE~equiv_moveR_pV~...] 0.004 secs (0.004u,0.s)
Chars 29773 - 29810 [snrapply~(_~oE~equiv_moveR_Mp~...] 0.004 secs (0.004u,0.s)
Chars 29813 - 29848 [snrapply~(_~oE~equiv_concat_l~...] 0.004 secs (0.003u,0.s)
Chars 29851 - 29910 [3:~exact~(moveL_Mp~_~_~_~(move...] 0.003 secs (0.002u,0.001s)
Chars 29913 - 29945 [snrapply~(equiv_moveR_pM~_~_~_).] 0.002 secs (0.002u,0.s)
Chars 29691 - 29730 [snrapply~(_~oE~equiv_path_inve...] 0.001 secs (0.001u,0.s)
Chars 29733 - 29770 [snrapply~(_~oE~equiv_moveR_pV~...] 0.001 secs (0.001u,0.s)
Chars 29773 - 29810 [snrapply~(_~oE~equiv_moveR_Mp~...] 0.001 secs (0.u,0.s)
Chars 29813 - 29848 [snrapply~(_~oE~equiv_concat_l~...] 0.001 secs (0.001u,0.s)
Chars 29851 - 29910 [3:~exact~(moveL_Mp~_~_~_~(move...] 0. secs (0.u,0.s)
Chars 29913 - 29945 [snrapply~(equiv_moveR_pM~_~_~_).] 0. secs (0.u,0.s)
Chars 29946 - 29954 [Defined.] 0.009 secs (0.008u,0.s)
Chars 30016 - 30245 [Definition~equiv_path_ind_move...] 0.003 secs (0.003u,0.s)
Chars 30246 - 30252 [Proof.] 0. secs (0.u,0.s)
MPCP_undec
     : undecidable MPCP
Can not derive computable instance from computableTime for higher-order-function
(forallb (A:=X))
Can not derive computable instance from computableTime for higher-order-function
(forallb (A:=X))
Can not derive computable instance from computableTime for higher-order-function
(forallb (A:=X))
Chars 23207 - 23244 [srapply~(equiv_extendable_iseq...] 40.12 secs (0.003u,0.028s)
Chars 23251 - 23288 [exact~(ooextendable_O_inverts~...] 0.002 secs (0.002u,0.s)
Chars 23207 - 23244 [srapply~(equiv_extendable_iseq...] 0. secs (0.u,0.s)
Chars 23251 - 23288 [exact~(ooextendable_O_inverts~...] 0. secs (0.u,0.s)
Chars 23293 - 23301 [Defined.] 0. secs (0.u,0.s)
Chars 23512 - 23825 [Definition~O_inverts_from_exte...] 0.001 secs (0.001u,0.s)
Chars 23830 - 23836 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 30255 - 30316 [exact~(equiv_path_ind~(fun~q~=...] 40.144 secs (0.003u,0.028s)
Chars 30255 - 30316 [exact~(equiv_path_ind~(fun~q~=...] 0. secs (0.u,0.s)
Chars 30317 - 30325 [Defined.] 0.001 secs (0.001u,0.s)
MPCPb_undec
     : undecidable MPCPb
Chars 30389 - 36211 [Definition~eh_V_p_pp_gen~{X~:~...] 2.484 secs (2.414u,0.065s)
Chars 36212 - 36218 [Proof.] 0. secs (0.u,0.s)
CM1_HALT_undec
     : undecidable CM1_HALT
Chars 23843 - 23870 [srapply~isequiv_adjointify.] 40.134 secs (0.002u,0.027s)
Chars 23877 - 23878 [-] 0. secs (0.u,0.s)
Chars 23879 - 23922 [exact~(O_rec~(fst~(e~(O~A)~_)~...] 0.005 secs (0.002u,0.001s)
Chars 23929 - 23930 [-] 0. secs (0.u,0.s)
Chars 23931 - 23950 [srapply~O_indpaths.] 0.007 secs (0.005u,0.001s)
Chars 23951 - 23960 [(intros~b).] 0.001 secs (0.001u,0.s)
Chars 23969 - 23988 [(rewrite~O_rec_beta).] 0.003 secs (0.003u,0.s)
Chars 23997 - 24049 [(pose~proof~(fun~h~k~=>~fst~(s...] 0.004 secs (0.004u,0.s)
Chars 24050 - 24060 [(cbn~in~e1).] 0.001 secs (0.001u,0.s)
Chars 24069 - 24154 [refine~~((e1~(fun~y~=>~O_funct...] 0.005 secs (0.004u,0.s)
Chars 24163 - 24172 [(intros~a).] 0.001 secs (0.001u,0.s)
Chars 24181 - 24230 [(rewrite~((fst~(e~(O~A)~(O_inO...] 0.008 secs (0.004u,0.001s)
Chars 24239 - 24258 [(apply~to_O_natural).] 0.001 secs (0.001u,0.s)
Chars 24265 - 24266 [-] 0. secs (0.u,0.s)
Chars 24267 - 24286 [srapply~O_indpaths.] 0.01 secs (0.007u,0.s)
Chars 24287 - 24296 [(intros~a).] 0.03 secs (0.02u,0.009s)
Chars 24305 - 24338 [(rewrite~to_O_natural,~O_rec_b...] 0.004 secs (0.002u,0.001s)
Chars 24347 - 24394 [exact~((fst~(e~(O~A)~(O_inO~A)...] 0.002 secs (0.002u,0.s)
Chars 23843 - 23870 [srapply~isequiv_adjointify.] 0. secs (0.u,0.s)
Chars 23879 - 23922 [exact~(O_rec~(fst~(e~(O~A)~_)~...] 0. secs (0.u,0.s)
Chars 23931 - 23950 [srapply~O_indpaths.] 0. secs (0.u,0.s)
Chars 23951 - 23960 [(intros~b).] 0. secs (0.u,0.s)
Chars 23969 - 23988 [(rewrite~O_rec_beta).] 0. secs (0.u,0.s)
Chars 23997 - 24049 [(pose~proof~(fun~h~k~=>~fst~(s...] 0. secs (0.u,0.s)
Chars 24050 - 24060 [(cbn~in~e1).] 0. secs (0.u,0.s)
Chars 24069 - 24154 [refine~~((e1~(fun~y~=>~O_funct...] 0. secs (0.u,0.s)
Chars 24163 - 24172 [(intros~a).] 0. secs (0.u,0.s)
Chars 24181 - 24230 [(rewrite~((fst~(e~(O~A)~(O_inO...] 0. secs (0.u,0.s)
Chars 24239 - 24258 [(apply~to_O_natural).] 0. secs (0.u,0.s)
Chars 24267 - 24286 [srapply~O_indpaths.] 0. secs (0.u,0.s)
Chars 24287 - 24296 [(intros~a).] 0. secs (0.u,0.s)
Chars 24305 - 24338 [(rewrite~to_O_natural,~O_rec_b...] 0. secs (0.u,0.s)
Chars 24347 - 24394 [exact~((fst~(e~(O~A)~(O_inO~A)...] 0. secs (0.u,0.s)
Chars 24399 - 24407 [Defined.] 0.005 secs (0.005u,0.s)
Chars 24413 - 24486 [#[local]Hint~Extern~4~~=>~(pro...] 0. secs (0.u,0.s)
Chars 24590 - 24784 [Definition~O_inverts_from_iseq...] 0.001 secs (0.001u,0.s)
Chars 24789 - 24795 [Proof.] 0. secs (0.u,0.s)
PCP_undec
     : undecidable PCP
Chars 36329 - 36388 [(destruct~H_ehrnat_p1_yz0,~H_e...] 40.85 secs (0.6u,0.105s)
Chars 36766 - 36781 [(revert_until~a).] 0.308 secs (0.306u,0.002s)
Chars 36784 - 36804 [(generalize_goal~lem).] 3.318 secs (3.266u,0.046s)
Chars 36807 - 36808 [{] 0. secs (0.u,0.s)
Chars 36809 - 36828 [(intros~P~H;~intros).] 0.043 secs (0.043u,0.s)
Chars 36832 - 36864 [(destruct~wry0,~wry1,~wrz0,~wr...] 0.174 secs (0.172u,0.001s)
Chars 36867 - 36915 [(destruct~wrpp_yz0,~wlpp_yz0,~...] 0.076 secs (0.073u,0.002s)
Chars 36919 - 36952 [revert~wlrnat_x_yz~H_wlrnat_x_yz.] 0.014 secs (0.014u,0.s)
Chars 36955 - 36988 [snrapply~equiv_path_ind_moveL_Mp.] 0.075 secs (0.075u,0.s)
Chars 36992 - 37023 [revert~wlrnat_x_y~wlrnat_V_x_y.] 0.018 secs (0.018u,0.s)
Chars 37026 - 37071 [snrapply~(equiv_path_ind~(equi...] 0.085 secs (0.085u,0.s)
Chars 37074 - 37105 [revert~wlrnat_x_z~wlrnat_V_x_z.] 0.023 secs (0.023u,0.s)
Chars 37108 - 37153 [snrapply~(equiv_path_ind~(equi...] 0.097 secs (0.097u,0.s)
Chars 37157 - 37186 [revert~ulnat_x0~ehlnat_1p_x0.] 0.026 secs (0.026u,0.s)
Chars 37189 - 37223 [snrapply~equiv_path_ind_rlucan...] 0.093 secs (0.093u,0.s)
Chars 37226 - 37255 [revert~ulnat_x1~ehlnat_1p_x1.] 0.026 secs (0.026u,0.s)
Chars 37258 - 37292 [snrapply~equiv_path_ind_rlucan...] 0.093 secs (0.09u,0.002s)
Chars 37295 - 37324 [revert~ulnat_x2~ehlnat_1p_x2.] 0.025 secs (0.025u,0.s)
Chars 37327 - 37361 [snrapply~equiv_path_ind_rlucan...] 0.093 secs (0.093u,0.s)
Chars 37365 - 37394 [revert~urnat_yz0~H_urnat_yz0.] 0.027 secs (0.027u,0.s)
Chars 37397 - 37430 [snrapply~equiv_path_ind_moveL_Mp.] 0.106 secs (0.105u,0.s)
Chars 37433 - 37462 [revert~urnat_yz1~H_urnat_yz1.] 0.027 secs (0.027u,0.s)
Chars 37465 - 37498 [snrapply~equiv_path_ind_moveL_Mp.] 0.116 secs (0.114u,0.001s)
Chars 37501 - 37534 [revert~wlrnat_yz_x~H_wlrnat_yz_x.] 0.034 secs (0.032u,0.001s)
Chars 37537 - 37570 [snrapply~equiv_path_ind_moveL_Mp.] 0.121 secs (0.12u,0.s)
Chars 37573 - 37604 [revert~ehrnat_yz0~H_ehrnat_yz0.] 0.031 secs (0.031u,0.s)
Chars 37607 - 37640 [snrapply~equiv_path_ind_moveL_Mp.] 0.129 secs (0.129u,0.s)
Chars 37643 - 37674 [revert~ehrnat_yz1~H_ehrnat_yz1.] 0.035 secs (0.035u,0.s)
Chars 37677 - 37710 [snrapply~equiv_path_ind_moveL_Mp.] 0.138 secs (0.137u,0.s)
Chars 37713 - 37742 [revert~ulnat_yz1~H_ulnat_yz1.] 0.038 secs (0.038u,0.s)
Chars 37745 - 37778 [snrapply~equiv_path_ind_moveL_Mp.] 0.144 secs (0.143u,0.s)
Chars 37781 - 37810 [revert~ulnat_yz0~H_ulnat_yz0.] 0.039 secs (0.038u,0.s)
Chars 37813 - 37846 [snrapply~equiv_path_ind_moveL_Mp.] 0.152 secs (0.15u,0.002s)
Chars 37850 - 37879 [revert~urnat_y0~ehrnat_p1_y0.] 0.042 secs (0.041u,0.s)
Chars 37882 - 37916 [snrapply~equiv_path_ind_rlucan...] 0.135 secs (0.133u,0.001s)
Chars 37919 - 37948 [revert~urnat_y1~ehrnat_p1_y1.] 0.039 secs (0.039u,0.s)
Chars 37951 - 37985 [snrapply~equiv_path_ind_rlucan...] 0.14 secs (0.138u,0.001s)
Chars 37988 - 38017 [revert~urnat_z0~ehrnat_p1_z0.] 0.042 secs (0.042u,0.s)
Chars 38020 - 38054 [snrapply~equiv_path_ind_rlucan...] 0.136 secs (0.136u,0.s)
Chars 38057 - 38086 [revert~urnat_z1~ehrnat_p1_z1.] 0.046 secs (0.045u,0.s)
Chars 38089 - 38123 [snrapply~equiv_path_ind_rlucan...] 0.14 secs (0.14u,0.s)
Chars 38127 - 38146 [revert~x0~urnat_x0.] 0.043 secs (0.043u,0.s)
Chars 38149 - 38183 [snrapply~equiv_path_ind_rlucan...] 0.143 secs (0.141u,0.001s)
Chars 38186 - 38205 [revert~x1~urnat_x1.] 0.045 secs (0.045u,0.s)
Chars 38208 - 38242 [snrapply~equiv_path_ind_rlucan...] 0.141 secs (0.14u,0.s)
Chars 38245 - 38264 [revert~x2~urnat_x2.] 0.042 secs (0.042u,0.s)
Chars 38267 - 38301 [snrapply~equiv_path_ind_rlucan...] 0.141 secs (0.141u,0.s)
Chars 38304 - 38323 [revert~y0~ulnat_y0.] 0.046 secs (0.043u,0.003s)
Chars 38326 - 38360 [snrapply~equiv_path_ind_rlucan...] 0.139 secs (0.139u,0.s)
Chars 38363 - 38382 [revert~y1~ulnat_y1.] 0.042 secs (0.042u,0.s)
Chars 38385 - 38419 [snrapply~equiv_path_ind_rlucan...] 0.141 secs (0.141u,0.s)
Chars 38422 - 38441 [revert~z0~ulnat_z0.] 0.047 secs (0.047u,0.s)
Chars 38444 - 38478 [snrapply~equiv_path_ind_rlucan...] 0.144 secs (0.14u,0.003s)
Chars 38481 - 38500 [revert~z1~ulnat_z1.] 0.042 secs (0.042u,0.s)
Chars 38503 - 38537 [snrapply~equiv_path_ind_rlucan...] 0.148 secs (0.146u,0.001s)
Chars 38541 - 38559 [revert~wlrnat_y_x.] 0.041 secs (0.041u,0.s)
Chars 38592 - 38614 [revert~wrx0~ehlnat_x0.] 0.044 secs (0.043u,0.s)
Chars 38617 - 38651 [snrapply~equiv_path_ind_rlucan...] 0.139 secs (0.139u,0.s)
Chars 38654 - 38672 [revert~wlrnat_z_x.] 0.045 secs (0.044u,0.s)
Chars 38705 - 38727 [revert~wrx1~ehlnat_x1.] 0.041 secs (0.041u,0.s)
Chars 38730 - 38764 [snrapply~equiv_path_ind_rlucan...] 0.144 secs (0.144u,0.s)
Chars 38767 - 38789 [revert~wrx2~ehlnat_x2.] 0.046 secs (0.045u,0.001s)
Chars 38792 - 38826 [snrapply~equiv_path_ind_rlucan...] 0.14 secs (0.139u,0.s)
Chars 38829 - 38851 [revert~wly0~ehrnat_y0.] 0.041 secs (0.041u,0.s)
Chars 38854 - 38888 [snrapply~equiv_path_ind_rlucan...] 0.142 secs (0.14u,0.001s)
Chars 38891 - 38913 [revert~wly1~ehrnat_y1.] 0.046 secs (0.046u,0.s)
Chars 38916 - 38950 [snrapply~equiv_path_ind_rlucan...] 0.157 secs (0.157u,0.s)
Chars 38953 - 38975 [revert~wlz0~ehrnat_z0.] 0.041 secs (0.041u,0.s)
Chars 38978 - 39012 [snrapply~equiv_path_ind_rlucan...] 0.158 secs (0.156u,0.001s)
Chars 39015 - 39037 [revert~wlz1~ehrnat_z1.] 0.041 secs (0.041u,0.s)
Chars 39040 - 39074 [snrapply~equiv_path_ind_rlucan...] 0.158 secs (0.157u,0.s)
Chars 39078 - 39090 [revert~wlx1.] 0.043 secs (0.042u,0.s)
Chars 39093 - 39127 [snrapply~equiv_path_ind_lrucan...] 0.252 secs (0.238u,0.014s)
Chars 39130 - 39142 [revert~wlx0.] 0.049 secs (0.047u,0.002s)
Chars 39145 - 39179 [snrapply~equiv_path_ind_lrucan...] 0.2 secs (0.198u,0.001s)
Chars 39183 - 39197 [(destruct~wlx2).] 0.203 secs (0.199u,0.003s)
Chars 39277 - 39285 [exact~H.] 0.077 secs (0.073u,0.002s)
Chars 39286 - 39287 [}] 0. secs (0.u,0.s)
Chars 39290 - 39300 [(apply~lem).] 0.737 secs (0.729u,0.006s)
Chars 39303 - 39315 [reflexivity.] 0.56 secs (0.532u,0.027s)
Chars 36329 - 36388 [(destruct~H_ehrnat_p1_yz0,~H_e...] 0.034 secs (0.034u,0.s)
Chars 36766 - 36781 [(revert_until~a).] 0.032 secs (0.032u,0.s)
Chars 36784 - 36804 [(generalize_goal~lem).] 0.068 secs (0.063u,0.004s)
Chars 36809 - 36828 [(intros~P~H;~intros).] 0.03 secs (0.03u,0.s)
Chars 36832 - 36864 [(destruct~wry0,~wry1,~wrz0,~wr...] 0.015 secs (0.015u,0.s)
Chars 36867 - 36915 [(destruct~wrpp_yz0,~wlpp_yz0,~...] 0.014 secs (0.014u,0.s)
Chars 36919 - 36952 [revert~wlrnat_x_yz~H_wlrnat_x_yz.] 0.014 secs (0.014u,0.s)
Chars 36955 - 36988 [snrapply~equiv_path_ind_moveL_Mp.] 0.04 secs (0.033u,0.006s)
Chars 36992 - 37023 [revert~wlrnat_x_y~wlrnat_V_x_y.] 0.018 secs (0.018u,0.s)
Chars 37026 - 37071 [snrapply~(equiv_path_ind~(equi...] 0.018 secs (0.018u,0.s)
Chars 37074 - 37105 [revert~wlrnat_x_z~wlrnat_V_x_z.] 0.02 secs (0.02u,0.s)
Chars 37108 - 37153 [snrapply~(equiv_path_ind~(equi...] 0.02 secs (0.02u,0.s)
Chars 37157 - 37186 [revert~ulnat_x0~ehlnat_1p_x0.] 0.022 secs (0.022u,0.s)
Chars 37189 - 37223 [snrapply~equiv_path_ind_rlucan...] 0.05 secs (0.049u,0.s)
Chars 37226 - 37255 [revert~ulnat_x1~ehlnat_1p_x1.] 0.024 secs (0.024u,0.s)
Chars 37258 - 37292 [snrapply~equiv_path_ind_rlucan...] 0.024 secs (0.024u,0.s)
Chars 37295 - 37324 [revert~ulnat_x2~ehlnat_1p_x2.] 0.025 secs (0.025u,0.s)
Chars 37327 - 37361 [snrapply~equiv_path_ind_rlucan...] 0.024 secs (0.024u,0.s)
Chars 37365 - 37394 [revert~urnat_yz0~H_urnat_yz0.] 0.039 secs (0.035u,0.003s)
Chars 37397 - 37430 [snrapply~equiv_path_ind_moveL_Mp.] 0.024 secs (0.024u,0.s)
Chars 37433 - 37462 [revert~urnat_yz1~H_urnat_yz1.] 0.026 secs (0.026u,0.s)
Chars 37465 - 37498 [snrapply~equiv_path_ind_moveL_Mp.] 0.026 secs (0.026u,0.s)
Chars 37501 - 37534 [revert~wlrnat_yz_x~H_wlrnat_yz_x.] 0.027 secs (0.027u,0.s)
Chars 37537 - 37570 [snrapply~equiv_path_ind_moveL_Mp.] 0.04 secs (0.038u,0.001s)
Chars 37573 - 37604 [revert~ehrnat_yz0~H_ehrnat_yz0.] 0.031 secs (0.031u,0.s)
Chars 37607 - 37640 [snrapply~equiv_path_ind_moveL_Mp.] 0.031 secs (0.031u,0.s)
Chars 37643 - 37674 [revert~ehrnat_yz1~H_ehrnat_yz1.] 0.032 secs (0.032u,0.s)
Chars 37677 - 37710 [snrapply~equiv_path_ind_moveL_Mp.] 0.049 secs (0.045u,0.003s)
Chars 37713 - 37742 [revert~ulnat_yz1~H_ulnat_yz1.] 0.035 secs (0.034u,0.s)
Chars 37745 - 37778 [snrapply~equiv_path_ind_moveL_Mp.] 0.035 secs (0.035u,0.s)
Chars 37781 - 37810 [revert~ulnat_yz0~H_ulnat_yz0.] 0.038 secs (0.038u,0.s)
Chars 37813 - 37846 [snrapply~equiv_path_ind_moveL_Mp.] 0.037 secs (0.037u,0.s)
Chars 37850 - 37879 [revert~urnat_y0~ehrnat_p1_y0.] 0.038 secs (0.038u,0.s)
Chars 37882 - 37916 [snrapply~equiv_path_ind_rlucan...] 0.049 secs (0.049u,0.s)
Chars 37919 - 37948 [revert~urnat_y1~ehrnat_p1_y1.] 0.038 secs (0.038u,0.s)
Chars 37951 - 37985 [snrapply~equiv_path_ind_rlucan...] 0.039 secs (0.039u,0.s)
Chars 37988 - 38017 [revert~urnat_z0~ehrnat_p1_z0.] 0.042 secs (0.042u,0.s)
Chars 38020 - 38054 [snrapply~equiv_path_ind_rlucan...] 0.039 secs (0.039u,0.s)
Chars 38057 - 38086 [revert~urnat_z1~ehrnat_p1_z1.] 0.039 secs (0.039u,0.s)
Chars 38089 - 38123 [snrapply~equiv_path_ind_rlucan...] 0.053 secs (0.05u,0.002s)
Chars 38127 - 38146 [revert~x0~urnat_x0.] 0.04 secs (0.04u,0.s)
Chars 38149 - 38183 [snrapply~equiv_path_ind_rlucan...] 0.039 secs (0.039u,0.s)
Chars 38186 - 38205 [revert~x1~urnat_x1.] 0.043 secs (0.043u,0.s)
Chars 38208 - 38242 [snrapply~equiv_path_ind_rlucan...] 0.039 secs (0.039u,0.s)
Chars 38245 - 38264 [revert~x2~urnat_x2.] 0.039 secs (0.039u,0.s)
Chars 38267 - 38301 [snrapply~equiv_path_ind_rlucan...] 0.052 secs (0.051u,0.s)
Chars 38304 - 38323 [revert~y0~ulnat_y0.] 0.039 secs (0.039u,0.s)
Chars 38326 - 38360 [snrapply~equiv_path_ind_rlucan...] 0.038 secs (0.038u,0.s)
Chars 38363 - 38382 [revert~y1~ulnat_y1.] 0.043 secs (0.043u,0.s)
Chars 38385 - 38419 [snrapply~equiv_path_ind_rlucan...] 0.04 secs (0.04u,0.s)
Chars 38422 - 38441 [revert~z0~ulnat_z0.] 0.04 secs (0.04u,0.s)
Chars 38444 - 38478 [snrapply~equiv_path_ind_rlucan...] 0.054 secs (0.051u,0.002s)
Chars 38481 - 38500 [revert~z1~ulnat_z1.] 0.04 secs (0.04u,0.s)
Chars 38503 - 38537 [snrapply~equiv_path_ind_rlucan...] 0.039 secs (0.039u,0.s)
Chars 38541 - 38559 [revert~wlrnat_y_x.] 0.044 secs (0.044u,0.s)
Chars 38592 - 38614 [revert~wrx0~ehlnat_x0.] 0.04 secs (0.04u,0.s)
Chars 38617 - 38651 [snrapply~equiv_path_ind_rlucan...] 0.041 secs (0.041u,0.s)
Chars 38654 - 38672 [revert~wlrnat_z_x.] 0.053 secs (0.05u,0.002s)
Chars 38705 - 38727 [revert~wrx1~ehlnat_x1.] 0.04 secs (0.039u,0.s)
Chars 38730 - 38764 [snrapply~equiv_path_ind_rlucan...] 0.039 secs (0.038u,0.s)
Chars 38767 - 38789 [revert~wrx2~ehlnat_x2.] 0.047 secs (0.046u,0.s)
Chars 38792 - 38826 [snrapply~equiv_path_ind_rlucan...] 0.038 secs (0.038u,0.s)
Chars 38829 - 38851 [revert~wly0~ehrnat_y0.] 0.039 secs (0.039u,0.s)
Chars 38854 - 38888 [snrapply~equiv_path_ind_rlucan...] 0.051 secs (0.048u,0.003s)
Chars 38891 - 38913 [revert~wly1~ehrnat_y1.] 0.039 secs (0.039u,0.s)
Chars 38916 - 38950 [snrapply~equiv_path_ind_rlucan...] 0.038 secs (0.038u,0.s)
Chars 38953 - 38975 [revert~wlz0~ehrnat_z0.] 0.046 secs (0.043u,0.003s)
Chars 38978 - 39012 [snrapply~equiv_path_ind_rlucan...] 0.038 secs (0.038u,0.s)
Chars 39015 - 39037 [revert~wlz1~ehrnat_z1.] 0.037 secs (0.037u,0.s)
Chars 39040 - 39074 [snrapply~equiv_path_ind_rlucan...] 0.051 secs (0.049u,0.001s)
Chars 39078 - 39090 [revert~wlx1.] 0.037 secs (0.037u,0.s)
Chars 39093 - 39127 [snrapply~equiv_path_ind_lrucan...] 0.037 secs (0.037u,0.s)
Chars 39130 - 39142 [revert~wlx0.] 0.045 secs (0.045u,0.s)
Chars 39145 - 39179 [snrapply~equiv_path_ind_lrucan...] 0.042 secs (0.042u,0.s)
Chars 39183 - 39197 [(destruct~wlx2).] 0.043 secs (0.043u,0.s)
Chars 39277 - 39285 [exact~H.] 0.045 secs (0.041u,0.003s)
Chars 39290 - 39300 [(apply~lem).] 0.046 secs (0.046u,0.s)
Chars 39303 - 39315 [reflexivity.] 0.203 secs (0.203u,0.s)
find_witness Control.TimeoutChars 39316 - 39320 [Qed.] 2.475 secs (2.461u,0.01s)
Chars 39322 - 39893 [Definition~eh_V_p_pp~{X}~{a~:~...] 0.715 secs (0.706u,0.007s)
Chars 39894 - 39900 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 24802 - 24834 [(apply~O_inverts_from_extendab...] 40.141 secs (0.001u,0.027s)
Chars 24841 - 24852 [(intros~Z~?).] 0. secs (0.u,0.s)
Chars 24859 - 24910 [rapply~((equiv_extendable_iseq...] 0.022 secs (0.02u,0.001s)
Chars 24802 - 24834 [(apply~O_inverts_from_extendab...] 0. secs (0.u,0.s)
Chars 24841 - 24852 [(intros~Z~?).] 0. secs (0.u,0.s)
Chars 24859 - 24910 [rapply~((equiv_extendable_iseq...] 0. secs (0.u,0.s)
Chars 24915 - 24923 [Defined.] 0. secs (0.u,0.s)
Chars 25042 - 25274 [Definition~inO_ooextendable_O_...] 0.001 secs (0.u,0.s)
Chars 25279 - 25285 [Proof.] 0. secs (0.u,0.s)
PCPb_undec
     : undecidable PCPb
find_witness Control.Timeoutfind_witness Control.TimeoutChars 39903 - 39991 [exact~~(eh_V_p_pp_gen~_~_~_~(e...] 40.987 secs (0.689u,0.109s)
Chars 39903 - 39991 [exact~~(eh_V_p_pp_gen~_~_~_~(e...] 0.08 secs (0.08u,0.s)
Chars 39992 - 40000 [Defined.] 0.744 secs (0.732u,0.01s)
"Did not find an instance for "
(extracted encodable_nat_enc)
"open obligation encodable_nat_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_nat_enc)
"open obligation encodable_nat_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_nat_enc)
"open obligation encodable_nat_enc_term for it. You might want to register a instance before and rerun this."
Chars 25292 - 25344 [(pose~(EZ~:=~fst~(E~Z~(O~Z)~(t...] 40.141 secs (0.003u,0.027s)
Chars 25351 - 25388 [exact~(inO_to_O_retract~_~EZ.1...] 0.001 secs (0.001u,0.s)
Chars 25292 - 25344 [(pose~(EZ~:=~fst~(E~Z~(O~Z)~(t...] 0. secs (0.u,0.s)
Chars 25351 - 25388 [exact~(inO_to_O_retract~_~EZ.1...] 0. secs (0.u,0.s)
Chars 25393 - 25401 [Defined.] 0. secs (0.u,0.s)
Chars 25482 - 25707 [Definition~inO_isequiv_precomp...] 0.001 secs (0.u,0.s)
Chars 25712 - 25718 [Proof.] 0. secs (0.u,0.s)
"Did not find an instance for "
(extracted encodable_nat_enc)
"open obligation encodable_nat_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_nat_enc)
"open obligation encodable_nat_enc_term for it. You might want to register a instance before and rerun this."
iPCPb_undec
     : undecidable iPCPb
"Did not find an instance for "
(extracted encodable_nat_enc)
"open obligation encodable_nat_enc_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout"Did not find an instance for "
(extracted encodable_nat_enc)
"open obligation encodable_nat_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_nat_enc)
"open obligation encodable_nat_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_nat_enc)
"open obligation encodable_nat_enc_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeoutfind_witness Control.Timeout"Did not find an instance for "
(extracted encodable_nat_enc)
"open obligation encodable_nat_enc_term for it. You might want to register a instance before and rerun this."
Chars 25725 - 25808 [(pose~~~(EZ~:=~~~~extension_is...] 40.129 secs (0.003u,0.029s)
Chars 25815 - 25852 [exact~(inO_to_O_retract~_~EZ.1...] 0.001 secs (0.001u,0.s)
Chars 25725 - 25808 [(pose~~~(EZ~:=~~~~extension_is...] 0. secs (0.u,0.s)
Chars 25815 - 25852 [exact~(inO_to_O_retract~_~EZ.1...] 0. secs (0.u,0.s)
Chars 25857 - 25865 [Defined.] 0. secs (0.u,0.s)
Chars 25871 - 26013 [Definition~to_O_inv_natural~{A...] 0.009 secs (0.006u,0.003s)
Chars 26018 - 26024 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutdPCPb_undec
     : undecidable dPCPb
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCan not derive computable instance from computableTime for higher-order-function
inb
Can not derive computable instance from computableTime for higher-order-function
inb
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCan not derive computable instance from computableTime for higher-order-function
inb
Can not derive computable instance from computableTime for higher-order-function
inb
Chars 26031 - 26067 [(refine~(O_indpaths~_~_~_);~in...] 40.157 secs (0.002u,0.028s)
Chars 26074 - 26094 [(apply~moveR_equiv_V).] 0.001 secs (0.u,0.s)
Chars 26101 - 26131 [refine~(to_O_natural~f~x~@~_).] 0.001 secs (0.u,0.s)
Chars 26138 - 26152 [(do~2~apply~ap).] 0.001 secs (0.001u,0.s)
Chars 26159 - 26183 [(symmetry;~apply~eissect).] 0.002 secs (0.002u,0.s)
Chars 26031 - 26067 [(refine~(O_indpaths~_~_~_);~in...] 0.001 secs (0.001u,0.s)
Chars 26074 - 26094 [(apply~moveR_equiv_V).] 0. secs (0.u,0.s)
Chars 26101 - 26131 [refine~(to_O_natural~f~x~@~_).] 0. secs (0.u,0.s)
Chars 26138 - 26152 [(do~2~apply~ap).] 0. secs (0.u,0.s)
Chars 26159 - 26183 [(symmetry;~apply~eissect).] 0. secs (0.u,0.s)
Chars 26188 - 26196 [Defined.] 0.001 secs (0.001u,0.s)
Chars 26306 - 26442 [Definition~O_functor_faithful_...] 0.001 secs (0.001u,0.s)
Chars 26447 - 26453 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeout"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
find_witness Control.TimeoutChars 26460 - 26469 [(intros~x).] 40.151 secs (0.001u,0.027s)
Chars 26476 - 26516 [refine~(ap~f~(eissect~(to~O~A)...] 0.005 secs (0.005u,0.s)
Chars 26523 - 26562 [refine~(_~@~ap~g~(eissect~(to~...] 0.005 secs (0.005u,0.s)
Chars 26569 - 26621 [transitivity~((to~O~B)^-1~(O_f...] 0.006 secs (0.003u,0.002s)
Chars 26628 - 26629 [+] 0. secs (0.u,0.s)
Chars 26630 - 26663 [(symmetry;~apply~to_O_inv_natu...] 0.003 secs (0.003u,0.s)
Chars 26670 - 26671 [+] 0. secs (0.u,0.s)
Chars 26672 - 26724 [transitivity~((to~O~B)^-1~(O_f...] 0.006 secs (0.004u,0.001s)
Chars 26733 - 26734 [*] 0. secs (0.u,0.s)
Chars 26735 - 26747 [(apply~ap,~e).] 0.001 secs (0.001u,0.s)
Chars 26756 - 26757 [*] 0. secs (0.u,0.s)
Chars 26758 - 26781 [(apply~to_O_inv_natural).] 0.001 secs (0.001u,0.s)
Chars 26460 - 26469 [(intros~x).] 0. secs (0.u,0.s)
Chars 26476 - 26516 [refine~(ap~f~(eissect~(to~O~A)...] 0. secs (0.u,0.s)
Chars 26523 - 26562 [refine~(_~@~ap~g~(eissect~(to~...] 0. secs (0.u,0.s)
Chars 26569 - 26621 [transitivity~((to~O~B)^-1~(O_f...] 0. secs (0.u,0.s)
Chars 26630 - 26663 [(symmetry;~apply~to_O_inv_natu...] 0.001 secs (0.001u,0.s)
Chars 26672 - 26724 [transitivity~((to~O~B)^-1~(O_f...] 0. secs (0.u,0.s)
Chars 26735 - 26747 [(apply~ap,~e).] 0. secs (0.u,0.s)
Chars 26758 - 26781 [(apply~to_O_inv_natural).] 0. secs (0.u,0.s)
Chars 26786 - 26794 [Defined.] 0.002 secs (0.001u,0.s)
Chars 26958 - 27064 [Definition~typeof_to_O~(A~:~Ty...] 0.001 secs (0.001u,0.s)
Chars 27070 - 27159 [#[global]~Instance~contr_typeo...] 0. secs (0.u,0.s)
Chars 27164 - 27170 [Proof.] 0. secs (0.u,0.s)
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted encodable_bool_enc)
"open obligation encodable_bool_enc_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
find_witness Control.TimeoutMore readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
"Did not find an instance for "
(extracted R1)
"open obligation var_R1_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
enc
With remainder:
[Ast.tRel 1]
More readable: initial segment:
enc
With remainder:
[Ast.tRel 1]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
"Did not find an instance for "
(extracted R1)
"open obligation var_R1_term for it. You might want to register a instance before and rerun this."
Chars 27177 - 27211 [exists~(O~A;~(to~O~A;~(_,~_))).] 40.155 secs (0.002u,0.029s)
Chars 27218 - 27241 [(intros~[OA~[Ou~[?~?]]]).] 0.008 secs (0.006u,0.001s)
Chars 27248 - 27281 [(pose~(f~:=~O_rec~Ou~:~O~A~->~...] 0.003 secs (0.003u,0.s)
Chars 27288 - 27342 [(pose~(g~:=~(O_functor~Ou)^-1~...] 0.004 secs (0.004u,0.s)
Chars 27349 - 27368 [(assert~(IsEquiv~f)).] 0.002 secs (0.001u,0.s)
Chars 27375 - 27376 [{] 0. secs (0.u,0.s)
Chars 27377 - 27413 [refine~(isequiv_adjointify~f~g...] 0.001 secs (0.001u,0.s)
Chars 27422 - 27423 [-] 0. secs (0.u,0.s)
Chars 27424 - 27463 [(apply~O_functor_faithful_inO;...] 0.003 secs (0.003u,0.s)
Chars 27474 - 27498 [(rewrite~O_functor_idmap).] 0.002 secs (0.002u,0.s)
Chars 27509 - 27535 [(rewrite~O_functor_compose).] 0.003 secs (0.003u,0.s)
Chars 27546 - 27555 [(unfold~g).] 0.001 secs (0.001u,0.s)
Chars 27566 - 27622 [(rewrite~(O_functor_compose~(t...] 0.005 secs (0.005u,0.s)
Chars 27633 - 27663 [(rewrite~O_functor_wellpointed).] 0.003 secs (0.002u,0.001s)
Chars 27674 - 27717 [(rewrite~(to_O_natural~(O_func...] 0.004 secs (0.003u,0.s)
Chars 27728 - 27758 [refine~(to_O_natural~f~_~@~_).] 0.002 secs (0.002u,0.s)
Chars 27769 - 27800 [(set~(y~:=~(O_functor~Ou)^-1~x)).] 0.002 secs (0.001u,0.s)
Chars 27811 - 27861 [(transitivity~(O_functor~Ou~y)...] 0.004 secs (0.004u,0.s)
Chars 27872 - 27892 [(unfold~f,~O_functor).] 0.001 secs (0.001u,0.s)
Chars 27903 - 27927 [(apply~O_rec_postcompose).] 0.002 secs (0.002u,0.s)
Chars 27936 - 27937 [-] 0. secs (0.u,0.s)
Chars 27938 - 27974 [(refine~(O_indpaths~_~_~_);~in...] 0.003 secs (0.003u,0.s)
Chars 27985 - 27994 [(unfold~f).] 0.001 secs (0.001u,0.s)
Chars 28005 - 28024 [(rewrite~O_rec_beta).] 0.003 secs (0.003u,0.s)
Chars 28025 - 28034 [(unfold~g).] 0.001 secs (0.001u,0.s)
Chars 28045 - 28065 [(apply~moveR_equiv_V).] 0.001 secs (0.001u,0.s)
Chars 28076 - 28105 [(symmetry;~apply~to_O_natural).] 0.004 secs (0.003u,0.s)
Chars 28112 - 28113 [}] 0. secs (0.u,0.s)
Chars 28120 - 28162 [(simple~refine~(path_sigma~_~_...] 0.009 secs (0.008u,0.s)
Chars 28169 - 28170 [-] 0. secs (0.u,0.s)
Chars 28171 - 28195 [exact~(path_universe~f).] 0.002 secs (0.002u,0.s)
Chars 28202 - 28203 [-] 0. secs (0.u,0.s)
Chars 28204 - 28228 [(rewrite~transport_sigma).] 0.007 secs (0.007u,0.s)
Chars 28237 - 28304 [(simple~refine~(path_sigma~_~_...] 0.099 secs (0.08u,0.018s)
Chars 28313 - 28340 [(apply~path_arrow;~intros~x).] 0.003 secs (0.002u,0.s)
Chars 28349 - 28383 [(rewrite~transport_arrow_fromc...] 0.002 secs (0.002u,0.s)
Chars 28392 - 28424 [(rewrite~transport_path_univer...] 0.003 secs (0.003u,0.s)
Chars 28433 - 28460 [(unfold~f;~apply~O_rec_beta).] 0.003 secs (0.002u,0.s)
Chars 27177 - 27211 [exists~(O~A;~(to~O~A;~(_,~_))).] 0. secs (0.u,0.s)
Chars 27218 - 27241 [(intros~[OA~[Ou~[?~?]]]).] 0. secs (0.u,0.s)
Chars 27248 - 27281 [(pose~(f~:=~O_rec~Ou~:~O~A~->~...] 0.001 secs (0.001u,0.s)
Chars 27288 - 27342 [(pose~(g~:=~(O_functor~Ou)^-1~...] 0.001 secs (0.001u,0.s)
Chars 27349 - 27368 [(assert~(IsEquiv~f)).] 0.001 secs (0.001u,0.s)
Chars 27377 - 27413 [refine~(isequiv_adjointify~f~g...] 0. secs (0.u,0.s)
Chars 27424 - 27463 [(apply~O_functor_faithful_inO;...] 0.001 secs (0.u,0.s)
Chars 27474 - 27498 [(rewrite~O_functor_idmap).] 0. secs (0.u,0.s)
Chars 27509 - 27535 [(rewrite~O_functor_compose).] 0. secs (0.u,0.s)
Chars 27546 - 27555 [(unfold~g).] 0. secs (0.u,0.s)
Chars 27566 - 27622 [(rewrite~(O_functor_compose~(t...] 0. secs (0.u,0.s)
Chars 27633 - 27663 [(rewrite~O_functor_wellpointed).] 0.001 secs (0.001u,0.s)
Chars 27674 - 27717 [(rewrite~(to_O_natural~(O_func...] 0. secs (0.u,0.s)
Chars 27728 - 27758 [refine~(to_O_natural~f~_~@~_).] 0. secs (0.u,0.s)
Chars 27769 - 27800 [(set~(y~:=~(O_functor~Ou)^-1~x)).] 0. secs (0.u,0.s)
Chars 27811 - 27861 [(transitivity~(O_functor~Ou~y)...] 0.001 secs (0.u,0.s)
Chars 27872 - 27892 [(unfold~f,~O_functor).] 0. secs (0.u,0.s)
Chars 27903 - 27927 [(apply~O_rec_postcompose).] 0.001 secs (0.001u,0.s)
Chars 27938 - 27974 [(refine~(O_indpaths~_~_~_);~in...] 0.001 secs (0.001u,0.s)
Chars 27985 - 27994 [(unfold~f).] 0. secs (0.u,0.s)
Chars 28005 - 28024 [(rewrite~O_rec_beta).] 0. secs (0.u,0.s)
Chars 28025 - 28034 [(unfold~g).] 0. secs (0.u,0.s)
Chars 28045 - 28065 [(apply~moveR_equiv_V).] 0. secs (0.u,0.s)
Chars 28076 - 28105 [(symmetry;~apply~to_O_natural).] 0.001 secs (0.001u,0.s)
Chars 28120 - 28162 [(simple~refine~(path_sigma~_~_...] 0.005 secs (0.004u,0.001s)
Chars 28171 - 28195 [exact~(path_universe~f).] 0. secs (0.u,0.s)
Chars 28204 - 28228 [(rewrite~transport_sigma).] 0.001 secs (0.u,0.s)
Chars 28237 - 28304 [(simple~refine~(path_sigma~_~_...] 0.009 secs (0.009u,0.s)
Chars 28313 - 28340 [(apply~path_arrow;~intros~x).] 0.001 secs (0.u,0.s)
Chars 28349 - 28383 [(rewrite~transport_arrow_fromc...] 0.001 secs (0.001u,0.s)
Chars 28392 - 28424 [(rewrite~transport_path_univer...] 0. secs (0.u,0.s)
Chars 28433 - 28460 [(unfold~f;~apply~O_rec_beta).] 0.001 secs (0.001u,0.s)
Chars 28465 - 28469 [Qed.] 0.034 secs (0.027u,0.006s)
Chars 28473 - 28486 [End~OInverts.] 0.089 secs (0.085u,0.003s)
Chars 28490 - 28504 [Section~Types.] 0. secs (0.u,0.s)
Chars 28540 - 28577 [#[global]Instance~inO_unit~:~(...] 0. secs (0.u,0.s)
Chars 28582 - 28588 [Proof.] 0. secs (0.u,0.s)
"Did not find an instance for "
(extracted R1)
"open obligation var_R1_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
enc
With remainder:
[Ast.tRel 1]
More readable: initial segment:
enc
With remainder:
[Ast.tRel 1]
More readable: initial segment:
enc
With remainder:
[Ast.tRel 1]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_prod_enc (Y:=Y))
With remainder:
[]
More readable: initial segment:
(encodable_list_enc (X:=X))
With remainder:
[]
More readable: initial segment:
(encodable_list_enc (X:=X))
With remainder:
[]
More readable: initial segment:
(encodable_list_enc (X:=X))
With remainder:
[]
Chars 28595 - 28643 [(apply~inO_to_O_retract~with~(...] 20.361 secs (11.118u,-0.884s)
More readable: initial segment:
(encodable_list_enc (X:=X))
With remainder:
[]
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building ident_interp_Proper...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building invertIdent...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building buildInvertIdentCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building base_default...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building package...
Building all_base...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_idents...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building ident_index...
Building eta_ident_cps_gen...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_ident_cps_gen_expand_literal...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_ident_cps...
Building simple_idents...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_raw_idents...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building raw_ident_index...
Building raw_ident_index_idempotent...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_raw_ident_cps_gen...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building split_raw_ident_gen...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building invert_bind_args...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building invert_bind_args_unknown...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_pattern_idents...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_pattern_ident_cps_gen...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_pattern_ident_cps_gen_expand_literal...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building split_types...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building add_types_from_raw_sig...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building to_type_split_types_subst_default_eq...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building projT1_add_types_from_raw_sig_eq...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building arg_types_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building type_of_list_arg_types_beq_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building to_typed_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building of_typed_ident_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building arg_types_of_typed_ident_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building unify...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building unify_unknown...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building final ident package...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Proving is_simple_correct0...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 0.524 secs (0.514u,0.006s) (success)
Proving invert_bind_args_raw_to_typed...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 0.386 secs (0.378u,0.004s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.026 secs (0.026u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.024 secs (0.024u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 1.248 secs (1.226u,0.012s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building index_of_base...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building base_type_list...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_base_cps_gen...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_base_cps...
Building base_interp...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_base...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Chars 28595 - 28643 [(apply~inO_to_O_retract~with~(...] 40.058 secs (0.u,0.028s)
Chars 28650 - 28672 [exact~(@contr~Unit~_).] 0.001 secs (0.001u,0.s)
Chars 28595 - 28643 [(apply~inO_to_O_retract~with~(...] 0. secs (0.u,0.s)
Chars 28650 - 28672 [exact~(@contr~Unit~_).] 0. secs (0.u,0.s)
Chars 28677 - 28685 [Defined.] 0. secs (0.u,0.s)
Chars 28751 - 28808 [#[global]Instance~inO_contr~~{...] 0. secs (0.u,0.s)
Chars 28813 - 28819 [Proof.] 0. secs (0.u,0.s)
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building base_eq_dec...
Tactic call ran for 2.61 secs (2.601u,0.002s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Building base_beq_and_reflect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building base_beq...
Building reflect_base_beq...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building baseHasNatAndCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building baseHasNat...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building baseHasNatCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building base_interp_beq...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building reflect_base_interp_beq...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building try_make_base_transport_cps...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building try_make_base_transport_cps_correct...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_idents...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_ident_and_interp...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building buildEagerIdentAndInterpCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building buildIdentAndInterpCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building buildIdent...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building buildInterpIdentCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building ident_interp_Proper...
Building invertIdent...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building buildInvertIdentCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building base_default...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building package...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_base...
Building all_idents...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Reifying...
Building ident_index...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Compiling decision tree...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_ident_cps_gen...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Splitting rewrite rules...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_ident_cps_gen_expand_literal...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_ident_cps...
Assembling rewrite_head...
Building simple_idents...
Building all_raw_idents...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Reducing rewrite_head...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building raw_ident_index...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 0.04 secs (0.04u,0.s) (success)
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building raw_ident_index_idempotent...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_raw_ident_cps_gen...
Assembling rewrite_head_no_dtree...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Reducing rewrite_head_no_dtree...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Proving Rewriter_Wf...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 0.02 secs (0.019u,0.001s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
Building split_raw_ident_gen...
Proving Rewriter_Interp...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 0.117 secs (0.116u,0.s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Assembling verified rewriter...
Refining with verified rewriter...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
find_witness Control.TimeoutCan not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Finished transaction in 21.116 secs (20.842u,0.201s) (successful)
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building invert_bind_args...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building invert_bind_args_unknown...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_pattern_idents...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_pattern_ident_cps_gen...
find_witness Control.TimeoutCan not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_pattern_ident_cps_gen_expand_literal...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building split_types...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building add_types_from_raw_sig...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building to_type_split_types_subst_default_eq...
Finished transaction in 33.079 secs (32.629u,0.264s) (successful)
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building projT1_add_types_from_raw_sig_eq...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building arg_types_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building of_typed_ident_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building arg_types_of_typed_ident_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Finished transaction in 0.019 secs (0.019u,0.s) (successful)
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
Building unify...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building unify_unknown...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building final ident package...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Proving is_simple_correct0...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 0.605 secs (0.595u,0.007s) (success)
Proving invert_bind_args_raw_to_typed...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 0.356 secs (0.351u,0.003s) (success)
Proving fold_invert_bind_args...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 0.037 secs (0.035u,0.001s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.022 secs (0.022u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 1.362 secs (1.314u,0.014s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.021 secs (0.017u,0.003s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
"Did not find an instance for "
(extracted enc)
"open obligation var_enc_term for it. You might want to register a instance before and rerun this."
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
find_witness Control.TimeoutCan not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Tactic call ran for 2.703 secs (2.665u,0.013s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building index_of_base...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building base_interp...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_base...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building base_eq_dec...
Building base_beq_and_reflect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building baseHasNat...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building baseHasNatCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building base_interp_beq...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building all_idents...
Building all_ident_and_interp...
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
Building buildEagerIdentAndInterpCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building buildEagerIdent...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building buildInterpEagerIdentCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building toRestrictedIdentAndCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building toRestrictedIdent...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building toFromRestrictedIdent...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building buildIdentAndInterpCorrect...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
find_witness Control.Timeout(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building ident_interp_Proper...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building invertIdent...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Reifying...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building ident_index...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_ident_cps_gen...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building raw_ident_index...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building raw_ident_index_idempotent...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_raw_ident_cps_gen...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building split_raw_ident_gen...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
"Did not find an instance for "
(extracted enc)
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
"open obligation var_enc_term for it. You might want to register a instance before and rerun this."
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building invert_bind_args...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building invert_bind_args_unknown...
Building all_pattern_idents...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_pattern_ident_cps_gen...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building eta_pattern_ident_cps_gen_expand_literal...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building split_types...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building add_types_from_raw_sig...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building to_type_split_types_subst_default_eq...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building projT1_add_types_from_raw_sig_eq...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Compiling decision tree...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Splitting rewrite rules...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building to_typed_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Building of_typed_ident_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Assembling rewrite_head...
Building arg_types_of_typed_ident_unfolded...
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Can not derive computable instance from computableTime for higher-order-function
(list_eqb (X:=X))
Reducing rewrite_head...
Tactic call ran for 0.241 secs (0.238u,0.002s) (success)
Tactic call ran for 0.219 secs (0.215u,0.002s) (success)
Tactic call ran for 0.174 secs (0.173u,0.s) (success)
Building unify...
Assembling rewrite_head_no_dtree...
Building unify_unknown...
Building final ident package...
Reducing rewrite_head_no_dtree...
Proving is_simple_correct0...
Tactic call ran for 0.748 secs (0.735u,0.009s) (success)
Proving invert_bind_args_raw_to_typed...
Proving Rewriter_Wf...
Tactic call ran for 0.46 secs (0.446u,0.01s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.059 secs (0.058u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.136 secs (0.133u,0.002s) (success)
Tactic call ran for 0.027 secs (0.027u,0.s) (success)
Proving eq_indep_types_of_eq_types...
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
Tactic call ran for 1.535 secs (1.5u,0.026s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 1.782 secs (1.739u,0.024s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.483 secs (0.474u,0.006s) (success)
Tactic call ran for 3.125 secs (3.088u,0.025s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Tactic call ran for 1.037 secs (1.02u,0.012s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 38.581 secs (37.979u,0.409s) (successful)
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
Reifying...
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
Chars 28826 - 28873 [exact~(inO_equiv_inO~Unit~equi...] 40.122 secs (0.003u,0.029s)
Chars 28826 - 28873 [exact~(inO_equiv_inO~Unit~equi...] 0. secs (0.u,0.s)
Chars 28878 - 28886 [Defined.] 0. secs (0.u,0.s)
Chars 28973 - 29039 [#[global]Instance~contr_O_cont...] 0. secs (0.u,0.s)
Chars 29044 - 29050 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
More readable: initial segment:
(encodable_option_enc (X:=X))
With remainder:
[]
"Did not find an instance for "
(extracted enc)
"open obligation var_enc_term for it. You might want to register a instance before and rerun this."
Compiling decision tree...
Splitting rewrite rules...
find_witness Control.TimeoutAssembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.231 secs (0.225u,0.003s) (success)
Tactic call ran for 0.312 secs (0.305u,0.007s) (success)
find_witness Control.TimeoutTactic call ran for 0.146 secs (0.144u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.154 secs (0.152u,0.s) (success)
Tactic call ran for 1.975 secs (1.937u,0.034s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.555 secs (0.551u,0.s) (success)
Tactic call ran for 1.161 secs (1.153u,0.005s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
find_witness Control.TimeoutMore readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
Building buildEagerIdentAndInterpCorrect...
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
Building eta_ident_cps...
Building simple_idents...
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Chars 29057 - 29088 [exact~(contr_equiv~A~(to~O~A)).] 40.147 secs (0.004u,0.028s)
Chars 29057 - 29088 [exact~(contr_equiv~A~(to~O~A)).] 0. secs (0.u,0.s)
Chars 29093 - 29101 [Defined.] 0. secs (0.u,0.s)
Chars 29175 - 29306 [#[global]~Instance~inO_forall~...] 0. secs (0.u,0.s)
Chars 29311 - 29317 [Proof.] 0. secs (0.u,0.s)
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
More readable: initial segment:
(cumul opt_to_list)
With remainder:
[]
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.713 secs (0.697u,0.008s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.457 secs (0.443u,0.012s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.054 secs (0.05u,0.003s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.025 secs (0.025u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 1.493 secs (1.45u,0.03s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 3.121 secs (3.088u,0.016s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
find_witness Control.TimeoutReifying...
Compiling decision tree...
Splitting rewrite rules...
find_witness Control.TimeoutAssembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.236 secs (0.228u,0.007s) (success)
Tactic call ran for 0.325 secs (0.319u,0.006s) (success)
Tactic call ran for 0.147 secs (0.144u,0.003s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
find_witness Control.TimeoutProving Rewriter_Wf...
Tactic call ran for 0.155 secs (0.153u,0.001s) (success)
Tactic call ran for 2.024 secs (1.988u,0.033s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.588 secs (0.579u,0.008s) (success)
Tactic call ran for 1.22 secs (1.203u,0.012s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 45.692 secs (45.165u,0.38s) (successful)
Success: (dlet y0 : Z := e1 + e2 in
          [y; y + 1; y + 2; y + y0; y + (y0 + 1)])
Success: [x1; x1; x1; x2; x2; x2; x3; x3; x3]
Chars 29324 - 29332 [intro~H.] 40.122 secs (0.u,0.028s)
Chars 29339 - 29396 [(pose~(ev~:=~fun~x~=>~fun~f~:~...] 0.001 secs (0.001u,0.s)
Chars 29403 - 29449 [(pose~(zz~:=~fun~x~:~A~=>~O_re...] 0.002 secs (0.002u,0.s)
Chars 29456 - 29517 [(apply~inO_to_O_retract~with~(...] 0.001 secs (0.001u,0.s)
Chars 29524 - 29534 [intro~phi.] 0. secs (0.u,0.s)
Chars 29541 - 29575 [(unfold~zz,~ev;~clear~zz;~clea...] 0.002 secs (0.002u,0.s)
Chars 29582 - 29609 [(apply~path_forall;~intro~x).] 0.002 secs (0.001u,0.s)
Chars 29616 - 29674 [exact~(O_rec_beta~(fun~f~:~for...] 0.002 secs (0.001u,0.s)
Chars 29324 - 29332 [intro~H.] 0. secs (0.u,0.s)
Chars 29339 - 29396 [(pose~(ev~:=~fun~x~=>~fun~f~:~...] 0. secs (0.u,0.s)
Chars 29403 - 29449 [(pose~(zz~:=~fun~x~:~A~=>~O_re...] 0. secs (0.u,0.s)
Chars 29456 - 29517 [(apply~inO_to_O_retract~with~(...] 0. secs (0.u,0.s)
Chars 29524 - 29534 [intro~phi.] 0. secs (0.u,0.s)
Chars 29541 - 29575 [(unfold~zz,~ev;~clear~zz;~clea...] 0.002 secs (0.002u,0.s)
Chars 29582 - 29609 [(apply~path_forall;~intro~x).] 0.001 secs (0.001u,0.s)
Chars 29616 - 29674 [exact~(O_rec_beta~(fun~f~:~for...] 0. secs (0.u,0.s)
Chars 29679 - 29687 [Defined.] 0.001 secs (0.001u,0.s)
Chars 29693 - 29776 [#[global]~Instance~inO_arrow~~...] 0. secs (0.u,0.s)
Chars 29781 - 29787 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 89.804 secs (89.296u,0.373s) (successful)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 18.918 secs (18.528u,0.341s) (successful)
find_witness Control.TimeoutChars 29794 - 29811 [(apply~inO_forall).] 40.148 secs (0.u,0.027s)
Chars 29818 - 29826 [intro~a.] 0. secs (0.u,0.s)
Chars 29827 - 29835 [exact~_.] 0. secs (0.u,0.s)
Chars 29794 - 29811 [(apply~inO_forall).] 0. secs (0.u,0.s)
Chars 29818 - 29826 [intro~a.] 0. secs (0.u,0.s)
Chars 29827 - 29835 [exact~_.] 0. secs (0.u,0.s)
Chars 29840 - 29848 [Defined.] 0. secs (0.u,0.s)
Chars 29876 - 29951 [#[global]Instance~inO_prod~~(A...] 0. secs (0.u,0.s)
Chars 29956 - 29962 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 29969 - 30069 [(apply~inO_to_O_retract~with~~...] 40.14 secs (0.002u,0.03s)
Chars 30076 - 30113 [(intros~[a~b];~apply~path_prod...] 0.005 secs (0.005u,0.s)
Chars 30120 - 30121 [-] 0. secs (0.u,0.s)
Chars 30122 - 30151 [exact~(O_rec_beta~fst~(a,~b)).] 0.002 secs (0.002u,0.s)
Chars 30158 - 30159 [-] 0. secs (0.u,0.s)
Chars 30160 - 30189 [exact~(O_rec_beta~snd~(a,~b)).] 0.002 secs (0.002u,0.s)
Chars 29969 - 30069 [(apply~inO_to_O_retract~with~~...] 0. secs (0.u,0.s)
Chars 30076 - 30113 [(intros~[a~b];~apply~path_prod...] 0.002 secs (0.002u,0.s)
Chars 30122 - 30151 [exact~(O_rec_beta~fst~(a,~b)).] 0. secs (0.u,0.s)
Chars 30160 - 30189 [exact~(O_rec_beta~snd~(a,~b)).] 0. secs (0.u,0.s)
Chars 30194 - 30202 [Defined.] 0.002 secs (0.002u,0.s)
Chars 30348 - 30445 [Definition~O_prod_unit~(A~B~:~...] 0.001 secs (0.001u,0.s)
Chars 30530 - 30648 [Definition~ooextendable_O_prod...] 0. secs (0.u,0.s)
Chars 30653 - 30659 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 30666 - 30698 [(apply~ooextendable_functor_pr...] 20.528 secs (11.229u,-1.069s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 30666 - 30698 [(apply~ooextendable_functor_pr...] 40.065 secs (0.u,0.03s)
Chars 30705 - 30740 [all:~(intros;~rapply~extendabl...] 0.045 secs (0.034u,0.01s)
Chars 30666 - 30698 [(apply~ooextendable_functor_pr...] 0. secs (0.u,0.s)
Chars 30705 - 30740 [all:~(intros;~rapply~extendabl...] 0.001 secs (0.001u,0.s)
Chars 30745 - 30753 [Defined.] 0. secs (0.u,0.s)
Chars 30802 - 30968 [Definition~isequiv_O_prod_unit...] 0.002 secs (0.001u,0.s)
Chars 30973 - 30979 [Proof.] 0. secs (0.u,0.s)
Chars 30986 - 31014 [rapply~isequiv_ooextendable.] 0.535 secs (0.002u,0.029s)
Chars 31021 - 31053 [rapply~ooextendable_O_prod_unit.] 0.002 secs (0.002u,0.s)
Chars 30986 - 31014 [rapply~isequiv_ooextendable.] 0. secs (0.u,0.s)
Chars 31021 - 31053 [rapply~ooextendable_O_prod_unit.] 0. secs (0.u,0.s)
Chars 31058 - 31066 [Defined.] 0. secs (0.u,0.s)
Chars 31072 - 31278 [Definition~equiv_O_prod_unit_p...] 0.003 secs (0.003u,0.s)
Chars 31446 - 31533 [#[global]~Instance~O_inverts_O...] 0. secs (0.u,0.s)
Chars 31538 - 31544 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 31551 - 31584 [rapply~O_inverts_from_extendable.] 40.126 secs (0.002u,0.029s)
Chars 31591 - 31631 [(intros;~rapply~ooextendable_O...] 0.005 secs (0.005u,0.s)
Chars 31551 - 31584 [rapply~O_inverts_from_extendable.] 0. secs (0.u,0.s)
Chars 31591 - 31631 [(intros;~rapply~ooextendable_O...] 0. secs (0.u,0.s)
Chars 31636 - 31644 [Defined.] 0. secs (0.u,0.s)
Chars 31650 - 31743 [Definition~O_prod_cmp~(A~B~:~T...] 0.015 secs (0.011u,0.004s)
Chars 31749 - 31830 [#[global]~Instance~isequiv_O_p...] 0. secs (0.u,0.s)
Chars 31835 - 31841 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
More readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
find_witness Control.TimeoutMore readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
Chars 31848 - 31879 [rapply~isequiv_O_rec_O_inverts.] 40.162 secs (0.002u,0.028s)
Chars 31848 - 31879 [rapply~isequiv_O_rec_O_inverts.] 0. secs (0.u,0.s)
Chars 31884 - 31892 [Defined.] 0. secs (0.u,0.s)
Chars 31898 - 32013 [Definition~equiv_O_prod_cmp~(A...] 0.002 secs (0.002u,0.s)
Chars 32044 - 32176 [#[global]~Instance~inO_pullbac...] 0.001 secs (0.001u,0.s)
Chars 32181 - 32187 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutMore readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
find_witness Control.TimeoutMore readable: initial segment:
(nth_error (A:=X))
With remainder:
[Ast.tApp (Ast.tRel 3) [Ast.tRel 1]; Ast.tRel 0]
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 140.012 secs (138.597u,0.811s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 32194 - 32219 [srapply~inO_to_O_retract.] 40.152 secs (0.002u,0.028s)
Chars 32226 - 32227 [-] 0. secs (0.u,0.s)
Chars 32228 - 32238 [(intros~op).] 0. secs (0.u,0.s)
Chars 32247 - 32269 [exists~(O_rec~pr1~op).] 0.002 secs (0.001u,0.001s)
Chars 32278 - 32313 [exists~(O_rec~(fun~p~=>~(p.2)....] 0.003 secs (0.002u,0.s)
Chars 32322 - 32368 [(revert~op;~apply~O_indpaths;~...] 0.009 secs (0.008u,0.s)
Chars 32377 - 32417 [(refine~(ap~f~(O_rec_beta~_~_)...] 0.005 secs (0.005u,0.s)
Chars 32426 - 32462 [refine~(a~@~ap~g~(O_rec_beta~_...] 0.004 secs (0.004u,0.s)
Chars 32469 - 32470 [-] 0. secs (0.u,0.s)
Chars 32471 - 32493 [(intros~[b~[c~a]];~cbn).] 0.041 secs (0.038u,0.002s)
Chars 32502 - 32522 [srapply~path_sigma'.] 0.024 secs (0.023u,0.001s)
Chars 32531 - 32532 [{] 0. secs (0.u,0.s)
Chars 32533 - 32550 [(apply~O_rec_beta).] 0.002 secs (0.001u,0.s)
Chars 32551 - 32552 [}] 0. secs (0.u,0.s)
Chars 32561 - 32600 [(refine~(transport_sigma'~_~_~...] 0.023 secs (0.021u,0.001s)
Chars 32609 - 32629 [srapply~path_sigma'.] 0.024 secs (0.021u,0.002s)
Chars 32638 - 32639 [{] 0. secs (0.u,0.s)
Chars 32640 - 32657 [(apply~O_rec_beta).] 0.002 secs (0.002u,0.s)
Chars 32658 - 32659 [}] 0. secs (0.u,0.s)
Chars 32668 - 32875 [(abstract~(rewrite~transport_p...] 0.205 secs (0.167u,0.034s)
Chars 32194 - 32219 [srapply~inO_to_O_retract.] 0. secs (0.u,0.s)
Chars 32228 - 32238 [(intros~op).] 0. secs (0.u,0.s)
Chars 32247 - 32269 [exists~(O_rec~pr1~op).] 0. secs (0.u,0.s)
Chars 32278 - 32313 [exists~(O_rec~(fun~p~=>~(p.2)....] 0. secs (0.u,0.s)
Chars 32322 - 32368 [(revert~op;~apply~O_indpaths;~...] 0.002 secs (0.002u,0.s)
Chars 32377 - 32417 [(refine~(ap~f~(O_rec_beta~_~_)...] 0.002 secs (0.002u,0.s)
Chars 32426 - 32462 [refine~(a~@~ap~g~(O_rec_beta~_...] 0.001 secs (0.u,0.s)
Chars 32471 - 32493 [(intros~[b~[c~a]];~cbn).] 0.011 secs (0.01u,0.s)
Chars 32502 - 32522 [srapply~path_sigma'.] 0.004 secs (0.003u,0.s)
Chars 32533 - 32550 [(apply~O_rec_beta).] 0.001 secs (0.001u,0.s)
Chars 32561 - 32600 [(refine~(transport_sigma'~_~_~...] 0.015 secs (0.014u,0.s)
Chars 32609 - 32629 [srapply~path_sigma'.] 0.004 secs (0.004u,0.s)
Chars 32640 - 32657 [(apply~O_rec_beta).] 0. secs (0.u,0.s)
Chars 32668 - 32875 [(abstract~(rewrite~transport_p...] 0.004 secs (0.004u,0.s)
Chars 32880 - 32888 [Defined.] 0.082 secs (0.082u,0.s)
Chars 32916 - 33032 [#[global]~Instance~inO_hfiber~...] 0. secs (0.u,0.s)
Chars 33037 - 33043 [Proof.] 0. secs (0.u,0.s)
     = ("swap",
        (["c1"; "c2"], [], bedrock_func_body:(
           $"v1" = load($"c1");
           $"v2" = load($"c2");
           store($"c1", $"v2");
           store($"c2", $"v1"))))
     : bedrock_func
find_witness Control.Timeoutfun (args : \<< A, word, word \>>) (tr' : Semantics.trace) 
  (mem' : mem) (locals' : locals) =>
tr' = tr /\
locals' =
#{ "v" => P2.car (P2.cdr args); "ptr" => ptr; "y" => P2.cdr (P2.cdr args) }# /\
(rp ptr (P2.car args) ⋆ R) mem'
     : \<< A, word, word \>> -> Semantics.trace -> mem -> locals -> Prop
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 33050 - 33089 [simple~refine~(inO_to_O_retrac...] 40.156 secs (0.u,0.029s)
Chars 33096 - 33097 [-] 0. secs (0.u,0.s)
Chars 33098 - 33128 [(intros~x;~simple~refine~(_;~_)).] 0.001 secs (0.001u,0.s)
Chars 33137 - 33138 [+] 0. secs (0.u,0.s)
Chars 33139 - 33159 [exact~(O_rec~pr1~x).] 0.003 secs (0.002u,0.s)
Chars 33168 - 33169 [+] 0. secs (0.u,0.s)
Chars 33170 - 33214 [(revert~x;~apply~O_indpaths;~i...] 0.005 secs (0.005u,0.s)
Chars 33225 - 33262 [refine~(ap~f~(O_rec_beta~pr1~x...] 0.002 secs (0.002u,0.s)
Chars 33273 - 33285 [exact~x.2.] 0. secs (0.u,0.s)
Chars 33292 - 33293 [-] 0. secs (0.u,0.s)
Chars 33294 - 33342 [(intros~[a~p];~simple~refine~(...] 0.01 secs (0.007u,0.002s)
Chars 33351 - 33352 [+] 0. secs (0.u,0.s)
Chars 33353 - 33382 [exact~(O_rec_beta~pr1~(a;~p)).] 0.002 secs (0.002u,0.s)
Chars 33391 - 33392 [+] 0. secs (0.u,0.s)
Chars 33393 - 33458 [(refine~(ap~(transport~_~_)~(O...] 0.009 secs (0.007u,0.001s)
Chars 33469 - 33505 [refine~(transport_paths_Fl~_~_...] 0.003 secs (0.003u,0.s)
Chars 33516 - 33534 [(apply~concat_V_pp).] 0.003 secs (0.003u,0.s)
Chars 33050 - 33089 [simple~refine~(inO_to_O_retrac...] 0. secs (0.u,0.s)
Chars 33098 - 33128 [(intros~x;~simple~refine~(_;~_)).] 0. secs (0.u,0.s)
Chars 33139 - 33159 [exact~(O_rec~pr1~x).] 0. secs (0.u,0.s)
Chars 33170 - 33214 [(revert~x;~apply~O_indpaths;~i...] 0.002 secs (0.002u,0.s)
Chars 33225 - 33262 [refine~(ap~f~(O_rec_beta~pr1~x...] 0. secs (0.u,0.s)
Chars 33273 - 33285 [exact~x.2.] 0. secs (0.u,0.s)
Chars 33294 - 33342 [(intros~[a~p];~simple~refine~(...] 0.004 secs (0.003u,0.s)
Chars 33353 - 33382 [exact~(O_rec_beta~pr1~(a;~p)).] 0. secs (0.u,0.s)
Chars 33393 - 33458 [(refine~(ap~(transport~_~_)~(O...] 0.003 secs (0.003u,0.s)
Chars 33469 - 33505 [refine~(transport_paths_Fl~_~_...] 0.001 secs (0.001u,0.s)
Chars 33516 - 33534 [(apply~concat_V_pp).] 0.001 secs (0.001u,0.s)
Chars 33539 - 33547 [Defined.] 0.024 secs (0.019u,0.004s)
Chars 33553 - 33680 [Definition~inO_unsigma~{A~:~Ty...] 0. secs (0.u,0.s)
Chars 33685 - 33691 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 33698 - 33749 [refine~(inO_equiv_inO~_~(hfibe...] 12.634 secs (0.026u,0.035s)
Chars 33876 - 33919 [all:~(refine~(inO_hfiber~pr1~x...] 0. secs (0.u,0.s)
Chars 33698 - 33749 [refine~(inO_equiv_inO~_~(hfibe...] 0. secs (0.u,0.s)
Chars 33876 - 33919 [all:~(refine~(inO_hfiber~pr1~x...] 0. secs (0.u,0.s)
Chars 33924 - 33932 [Defined.] 0. secs (0.u,0.s)
Chars 33938 - 34000 [#[local]Hint~Immediate~inO_uns...] 0. secs (0.u,0.s)
Chars 34120 - 34231 [Definition~O_functor_hfiber~{A...] 0.001 secs (0.001u,0.s)
Chars 34236 - 34242 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Fun.Finally_raised: Control.Timeoutfind_witness Control.TimeoutChars 34249 - 34261 [(apply~O_rec).] 40.197 secs (0.036u,0.039s)
Chars 34262 - 34275 [(intros~[a~p]).] 0.001 secs (0.001u,0.s)
Chars 34282 - 34300 [exists~(to~O~A~a).] 0.001 secs (0.001u,0.s)
Chars 34307 - 34337 [refine~(to_O_natural~f~a~@~_).] 0.001 secs (0.u,0.s)
Chars 34344 - 34356 [(apply~ap,~p).] 0.001 secs (0.u,0.001s)
Chars 34249 - 34261 [(apply~O_rec).] 0. secs (0.u,0.s)
Chars 34262 - 34275 [(intros~[a~p]).] 0. secs (0.u,0.s)
Chars 34282 - 34300 [exists~(to~O~A~a).] 0. secs (0.u,0.s)
Chars 34307 - 34337 [refine~(to_O_natural~f~a~@~_).] 0. secs (0.u,0.s)
Chars 34344 - 34356 [(apply~ap,~p).] 0. secs (0.u,0.s)
Chars 34361 - 34369 [Defined.] 0.001 secs (0.001u,0.s)
Chars 34375 - 34540 [Definition~O_functor_hfiber_na...] 0.004 secs (0.004u,0.s)
Chars 34545 - 34551 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutMore readable: initial segment:
(VectorDef.fold_left Init.Nat.max 0)
With remainder:
[Ast.tApp
   (Ast.tConst (Kernames.MPfile ["VectorDef"; "Vectors"; "Coq"], "map") [])
   [Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["TM"; "TM"; "Undecidability"], "tape") 0) [])
      [Ast.tVar "sig"];
    Ast.tInd
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0)
      [];
    Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["TM_facts"; "Util"; "TM"; "Undecidability"],
          "sizeOfTape") []) [Ast.tVar "sig"]; Ast.tVar "n"; 
    Ast.tRel 0]]
find_witness Control.TimeoutMore readable: initial segment:
(VectorDef.fold_left Init.Nat.max 0)
With remainder:
[Ast.tApp
   (Ast.tConst (Kernames.MPfile ["VectorDef"; "Vectors"; "Coq"], "map") [])
   [Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["TM"; "TM"; "Undecidability"], "tape") 0) [])
      [Ast.tVar "sig"];
    Ast.tInd
      (Kernames.mkInd (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0)
      [];
    Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["TM_facts"; "Util"; "TM"; "Undecidability"],
          "sizeOfTape") []) [Ast.tVar "sig"]; Ast.tVar "n"; 
    Ast.tRel 0]]
find_witness Control.Timeoutfind_witness Control.TimeoutChars 34558 - 34632 [(intros~[a~p];~unfold~O_functo...] 40.193 secs (0.01u,0.029s)
Chars 34639 - 34667 [refine~(O_rec_beta~_~_~@~_).] 0.004 secs (0.003u,0.s)
Chars 34674 - 34703 [exact~(ap~_~(inv_V~_~@@~1))^.] 0.004 secs (0.004u,0.s)
Chars 34558 - 34632 [(intros~[a~p];~unfold~O_functo...] 0.004 secs (0.003u,0.s)
Chars 34639 - 34667 [refine~(O_rec_beta~_~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 34674 - 34703 [exact~(ap~_~(inv_V~_~@@~1))^.] 0.001 secs (0.u,0.s)
Chars 34708 - 34716 [Defined.] 0.011 secs (0.01u,0.s)
Chars 34790 - 34959 [Definition~O_inverts_functor_s...] 0.002 secs (0.001u,0.001s)
Chars 34964 - 34970 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeout(ret [[0.33333333333332099; 0.33333333333334692]])
(ret [[0.39052428152232477; 0.3905243021208048]])
(ret [[0.39051452913860984; 0.39053541828418686]])
(ret [[0.40546510799655183; 0.40546510821793463]])
(ret [[0.40546510810804604; 0.40546510810828312]])
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout     = ("nondet_xor",
        (["w"], ["out"], bedrock_func_body:(
           stackalloc 8 as $"bs";
           $"idx" = $0;
           $"undef" = load1($"bs" + $1 * $0);
           $"out" = $"w";
           $"out" = $"undef" ^ $"out";
           $"out" = $"undef" ^ $"out")))
     : bedrock_func
find_witness Control.TimeoutChars 34977 - 35025 [(apply~O_inverts_from_extendab...] 40.152 secs (0.002u,0.029s)
Chars 35032 - 35078 [(apply~ooextendable_functor_si...] 0.002 secs (0.002u,0.s)
Chars 35085 - 35125 [(nrapply~ooextendable_O_invert...] 0.007 secs (0.007u,0.s)
Chars 34977 - 35025 [(apply~O_inverts_from_extendab...] 0.001 secs (0.001u,0.s)
Chars 35032 - 35078 [(apply~ooextendable_functor_si...] 0. secs (0.u,0.s)
Chars 35085 - 35125 [(nrapply~ooextendable_O_invert...] 0.001 secs (0.001u,0.s)
Chars 35130 - 35138 [Defined.] 0. secs (0.u,0.s)
Chars 35578 - 35669 [Definition~equiv_O_sigma_O~{A}...] 0.001 secs (0.001u,0.s)
Chars 35765 - 35771 [Proof.] 0. secs (0.u,0.s)
     = ("io_sum",
        ([], [], bedrock_func_body:(
           ($"w1") = $"readw"();
           ($"w2") = $"readw"();
           $"sum" = $"w1" + $"w2";
           $"writew"($"sum"))))
     : bedrock_func
     = "void io_echo(void) {
  uintptr_t w;
  w = readw();
  writew(w);
  return;
}
"
     : string
     = "void io_sum(void) {
  uintptr_t w1, w2, sum;
  w1 = readw();
  w2 = readw();
  sum = (w1)+(w2);
  writew(sum);
  return;
}
"
     : string
     = "uintptr_t io_check(uintptr_t expected) {
  uintptr_t read, err;
  read = readw();
  if ((uintptr_t)((read)==(expected))) {
    writew((uintptr_t)0ULL);
    err = (uintptr_t)0ULL;
  } else {
    writew((uintptr_t)42ULL);
    err = (uintptr_t)42ULL;
  }
  err = (err)+((uintptr_t)1ULL);
  return err;
}
"
     : string
'expQnat_R' is now a registered translation.
find_witness Control.Timeoutfind_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.TimeoutChars 35778 - 35803 [srapply~equiv_adjointify.] 40.141 secs (0.001u,0.03s)
Chars 35810 - 35811 [-] 0. secs (0.u,0.s)
Chars 35812 - 35850 [(apply~O_rec;~intros~[a~op];~r...] 0.003 secs (0.002u,0.s)
Chars 35859 - 35881 [(apply~O_rec;~intros~p).] 0.001 secs (0.001u,0.s)
Chars 35890 - 35911 [exact~(to~O~_~(a;~p)).] 0.001 secs (0.001u,0.s)
Chars 35918 - 35919 [-] 0. secs (0.u,0.s)
Chars 35920 - 35936 [(apply~O_functor).] 0. secs (0.u,0.s)
Chars 35945 - 35995 [exact~(functor_sigma~idmap~(fu...] 0.001 secs (0.001u,0.s)
Chars 36002 - 36003 [-] 0. secs (0.u,0.s)
Chars 36004 - 36040 [(unfold~O_functor;~rapply~O_in...] 0.033 secs (0.022u,0.011s)
Chars 36049 - 36069 [(intros~[a~p];~simpl).] 0.005 secs (0.004u,0.001s)
Chars 36078 - 36130 [(abstract~(repeat~rewrite~O_re...] 0.02 secs (0.018u,0.001s)
Chars 36137 - 36138 [-] 0. secs (0.u,0.s)
Chars 36139 - 36175 [(unfold~O_functor;~rapply~O_in...] 0.01 secs (0.007u,0.003s)
Chars 36184 - 36245 [(intros~[a~op];~revert~op;~rap...] 0.017 secs (0.016u,0.s)
Chars 36254 - 36306 [(abstract~(repeat~rewrite~O_re...] 0.019 secs (0.017u,0.002s)
Chars 35778 - 35803 [srapply~equiv_adjointify.] 0. secs (0.u,0.s)
Chars 35812 - 35850 [(apply~O_rec;~intros~[a~op];~r...] 0. secs (0.u,0.s)
Chars 35859 - 35881 [(apply~O_rec;~intros~p).] 0. secs (0.u,0.s)
Chars 35890 - 35911 [exact~(to~O~_~(a;~p)).] 0. secs (0.u,0.s)
Chars 35920 - 35936 [(apply~O_functor).] 0. secs (0.u,0.s)
Chars 35945 - 35995 [exact~(functor_sigma~idmap~(fu...] 0. secs (0.u,0.s)
Chars 36004 - 36040 [(unfold~O_functor;~rapply~O_in...] 0.002 secs (0.002u,0.s)
Chars 36049 - 36069 [(intros~[a~p];~simpl).] 0.002 secs (0.001u,0.s)
Chars 36078 - 36130 [(abstract~(repeat~rewrite~O_re...] 0.001 secs (0.001u,0.s)
Chars 36139 - 36175 [(unfold~O_functor;~rapply~O_in...] 0.002 secs (0.001u,0.s)
Chars 36184 - 36245 [(intros~[a~op];~revert~op;~rap...] 0.007 secs (0.007u,0.s)
Chars 36254 - 36306 [(abstract~(repeat~rewrite~O_re...] 0.001 secs (0.001u,0.s)
Chars 36311 - 36319 [Defined.] 0.015 secs (0.013u,0.001s)
Chars 36705 - 36825 [#[global]~Instance~inO_equiv~~...] 0. secs (0.u,0.s)
Chars 36830 - 36836 [Proof.] 0. secs (0.u,0.s)
Chars 36843 - 36894 [refine~(inO_equiv_inO~_~(issig...] 18.063 secs (8.03u,-1.639s)
find_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Chars 36843 - 36894 [refine~(inO_equiv_inO~_~(issig...] 40.076 secs (0.015u,0.031s)
Chars 36901 - 37038 [refine~~(inO_equiv_inO~_~~~~~(...] 0.044 secs (0.032u,0.012s)
Chars 37045 - 37149 [transparent~assert~(~c~:~~(pro...] 0.019 secs (0.015u,0.003s)
Chars 37156 - 37157 [{] 0. secs (0.u,0.s)
Chars 37158 - 37197 [(intros~[f~[g~h]];~exact~(h~o~...] 0.032 secs (0.022u,0.009s)
Chars 37198 - 37199 [}] 0. secs (0.u,0.s)
Chars 37206 - 37248 [(pose~(U~:=~hfiber@{k~k}~c~(id...] 0.002 secs (0.u,0.001s)
Chars 37255 - 37291 [refine~(inO_equiv_inO'@{k~k~k}...] 0.307 secs (0.268u,0.032s)
Chars 37365 - 37396 [(unfold~hfiber,~BiInv;~cbn~in~*).] 0.001 secs (0.001u,0.s)
Chars 37403 - 37438 [srefine~(equiv_adjointify~_~_~...] 0.001 secs (0.001u,0.s)
Chars 37445 - 37446 [-] 0. secs (0.u,0.s)
Chars 37447 - 37468 [(intros~[[f~[g~h]]~p]).] 0.004 secs (0.004u,0.s)
Chars 37477 - 37526 [(apply~(equiv_inverse~(equiv_p...] 0.002 secs (0.002u,0.s)
Chars 37535 - 37565 [(destruct~p~as~[p~q];~cbn~in~*).] 0.004 secs (0.003u,0.s)
Chars 37574 - 37615 [(exists~f;~split;~[~exists~h~|...] 0.005 secs (0.005u,0.s)
Chars 37624 - 37651 [all:~(apply~ap10;~assumption).] 0.004 secs (0.004u,0.s)
Chars 37658 - 37659 [-] 0. secs (0.u,0.s)
Chars 37660 - 37685 [(intros~[f~[[g~p]~[h~q]]]).] 0.003 secs (0.003u,0.s)
Chars 37694 - 37716 [(exists~(f,~(h,~g));~cbn).] 0.003 secs (0.003u,0.s)
Chars 37725 - 37771 [(apply~path_prod;~apply~path_a...] 0.006 secs (0.006u,0.s)
Chars 37778 - 37779 [-] 0. secs (0.u,0.s)
Chars 37780 - 37810 [(intros~[f~[[g~p]~[h~q]]];~cbn).] 0.03 secs (0.03u,0.s)
Chars 37819 - 37921 [(apply~(path_sigma'~_~1);~appl...] 0.025 secs (0.025u,0.s)
Chars 37930 - 37957 [1:~(rewrite~ap_fst_path_prod).] 0.004 secs (0.004u,0.s)
Chars 37966 - 37993 [2:~(rewrite~ap_snd_path_prod).] 0.004 secs (0.004u,0.s)
Chars 38002 - 38072 [all:~(apply~path_forall;~intro...] 0.051 secs (0.035u,0.015s)
Chars 38079 - 38080 [-] 0. secs (0.u,0.s)
Chars 38081 - 38093 [(intros~fghp).] 0.008 secs (0.008u,0.s)
Chars 38094 - 38098 [(cbn).] 0.016 secs (0.016u,0.s)
Chars 38107 - 38136 [(apply~(path_sigma'~_~1);~cbn).] 0.005 secs (0.005u,0.s)
Chars 38145 - 38218 [(refine~(_~@~eta_path_prod~(pr...] 0.01 secs (0.01u,0.s)
Chars 36843 - 36894 [refine~(inO_equiv_inO~_~(issig...] 0. secs (0.u,0.s)
Chars 36901 - 37038 [refine~~(inO_equiv_inO~_~~~~~(...] 0. secs (0.u,0.s)
Chars 37045 - 37149 [transparent~assert~(~c~:~~(pro...] 0. secs (0.u,0.s)
Chars 37158 - 37197 [(intros~[f~[g~h]];~exact~(h~o~...] 0. secs (0.u,0.s)
Chars 37206 - 37248 [(pose~(U~:=~hfiber@{k~k}~c~(id...] 0. secs (0.u,0.s)
Chars 37255 - 37291 [refine~(inO_equiv_inO'@{k~k~k}...] 0. secs (0.u,0.s)
Chars 37365 - 37396 [(unfold~hfiber,~BiInv;~cbn~in~*).] 0. secs (0.u,0.s)
Chars 37403 - 37438 [srefine~(equiv_adjointify~_~_~...] 0. secs (0.u,0.s)
Chars 37447 - 37468 [(intros~[[f~[g~h]]~p]).] 0. secs (0.u,0.s)
Chars 37477 - 37526 [(apply~(equiv_inverse~(equiv_p...] 0. secs (0.u,0.s)
Chars 37535 - 37565 [(destruct~p~as~[p~q];~cbn~in~*).] 0.001 secs (0.001u,0.s)
Chars 37574 - 37615 [(exists~f;~split;~[~exists~h~|...] 0.002 secs (0.002u,0.s)
Chars 37624 - 37651 [all:~(apply~ap10;~assumption).] 0.002 secs (0.002u,0.s)
Chars 37660 - 37685 [(intros~[f~[[g~p]~[h~q]]]).] 0. secs (0.u,0.s)
Chars 37694 - 37716 [(exists~(f,~(h,~g));~cbn).] 0.001 secs (0.001u,0.s)
Chars 37725 - 37771 [(apply~path_prod;~apply~path_a...] 0.003 secs (0.003u,0.s)
Chars 37780 - 37810 [(intros~[f~[[g~p]~[h~q]]];~cbn).] 0.007 secs (0.007u,0.s)
Chars 37819 - 37921 [(apply~(path_sigma'~_~1);~appl...] 0.014 secs (0.014u,0.s)
Chars 37930 - 37957 [1:~(rewrite~ap_fst_path_prod).] 0.001 secs (0.001u,0.s)
Chars 37966 - 37993 [2:~(rewrite~ap_snd_path_prod).] 0.001 secs (0.001u,0.s)
Chars 38002 - 38072 [all:~(apply~path_forall;~intro...] 0.006 secs (0.006u,0.s)
Chars 38081 - 38093 [(intros~fghp).] 0.004 secs (0.004u,0.s)
Chars 38094 - 38098 [(cbn).] 0.013 secs (0.013u,0.s)
Chars 38107 - 38136 [(apply~(path_sigma'~_~1);~cbn).] 0.003 secs (0.003u,0.s)
Chars 38145 - 38218 [(refine~(_~@~eta_path_prod~(pr...] 0.005 secs (0.005u,0.s)
Chars 38223 - 38231 [Defined.] 0.053 secs (0.053u,0.s)
Chars 38258 - 38344 [Definition~inO_paths@{i~j}~(S~...] 0. secs (0.u,0.s)
Chars 38349 - 38355 [Proof.] 0. secs (0.u,0.s)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
recRel_prettify_arith_step
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
recRel_prettify_arith_step
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
recRel_prettify_arith_step
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
recRel_prettify_arith_step
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
Chars 38362 - 38414 [(simple~refine~(inO_to_O_retra...] 40.137 secs (0.003u,0.029s)
Chars 38421 - 38422 [-] 0. secs (0.u,0.s)
Chars 38423 - 38474 [(assert~(p~:~(fun~_~:~O~(x~=~y...] 0.001 secs (0.001u,0.s)
Chars 38483 - 38484 [{] 0. secs (0.u,0.s)
Chars 38485 - 38518 [(refine~(O_indpaths~_~_~_);~si...] 0.002 secs (0.002u,0.s)
Chars 38529 - 38546 [(intro~v;~exact~v).] 0. secs (0.u,0.s)
Chars 38547 - 38548 [}] 0. secs (0.u,0.s)
Chars 38557 - 38569 [exact~(p~u).] 0. secs (0.u,0.s)
Chars 38576 - 38577 [-] 0. secs (0.u,0.s)
Chars 38578 - 38584 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 38593 - 38630 [(rewrite~O_indpaths_beta;~refl...] 0.003 secs (0.003u,0.s)
Chars 38362 - 38414 [(simple~refine~(inO_to_O_retra...] 0.001 secs (0.001u,0.s)
Chars 38423 - 38474 [(assert~(p~:~(fun~_~:~O~(x~=~y...] 0. secs (0.u,0.s)
Chars 38485 - 38518 [(refine~(O_indpaths~_~_~_);~si...] 0. secs (0.u,0.s)
Chars 38529 - 38546 [(intro~v;~exact~v).] 0. secs (0.u,0.s)
Chars 38557 - 38569 [exact~(p~u).] 0. secs (0.u,0.s)
Chars 38578 - 38584 [(simpl).] 0. secs (0.u,0.s)
Chars 38593 - 38630 [(rewrite~O_indpaths_beta;~refl...] 0. secs (0.u,0.s)
Chars 38635 - 38639 [Qed.] 0.003 secs (0.003u,0.s)
Chars 38644 - 38679 [#[global]Existing~Instance~inO...] 0. secs (0.u,0.s)
Chars 38685 - 38776 [Lemma~O_concat~{A~:~Type}~{a0~...] 0.001 secs (0.001u,0.s)
Chars 38781 - 38787 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
recRel_prettify_arith_step
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
recRel_prettify_arith_step
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_BinaryCC)
"open obligation cnstr_BinaryCC0_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted g)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "g"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.Timeoutfind_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted g)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "g"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted g)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "g"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
More readable: initial segment:
Some
With remainder:
[Ast.tRel 1]
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 38794 - 38805 [(intros~p~q).] 40.126 secs (0.001u,0.028s)
Chars 38812 - 38830 [strip_reflections.] 0.016 secs (0.01u,0.001s)
Chars 38837 - 38860 [exact~(to~O~_~(p~@~q)).] 0.001 secs (0.001u,0.s)
Chars 38794 - 38805 [(intros~p~q).] 0. secs (0.u,0.s)
Chars 38812 - 38830 [strip_reflections.] 0. secs (0.u,0.s)
Chars 38837 - 38860 [exact~(to~O~_~(p~@~q)).] 0. secs (0.u,0.s)
Chars 38865 - 38873 [Defined.] 0. secs (0.u,0.s)
Chars 39065 - 39132 [#[global]Instance~ishprop_O_is...] 0. secs (0.u,0.s)
Chars 39137 - 39143 [Proof.] 0. secs (0.u,0.s)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted g)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "g"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted g)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "g"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.Timeoutfind_witness Control.TimeoutrecRel_prettify_arith_step
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted g)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "g"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
recRel_prettify_arith_step
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted g)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "g"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted g)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "g"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.TimeoutrecRel_prettify_arith_step
recRel_prettify_arith_step
recRel_prettify_arith_step
recRel_prettify_arith_step
find_witness Control.TimeoutrecRel_prettify_arith_step
Chars 39150 - 39178 [refine~ishprop_isequiv_diag.] 40.183 secs (0.033u,0.031s)
Chars 39185 - 39295 [refine~~(isequiv_homotopic~(O_...] 0.028 secs (0.023u,0.004s)
Chars 39302 - 39336 [(apply~O_indpaths;~intros~x;~s...] 0.018 secs (0.015u,0.003s)
Chars 39343 - 39414 [refine~(ap~(O_prod_cmp~A~A)~(t...] 0.003 secs (0.003u,0.s)
Chars 39421 - 39457 [(unfold~O_prod_cmp;~apply~O_re...] 0.002 secs (0.002u,0.s)
Chars 39150 - 39178 [refine~ishprop_isequiv_diag.] 0. secs (0.u,0.s)
Chars 39185 - 39295 [refine~~(isequiv_homotopic~(O_...] 0. secs (0.u,0.s)
Chars 39302 - 39336 [(apply~O_indpaths;~intros~x;~s...] 0.001 secs (0.001u,0.s)
Chars 39343 - 39414 [refine~(ap~(O_prod_cmp~A~A)~(t...] 0. secs (0.u,0.s)
Chars 39421 - 39457 [(unfold~O_prod_cmp;~apply~O_re...] 0.001 secs (0.001u,0.s)
Chars 39462 - 39470 [Defined.] 0.002 secs (0.002u,0.s)
Chars 39531 - 39612 [#[global]~Instance~inO_istrunc...] 0. secs (0.u,0.s)
Chars 39617 - 39623 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted g)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "g"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.Timeoutfind_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted g)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "g"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Chars 39630 - 39690 [(generalize~dependent~A;~simpl...] 40.16 secs (0.003u,0.029s)
Chars 39697 - 39698 [-] 0. secs (0.u,0.s)
Chars 39899 - 39957 [refine~(inO_equiv_inO~_~equiv_...] 0.124 secs (0.104u,0.019s)
Chars 39964 - 39965 [-] 0. secs (0.u,0.s)
Chars 39966 - 40012 [(change~(In~O~(forall~x~y~:~A,...] 0.001 secs (0.001u,0.s)
Chars 40021 - 40029 [exact~_.] 0.03 secs (0.026u,0.004s)
Chars 39630 - 39690 [(generalize~dependent~A;~simpl...] 0. secs (0.u,0.s)
Chars 39899 - 39957 [refine~(inO_equiv_inO~_~equiv_...] 0. secs (0.u,0.s)
Chars 39966 - 40012 [(change~(In~O~(forall~x~y~:~A,...] 0. secs (0.u,0.s)
Chars 40021 - 40029 [exact~_.] 0. secs (0.u,0.s)
Chars 40034 - 40042 [Defined.] 0.001 secs (0.u,0.s)
Chars 40074 - 40228 [Definition~O_inverts_functor_s...] 0.002 secs (0.002u,0.s)
Chars 40233 - 40239 [Proof.] 0. secs (0.u,0.s)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (I 1 = list2D_to_matrix [[C1]])
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching:
((fun x z : nat => Σ (fun y : nat => ⟨ 0 ∣ x y * ∣ 0 ⟩ y z) 2) = I 1)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
recRel_prettify_arith_step
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(hadamard x 0%nat * (/ √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩) 0%nat 0%nat +
 hadamard x 1%nat * (/ √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩) 1%nat 0%nat =
 ∣ 0 ⟩ x 0%nat)
Crunching: (Cmod2 Hx = 0)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (Cmod2 Hx = 0)
Crunching:
(hadamard x 0%nat * (/ √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩) 0%nat y +
 hadamard x 1%nat * (/ √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩) 1%nat y = 
 ∣ 0 ⟩ x y)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (∣1⟩ = basis_vector 2 1)
Chars 40246 - 40286 [(apply~O_inverts_from_extendab...] 40.154 secs (0.002u,0.029s)
Chars 40293 - 40364 [(apply~extendable_functor_sum;...] 0.006 secs (0.006u,0.s)
Chars 40246 - 40286 [(apply~O_inverts_from_extendab...] 0.001 secs (0.u,0.001s)
Chars 40293 - 40364 [(apply~extendable_functor_sum;...] 0.003 secs (0.002u,0.s)
Chars 40369 - 40377 [Defined.] 0. secs (0.u,0.s)
Chars 40383 - 40588 [Definition~equiv_O_functor_sum...] 0.005 secs (0.005u,0.s)
Chars 40594 - 40706 [Definition~equiv_O_sum~{A}~{B}...] 0.004 secs (0.003u,0.s)
Chars 40740 - 40754 [Section~OCoeq.] 0. secs (0.u,0.s)
Chars 40761 - 40797 [Context~{B~A~:~Type}~(f~g~:~B~...] 0. secs (0.u,0.s)
Chars 40805 - 41086 [Definition~O_inverts_functor_c...] 0.006 secs (0.004u,0.001s)
Chars 41093 - 41099 [Proof.] 0. secs (0.u,0.s)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching: (probability_of_outcome a b = probability_of_outcome b a)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.Timeoutfind_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Crunching:
(forall x : nat -> nat,
 (forall x0 : nat,
  x0 < H3 -> b x0 < H3 /\ x x0 < H3 /\ x (b x0) = x0 /\ b (x x0) = x0) ->
 permutation H3 (a ∘ b)%prg)
Crunching: False
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (Cmod2 Hx = 0)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted a)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching: (n < 0 -> √ (n + l) <= √ n + √ l)
Crunching: (a - b - n = 0)
find_witness Control.TimeoutCrunching: (n < 0 -> √ (n + l) <= √ n + √ l)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted n)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching:
(forall x : nat -> nat,
 (forall x0 : nat,
  x0 < H3 -> b x0 < H3 /\ x x0 < H3 /\ x (b x0) = x0 /\ b (x x0) = x0) ->
 permutation H3 (a ∘ b)%prg)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(probability_of_outcome b c =
 (norm (fun x z : nat => Σ (fun y : nat => ((b) † x y * c y z)%C) a) *
  (norm (fun x z : nat => Σ (fun y : nat => ((b) † x y * c y z)%C) a) * 1))%R)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Crunching: (permutation k H5 -> permutation k (kM ∘ H5)%prg)
Crunching:
((forall r1 r2 : R, r1 < r2 -> ~ r2 < r1) ->
 (forall r1 r2 : R, r1 < r2 \/ r1 > r2 -> r1 <> r2) ->
 forall p q : positive,
 Z.abs_N (Z.rem (Z.pos p) (Z.pos q)) = (N.pos p mod N.pos q)%N)
clear  H0  :  (False -> cB (map (rec a1)) a1 = Lt)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching:
(R ->
 R ->
 forall ψ : Vector delta1,
 probability_of_outcome H2 ψ =
 (norm (fun x z : nat => Σ (fun y : nat => ((H2) † x y * ψ y z)%C) delta1)
  ^ 2)%R)
Crunching:
(R ->
 R ->
 forall ψ : Vector delta1,
 probability_of_outcome H2 ψ =
 (norm (fun x z : nat => Σ (fun y : nat => ((H2) † x y * ψ y z)%C) delta1)
  ^ 2)%R)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (n - (n - z) - z = 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Chars 41108 - 41140 [(apply~O_inverts_from_extendab...] 40.153 secs (0.002u,0.029s)
Chars 41149 - 41164 [(intros~Z~Z_inO).] 0.001 secs (0.001u,0.s)
Chars 41173 - 41204 [(apply~extendable_functor_coeq').] 0.002 secs (0.001u,0.s)
Chars 41213 - 41260 [all:~(nrapply~ooextendable_O_i...] 0.018 secs (0.017u,0.s)
Chars 41108 - 41140 [(apply~O_inverts_from_extendab...] 0. secs (0.u,0.s)
Chars 41149 - 41164 [(intros~Z~Z_inO).] 0. secs (0.u,0.s)
Chars 41173 - 41204 [(apply~extendable_functor_coeq').] 0. secs (0.u,0.s)
Chars 41213 - 41260 [all:~(nrapply~ooextendable_O_i...] 0.003 secs (0.003u,0.s)
Chars 41267 - 41275 [Defined.] 0.001 secs (0.001u,0.s)
Chars 41283 - 41623 [Definition~equiv_O_functor_coe...] 0.009 secs (0.009u,0.s)
Chars 41631 - 41848 [Definition~coeq_cmp~:~Coeq~f~g...] 0.004 secs (0.003u,0.s)
Chars 41856 - 41912 [#[global]Instance~isequiv_O_co...] 0. secs (0.u,0.s)
Chars 41919 - 41925 [Proof.] 0. secs (0.u,0.s)
Crunching: (n - c - H = 0)
Crunching: (1 = 0)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching: False
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (1 = 0)
Crunching: (1 = 0)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
find_witness Control.TimeoutCrunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching: (x < S n -> f x = n -> permutation n (fswap f x n))
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching:
((Hx >= 2 ^ dim)%nat \/ (H1 >= 2 ^ dim)%nat -> pad start dim A Hx H1 = 0)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching: (1 = 0)
Crunching: (1 = 0)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching:
(permutation (b 0)
   (fun i : nat => if i =? 0 then b (b 0) else if i =? b 0 then b 0 else b i))
Crunching:
(permutation (b 0)
   (fun i : nat => if i =? 0 then b (b 0) else if i =? b 0 then b 0 else b i))
out of reach
Tactic call ran for 0.006 secs (0.004u,0.001s) (failure)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
find_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (f ⨂ hadamard × Hx = f ⨂ n)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching:
((fun x0 y : nat => if (x0 =? y) && (x0 <? x) then C1 else 0) =
 big_sum (fun i : nat => basis_vector p i × (basis_vector p i) †) x)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(permutation a
   (fun i : nat => if i =? 0 then b a else if i =? a then b 0 else b i))
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (pad start dim A x e1 = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
find_witness Control.TimeoutCrunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (pad start dim A Hx y = 0)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (pad start dim A Hx y = 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (∣0⟩ = basis_vector 2 0)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pad start dim A Hx y = 0)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.TimeoutCrunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
Chars 41934 - 41964 [rapply~O_inverts_functor_coeq.] 40.193 secs (0.031u,0.036s)
Chars 41934 - 41964 [rapply~O_inverts_functor_coeq.] 0. secs (0.u,0.s)
Chars 41971 - 41979 [Defined.] 0.001 secs (0.001u,0.s)
Chars 41987 - 42123 [Definition~equiv_O_coeq~:~~~O~...] 0.002 secs (0.002u,0.s)
Chars 42131 - 42288 [Definition~equiv_O_coeq_to_O~(...] 0.002 secs (0.002u,0.s)
Chars 42295 - 42301 [Proof.] 0. secs (0.u,0.s)
Crunching: (n ⨂ hadamard × n ⨂ ∣0⟩ = n ⨂ ∣+⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (I 0 x y = Zero x y)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (X ⨂ hadamard × X ⨂ ∣0⟩ = ?y)
Crunching: (I 0 x y = Zero x y)
Crunching: (x < S n -> f x = n -> permutation n (fswap f x n))
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching: (f ⨂ hadamard × n = f ⨂ H2)
find_witness Control.TimeoutCrunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching: False
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Chars 42310 - 42336 [refine~(to_O_natural~_~_).] 10.875 secs (0.002u,0.029s)
Chars 42310 - 42336 [refine~(to_O_natural~_~_).] 0. secs (0.u,0.s)
Chars 42343 - 42351 [Defined.] 0. secs (0.u,0.s)
Chars 42359 - 42527 [Definition~inverse_equiv_O_coe...] 0.003 secs (0.003u,0.s)
Chars 42534 - 42540 [Proof.] 0. secs (0.u,0.s)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.Timeout(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Crunching:
(I (S m) =
 I m
 .+ (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0)
    × (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0) †)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Chars 42549 - 42604 [(apply~moveR_equiv_V;~symmetry...] 1.694 secs (0.004u,0.029s)
Chars 42549 - 42604 [(apply~moveR_equiv_V;~symmetry...] 0.065 secs (0.051u,0.013s)
Chars 42611 - 42619 [Defined.] 0.001 secs (0.001u,0.s)
Chars 42625 - 42635 [End~OCoeq.] 0.012 secs (0.011u,0.s)
Chars 42665 - 42682 [Section~OPushout.] 0. secs (0.u,0.s)
Chars 42689 - 42738 [Context~{A~B~C~:~Type}~(f~:~A~...] 0. secs (0.u,0.s)
Chars 42746 - 43057 [Definition~O_inverts_functor_p...] 0.008 secs (0.006u,0.001s)
Chars 43064 - 43070 [Proof.] 0. secs (0.u,0.s)
Crunching: (∣0⟩ = basis_vector 2 0)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
Chars 43079 - 43139 [(rapply~O_inverts_functor_coeq...] 1.608 secs (0.162u,0.059s)
Chars 43079 - 43139 [(rapply~O_inverts_functor_coeq...] 0.001 secs (0.001u,0.s)
Chars 43146 - 43154 [Defined.] 0.002 secs (0.002u,0.s)
Chars 43162 - 43517 [Definition~equiv_O_pushout~:~~...] 0.01 secs (0.01u,0.s)
Chars 43525 - 43702 [Definition~equiv_O_pushout_to_...] 0.003 secs (0.003u,0.s)
Chars 43709 - 43715 [Proof.] 0. secs (0.u,0.s)
(bytestring.String.String "D"
   (bytestring.String.String "i"
      (bytestring.String.String "d"
         (bytestring.String.String " "
            (bytestring.String.String "n"
               (bytestring.String.String "o"
                  (bytestring.String.String "t"
                     (bytestring.String.String " "
                        (bytestring.String.String "f"
                           (bytestring.String.String "i"
                              (bytestring.String.String "n"
                                 (bytestring.String.String "d"
                                    (bytestring.String.String " "
                                       (bytestring.String.String "a"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "i"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "s"
                                                 (bytestring.String.String
                                                 "t"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "n"
                                                 (bytestring.String.String
                                                 "c" 
                                                 (...))))))))))))))))))))))))
(extracted f)
(bytestring.String.String "o"
   (bytestring.String.String "p"
      (bytestring.String.String "e"
         (bytestring.String.String "n"
            (bytestring.String.String " "
               (bytestring.String.String "o"
                  (bytestring.String.String "b"
                     (bytestring.String.String "l"
                        (bytestring.String.String "i"
                           (bytestring.String.String "g"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "o"
                                          (bytestring.String.String "n"
                                             (bytestring.String.String " "
                                                (bytestring.String.String "v"
                                                 (bytestring.String.String
                                                 "a"
                                                 (bytestring.String.String
                                                 "r"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "f"
                                                 (bytestring.String.String
                                                 "_"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...))))))))))))))))))))))))
find_witness Control.TimeoutCrunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
((Hfalse < 2)%nat -> (H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
Crunching: (prob_partial_meas ψ ϕ = (norm ((ψ ⊗ I (2 ^ d)) † × ϕ) ^ 2)%R)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching:
((forall z : R, cond_positivity z = false <-> z < 0) ->
 (hn0 < 1)%nat -> (σx × ∣ 0 ⟩) h hn0 = ∣ 1 ⟩ h hn0)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) i j = ∣ 1 ⟩ i j)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: ((σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching: ((p < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching:
((Hfalse < 2)%nat -> (H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
Crunching: ((H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
find_witness Control.TimeoutCrunching:
(prob_partial_meas psi2 H8 =
 (norm
    (fun x z : nat =>
     Σ
       (fun y : nat =>
        (((psi2
           ⊗ (fun x0 y0 : nat =>
              if (x0 =? y0) && (x0 <? 2 ^ H) then C1 else 0)) y x) ^* *
         H8 y z)%C) (2 ^ d * 2 ^ H)) ^ 2)%R)
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching:
(forall (ϕ : Vector (2 ^ A)) (ψ : Vector (2 ^ (A + Hxz))),
 prob_partial_meas ϕ ψ =
 (norm
    (fun x z : nat =>
     Σ
       (fun y : nat =>
        (((ϕ
           ⊗ (fun x0 y0 : nat =>
              if (x0 =? y0) && (x0 <? 2 ^ Hxz) then C1 else 0)) y x) ^* *
         ψ y z)%C) (2 ^ A * 2 ^ Hxz)) ^ 2)%R)
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
find_witness Control.TimeoutCrunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
Crunching: (x0 = a x0)
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching: (0 < cos (7 / 8))
Crunching: (0 < cos (7 / 8))
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching: (prob_partial_meas ψ ϕ = (norm ((ψ ⊗ I (2 ^ d)) † × ϕ) ^ 2)%R)
Crunching: (0 < cos (7 / 8))
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching: (0 < cos (7 / 8))
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
Crunching:
((forall z : R, cond_positivity z = false <-> z < 0) ->
 (hn0 < 1)%nat -> (σx × ∣ 0 ⟩) h hn0 = ∣ 1 ⟩ h hn0)
Tactic call ran for 0.008 secs (0.006u,0.002s) (success)
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hz)),
 pad start H5 A × pad start H5 B = pad start H5 (A × B))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (pad 0 x (I 2) = I (2 ^ x))
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching:
((Hfalse < 2)%nat -> (H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
Crunching:
((forall z : R, cond_positivity z = false <-> z < 0) ->
 (hn0 < 1)%nat -> (σx × ∣ 0 ⟩) h hn0 = ∣ 1 ⟩ h hn0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (((R0 < R0)%R -> False) -> S ?x@{n:=0} <= 0)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching: (pad 0 x (I 2) = I (2 ^ x))
More readable: initial segment:
@pair
With remainder:
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) i j = ∣ 1 ⟩ i j)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching:
((0 >= 2 ^ alpha)%nat \/ (0 >= 2 ^ alpha)%nat ->
 pad 0 alpha (I 2) 0%nat 0%nat = 0)
Crunching: ((LE < 2)%nat -> (x < 1)%nat -> (σx × ∣ 0 ⟩) LE x = ∣ 1 ⟩ LE x)
Crunching: ((eps < 1)%nat -> (σx × ∣ 0 ⟩) LE eps = ∣ 1 ⟩ LE eps)
Crunching: (prob_partial_meas ϕ ψ = (norm ((ϕ ⊗ I (2 ^ n)) † × ψ) ^ 2)%R)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) i j = ∣ 1 ⟩ i j)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
find_witness Control.TimeoutCrunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
Crunching: ((σx × ∣ 0 ⟩) i 0%nat = ∣ 1 ⟩ i 0%nat)
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching: (0 < 1 -> σx × ∣ 0 ⟩ = ∣ 1 ⟩)
find_witness Control.TimeoutCrunching: ((σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching: ((σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((p < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching: ((σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
Finished transaction in 73.755 secs (71.691u,1.601s) (successful)
Crunching: ((σx × ∣ 0 ⟩) Hfalse p = ∣ 1 ⟩ Hfalse p)
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Chars 43724 - 43728 [(cbn).] 40.146 secs (0.002u,0.028s)
Chars 43737 - 43757 [rapply~to_O_natural.] 0.003 secs (0.003u,0.s)
Chars 43724 - 43728 [(cbn).] 0. secs (0.u,0.s)
Chars 43737 - 43757 [rapply~to_O_natural.] 0.001 secs (0.001u,0.s)
Chars 43764 - 43772 [Defined.] 0.002 secs (0.002u,0.s)
Chars 43780 - 43957 [Definition~equiv_O_pushout_to_...] 0.003 secs (0.003u,0.s)
Chars 43964 - 43970 [Proof.] 0. secs (0.u,0.s)
Chars 43979 - 43983 [(cbn).] 0.104 secs (0.002u,0.029s)
Chars 43992 - 44012 [rapply~to_O_natural.] 0.003 secs (0.003u,0.s)
Chars 43979 - 43983 [(cbn).] 0. secs (0.u,0.s)
Chars 43992 - 44012 [rapply~to_O_natural.] 0.001 secs (0.u,0.001s)
Chars 44019 - 44027 [Defined.] 0.002 secs (0.002u,0.s)
Chars 44035 - 44223 [Definition~inverse_equiv_O_pus...] 0.013 secs (0.012u,0.s)
Chars 44230 - 44236 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching:
(prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (y / 1)%nat * H11 (x mod 2 ^ t) (y mod 1)) =
 probability_of_outcome l2 H0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(sum_over_list (alp_f2t2 ++ H14) =
 (sum_over_list alp_f2t2 + sum_over_list H14)%R)
Crunching:
(forall (ϕ ψ1 : Vector (2 ^ 0)) (ψ2 : Vector (2 ^ H'1)),
 Pure_State_Vector ψ2 ->
 prob_partial_meas ϕ
   (fun x y : nat =>
    ψ1 (x / 2 ^ H'1)%nat (y / 1)%nat * ψ2 (x mod 2 ^ H'1) (y mod 1)) =
 probability_of_outcome ϕ ψ1)
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
Crunching: (list2D_to_matrix [[e]; [e0]] = σy × ∣ 0 ⟩)
More readable: initial segment:
@pair
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         [bytestring.String.String "G"
            (bytestring.String.String "e"
               (bytestring.String.String "n"
                  (bytestring.String.String "e"
                     (bytestring.String.String "r"
                        (bytestring.String.String "i"
                           (bytestring.String.String "c"
                              (bytestring.String.String "N"
                                 (bytestring.String.String "a"
                                    (bytestring.String.String "r"
                                       (bytestring.String.String "y"
                                          bytestring.String.EmptyString))))))))));
          bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       bytestring.String.EmptyString)))))))));
          bytestring.String.String "L" bytestring.String.EmptyString;
          bytestring.String.String "U"
            (bytestring.String.String "n"
               (bytestring.String.String "d"
                  (bytestring.String.String "e"
                     (bytestring.String.String "c"
                        (bytestring.String.String "i"
                           (bytestring.String.String "d"
                              (bytestring.String.String "a"
                                 (bytestring.String.String "b"
                                    (bytestring.String.String "i"
                                       (bytestring.String.String "l"
                                          (bytestring.String.String "i"
                                             (bytestring.String.String "t"
                                                (bytestring.String.String "y"
                                                 bytestring.String.EmptyString)))))))))))))],
       bytestring.String.String "R"
         (bytestring.String.String "t"
            (bytestring.String.String "u"
               (bytestring.String.String "p"
                  (bytestring.String.String "l"
                     (bytestring.String.String "e"
                        bytestring.String.EmptyString))))))
      [Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))));
       Universes.Level.Level
         (bytestring.String.String "C"
            (bytestring.String.String "o"
               (bytestring.String.String "m"
                  (bytestring.String.String "p"
                     (bytestring.String.String "l"
                        (bytestring.String.String "e"
                           (bytestring.String.String "x"
                              (bytestring.String.String "i"
                                 (bytestring.String.String "t"
                                    (bytestring.String.String "y"
                                       (bytestring.String.String "."
                                          (bytestring.String.String "C"
                                             (bytestring.String.String "o"
                                                (bytestring.String.String "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x"
                                                 (bytestring.String.String
                                                 "i"
                                                 (bytestring.String.String
                                                 "t" 
                                                 (...)))))))))))))))))))))])
   [Ast.tApp
      (Ast.tConstruct
         (Kernames.mkInd
            (Kernames.MPfile
               [bytestring.String.String "D"
                  (bytestring.String.String "a"
                     (bytestring.String.String "t"
                        (bytestring.String.String "a"
                           (bytestring.String.String "t"
                              (bytestring.String.String "y"
                                 (bytestring.String.String "p"
                                    (bytestring.String.String "e"
                                       (bytestring.String.String "s"
                                          bytestring.String.EmptyString))))))));
                bytestring.String.String "I"
                  (bytestring.String.String "n"
                     (bytestring.String.String "i"
                        (bytestring.String.String "t"
                           bytestring.String.EmptyString)));
                bytestring.String.String "C"
                  (bytestring.String.String "o"
                     (bytestring.String.String "q"
                        bytestring.String.EmptyString))],
             bytestring.String.String "l"
               (bytestring.String.String "i"
                  (bytestring.String.String "s"
                     (bytestring.String.String "t"
                        bytestring.String.EmptyString)))) 0) 1 [])
      [Ast.tSort
         (Universes.Universe.of_levels
            (inr
               (Universes.Level.Level
                  (bytestring.String.String "C"
                     (bytestring.String.String "o"
                        (bytestring.String.String "m"
                           (bytestring.String.String "p"
                              (bytestring.String.String "l"
                                 (bytestring.String.String "e"
                                    (bytestring.String.String "x"
                                       (bytestring.String.String "i"
                                          (bytestring.String.String "t"
                                             (bytestring.String.String "y"
                                                (bytestring.String.String "."
                                                 (bytestring.String.String
                                                 "C"
                                                 (bytestring.String.String
                                                 "o"
                                                 (bytestring.String.String
                                                 "m"
                                                 (bytestring.String.String
                                                 "p"
                                                 (bytestring.String.String
                                                 "l"
                                                 (bytestring.String.String
                                                 "e"
                                                 (bytestring.String.String
                                                 "x" ...)))))))))))))))))))));
       Ast.tRel 7; Ast.tRel 6]]; Ast.tRel 9; Ast.tRel 0; 
 Ast.tRel 1]
Crunching: (m >= n \/ Hm >= n -> perm_mat n p m Hm = 0%R)
Crunching: (prob_partial_meas q (q' ⊗ WF) <= probability_of_outcome q q')
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Crunching: (x >= a \/ y >= a -> perm_mat a b x y = 0%R)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
Crunching: ((σy × ∣ 0 ⟩) n H = 0)
Crunching: (m >= n -> perm_mat n p m Hm = 0%R)
could not simplify some occuring term, shelved instead
Crunching:
(R_dist (?Un n)
   (big_sum (fun i : nat => nth i (start ++ b) 0) (length (start ++ b))) <
 contra)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Crunching: (WF_Matrix (pad 0 1 (I 2)))
Crunching: (WF_Matrix (pad 0 1 (I 2)))
could not simplify some occuring term, shelved instead
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = σy × ∣ 0 ⟩)
could not simplify some occuring term, shelved instead
Crunching:
((if 0 + 1 <=? alpha
  then I (2 ^ 0) ⊗ I 2 ⊗ I (2 ^ (alpha - (0 + 1)))
  else Zero) = I (2 ^ alpha))
could not simplify some occuring term, shelved instead
Crunching: (0 = cv - n - m)
could not simplify some occuring term, shelved instead
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
could not simplify some occuring term, shelved instead
Crunching: (cv - n - m = 0)
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
Crunching: (0 = cv - n - m)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Crunching: (cv - n - m = 0)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
could not simplify some occuring term, shelved instead
Finished transaction in 14.887 secs (14.499u,0.299s) (successful)
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
Crunching:
(PI / 4 < PI / 2 ->
 forall (ϕ ψ1 : Vector (2 ^ m)) (ψ2 : Vector (2 ^ 0)),
 Pure_State_Vector ψ2 ->
 prob_partial_meas ϕ
   (fun x y : nat =>
    ψ1 (x / 2 ^ 0)%nat (y / 1)%nat * ψ2 (x mod 2 ^ 0) (y mod 1)) =
 probability_of_outcome ϕ ψ1)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Crunching: (pad 0 0 (I 2) = I (2 ^ 0))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (m >= n \/ Hm >= n -> perm_mat n p m Hm = 0%R)
Crunching: (∣1⟩ = basis_vector 2 1)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Crunching: (∣0⟩ = basis_vector 2 0)
More readable: initial segment:
[]
With remainder:
[]
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
could not simplify some occuring term, shelved instead
find_witness Control.TimeoutMore readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
find_witness Control.TimeoutMore readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(Pure_State_Vector H6 ->
 prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (y / 1)%nat * H6 (x mod 2 ^ t) (y mod 1)) =
 probability_of_outcome l2 H0)
clear  H1  :  (False -> b1 = false)
Crunching:
(Pure_State_Vector abs ->
 prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (y / 1)%nat * abs (x mod 2 ^ t) (y mod 1)) =
 probability_of_outcome l2 H0)
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
Crunching:
(prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (y / 1)%nat * H11 (x mod 2 ^ t) (y mod 1)) =
 probability_of_outcome l2 H0)
Crunching:
(prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (fst (Nat.divmod y 0 0 0)) * H11 (x mod 2 ^ t) 0%nat) =
 probability_of_outcome l2 H0)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Crunching:
(- 0 <
 big_sum (fun i : nat => match i with
                         | 0%nat => x
                         | S m => nth m y 0
                         end) (length y) +
 match length y with
 | 0%nat => x
 | S m => nth m y 0
 end)
could not simplify some occuring term, shelved instead
Crunching:
(prob_partial_meas l2
   (fun x y : nat =>
    H0 (x / 2 ^ t)%nat (fst (Nat.divmod y 0 0 0)) * abs (x mod 2 ^ t) 0%nat) =
 probability_of_outcome l2 H0)
could not simplify some occuring term, shelved instead
Crunching:
(- 0 <= big_sum (fun i : nat => nth i (x :: y) 0) (length (x :: y)))
could not simplify some occuring term, shelved instead
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
could not simplify some occuring term, shelved instead
Crunching: ((σy × ∣ 0 ⟩) 0%nat 0%nat = 0)
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
Crunching:
(forall (ϕ ψ1 : Vector (2 ^ 0)) (ψ2 : Vector (2 ^ H'1)),
 Pure_State_Vector ψ2 ->
 prob_partial_meas ϕ
   (fun x y : nat =>
    ψ1 (x / 2 ^ H'1)%nat (y / 1)%nat * ψ2 (x mod 2 ^ H'1) (y mod 1)) =
 probability_of_outcome ϕ ψ1)
More readable: initial segment:
[]
With remainder:
[]
Crunching: ((σy × ∣ 0 ⟩) 0%nat 0%nat = 0)
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(forall ψ2 : Vector (2 ^ H'1),
 Pure_State_Vector ψ2 ->
 prob_partial_meas Hyp_a
   (fun x y : nat =>
    abs (x / 2 ^ H'1)%nat (y / 1)%nat * ψ2 (x mod 2 ^ H'1) (y mod 1)) =
 probability_of_outcome Hyp_a abs)
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
More readable: initial segment:
[]
With remainder:
[]
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
Crunching: (1%R = 1%R -> 1%R = 1%R -> perm_mat n m 0 H4 = 0%R)
More readable: initial segment:
[]
With remainder:
[]
Crunching: ((σy × ∣ 0 ⟩) 0%nat 0%nat = 0)
Crunching: (forall x y z : R, y <= z - x -> x + y <= z)
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
could not simplify some occuring term, shelved instead
Crunching: (forall x y z : R, y <= z - x -> x + y <= z)
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Crunching: ((σy × ∣ 0 ⟩) 0%nat 0%nat = 0)
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(0%nat = m ->
 0 + σy 0%nat 0%nat * match m with
                      | 0%nat => C1
                      | S _ => 0
                      end +
 σy 0%nat 1%nat * match m with
                  | 0%nat | _ => 0
                  end = 0)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
More readable: initial segment:
[]
With remainder:
[]
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Chars 44245 - 44309 [(apply~moveR_equiv_V;~symmetry...] 40.157 secs (0.004u,0.031s)
Chars 44245 - 44309 [(apply~moveR_equiv_V;~symmetry...] 0.002 secs (0.002u,0.s)
Chars 44316 - 44320 [Qed.] 0.002 secs (0.001u,0.001s)
Chars 44328 - 44516 [Definition~inverse_equiv_O_pus...] 0.013 secs (0.012u,0.s)
Chars 44523 - 44529 [Proof.] 0. secs (0.u,0.s)
Chars 44538 - 44602 [(apply~moveR_equiv_V;~symmetry...] 0.159 secs (0.006u,0.028s)
Chars 44538 - 44602 [(apply~moveR_equiv_V;~symmetry...] 0.002 secs (0.002u,0.s)
Chars 44609 - 44613 [Qed.] 0.001 secs (0.001u,0.s)
Chars 44619 - 44632 [End~OPushout.] 0.012 secs (0.012u,0.s)
could not simplify some occuring term, shelved instead
Finished transaction in 24.516 secs (24.33u,0.157s) (successful)
could not simplify some occuring term, shelved instead
Chars 44636 - 44646 [End~Types.] 0.293 secs (0.271u,0.021s)
Chars 44650 - 44668 [Section~Decidable.] 0. secs (0.u,0.s)
Chars 44745 - 44835 [#[global]~Instance~decidable_O...] 0. secs (0.u,0.s)
Chars 44840 - 44846 [Proof.] 0. secs (0.u,0.s)
Crunching: ((r0 < 1)%nat -> (σz × ∣ 0 ⟩) r r0 = ∣ 0 ⟩ r r0)
Crunching: (∣0⟩ = basis_vector 2 0)
More readable: initial segment:
[]
With remainder:
[]
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall j : nat,
 (H0 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H0 j = ∣ 0 ⟩ H0 j)
Crunching: (1%R = 1%R -> 1%R = 1%R -> perm_mat n m 0 H4 = 0%R)
Crunching:
(forall j : nat,
 (s2 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) s2 j = ∣ 0 ⟩ s2 j)
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> WF_Unitary (perm_mat n p))
More readable: initial segment:
[]
With remainder:
[]
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> WF_Unitary (perm_mat n p))
More readable: initial segment:
[]
With remainder:
[]
Crunching:
(forall j : nat,
 (H1 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H1 j = ∣ 0 ⟩ H1 j)
find_witness Control.TimeoutCrunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
Crunching: ((r0 < 1)%nat -> (σz × ∣ 0 ⟩) r r0 = ∣ 0 ⟩ r r0)
could not simplify some occuring term, shelved instead
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
could not simplify some occuring term, shelved instead
Crunching: (pad_u n v le x y = 0)
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> WF_Unitary (perm_mat n p))
Crunching:
(forall j : nat,
 (H0 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H0 j = ∣ 0 ⟩ H0 j)
could not simplify some occuring term, shelved instead
could not simplify some occuring term, shelved instead
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Finished transaction in 9.798 secs (9.671u,0.116s) (successful)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(forall j : nat,
 (s2 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) s2 j = ∣ 0 ⟩ s2 j)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (up (INR n) = Z.succ (Z.of_nat n) -> WF_Unitary (perm_mat n p))
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
could not simplify some occuring term, shelved instead
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((forall (x : R) (n : nat), cos_approx x n = cos_approx (- x) n) -> False)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (~ (forall r : R, (sample r0 r <= length r0)%nat))
could not simplify some occuring term, shelved instead
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
Crunching:
(forall j : nat,
 (l1' < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) l1' j = ∣ 0 ⟩ l1' j)
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (pad_u n v le V0 H11 = 0)
Crunching:
((l1' < 2)%nat ->
 (e < 1)%nat ->
 0 + σz l1' 0%nat * match e with
                    | 0%nat => C1
                    | S _ => 0
                    end + σz l1' 1%nat * match e with
                                         | 0%nat | _ => 0
                                         end = ∣0⟩ l1' e)
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Crunching:
((l1' < 2)%nat ->
 (e < 1)%nat ->
 0 + σz l1' 0%nat * match e with
                    | 0%nat => C1
                    | S _ => 0
                    end + σz l1' 1%nat * match e with
                                         | 0%nat | _ => 0
                                         end = ∣0⟩ l1' e)
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((l1' < 2)%nat ->
 (e < 1)%nat ->
 0 + σz l1' 0%nat * match e with
                    | 0%nat => C1
                    | S _ => 0
                    end + σz l1' 1%nat * match e with
                                         | 0%nat | _ => 0
                                         end = ∣0⟩ l1' e)
Crunching: (pad_u n v le V0 H11 = 0)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
could not simplify some occuring term, shelved instead
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(forall j : nat,
 (H17 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H17 j = ∣ 0 ⟩ H17 j)
could not simplify some occuring term, shelved instead
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((H17 < 2)%nat -> (He < 1)%nat -> (σz × ∣ 0 ⟩) H17 He = ∣ 0 ⟩ H17 He)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (sample a EQ <= length a)%nat
find_witness Control.TimeoutCrunching: (~ (forall r : R, (sample r0 r <= length r0)%nat))
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (1 <= 4)
Crunching:
((x < 2)%nat ->
 (n < 1)%nat -> Σ (fun y : nat => σz x y * ∣ 0 ⟩ y n) 2 = ∣ 0 ⟩ x n)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (perm_mat Hn H s2 n = 0%R)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Crunching: (perm_mat Hn H s2 n = 0%R)
Building all_base_and_interp...
Building index_of_ident...
Crunching: (perm_mat Hn H s2 n = 0%R)
Crunching: (perm_mat Hn H s2 n = 0%R)
Crunching: (perm_mat Hn H s2 n = 0%R)
Crunching: (perm_mat Hn H s2 n = 0%R)
rewrite if_dtt
if (pA a)
then (fun E : pA a = true => p (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
Crunching: ((x < 2)%nat -> (n < 1)%nat -> (σz × ∣ 0 ⟩) x n = ∣ 0 ⟩ x n)
Crunching:
((x < 2)%nat -> (0 < 1)%nat -> (σz × ∣ 0 ⟩) x 0%nat = ∣ 0 ⟩ x 0%nat)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> WF_Unitary (perm_mat n p))
could not simplify some occuring term, shelved instead
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Finished transaction in 22.984 secs (22.732u,0.117s) (successful)
Crunching:
(forall j : nat,
 (H1 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H1 j = ∣ 0 ⟩ H1 j)
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (sample (r :: r0) H0 <= length (r :: r0))%nat
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: ((m < 1)%nat -> (σz × ∣ 0 ⟩) H1 m = ∣ 0 ⟩ H1 m)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Chars 44853 - 44879 [(destruct~(dec~A)~as~[y|~n]).] 40.152 secs (0.002u,0.029s)
Chars 44886 - 44887 [-] 0. secs (0.u,0.s)
Chars 44888 - 44911 [exact~(inl~(to~O~A~y)).] 0.001 secs (0.001u,0.s)
Chars 44918 - 44919 [-] 0. secs (0.u,0.s)
Chars 44920 - 44942 [exact~(inr~(O_rec~n)).] 0.001 secs (0.u,0.s)
Chars 44853 - 44879 [(destruct~(dec~A)~as~[y|~n]).] 0. secs (0.u,0.s)
Chars 44888 - 44911 [exact~(inl~(to~O~A~y)).] 0. secs (0.u,0.s)
Chars 44920 - 44942 [exact~(inr~(O_rec~n)).] 0. secs (0.u,0.s)
Chars 44947 - 44955 [Defined.] 0. secs (0.u,0.s)
Chars 45027 - 45102 [Definition~O_decidable~(A~:~Ty...] 0. secs (0.u,0.s)
Chars 45107 - 45113 [Proof.] 0. secs (0.u,0.s)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((- b + 0)%R = (- b)%R ->
 (0 + - b)%R = (- b)%R -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
could not simplify some occuring term, shelved instead
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(forall y : nat,
 (0 >= 2 ^ l)%nat \/ (y >= 2 ^ l)%nat -> pad_ctrl l IN f z1 0%nat y = 0)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => IZR (Z.succ (-1))
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => IZR (Z.succ (-1))
             end
  | S (S _) => IZR (Z.succ (-1))
  end) × ∣ b ⟩)
could not simplify some occuring term, shelved instead
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((- b + 0)%R = (- b)%R ->
 (0 + - b)%R = (- b)%R -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift e2 × ∣ b ⟩)
Crunching: (forall b : bool, phase_shift e2 × ∣ b ⟩ = Cexp (b * e2) .* ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift e2 × ∣ b ⟩)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((phase_shift m × ∣ ϕ ⟩) 0%nat 0%nat = (Cexp (ϕ * m) .* ∣ ϕ ⟩) 0%nat 0%nat)
Crunching:
((phase_shift m × ∣ contra ⟩) 0%nat 0%nat =
 (Cexp (contra * m) .* ∣ contra ⟩) 0%nat 0%nat)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Crunching:
((phase_shift m × ∣ a ⟩) 0%nat 0%nat = (Cexp (a * m) .* ∣ a ⟩) 0%nat 0%nat)
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => IZR (Z.succ (-1))
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => IZR (Z.succ (-1))
             end
  | S (S _) => IZR (Z.succ (-1))
  end) × ∣ b ⟩)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 g)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ g)%prg)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Crunching:
((- b + 0)%R = (- b)%R ->
 (0 + - b)%R = (- b)%R -> Cexp (b * θ) .* ∣ b ⟩ = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (perm_mat 0 (EQ ∘ psi1)%prg = list2D_to_matrix [])
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (perm_mat 0 (EQ ∘ psi1)%prg = list2D_to_matrix [])
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((- b + 0)%R = (- b)%R ->
 (0 + - b)%R = (- b)%R -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((- b + √ 0)%R = (- b)%R ->
 (√ 0 + - b)%R = (- b)%R -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
Tactic call ran for 0.011 secs (0.01u,0.s) (success)
Crunching: (S (sample l' alp_f1d) <= length l')%nat
Building all_idents...
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Crunching: (perm_mat Hyp n × perm_mat Hyp H = perm_mat Hyp (n ∘ H)%prg)
Building ident_is_var_like...
Crunching: (perm_mat Hyp n × perm_mat Hyp H = perm_mat Hyp (n ∘ H)%prg)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
find_witness Control.TimeoutCrunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Building eqv_Reflexive_Proper...
Crunching: (S (sample l' alp_f1d) <= length l')%nat
Tactic call ran for 0.022 secs (0.014u,0.008s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift op × ∣ n ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift e2 × ∣ b ⟩)
Crunching: (forall b : bool, phase_shift e2 × ∣ b ⟩ = Cexp (b * e2) .* ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift e2 × ∣ b ⟩)
Building ident_interp_Proper...
Building invertIdent...
Crunching: (∣1⟩ = basis_vector 2 1)
Building buildInvertIdentCorrect...
Crunching: (0 <= E1 < sum_over_list [] -> (0 < 0)%nat)
Building base_default...
Building package...
Crunching:
((phase_shift m × ∣ ϕ ⟩) 0%nat 0%nat = (Cexp (ϕ * m) .* ∣ ϕ ⟩) 0%nat 0%nat)
Crunching:
((phase_shift m × ∣ contra ⟩) 0%nat 0%nat =
 (Cexp (contra * m) .* ∣ contra ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift m × ∣ contra ⟩)
Crunching:
(forall y : nat,
 (r >= 2 ^ start)%nat \/ (y >= 2 ^ start)%nat -> pad_ctrl start b p q r y = 0)
Crunching:
(n = 0 ->
 forall g : nat -> nat,
 permutation 0 g -> perm_mat 0 m × perm_mat 0 g = perm_mat 0 (m ∘ g)%prg)
Crunching:
((phase_shift m × ∣ a ⟩) 0%nat 0%nat = (Cexp (a * m) .* ∣ a ⟩) 0%nat 0%nat)
Tactic call ran for 0.011 secs (0.011u,0.s) (success)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => IZR (Z.succ (-1))
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => IZR (Z.succ (-1))
             end
  | S (S _) => IZR (Z.succ (-1))
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => IZR (Z.succ (-1))
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => IZR (Z.succ (-1))
             end
  | S (S _) => IZR (Z.succ (-1))
  end) × ∣ b ⟩)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (forall m n : nat, WF_Matrix (pad_swap Hfalse m n))
Crunching: (ConstructiveCauchyReals.CRealLtProp (Rrepr 0) (Rrepr 0))
Crunching: False
Finished transaction in 42.592 secs (2.067u,0.221s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 g)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ g)%prg)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (perm_mat 0 (EQ ∘ psi1)%prg = list2D_to_matrix [])
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
out of reach
Tactic call ran for 0.006 secs (0.005u,0.001s) (failure)
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (perm_mat 0 (EQ ∘ psi1)%prg = list2D_to_matrix [])
Crunching: (list2D_to_matrix [] = perm_mat 0 EQ × perm_mat 0 psi1)
Crunching: (list2D_to_matrix [] = perm_mat 0 (EQ ∘ psi1)%prg)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Finished transaction in 1.605 secs (1.589u,0.013s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
simplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0 => 0
    | S n' => (big_sum G H f n' + f n')%G
    end) C C_is_monoid
   (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp n y0 y)%C) Hyp =
 perm_mat Hyp (m ∘ n)%prg x y)
simplified dependent [if false]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
Crunching: nat
Crunching: (pad_swap m x n x0 0%nat = 0)
Chars 45120 - 45150 [(destruct~(dec~(O~A))~as~[y|~n]).] 40.144 secs (0.001u,0.03s)
Chars 45157 - 45158 [-] 0. secs (0.u,0.s)
Chars 45159 - 45183 [exact~(O_functor~inl~y).] 0.001 secs (0.001u,0.s)
Chars 45190 - 45191 [-] 0. secs (0.u,0.s)
Chars 45192 - 45217 [refine~(O_functor~inr~_).] 0.001 secs (0.001u,0.s)
Chars 45226 - 45245 [(apply~to;~intros~a).] 0. secs (0.u,0.s)
Chars 45254 - 45275 [exact~(n~(to~O~A~a)).] 0.001 secs (0.001u,0.s)
Chars 45120 - 45150 [(destruct~(dec~(O~A))~as~[y|~n]).] 0. secs (0.u,0.s)
Chars 45159 - 45183 [exact~(O_functor~inl~y).] 0. secs (0.u,0.s)
Chars 45192 - 45217 [refine~(O_functor~inr~_).] 0. secs (0.u,0.s)
Chars 45226 - 45245 [(apply~to;~intros~a).] 0. secs (0.u,0.s)
Chars 45254 - 45275 [exact~(n~(to~O~A~a)).] 0. secs (0.u,0.s)
Chars 45280 - 45288 [Defined.] 0.008 secs (0.001u,0.007s)
Chars 45292 - 45306 [End~Decidable.] 0.008 secs (0.002u,0.005s)
Chars 45310 - 45324 [Section~Monad.] 0. secs (0.u,0.s)
Chars 45330 - 45403 [Definition~O_monad_mult~(A~:~T...] 0.007 secs (0.001u,0.005s)
Chars 45409 - 45539 [Definition~O_monad_mult_natura...] 0.003 secs (0.003u,0.s)
Chars 45544 - 45550 [Proof.] 0. secs (0.u,0.s)
Crunching: (forall m n : nat, WF_Matrix (pad_swap Hfalse m n))
Finished transaction in 1.577 secs (1.569u,0.005s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching:
(Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp =
 perm_mat Hyp (m ∘ ϕ)%prg x y)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching:
(perm_mat Hyp (m ∘ ϕ)%prg x y =
 Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp)
Crunching:
(Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp =
 perm_mat Hyp (m ∘ ϕ)%prg x y)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching:
(perm_mat Hyp (m ∘ ϕ)%prg x y =
 Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
Crunching:
(Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp =
 perm_mat Hyp (m ∘ ϕ)%prg x y)
Crunching:
(perm_mat Hyp (m ∘ ϕ)%prg x y =
 Σ (fun y0 : nat => (perm_mat Hyp m x y0 * perm_mat Hyp ϕ y0 y)%C) Hyp)
out of reach
Tactic call ran for 0.004 secs (0.002u,0.s) (failure)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching:
((hadamard × ∣ b ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ b .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching: (S (sample l' alp_f1d) <= length l')%nat
Crunching: (S (sample l' alp_f1d) <= length l')%nat
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
Crunching:
(fst ((hadamard × ∣ p ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ p .* ∣ 1 ⟩)) x y))
Finished transaction in 3.062 secs (3.047u,0.012s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (m < n)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ p ⟩)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
recRel_prettify_arith_step
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ n ⟩)
recRel_prettify_arith_step
Crunching:
((hadamard × ∣ b ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ b .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching:
(fst ((hadamard × ∣ b ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ b .* ∣ 1 ⟩)) x y))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ b ⟩)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Crunching: (0 < 0)%nat
Crunching: (1 < 0)
recRel_prettify_arith_step
Crunching: (perm_mat L R = I L)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (perm_mat m Streicher_K = I m)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching: (0 <= E1 < sum_over_list [] -> (0 < 0)%nat)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Finished transaction in 4.349 secs (4.315u,0.03s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (sum_over_list [a] <= X -> sample [a] X = length [a])
Crunching:
(fst ((hadamard × ∣ p ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ p .* ∣ 1 ⟩)) x y))
Finished transaction in 132.473 secs (127.605u,3.5s) (successful)
Crunching: (H <= (H10 + Hb) / 2 <= nna)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ p ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ p ⟩)
find_witness Control.TimeoutFinished transaction in 4.332 secs (4.292u,0.035s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching:
(forall x : nat,
 (hadamard × ∣ p ⟩) x = (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ p .* ∣ 1 ⟩)) x)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Crunching: (forall m n : nat, WF_Matrix (pad_swap Hfalse m n))
Crunching: (H4 > 0 -> a < H4)
Finished transaction in 4.401 secs (4.367u,0.03s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (perm_mat L R = I L)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ n ⟩)
Crunching:
((hadamard × ∣ z_ne_0 ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ z_ne_0 .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching: (cos_in 0 (cos 0) -> WF_Unitary Ha -> WF_Unitary (pad n m Ha))
Crunching: (WF_Unitary (pad n m Ha))
Crunching:
((hadamard × ∣ b ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ b .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching:
(fst ((hadamard × ∣ b ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ b .* ∣ 1 ⟩)) x y))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ b ⟩)
Crunching:
((forall r1 r2 : R, r1 > 0 -> r2 > 0 -> r1 * r2 > 0) ->
 hadamard × ∣ b ⟩ =
 (fun x y : nat => / √ 2 * (∣ 0 ⟩ x y + (-1) ^ b * ∣ 1 ⟩ x y)))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ b ⟩)
recRel_prettify_arith_step
Crunching:
((N3 + Hb <= H10)%nat -> WF_Unitary H -> WF_Unitary (pad N3 H10 H))
Finished transaction in 5.749 secs (5.696u,0.046s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (perm_mat m Streicher_K = I m)
Crunching: (1 < 0)
Crunching: (1 < 0)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (perm_mat m Streicher_K = I m)
Crunching: (WF_Unitary (pad HQ0 (HQ0 + l) HQP))
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
find_witness Control.TimeoutCrunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Finished transaction in 5.81 secs (5.697u,0.106s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
find_witness Control.TimeoutCrunching: (perm_mat 0 f = I 0)
Crunching: (I 0 = perm_mat 0 f)
Crunching: (perm_mat 0 f = I 0)
find_witness Control.TimeoutChars 45557 - 45605 [(apply~O_indpaths;~intros~x;~u...] 40.15 secs (0.004u,0.027s)
Chars 45612 - 45651 [(rewrite~(to_O_natural~(O_func...] 0.004 secs (0.004u,0.s)
Chars 45658 - 45687 [(rewrite~(O_rec_beta~idmap~x)).] 0.003 secs (0.002u,0.s)
Chars 45694 - 45737 [(rewrite~(O_rec_beta~idmap~(O_...] 0.003 secs (0.003u,0.s)
Chars 45744 - 45756 [reflexivity.] 0. secs (0.u,0.s)
Chars 45557 - 45605 [(apply~O_indpaths;~intros~x;~u...] 0.001 secs (0.001u,0.s)
Chars 45612 - 45651 [(rewrite~(to_O_natural~(O_func...] 0. secs (0.u,0.s)
Chars 45658 - 45687 [(rewrite~(O_rec_beta~idmap~x)).] 0. secs (0.u,0.s)
Chars 45694 - 45737 [(rewrite~(O_rec_beta~idmap~(O_...] 0. secs (0.u,0.s)
Chars 45744 - 45756 [reflexivity.] 0. secs (0.u,0.s)
Chars 45761 - 45765 [Qed.] 0.004 secs (0.003u,0.s)
Chars 45771 - 45855 [Definition~O_monad_unitlaw1~(A...] 0.001 secs (0.u,0.s)
Chars 45860 - 45866 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 3.064 secs (3.06u,0.001s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Chars 45873 - 45921 [(apply~O_indpaths;~intros~x;~u...] 0.815 secs (0.003u,0.028s)
Chars 45928 - 45964 [exact~(O_rec_beta~idmap~(to~O~...] 0.001 secs (0.001u,0.s)
Chars 45873 - 45921 [(apply~O_indpaths;~intros~x;~u...] 0. secs (0.u,0.s)
Chars 45928 - 45964 [exact~(O_rec_beta~idmap~(to~O~...] 0. secs (0.u,0.s)
Chars 45969 - 45977 [Defined.] 0.001 secs (0.001u,0.s)
Chars 45983 - 46075 [Definition~O_monad_unitlaw2~(A...] 0.001 secs (0.001u,0.s)
Chars 46080 - 46086 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching: (cos_in 0 (cos 0) -> WF_Unitary Ha -> WF_Unitary (pad n m Ha))
Crunching: (WF_Unitary (pad n m Ha))
simplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => F (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
find_witness Control.Timeoutfind_witness Control.TimeoutReifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Assembling rewrite_head_no_dtree...
Crunching: (permutation (2 ^ H12) (qubit_perm_to_nat_perm H12 a))
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.039 secs (0.039u,0.s) (success)
Tactic call ran for 0.337 secs (0.332u,0.003s) (success)
Proving Rewriter_Interp...
Crunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Tactic call ran for 0.604 secs (0.602u,0.s) (success)
Tactic call ran for 0.112 secs (0.112u,0.s) (success)
rewrite if_dtt
if (pA a1)
then (fun E : pA a1 = true => F (exist (fun a0 : A => pA a0 = true) a1 E))
else (fun _ : pA a1 = false => false)
Assembling verified rewriter...
Refining with verified rewriter...
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (permutation (2 ^ H) (qubit_perm_to_nat_perm H a))
find_witness Control.TimeoutCrunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (permutation (2 ^ H12) (qubit_perm_to_nat_perm H12 a))
Crunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Crunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Crunching: (WF_Unitary (pad esp contra Ha))
simplified dependent [if true] in H0
Ha' : (pA a')  = true
if (pA a')
then (fun E : pA a' = true => F (exist (fun a0 : A => pA a0 = true) a' E))
else (fun _ : pA a' = false => false)
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Crunching:
(cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat))
out of reach
Tactic call ran for 0.029 secs (0.029u,0.s) (failure)
Crunching: (pad N1 HN1 H a y = 0)
Crunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
find_witness Control.TimeoutCrunching: (permutation (2 ^ H) (qubit_perm_to_nat_perm H a))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (permutation (2 ^ H12) (qubit_perm_to_nat_perm H12 a))
Crunching:
((N3 + Hb <= H10)%nat -> WF_Unitary H -> WF_Unitary (pad N3 H10 H))
Crunching: (permutation (2 ^ H12) (qubit_perm_to_nat_perm H12 f))
Crunching: (permutation (2 ^ H12) (qubit_perm_to_nat_perm H12 f))
Crunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
Crunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Crunching: False
Crunching: ((-1) ^ (2 * n + 1) = -1)
Crunching:
(permutation H10 p -> permutation (2 ^ H10) (qubit_perm_to_nat_perm H10 p))
Crunching:
(forall (n : nat) (p : nat -> nat),
 permutation n p -> permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Crunching: (permutation (2 ^ n) (qubit_perm_to_nat_perm n p))
Crunching:
(forall x : R,
 sin_in 0² x ->
 forall x0 y : nat,
 (x0 < 2)%nat -> (y < 2)%nat -> cnot × ∣ x0, y ⟩ = ∣ x0, (x0 + y) mod 2 ⟩)
Crunching:
(0%nat <> 2%nat ->
 WF_Matrix (pad_u m Hm a) /\ (pad_u m Hm a) † × pad_u m Hm a = I (2 ^ m))
Crunching:
(cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat))
Crunching:
((fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat) =
 cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ q, q' ⟩)
Crunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
find_witness Control.TimeoutChars 46093 - 46152 [(apply~O_indpaths;~intros~x;~u...] 40.164 secs (0.003u,0.028s)
Chars 46159 - 46185 [(repeat~rewrite~O_rec_beta).] 0.005 secs (0.005u,0.s)
Chars 46192 - 46204 [reflexivity.] 0. secs (0.u,0.s)
Chars 46093 - 46152 [(apply~O_indpaths;~intros~x;~u...] 0.001 secs (0.001u,0.s)
Chars 46159 - 46185 [(repeat~rewrite~O_rec_beta).] 0. secs (0.u,0.s)
Chars 46192 - 46204 [reflexivity.] 0. secs (0.u,0.s)
Chars 46209 - 46213 [Qed.] 0.003 secs (0.003u,0.s)
Chars 46219 - 46349 [Definition~O_monad_mult_assoc~...] 0.002 secs (0.002u,0.s)
Chars 46354 - 46360 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 42.834 secs (2.386u,0.166s) (successful)
Finished transaction in 0.204 secs (0.199u,0.005s) (successful)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Tactic call ran for 0.003 secs (0.002u,0.001s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Finished transaction in 1.952 secs (1.94u,0.008s) (successful)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Finished transaction in 15.337 secs (15.098u,0.139s) (successful)
Crunching:
(ln 1 <= r -> r < sum_over_list l1 -> sample (l1 ++ []) r = sample l1 r)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Chars 46367 - 46426 [(apply~O_indpaths;~intros~x;~u...] 4.677 secs (0.002u,0.03s)
Chars 46433 - 46459 [(repeat~rewrite~O_rec_beta).] 0.007 secs (0.007u,0.s)
Chars 46466 - 46478 [reflexivity.] 0. secs (0.u,0.s)
Chars 46367 - 46426 [(apply~O_indpaths;~intros~x;~u...] 0. secs (0.u,0.s)
Chars 46433 - 46459 [(repeat~rewrite~O_rec_beta).] 0. secs (0.u,0.s)
Chars 46466 - 46478 [reflexivity.] 0. secs (0.u,0.s)
Chars 46483 - 46487 [Qed.] 0.004 secs (0.001u,0.002s)
Chars 46491 - 46501 [End~Monad.] 0.006 secs (0.004u,0.001s)
Chars 46505 - 46525 [Section~StrongMonad.] 0. secs (0.u,0.s)
Chars 46530 - 46552 [Context~{fs~:~Funext}.] 0. secs (0.u,0.s)
Chars 46558 - 46698 [Definition~O_monad_strength~(A...] 0.053 secs (0.036u,0.016s)
Chars 46704 - 46908 [Definition~O_monad_strength_na...] 0.002 secs (0.001u,0.s)
Chars 46913 - 46919 [Proof.] 0. secs (0.u,0.s)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Crunching: (forall x y : R, Rabs x < Rabs y -> y > 0 -> x < y)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Crunching:
(permutation q Hqgt0 ->
 perm_to_matrix q Hqgt0 × f_to_vec q H =
 f_to_vec q (fun x : nat => H (Hqgt0 x)))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall y : nat, (EQ >= 1)%nat \/ (y >= 1)%nat -> pad_u 0 Hm Hn EQ y = 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (WF_Unitary Hn -> WF_Unitary (pad_u 0 Hm Hn))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(Forall (fun x : R => 0 <= x) [] ->
 Forall (fun x : R => 0 <= x) x ->
 sum_over_list [] <= l ->
 sample ([] ++ x) l = (length [] + sample x (l + - sum_over_list []))%nat)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
Crunching:
(0%nat <> 2%nat ->
 WF_Matrix (pad_u m Hm a) /\ (pad_u m Hm a) † × pad_u m Hm a = I (2 ^ m))
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (∣ 0, 0 ⟩ r s = 0)
Crunching: (∣ 0, 0 ⟩ r s = 0)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: ((PI / 4 < PI / 2)%R -> forall y : nat, f lm = f y -> lm = y)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: ((e2 >= 2 * 2)%nat \/ (H2 >= 1 * 1)%nat -> ∣ 0, 0 ⟩ e2 H2 = 0)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.001u,0.s) (success)
Reifying...
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.072 secs (0.07u,0.001s) (success)
Tactic call ran for 0.014 secs (0.014u,0.s) (success)
Tactic call ran for 0.092 secs (0.091u,0.s) (success)
Crunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.026 secs (0.026u,0.s) (success)
Tactic call ran for 0.387 secs (0.382u,0.004s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.399 secs (0.399u,0.s) (success)
Tactic call ran for 0.093 secs (0.093u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
out of reach
Tactic call ran for 0.006 secs (0.005u,0.001s) (failure)
Crunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Finished transaction in 46.877 secs (6.426u,0.173s) (successful)
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
Finished transaction in 0.42 secs (0.411u,0.007s) (successful)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (perm_to_matrix q1 q2 x y * f_to_vec q1 f y z)%C)
    (2 ^ q1)) = f_to_vec q1 (fun x : nat => f (q2 x)))
Crunching:
((fun x z : nat =>
  Σ
    (fun y : nat =>
     (perm_to_matrix q1 q2 x y *
      basis_vector (2 ^ q1) (funbool_to_nat q1 f) y z)%C) 
    (2 ^ q1)) = f_to_vec q1 (fun x : nat => f (q2 x)))
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
(WF_Matrix u ->
 (u) † × u = I 2 ->
 PI / 4 < PI / 2 -> ~ (dim < 0 + (1 + (1 - 0 - 1) + 1))%nat)
Crunching:
((fun x z : nat =>
  Σ
    (fun y : nat =>
     (perm_to_matrix q1 q2 x y *
      basis_vector (2 ^ q1) (funbool_to_nat q1 f) y z)%C) 
    (2 ^ q1)) = f_to_vec q1 (fun x : nat => f (q2 x)))
Crunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz = 0)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
((u ⊗ I (2 ^ (m - 0)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (m - 0)) ⊗ ∣0⟩⟨0∣) z intz = 0)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz = 0)
Crunching:
(0 =
 (u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz)
Crunching:
(0 = (u ⊗ I (2 ^ (m - 0)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (m - 0)) ⊗ ∣0⟩⟨0∣) z intz)
Finished transaction in 3.889 secs (3.877u,0.006s) (successful)
Crunching:
(0 =
 (u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz = 0)
Crunching:
((u ⊗ I (2 ^ (m - 0)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (m - 0)) ⊗ ∣0⟩⟨0∣) z intz = 0)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   z intz = 0)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   a Hab = 0)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
((u ⊗ I (2 ^ (m - 0)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (m - 0)) ⊗ ∣0⟩⟨0∣) a Hab = 0)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
((u ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (S m - 0 - 1)) ⊗ ∣0⟩⟨0∣)
   a H5 = 0)
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
Crunching:
((u ⊗ I (2 ^ (m - 0)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (m - 0)) ⊗ ∣0⟩⟨0∣) a H5 = 0)
Crunching:
(sample (A ++ []) x0 = (length A + sample [] (x0 - sum_over_list A))%nat)
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
Crunching:
(Forall (fun x : R => 0 <= x) A ->
 Forall (fun x : R => 0 <= x) a ->
 sum_over_list A <= q ->
 sample (A ++ a) q = (length A + sample a (q - sum_over_list A))%nat)
Crunching:
(permutation q Hqgt0 ->
 perm_to_matrix q Hqgt0 × f_to_vec q H =
 f_to_vec q (fun x : nat => H (Hqgt0 x)))
Crunching:
(permutation q Hqgt0 ->
 perm_to_matrix q Hqgt0 × f_to_vec q l1 =
 f_to_vec q (fun x : nat => l1 (Hqgt0 x)))
Crunching:
(sample (n ++ IH) a = (length n + sample IH (a - sum_over_list n))%nat)
Crunching:
(sample (n ++ IH) a = (length n + sample IH (a - sum_over_list n))%nat)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(pad 0 dim (u ⊗ I (2 ^ (m - 0)) ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ I (2 ^ (m - 0)) ⊗ ∣0⟩⟨0∣)
   Hs abs = 0)
Chars 46926 - 46939 [(intros~[a~b]).] 40.168 secs (0.002u,0.023s)
Chars 46940 - 46949 [revert~a.] 0. secs (0.u,0.s)
Chars 46950 - 46961 [(apply~ap10).] 0.001 secs (0.u,0.001s)
Chars 46968 - 46986 [strip_reflections.] 0.056 secs (0.049u,0.006s)
Chars 46993 - 47020 [(apply~path_arrow;~intros~a).] 0.002 secs (0.002u,0.s)
Chars 47027 - 47069 [(unfold~O_monad_strength,~O_fu...] 0.003 secs (0.002u,0.001s)
Chars 47076 - 47102 [(repeat~rewrite~O_rec_beta).] 0.013 secs (0.011u,0.002s)
Chars 47109 - 47121 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 46926 - 46939 [(intros~[a~b]).] 0. secs (0.u,0.s)
Chars 46940 - 46949 [revert~a.] 0. secs (0.u,0.s)
Chars 46950 - 46961 [(apply~ap10).] 0. secs (0.u,0.s)
Chars 46968 - 46986 [strip_reflections.] 0. secs (0.u,0.s)
Chars 46993 - 47020 [(apply~path_arrow;~intros~a).] 0.001 secs (0.001u,0.s)
Chars 47027 - 47069 [(unfold~O_monad_strength,~O_fu...] 0.002 secs (0.002u,0.s)
Chars 47076 - 47102 [(repeat~rewrite~O_rec_beta).] 0.001 secs (0.001u,0.s)
Chars 47109 - 47121 [reflexivity.] 0. secs (0.u,0.s)
Chars 47126 - 47130 [Qed.] 0.011 secs (0.008u,0.002s)
Chars 47220 - 47343 [Definition~O_monad_strength_un...] 0.002 secs (0.002u,0.s)
Chars 47348 - 47354 [Proof.] 0. secs (0.u,0.s)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
Crunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
Crunching: (WF_Unitary (perm_to_matrix x xint))
Crunching: (PI_2_3_7_tg (S n) < PI_2_3_7_tg n)
Crunching:
(sample (f ++ []) l = (length f + sample [] (l - sum_over_list f))%nat)
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
Tactic call ran for 0.107 secs (0.104u,0.002s) (success)
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
Finished transaction in 0.446 secs (0.438u,0.005s) (successful)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (WF_Unitary (perm_to_matrix x xint))
Crunching: (WF_Unitary (perm_to_matrix x xint))
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (WF_Unitary (perm_to_matrix x xint))
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (∣1⟩ = basis_vector 2 1)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
Crunching: (∣1⟩ = basis_vector 2 1)
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (a <= sample (repeat 0%R a ++ b) r)%nat
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (n <= sample (repeat 0%R n ++ n_lb) i)%nat
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching:
(list2D_to_matrix [[e]] = (perm_to_matrix 0 p) † × perm_to_matrix 0 p)
Crunching: (list2D_to_matrix [[(perm_to_matrix 0 p 0 0) ^*]] = I 1)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
Chars 47361 - 47375 [(intros~[[]~a]).] 18.898 secs (0.001u,0.031s)
Chars 47376 - 47394 [strip_reflections.] 0.005 secs (0.004u,0.s)
Chars 47401 - 47436 [(unfold~O_monad_strength,~O_fu...] 0. secs (0.u,0.s)
Chars 47437 - 47443 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 47450 - 47469 [(rewrite~O_rec_beta).] 0.003 secs (0.002u,0.s)
Chars 47476 - 47495 [nrapply~O_rec_beta.] 0.002 secs (0.001u,0.s)
Chars 47361 - 47375 [(intros~[[]~a]).] 0. secs (0.u,0.s)
Chars 47376 - 47394 [strip_reflections.] 0. secs (0.u,0.s)
Chars 47401 - 47436 [(unfold~O_monad_strength,~O_fu...] 0. secs (0.u,0.s)
Chars 47437 - 47443 [(simpl).] 0. secs (0.u,0.s)
Chars 47450 - 47469 [(rewrite~O_rec_beta).] 0. secs (0.u,0.s)
Chars 47476 - 47495 [nrapply~O_rec_beta.] 0. secs (0.u,0.s)
Chars 47500 - 47504 [Qed.] 0.003 secs (0.003u,0.s)
Chars 47510 - 47631 [Definition~O_monad_strength_un...] 0.004 secs (0.001u,0.s)
Chars 47636 - 47642 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Crunching: (a <= sample (repeat 0%R a ++ b) r)%nat
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching:
(0 <= H ->
 (2 * Nat.div2 x + Nat.b2n (Nat.odd x) <= sample (repeat 0%R x ++ y) H)%nat)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
find_witness Control.TimeoutMore readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
find_witness Control.TimeoutReifying...
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
Crunching: (WF_Unitary (perm_to_matrix x xint))
Crunching: (WF_Unitary (perm_to_matrix x xint))
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
Crunching: (WF_Unitary (perm_to_matrix x xint))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (WF_Unitary (perm_to_matrix x xint))
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
Crunching:
(WF_Matrix (perm_to_matrix 0 Hn) /\
 (perm_to_matrix 0 Hn) † × perm_to_matrix 0 Hn = I 1)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
(Build_TCCCardP (Sigma:=X))
With remainder:
[]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
Crunching: (n <= sample (repeat 0%R n ++ n_lb) i)%nat
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (∣1⟩ = basis_vector 2 1)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (forall a b : R, 0 <= a <= b -> b * a + a * b <= a * a + b * b)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (WF_Unitary (pad_swap dim m n))
find_witness Control.TimeoutMore readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Crunching: (0 < r -> (a <= sample (repeat 0%R a ++ b) r)%nat)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Reifying...
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (a <= sample (repeat 0%R a ++ b) r)%nat
out of reach
Tactic call ran for 0.003 secs (0.001u,0.s) (failure)
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
More readable: initial segment:
sizeOfTape
With remainder:
[Ast.tRel 3; Ast.tRel 1]
Compiling decision tree...
Splitting rewrite rules...
Crunching: positive
find_witness Control.TimeoutCrunching:
(permutation x q ->
 (qubit_perm_to_nat_perm x q ∘ qubit_perm_to_nat_perm x r)%prg =
 qubit_perm_to_nat_perm x (r ∘ q)%prg)
Assembling rewrite_head...
Reducing rewrite_head...
Crunching: (WF_Unitary (pad_swap dim m n))
Tactic call ran for 0.518 secs (0.505u,0.011s) (success)
Crunching: (0%nat <> 0%nat)
Crunching:
(permutation x q ->
 (qubit_perm_to_nat_perm x q ∘ qubit_perm_to_nat_perm x r)%prg =
 qubit_perm_to_nat_perm x (r ∘ q)%prg)
Tactic call ran for 1.091 secs (1.071u,0.018s) (success)
Crunching:
(0 <= H ->
 (2 * Nat.div2 x + Nat.b2n (Nat.odd x) <= sample (repeat 0%R x ++ y) H)%nat)
Crunching: (0%nat <> 0%nat)
Tactic call ran for 0.157 secs (0.156u,0.s) (success)
find_witness Control.TimeoutAssembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Crunching:
(0 <= H ->
 (2 * Nat.div2 x + Nat.b2n (Nat.odd x) <= sample (repeat 0%R x ++ y) H)%nat)
Proving Rewriter_Wf...
Tactic call ran for 0.568 secs (0.555u,0.011s) (success)
out of reach
Tactic call ran for 0.004 secs (0.001u,0.002s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.002u,0.004s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
Crunching:
(permutation x q ->
 (qubit_perm_to_nat_perm x q ∘ qubit_perm_to_nat_perm x r)%prg =
 qubit_perm_to_nat_perm x (r ∘ q)%prg)
Compiling decision tree...
Splitting rewrite rules...
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
Tactic call ran for 6.036 secs (5.908u,0.117s) (success)
Crunching: ((0 + 1)%R = 1 -> 1 < 0)
Tactic call ran for 0.004 secs (0.003u,0.001s) (success)
Crunching:
(pr_outcome_sum [l1] f = (l1 + pr_outcome_sum [] (fun y : nat => f (S y)))%R)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Crunching:
(pr_outcome_sum (x :: n) Hapart =
 (if Hapart 0%nat
  then (x + pr_outcome_sum n (fun y : nat => Hapart (S y)))%R
  else pr_outcome_sum n (fun y : nat => Hapart (S y))))
Proving Rewriter_Interp...
Chars 47649 - 47662 [(intros~[a~b]).] 40.157 secs (0.001u,0.029s)
Chars 47669 - 47707 [(unfold~O_monad_strength,~func...] 0. secs (0.u,0.s)
Chars 47708 - 47714 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 47721 - 47742 [(revert~a;~apply~ap10).] 0.002 secs (0.002u,0.s)
Chars 47749 - 47768 [nrapply~O_rec_beta.] 0.002 secs (0.002u,0.s)
Chars 47649 - 47662 [(intros~[a~b]).] 0. secs (0.u,0.s)
Chars 47669 - 47707 [(unfold~O_monad_strength,~func...] 0. secs (0.u,0.s)
Chars 47708 - 47714 [(simpl).] 0. secs (0.u,0.s)
Chars 47721 - 47742 [(revert~a;~apply~ap10).] 0.001 secs (0.001u,0.s)
Chars 47749 - 47768 [nrapply~O_rec_beta.] 0. secs (0.u,0.s)
Chars 47773 - 47777 [Qed.] 0.002 secs (0.001u,0.s)
Chars 47783 - 48016 [Definition~O_monad_strength_as...] 0.013 secs (0.01u,0.003s)
Chars 48021 - 48027 [Proof.] 0. secs (0.u,0.s)
Assembling rewrite_head...
Reducing rewrite_head...
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
(permutation q p0 ->
 (qubit_perm_to_nat_perm q p0 ∘ qubit_perm_to_nat_perm q l)%prg =
 qubit_perm_to_nat_perm q (l ∘ p0)%prg)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 1.795 secs (1.776u,0.014s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Fun.Finally_raised: Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
((forall m : nat, (m < H7)%nat -> WF_Unitary (pad_swap (S n) 0 n)) ->
 WF_Unitary (pad_swap (S n) 0 n))
     = (exist (fun k : nat => (k <? 6) = true) 0 eq_refl,
        (exist (fun k : nat => (k <? 5) = true) 0 eq_refl,
         (exist (fun k : nat => (k <? 4) = true) 0 eq_refl,
          (exist (fun k : nat => (k <? 3) = true) 0 eq_refl,
           (exist (fun k : nat => (k <? 2) = true) 0 eq_refl,
            (exist (fun k : nat => (k <? 1) = true) 0 eq_refl, tt))))))
     : decr_list (fun n : nat => ltN (S n)) 6
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
rewrite if_dtt
if
match q with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := a in a) m'
end
then
(fun
   E0 : match q with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := a in a) m'
        end = true =>
 AA
   (exist
      (fun k : nat =>
       match q with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) (let (a, _) := a in a) E0))
else
(fun
   E0 : match q with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := a in a) m'
        end = false =>
 BB
   (exist (fun _ : nat => false = true)
      ((fix sub (n m : nat) {struct n} : nat :=
          match n with
          | 0 => n
          | S k => match m with
                   | 0 => n
                   | S l => sub k l
                   end
          end) (let (a, _) := a in a) q)
      (ltN_split_lemma1
         (let
            (a, b) as e
             return
               (match
                  (fix add (n m : nat) {struct n} : nat :=
                     match n with
                     | 0 => m
                     | S p => S (add p m)
                     end) q 0
                with
                | 0 => false
                | S m' =>
                    (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m'0 => leb n' m'0
                           end
                       end) (let (a, _) := e in a) m'
                end = true) := a in
          b) E0)))
Crunching: positive
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
Crunching: positive
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
out of reach
Tactic call ran for 0.01 secs (0.008u,0.002s) (failure)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 9.768 secs (9.674u,0.078s) (success)
find_witness Control.TimeoutCrunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
find_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (WF_Unitary (pad_swap dim m n))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (0%nat <> 0%nat)
Crunching: (0%nat <> 0%nat)
Crunching: (forall x : nat, (cnot × ∣ 1, 1 ⟩) x = ∣ 1, 0 ⟩ x)
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (0%nat <> 0%nat)
Crunching: (0%nat <> 0%nat)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
Tactic call ran for 6.607 secs (6.48u,0.116s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
(H * m + m * H < m * m + H * H \/ (H * m + m * H)%R = (m * m + H * H)%R)
rewrite if_dtt
if
match q with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := a in a) m'
end
then
(fun
   E0 : match q with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := a in a) m'
        end = true =>
 AA
   (exist
      (fun k : nat =>
       match q with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) (let (a, _) := a in a) E0))
else
(fun
   E0 : match q with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := a in a) m'
        end = false =>
 BB
   (exist (fun _ : nat => false = true)
      ((fix sub (n m : nat) {struct n} : nat :=
          match n with
          | 0 => n
          | S k => match m with
                   | 0 => n
                   | S l => sub k l
                   end
          end) (let (a, _) := a in a) q)
      (ltN_split_lemma1
         (let
            (a, b) as e
             return
               (match
                  (fix add (n m : nat) {struct n} : nat :=
                     match n with
                     | 0 => m
                     | S p => S (add p m)
                     end) q 0
                with
                | 0 => false
                | S m' =>
                    (fix leb (n m : nat) {struct n} : bool :=
                       match n with
                       | 0 => true
                       | S n' =>
                           match m with
                           | 0 => false
                           | S m'0 => leb n' m'0
                           end
                       end) (let (a, _) := e in a) m'
                end = true) := a in
          b) E0)))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (forall x : nat, (cnot × ∣ 1, 1 ⟩) x = ∣ 1, 0 ⟩ x)
Crunching:
(pr_outcome_sum [l1] f = (l1 + pr_outcome_sum [] (fun y : nat => f (S y)))%R)
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
Finished transaction in 38.711 secs (37.951u,0.411s) (successful)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.001s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Finished transaction in 47.357 secs (6.836u,0.2s) (successful)
Crunching:
(pr_outcome_sum [x] Hapart =
 (if Hapart 0%nat
  then (x + pr_outcome_sum [] (fun y : nat => Hapart (S y)))%R
  else pr_outcome_sum [] (fun y : nat => Hapart (S y))))
Crunching:
(pr_outcome_sum (x :: n) Hapart =
 (if Hapart 0%nat
  then (x + pr_outcome_sum n (fun y : nat => Hapart (S y)))%R
  else pr_outcome_sum n (fun y : nat => Hapart (S y))))
Assembling verified rewriter...
Refining with verified rewriter...
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (pad_u Hpr H' A × pad_u Hpr x B = pad_u Hpr x B × pad_u Hpr H' A)
Crunching:
(pr_outcome_sum (s2 :: H1) H2 =
 (if H2 0%nat
  then (s2 + pr_outcome_sum H1 (fun y : nat => H2 (S y)))%R
  else pr_outcome_sum H1 (fun y : nat => H2 (S y))))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Finished transaction in 0.486 secs (0.465u,0.019s) (successful)
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(forall g : nat -> nat,
 permutation 0 Hlen' ->
 permutation 0 g ->
 perm_to_matrix 0 Hlen' × perm_to_matrix 0 g =
 perm_to_matrix 0 (g ∘ Hlen')%prg)
Crunching:
(forall f : nat -> bool,
 pr_outcome_sum (k :: c) f =
 (if f 0%nat
  then (k + pr_outcome_sum c (fun y : nat => f (S y)))%R
  else pr_outcome_sum c (fun y : nat => f (S y))))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: ((cnot × ∣ 1, 1 ⟩) x y = ∣ 1, 0 ⟩ x y)
Crunching: ((cnot × ∣ 1, 1 ⟩) x y = ∣ 1, 0 ⟩ x y)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (pad_u Hpr H' A × pad_u Hpr x B = pad_u Hpr x B × pad_u Hpr H' A)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (forall x : nat, (cnot × ∣ 1, 1 ⟩) x = ∣ 1, 0 ⟩ x)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Finished transaction in 5.105 secs (5.085u,0.01s) (successful)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(pr_outcome_sum (H6 ++ l2) l =
 (pr_outcome_sum H6 l +
  pr_outcome_sum l2 (fun x : nat => l (length H6 + x)%nat))%R)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Tactic call ran for 31.046 secs (30.163u,0.799s) (success)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Tactic call ran for 0.275 secs (0.275u,0.s) (success)
Crunching: (Rmax y r < z <-> y < z /\ r < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(pr_outcome_sum (H6 ++ l2) l =
 (pr_outcome_sum H6 l +
  pr_outcome_sum l2 (fun x : nat => l (length H6 + x)%nat))%R)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(pr_outcome_sum (H6 ++ l2) l =
 (pr_outcome_sum H6 l +
  pr_outcome_sum l2 (fun x : nat => l (length H6 + x)%nat))%R)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Assembling rewrite_head_no_dtree...
Crunching:
(pr_outcome_sum (H6 ++ l2) l =
 (pr_outcome_sum H6 l +
  pr_outcome_sum l2 (fun x : nat => l (length H6 + x)%nat))%R)
Reducing rewrite_head_no_dtree...
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (forall a b : R, 0 <= a <= b -> b * a + a * b <= a * a + b * b)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
out of reach
Tactic call ran for 0.007 secs (0.006u,0.001s) (failure)
Crunching:
(forall f : nat -> bool,
 pr_outcome_sum (H6 ++ H5) f =
 (pr_outcome_sum H6 f +
  pr_outcome_sum H5 (fun x : nat => f (length H6 + x)%nat))%R)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
recRel_prettify_arith_step
Proving Rewriter_Wf...
out of reach
Tactic call ran for 0.011 secs (0.008u,0.002s) (failure)
Crunching:
(forall (l1 l2 : list R) (f : nat -> bool),
 pr_outcome_sum (l1 ++ l2) f =
 (pr_outcome_sum l1 f +
  pr_outcome_sum l2 (fun x : nat => f (length l1 + x)%nat))%R)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(Σ (fun y0 : nat => (perm_to_matrix m n x y0 * perm_to_matrix m o y0 y)%C)
   (2 ^ m) = perm_to_matrix m (fun x : nat => o (n x)) x y)
Tactic call ran for 1.318 secs (1.316u,0.s) (success)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
out of reach
Tactic call ran for 0.012 secs (0.012u,0.s) (failure)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
out of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Chars 48034 - 48051 [(intros~[[a~b]~c]).] 40.17 secs (0.004u,0.028s)
Chars 48058 - 48079 [(revert~a;~apply~ap10).] 0.003 secs (0.002u,0.001s)
Chars 48080 - 48101 [(revert~b;~apply~ap10).] 0.003 secs (0.003u,0.s)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Chars 48108 - 48126 [strip_reflections.] 0.271 secs (0.218u,0.052s)
Chars 48133 - 48160 [(apply~path_arrow;~intros~b).] 0.003 secs (0.003u,0.s)
Chars 48161 - 48188 [(apply~path_arrow;~intros~a).] 0.003 secs (0.003u,0.s)
Chars 48195 - 48244 [(unfold~O_monad_strength,~O_fu...] 0.001 secs (0.001u,0.s)
Chars 48245 - 48251 [(simpl).] 0.004 secs (0.004u,0.s)
Chars 48258 - 48284 [(repeat~rewrite~O_rec_beta).] 0.015 secs (0.012u,0.002s)
Chars 48291 - 48303 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 48034 - 48051 [(intros~[[a~b]~c]).] 0.001 secs (0.001u,0.s)
Chars 48058 - 48079 [(revert~a;~apply~ap10).] 0.001 secs (0.001u,0.s)
Chars 48080 - 48101 [(revert~b;~apply~ap10).] 0.001 secs (0.001u,0.s)
Chars 48108 - 48126 [strip_reflections.] 0. secs (0.u,0.s)
Chars 48133 - 48160 [(apply~path_arrow;~intros~b).] 0.001 secs (0.001u,0.s)
Chars 48161 - 48188 [(apply~path_arrow;~intros~a).] 0.001 secs (0.001u,0.s)
Chars 48195 - 48244 [(unfold~O_monad_strength,~O_fu...] 0. secs (0.u,0.s)
Chars 48245 - 48251 [(simpl).] 0.002 secs (0.002u,0.s)
Chars 48258 - 48284 [(repeat~rewrite~O_rec_beta).] 0.001 secs (0.001u,0.s)
Chars 48291 - 48303 [reflexivity.] 0. secs (0.u,0.s)
Chars 48308 - 48312 [Qed.] 0.018 secs (0.015u,0.002s)
Chars 48318 - 48521 [Definition~O_monad_strength_as...] 0.004 secs (0.003u,0.s)
Chars 48526 - 48532 [Proof.] 0. secs (0.u,0.s)
Crunching:
(forall (l2 : list R) (f : nat -> bool),
 pr_outcome_sum (r :: r0 ++ l2) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum l2 (fun x : nat => f (S (length r0 + x))))%R)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(forall f : nat -> bool,
 pr_outcome_sum (r :: r0 ++ Hxy) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum Hxy (fun x : nat => f (S (length r0 + x))))%R)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
find_witness Control.Timeoutout of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
out of reach
Tactic call ran for 0.017 secs (0.007u,0.009s) (failure)
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (swap × ∣ H5, H'1 ⟩ = ∣ H'1, H5 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(list2D_to_matrix [[e]] = perm_to_matrix 0 Hlen' × perm_to_matrix 0 g)
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 g 0 0]] =
 perm_to_matrix 0 (g ∘ Hlen')%prg)
Crunching:
(forall g : nat -> nat,
 permutation 0 Hlen' ->
 permutation 0 g ->
 perm_to_matrix 0 Hlen' × perm_to_matrix 0 g =
 perm_to_matrix 0 (g ∘ Hlen')%prg)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(pr_outcome_sum (H6 ++ l2) l =
 (pr_outcome_sum H6 l +
  pr_outcome_sum l2 (fun x : nat => l (length H6 + x)%nat))%R)
Crunching:
(forall x y : nat,
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(perm_to_matrix 0 Hlen' × perm_to_matrix 0 x =
 perm_to_matrix 0 (x ∘ Hlen')%prg)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
Tactic call ran for 6.942 secs (6.915u,0.017s) (success)
Crunching: (∣0⟩ = basis_vector 2 0)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = swap × ∣ H5, m ⟩)
Crunching: (swap × ∣ H5, H'1 ⟩ = ∣ H'1, H5 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (swap × ∣ H5, h ⟩ = ∣ h, H5 ⟩)
Crunching:
(permutation Hnm HF ->
 perm_to_matrix Hnm Hpq × perm_to_matrix Hnm HF =
 perm_to_matrix Hnm (HF ∘ Hpq)%prg)
out of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x <= y -> x < z)
Crunching: (x < z)
Crunching:
(forall x y : nat,
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
Crunching: (x <= y -> x < z)
Crunching: (x < z)
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching: (x <= y -> x < z)
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Crunching: (x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching: (x <= y -> x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Proving Rewriter_Interp...
Crunching: (x < z)
Crunching: (x <= y -> x < z)
Crunching: (x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(PI / 4 < PI / 2 ->
 {l : R | derivable_pt_abs (fun x : R => (sin x / cos x)%R) x l})
find_witness Control.TimeoutMore readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x <= y -> x < z)
Crunching: (x < z)
Crunching:
(Σ (fun y : nat => (perm_to_matrix m n 0 y * perm_to_matrix m o y 0)%C)
   (2 ^ m) = perm_to_matrix m (fun x : nat => o (n x)) 0 0)
Crunching:
(Σ (fun y : nat => (perm_to_matrix m n 0 y * perm_to_matrix m o y 0)%C)
   (2 ^ m) = perm_to_matrix m (fun x : nat => o (n x)) 0 0)
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted f)
"open obligation var_f_term for it. You might want to register a instance before and rerun this."
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
out of reach
Tactic call ran for 0.007 secs (0.006u,0.s) (failure)
Crunching:
(PI / 4 < PI / 2 ->
 {l : R | derivable_pt_abs (fun x : R => (sin x / cos x)%R) x l})
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(swap
 × (fun x y : nat =>
    ∣ Hocc ⟩ (x / 2)%nat (y / 1)%nat * ∣ H7 ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ H7 ⟩ (x / 2)%nat (y / 1)%nat * ∣ Hocc ⟩ (x mod 2)%nat (y mod 1)%nat))
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (swap × ∣ ρ, mixed ⟩ = ∣ mixed, ρ ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Tactic call ran for 5.255 secs (5.205u,0.044s) (success)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = swap × ∣ H5, m ⟩)
Crunching: (swap × ∣ H5, H'1 ⟩ = ∣ H'1, H5 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
Crunching: (x <= y -> x < z)
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (forall y : nat, swap × ∣ H5, y ⟩ = ∣ y, H5 ⟩)
Crunching: (x <= y -> x < z)
Crunching: (x < z)
Crunching: (swap × ∣ H5, H'1 ⟩ = ∣ H'1, H5 ⟩)
Tactic call ran for 2.097 secs (2.078u,0.013s) (success)
Crunching: (x <= y -> x < z)
Crunching: (x < z)
Crunching: (swap × ∣ H5, q' ⟩ = ∣ q', H5 ⟩)
Crunching: (swap × ∣ H5, h ⟩ = ∣ h, H5 ⟩)
Crunching: (x <= y -> x < z)
Crunching: (x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x <= y -> x < z)
Crunching: (x < z)
Crunching: (swap × ∣ x0, H7 ⟩ = ∣ H7, x0 ⟩)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x <= y -> x < z)
Crunching: (x < z)
Crunching: (swap × ∣ Hlt, le_mn2 ⟩ = ∣ le_mn2, Hlt ⟩)
Assembling verified rewriter...
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Refining with verified rewriter...
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(perm_to_matrix n f =
 (fun x y : nat => if (x =? y) && (x <? 2 ^ n) then C1 else 0%R))
out of reach
Tactic call ran for 0.007 secs (0.006u,0.s) (failure)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(forall x y : nat,
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
((a >= 4)%nat \/ (n >= 1)%nat ->
 Σ
   (fun y : nat =>
    swap a y *
    (∣ k ⟩ (fst (Nat.divmod y 1 0 1)) (fst (Nat.divmod n 0 0 0)) *
     ∣ s1 ⟩
       match snd (Nat.divmod y 1 0 1) with
       | 0%nat => 1%nat
       | S _ => 0%nat
       end 0%nat)) 4 = 0)
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (x <= y -> x < z)
Crunching: (forall x : nat, perm_to_matrix 0 f x = I 1 x)
Crunching: (x < z)
Crunching: (x <= y -> x < z)
Crunching: (x < z)
Crunching: (x <= y -> x < z)
Crunching: (x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
out of reach
Tactic call ran for 0.021 secs (0.011u,0.008s) (failure)
Crunching: (x <= y -> x < z)
Crunching: (x < z)
Crunching:
(perm_to_matrix n f =
 (fun x y : nat => if (x =? y) && (x <? 2 ^ n) then C1 else 0%R))
Crunching: (x <= y -> x < z)
Crunching: (x < z)
More readable: initial segment:
(canonicalHom (Y:=bool))
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile
         ["CC_to_BinaryCC"; "Reductions"; "CookLevin"; "SAT"; "NP";
          "Complexity"], "hNat") [])
   [Ast.tApp
      (Ast.tConst
         (Kernames.MPfile
            ["FlatCC"; "Subproblems"; "CookLevin"; "SAT"; "NP"; "Complexity"],
          "Sigma") []) [Ast.tRel 0]]]
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (x <= y -> x < z)
Crunching:
(pad_u 0 R S × pad_ctrl 0 R' HRR' S' = pad_ctrl 0 R' HRR' S' × pad_u 0 R S)
Crunching: (x < z)
Crunching:
(pad_u 0 R S × pad_ctrl 0 R' HRR' S' = pad_ctrl 0 R' HRR' S' × pad_u 0 R S)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(swap
 × (fun x y0 : nat =>
    ∣ l ⟩ (x / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x mod 2)%nat (y0 mod 1)%nat) =
 (fun x y0 : nat =>
  ∣ y ⟩ (x / 2)%nat (y0 / 1)%nat * ∣ l ⟩ (x mod 2)%nat (y0 mod 1)%nat))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(pad_u 0 R S × pad_ctrl 0 R' HRR' S' = pad_ctrl 0 R' HRR' S' × pad_u 0 R S)
Crunching:
(pad_u 0 R S × pad_ctrl 0 R' HRR' S' = pad_ctrl 0 R' HRR' S' × pad_u 0 R S)
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
find_witness Control.TimeoutCrunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
Crunching: (x < z)
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(pad_u n m H × pad_ctrl n p Hn H8 = pad_ctrl n p Hn H8 × pad_u n m H)
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Crunching: (x < z)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat =
 Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2))
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(Σ
   (fun y1 : nat =>
    swap x0 y1 *
    (∣ x ⟩ (y1 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (y1 mod 2)%nat (y0 mod 1)%nat))
   (2 * 2) =
 ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat)
Finished transaction in 40.869 secs (0.339u,0.153s) (successful)
Finished transaction in 0.023 secs (0.022u,0.001s) (successful)
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Finished transaction in 0.164 secs (0.163u,0.s) (successful)
Crunching: (forall x : nat, perm_to_matrix 0 f x = I 1 x)
Crunching:
((fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching: (forall x : nat, perm_to_matrix 0 f x = I 1 x)
Crunching:
((fun n : nat => forall x : nat, perm_to_matrix n f x = I (S n) x) 0)
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
Crunching: (forall x : nat, perm_to_matrix 0 f x = I 1 x)
Crunching: (perm_to_matrix 0 f a = I 1 a)
Crunching: (forall x : nat, perm_to_matrix 0 f x = I 1 x)
Crunching: (forall x : nat, I 1 x = perm_to_matrix 0 f x)
out of reach
Tactic call ran for 0.05 secs (0.047u,0.002s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
More readable: initial segment:
(Build_TCCCard (Sigma:=X))
With remainder:
[]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Crunching:
(pad_u Hq Hr H × pad_ctrl Hq H2 x B = pad_ctrl Hq H2 x B × pad_u Hq Hr H)
More readable: initial segment:
(Build_TCCCard (Sigma:=X))
With remainder:
[]
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
Crunching:
(forall A B : Square 2,
 Hr <> H14 ->
 Hr <> EQ ->
 WF_Matrix A ->
 WF_Matrix B ->
 pad_u Hq Hr A × pad_ctrl Hq H14 EQ B = pad_ctrl Hq H14 EQ B × pad_u Hq Hr A)
Tactic call ran for 0.008 secs (0.006u,0.001s) (success)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
out of reach
Tactic call ran for 0.057 secs (0.057u,0.s) (failure)
Crunching:
((if Hr + 1 <=? Hq then I (2 ^ Hr) ⊗ IH ⊗ I (2 ^ (Hq - (Hr + 1))) else Zero)
 × pad_ctrl Hq H14 n B =
 pad_ctrl Hq H14 n B
 × (if Hr + 1 <=? Hq then I (2 ^ Hr) ⊗ IH ⊗ I (2 ^ (Hq - (Hr + 1))) else Zero))
Chars 48539 - 48552 [(intros~[a~b]).] 40.183 secs (0.u,0.032s)
Chars 48553 - 48574 [(revert~a;~apply~ap10).] 0.002 secs (0.002u,0.s)
Chars 48581 - 48599 [strip_reflections.] 0.105 secs (0.083u,0.021s)
Chars 48606 - 48633 [(apply~path_arrow;~intros~a).] 0.002 secs (0.002u,0.s)
Chars 48640 - 48703 [(unfold~O_monad_strength,~O_fu...] 0.001 secs (0.u,0.s)
Chars 48704 - 48710 [(simpl).] 0.002 secs (0.002u,0.s)
Chars 48717 - 48752 [(repeat~(rewrite~O_rec_beta;~s...] 0.022 secs (0.02u,0.002s)
Chars 48759 - 48771 [reflexivity.] 0. secs (0.u,0.s)
Chars 48539 - 48552 [(intros~[a~b]).] 0.001 secs (0.001u,0.s)
Chars 48553 - 48574 [(revert~a;~apply~ap10).] 0.001 secs (0.001u,0.s)
Chars 48581 - 48599 [strip_reflections.] 0. secs (0.u,0.s)
Chars 48606 - 48633 [(apply~path_arrow;~intros~a).] 0.001 secs (0.001u,0.s)
Chars 48640 - 48703 [(unfold~O_monad_strength,~O_fu...] 0. secs (0.u,0.s)
Chars 48704 - 48710 [(simpl).] 0.002 secs (0.001u,0.s)
Chars 48717 - 48752 [(repeat~(rewrite~O_rec_beta;~s...] 0.001 secs (0.001u,0.s)
Chars 48759 - 48771 [reflexivity.] 0. secs (0.u,0.s)
Chars 48776 - 48780 [Qed.] 0.025 secs (0.023u,0.001s)
Chars 48784 - 48800 [End~StrongMonad.] 0.041 secs (0.038u,0.002s)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Chars 48802 - 48829 [End~Reflective_Subuniverse.] 0.645 secs (0.588u,0.053s)
Chars 48883 - 48935 [Notation~O_inverts~O~f:=~(IsEq...] 0. secs (0.u,0.s)
Chars 49786 - 49894 [Class~IsConnected~(O~:~Reflect...] 0.001 secs (0.u,0.s)
Chars 49896 - 49941 [#[global]Existing~Instance~isc...] 0. secs (0.u,0.s)
Chars 49943 - 49966 [Section~ConnectedTypes.] 0. secs (0.u,0.s)
Chars 49969 - 50005 [Context~(O~:~ReflectiveSubuniv...] 0. secs (0.u,0.s)
Chars 50046 - 50124 [#[global]~Instance~ishprop_isc...] 0. secs (0.u,0.s)
Chars 50127 - 50133 [Proof.] 0. secs (0.u,0.s)
Crunching:
((1 + 0)%R = 1 ->
 (0 + 1)%R = 1 ->
 Hr <> H14 ->
 Hr <> n ->
 WF_Matrix IH ->
 WF_Matrix H5 ->
 pad_u Hq Hr IH × pad_ctrl Hq H14 n H5 =
 pad_ctrl Hq H14 n H5 × pad_u Hq Hr IH)
Tactic call ran for 0.008 secs (0.007u,0.s) (success)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Crunching:
((if Hr + 1 <=? Hq then I (2 ^ Hr) ⊗ IH ⊗ I (2 ^ (Hq - (Hr + 1))) else Zero)
 × pad_ctrl Hq n Hn B =
 pad_ctrl Hq n Hn B
 × (if Hr + 1 <=? Hq then I (2 ^ Hr) ⊗ IH ⊗ I (2 ^ (Hq - (Hr + 1))) else Zero))
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: (~ 1 < 0)
Crunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
out of reach
Tactic call ran for 0.047 secs (0.045u,0.002s) (failure)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (0 = (pr_outcome_sum (repeat 0 n) f + 0)%R)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.001s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching:
(forall x0 : nat,
 (x0 < 2 ^ a)%nat ->
 pad_u a b Ha x x0 * pad_ctrl a c Hc Hb x0 y =
 pad_ctrl a c Hc Hb x x0 * pad_u a b Ha x0 y)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
Crunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
Crunching: (a < 0 -> √ (a + b) < √ a + √ b \/ √ (a + b) = (√ a + √ b)%R)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(forall x0 : nat,
 (x0 < 2 ^ a)%nat ->
 pad_u a b Ha x x0 * pad_ctrl a c Hc Hb x0 y =
 pad_ctrl a c Hc Hb x x0 * pad_u a b Ha x0 y)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching:
(pad_u a b Ha × pad_ctrl a c Hc Hb = pad_ctrl a c Hc Hb × pad_u a b Ha)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Chars 50138 - 50166 [(unfold~IsConnected;~exact~_).] 10.526 secs (0.003u,0.029s)
Chars 50138 - 50166 [(unfold~IsConnected;~exact~_).] 0. secs (0.u,0.s)
Chars 50169 - 50177 [Defined.] 0. secs (0.u,0.s)
Chars 50244 - 50364 [Definition~isconnected_equiv~(...] 0. secs (0.u,0.s)
Chars 50367 - 50373 [Proof.] 0. secs (0.u,0.s)
out of reach
Tactic call ran for 0.047 secs (0.046u,0.s) (failure)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (a < 0 -> √ (a + b) < √ a + √ b \/ √ (a + b) = (√ a + √ b)%R)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
(API.wf nil (RewriteArith opts e LE) (RewriteArith opts e EQ))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Crunching:
(pad_u n 0 A × pad_ctrl n n0 o B = pad_ctrl n n0 o B × pad_u n 0 A)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (0 < 2)
Crunching:
(perm_to_matrix n f x 0 =
 (if (x =? 0) && (x <? 2 ^ n) then IZR (Z.succ 0) else (- 0)%R))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
find_witness Control.TimeoutCrunching: (0 < / 2 -> NZ < 0 -> √ (NZ + EQ) <= √ NZ + √ EQ)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.004u,0.001s) (failure)
Crunching:
(forall (n : nat) (p : nat -> nat) (x y : nat),
 2 ^ n <= x \/ 2 ^ n <= y -> perm_to_matrix n p x y = 0%R)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.005u,0.001s) (failure)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
(interp256 cont
   {|
     CC.cc_c :=
       if in_dec CC.code_dec CC.C (writes_conditions i)
       then cc_spec CC.C (spec i (Tuple.map HF args) H)
       else CC.cc_c H;
     CC.cc_m :=
       if in_dec CC.code_dec CC.M (writes_conditions i)
       then cc_spec CC.M (spec i (Tuple.map HF args) H)
       else CC.cc_m H;
     CC.cc_l :=
       if in_dec CC.code_dec CC.L (writes_conditions i)
       then cc_spec CC.L (spec i (Tuple.map HF args) H)
       else CC.cc_l H;
     CC.cc_z :=
       if in_dec CC.code_dec CC.Z (writes_conditions i)
       then cc_spec CC.Z (spec i (Tuple.map HF args) H)
       else CC.cc_z H
   |}
   (fun r' : register =>
    if reg_eqb r' r
    then ?x
    else
     if reg_eqb r' rd
     then spec i (Tuple.map HF args) H mod wordmax
     else HF r') =
 interp256 cont
   (CC.update (writes_conditions i)
      (spec i
         (Tuple.map (fun r' : register => if reg_eqb r' r then Hn else HF r')
            args) H) cc_spec H)
   (fun n : register =>
    if reg_eqb n rd
    then
     spec i
       (Tuple.map (fun r' : register => if reg_eqb r' r then Hn else HF r')
          args) H mod wordmax
    else if reg_eqb n r then Hn else HF n))
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
out of reach
Tactic call ran for 0.004 secs (0.002u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
Reifying...
out of reach
Tactic call ran for 0.004 secs (0.003u,0.001s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 4; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 3; Ast.tRel 0]]
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
Crunching: (~ y <= z * / x)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.001s) (failure)
Finished transaction in 41.246 secs (0.67u,0.174s) (successful)
Finished transaction in 0.049 secs (0.049u,0.s) (successful)
find_witness Control.TimeoutCrunching: (forall z : nat, a - z = H -> a - H - z = 0)
Finished transaction in 0.368 secs (0.365u,0.001s) (successful)
(ctx (of_prefancy_scalar ###v) = Compilers.ident_interp idc)
(Compilers.ident_interp idc = ctx (of_prefancy_scalar ###v))
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.001s) (failure)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Crunching: (forall z : nat, a - z = H -> a - H - z = 0)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (Heqn * / EQ < H)
Crunching: (Heqn * / EQ < H)
find_witness Control.TimeoutCrunching: (forall z : nat, a - z = H -> a - H - z = 0)
out of reach
Tactic call ran for 0.005 secs (0.002u,0.002s) (failure)
Crunching:
(forall (n : nat) (p : nat -> nat) (x y : nat),
 x >= 2 ^ n \/ y >= 2 ^ n -> perm_to_matrix n p x y = 0%R)
Crunching:
(pr_outcome_sum (f :: len) n =
 ((if n 0%nat then f else - 0) + pr_outcome_sum len (fun i : nat => n (S i)))%R)
find_witness Control.TimeoutCrunching:
(S (0 + 1) ^ 0 <= E \/ S (0 + 1) ^ 0 <= p -> perm_to_matrix 0 H E p = 0%R)
Crunching:
(forall y : nat, 2 ^ 0 <= E \/ 2 ^ 0 <= y -> perm_to_matrix 0 H E y = 0%R)
Crunching:
(forall y : nat, 2 ^ 0 <= E \/ 2 ^ 0 <= y -> perm_to_matrix 0 H E y = 0%R)
Crunching:
(forall y : nat, 2 ^ 0 <= E \/ 2 ^ 0 <= y -> perm_to_matrix 0 H E y = 0%R)
out of reach
Tactic call ran for 0.009 secs (0.009u,0.s) (failure)
Crunching: (√ (a + b) < √ a + √ b \/ √ (a + b) = (√ a + √ b)%R)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: (a < 0 -> √ (a + b) < √ a + √ b \/ √ (a + b) = (√ a + √ b)%R)
Crunching: (x <= y -> √ x + √ y >= √ (x + y))
Crunching:
(forall (n : nat) (p : nat -> nat) (x y : nat),
 2 ^ n <= x \/ 2 ^ n <= y -> perm_to_matrix n p x y = 0%R)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching: (R0 < R0 -> - Ci .* σx × (σy × (σz × ∣ 1 ⟩)) = ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
((1 + 0)%R = 1 -> (0 + 1)%R = 1 -> pr_outcome_sum f g = pr_outcome_sum f H)
Chars 50378 - 50431 [(intros~?;~refine~(contr_equiv...] 40.176 secs (0.013u,0.03s)
Chars 50378 - 50431 [(intros~?;~refine~(contr_equiv...] 0. secs (0.u,0.s)
Chars 50434 - 50442 [Defined.] 0. secs (0.u,0.s)
Chars 50446 - 50580 [Definition~isconnected_equiv'~...] 0.002 secs (0.002u,0.s)
Chars 50635 - 50665 [Definition~Conn~:~Subuniverse.] 0. secs (0.u,0.s)
Chars 50668 - 50674 [Proof.] 0. secs (0.u,0.s)
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (R0 < R0 -> - Ci .* σx × (σy × (σz × ∣ 1 ⟩)) = ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching: (0 < 1 -> pr_outcome_sum derv start = pr_outcome_sum derv b)
Crunching: (0 < 1 -> pr_outcome_sum derv start = pr_outcome_sum derv b)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Reifying...
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
(expr.wf H e1 l1 ->
 (forall (t : type) (v1 : value_with_lets1 t) (v2 : value_with_lets2 t),
  In
    (existT
       (fun t0 : type => (value_with_lets1 t0 * value_with_lets2 t0)%type) t
       (v1, v2)) H ->
  UnderLets.wf
    (fun G' : list {t0 : type & (var1 t0 * var2 t0)%type} => wf_value G') G'
    v1 v2) ->
 UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => wf_value G') G'
   (interp1 annotate_with_state e1) (interp2 annotate_with_state l1))
find_witness Control.Timeout"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Crunching: (0 < 0)%nat
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Crunching: (perm_to_matrix f g n v = (R0, R0))
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeoutout of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
(expr.wf H e1 l1 ->
 (forall (t : type) (v1 : value_with_lets1 t) (v2 : value_with_lets2 t),
  In
    (existT
       (fun t0 : type => (value_with_lets1 t0 * value_with_lets2 t0)%type) t
       (v1, v2)) H ->
  UnderLets.wf
    (fun G' : list {t0 : type & (var1 t0 * var2 t0)%type} => wf_value G') G'
    v1 v2) ->
 UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => wf_value G') G'
   (interp1 annotate_with_state e1) (interp2 annotate_with_state l1))
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Crunching:
(pad_ctrl a H2 n A × pad_ctrl a o p B = pad_ctrl a o p B × pad_ctrl a H2 n A)
Crunching:
(pad_ctrl a o p B × pad_ctrl a H2 n A = pad_ctrl a H2 n A × pad_ctrl a o p B)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Crunching:
((if m <? H1
  then
   if m + S (H1 - m - 1 + 1) <=? a
   then
    I (2 ^ m)
    ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (H1 - m - 1)) ⊗ A
       .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (H1 - m - 1)) ⊗ I 2)
    ⊗ I (2 ^ (a - (m + S (H1 - m - 1 + 1))))
   else Zero
  else
   if H1 <? m
   then
    if H1 + S (m - H1 - 1 + 1) <=? a
    then
     I (2 ^ H1)
     ⊗ (A ⊗ I (2 ^ (m - H1 - 1)) ⊗ ∣1⟩⟨1∣
        .+ I 2 ⊗ I (2 ^ (m - H1 - 1)) ⊗ ∣0⟩⟨0∣)
     ⊗ I (2 ^ (a - (H1 + S (m - H1 - 1 + 1))))
    else Zero
   else Zero)
 × (if H2 <? p
    then
     if H2 + S (p - H2 - 1 + 1) <=? a
     then
      I (2 ^ H2)
      ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (p - H2 - 1)) ⊗ B
         .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (p - H2 - 1)) ⊗ I 2)
      ⊗ I (2 ^ (a - (H2 + S (p - H2 - 1 + 1))))
     else Zero
    else
     if p <? H2
     then
      if p + S (H2 - p - 1 + 1) <=? a
      then
       I (2 ^ p)
       ⊗ (B ⊗ I (2 ^ (H2 - p - 1)) ⊗ ∣1⟩⟨1∣
          .+ I 2 ⊗ I (2 ^ (H2 - p - 1)) ⊗ ∣0⟩⟨0∣)
       ⊗ I (2 ^ (a - (p + S (H2 - p - 1 + 1))))
      else Zero
     else Zero) =
 (if H2 <? p
  then
   if H2 + S (p - H2 - 1 + 1) <=? a
   then
    I (2 ^ H2)
    ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (p - H2 - 1)) ⊗ B
       .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (p - H2 - 1)) ⊗ I 2)
    ⊗ I (2 ^ (a - (H2 + S (p - H2 - 1 + 1))))
   else Zero
  else
   if p <? H2
   then
    if p + S (H2 - p - 1 + 1) <=? a
    then
     I (2 ^ p)
     ⊗ (B ⊗ I (2 ^ (H2 - p - 1)) ⊗ ∣1⟩⟨1∣
        .+ I 2 ⊗ I (2 ^ (H2 - p - 1)) ⊗ ∣0⟩⟨0∣)
     ⊗ I (2 ^ (a - (p + S (H2 - p - 1 + 1))))
    else Zero
   else Zero)
 × (if m <? H1
    then
     if m + S (H1 - m - 1 + 1) <=? a
     then
      I (2 ^ m)
      ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (H1 - m - 1)) ⊗ A
         .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (H1 - m - 1)) ⊗ I 2)
      ⊗ I (2 ^ (a - (m + S (H1 - m - 1 + 1))))
     else Zero
    else
     if H1 <? m
     then
      if H1 + S (m - H1 - 1 + 1) <=? a
      then
       I (2 ^ H1)
       ⊗ (A ⊗ I (2 ^ (m - H1 - 1)) ⊗ ∣1⟩⟨1∣
          .+ I 2 ⊗ I (2 ^ (m - H1 - 1)) ⊗ ∣0⟩⟨0∣)
       ⊗ I (2 ^ (a - (H1 + S (m - H1 - 1 + 1))))
      else Zero
     else Zero))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (pr_outcome_sum l f1 = pr_outcome_sum l f2)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
out of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Compiling decision tree...
Splitting rewrite rules...
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Compiling decision tree...
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Splitting rewrite rules...
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
find_witness Control.Timeout"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Crunching:
((1 + 0)%R = 1 -> (0 + 1)%R = 1 -> pr_outcome_sum f g = pr_outcome_sum f H)
Crunching: (pr_outcome_sum l f1 = pr_outcome_sum l f2)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
Crunching: (pr_outcome_sum l H = pr_outcome_sum l H')
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
find_witness Control.TimeoutCrunching: (pr_outcome_sum derv f1 = pr_outcome_sum derv c)
Crunching: (pr_outcome_sum derv H = pr_outcome_sum derv f2)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching: (0 < 1 -> pr_outcome_sum derv start = pr_outcome_sum derv b)
find_witness Control.TimeoutMore readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
out of reach
Tactic call ran for 0.003 secs (0.002u,0.001s) (failure)
Crunching: (pr_outcome_sum derv b = pr_outcome_sum derv start)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching: (pr_outcome_sum derv start = pr_outcome_sum derv b)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching: (pr_outcome_sum derv start = pr_outcome_sum derv b)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Crunching: (0 < 1 -> pr_outcome_sum derv start = pr_outcome_sum derv b)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Case compile_stmt_correct/SInteract
Crunching: (pr_outcome_sum derv b = pr_outcome_sum derv start)
Crunching: (pr_outcome_sum derv start = pr_outcome_sum derv b)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (pr_outcome_sum derv start = pr_outcome_sum derv b)
Crunching: (0 < 1 -> pr_outcome_sum derv start = pr_outcome_sum derv b)
out of reach
Tactic call ran for 0.01 secs (0.009u,0.s) (failure)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Case compile_stmt_correct/SCall
out of reach
Tactic call ran for 0.013 secs (0.013u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Assembling rewrite_head...
Reducing rewrite_head...
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
Crunching: (update n m Hb m = Hb)
Crunching:
(ConstructiveCauchyReals.CRealEq (Rrepr (pr_outcome_sum n m)) (Rrepr 0))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Tactic call ran for 3.458 secs (3.407u,0.052s) (success)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (update f f' k f' = k)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Chars 50679 - 50722 [rapply~(Build_Subuniverse~(IsC...] 40.178 secs (0.01u,0.032s)
Chars 50727 - 50764 [(simpl;~intros~T~U~isconnT~f~i...] 0. secs (0.u,0.s)
Chars 50769 - 50807 [exact~(isconnected_equiv~T~f~i...] 0.001 secs (0.001u,0.s)
Chars 50679 - 50722 [rapply~(Build_Subuniverse~(IsC...] 0. secs (0.u,0.s)
Chars 50727 - 50764 [(simpl;~intros~T~U~isconnT~f~i...] 0. secs (0.u,0.s)
Chars 50769 - 50807 [exact~(isconnected_equiv~T~f~i...] 0. secs (0.u,0.s)
Chars 50810 - 50818 [Defined.] 0. secs (0.u,0.s)
Chars 50999 - 51110 [Definition~isconnected_elim~{A...] 0. secs (0.u,0.s)
Chars 51113 - 51119 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Assembling rewrite_head...
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Reducing rewrite_head...
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
             match a with
             | (a'~1)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 1%N
                           | N.pos p => N.pos p~1
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end)
             | (a'~0)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 0%N
                           | N.pos p => N.pos p~0
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end)
             | 1%positive =>
                 match b with
                 | 1%N => (1%N, 0%N)
                 | _ => (0%N, 1%N)
                 end
             end) p (N.pos Hab) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq Hab m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' Hab
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
         match a with
         | (a'~1)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end)
         | (a'~0)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end)
         | 1%positive =>
             match b with
             | 1%N => (1%N, 0%N)
             | _ => (0%N, 1%N)
             end
         end) p (N.pos Hab) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq Hab m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' Hab
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
             match a with
             | (a'~1)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 1%N
                           | N.pos p => N.pos p~1
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end)
             | (a'~0)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 0%N
                           | N.pos p => N.pos p~0
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end)
             | 1%positive =>
                 match b with
                 | 1%N => (1%N, 0%N)
                 | _ => (0%N, 1%N)
                 end
             end) p (N.pos Hab) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq Hab m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' Hab
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
         match a with
         | (a'~1)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end)
         | (a'~0)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end)
         | 1%positive =>
             match b with
             | 1%N => (1%N, 0%N)
             | _ => (0%N, 1%N)
             end
         end) p (N.pos Hab) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq Hab m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' Hab
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(Z.abs_N (Z.rem (Z.pos A) (Z.pos eq_dec)) = (N.pos A mod N.pos eq_dec)%N)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
"Did not find an instance for "
(extracted Build_FlatTCC)
"open obligation cnstr_FlatTCC0_term for it. You might want to register a instance before and rerun this."
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 2.651 secs (2.623u,0.025s) (success)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
((fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x : nat =>
    if n x
    then
     (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
        match x0 with
        | 0%nat => match x1 with
                   | [] => x2
                   | x3 :: _ => x3
                   end
        | S x3 => match x1 with
                  | [] => x2
                  | _ :: x5 => Ffix x3 x5 x2
                  end
        end) x a R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end) a) = R0)
Crunching:
((fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x : nat =>
    if n x
    then
     (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
        match x0 with
        | 0%nat => match x1 with
                   | [] => x2
                   | x3 :: _ => x3
                   end
        | S x3 => match x1 with
                  | [] => x2
                  | _ :: x5 => Ffix x3 x5 x2
                  end
        end) x a R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end) a) = R0)
Crunching:
((fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x : nat =>
    if n x
    then
     (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
        match x0 with
        | 0%nat => match x1 with
                   | [] => x2
                   | x3 :: _ => x3
                   end
        | S x3 => match x1 with
                  | [] => x2
                  | _ :: x5 => Ffix x3 x5 x2
                  end
        end) x a R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end) a) = R0)
Crunching:
(R0 =
 (fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x : nat =>
    if n x
    then
     (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
        match x0 with
        | 0%nat => match x1 with
                   | [] => x2
                   | x3 :: _ => x3
                   end
        | S x3 => match x1 with
                  | [] => x2
                  | _ :: x5 => Ffix x3 x5 x2
                  end
        end) x a R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end) a))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Case compile_stmt_correct/SLoad
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
((fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x : nat =>
    if IN x
    then
     (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
        match x0 with
        | 0%nat => match x1 with
                   | [] => x2
                   | x3 :: _ => x3
                   end
        | S x3 => match x1 with
                  | [] => x2
                  | _ :: x5 => Ffix x3 x5 x2
                  end
        end) x l R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end) l) = R0)
Case compile_stmt_correct/SStore
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Case compile_stmt_correct/SInlinetable
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
((forall i : nat, (i < length (H1 :: H2))%nat -> abs i = false) ->
 pr_outcome_sum (H1 :: H2) abs = 0)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching: (pr_outcome_sum (H :: x) Hxy = 0)
find_witness Control.TimeoutMore readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
(ConstructiveCauchyReals.CRealEq (Rrepr (pr_outcome_sum n m)) (Rrepr 0))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
out of reach
Tactic call ran for 0.011 secs (0.004u,0.006s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching: (update n m Hb m = Hb)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Reifying...
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
out of reach
Tactic call ran for 0.008 secs (0.007u,0.001s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
find_witness Control.TimeoutCrunching:
(forall x y lb ub : nat,
 lb <= x <= ub /\ lb <= y <= ub -> lb <= (x + y) / 2 <= ub)
find_witness Control.TimeoutMore readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          let (q, r) :=
            (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
               match a with
               | (a'~1)%positive =>
                   let (q, r) := pos_div_eucl a' b in
                   if
                    match
                      match b with
                      | 0%N =>
                          match
                            match r with
                            | 0%N => 1%N
                            | N.pos p => N.pos p~1
                            end
                          with
                          | 0%N => Eq
                          | N.pos _ => Lt
                          end
                      | N.pos n' =>
                          match
                            match r with
                            | 0%N => 1%N
                            | N.pos p => N.pos p~1
                            end
                          with
                          | 0%N => Gt
                          | N.pos m' =>
                              (fix compare_cont
                                 (r0 : comparison) 
                                 (x y : positive) {struct y} : comparison :=
                                 match x with
                                 | (p~1)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont r0 p q0
                                     | (q0~0)%positive =>
                                         compare_cont Gt p q0
                                     | 1%positive => Gt
                                     end
                                 | (p~0)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont Lt p q0
                                     | (q0~0)%positive =>
                                         compare_cont r0 p q0
                                     | 1%positive => Gt
                                     end
                                 | 1%positive =>
                                     match y with
                                     | 1%positive => r0
                                     | _ => Lt
                                     end
                                 end) Eq n' m'
                          end
                      end
                    with
                    | Gt => false
                    | _ => true
                    end
                   then
                    (match q with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end,
                     match
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                     with
                     | 0%N => 0%N
                     | N.pos n' =>
                         match b with
                         | 0%N =>
                             match r with
                             | 0%N => 1%N
                             | N.pos p => N.pos p~1
                             end
                         | N.pos m' =>
                             match
                               (fix sub_mask (x y : positive) {struct y} :
                                    Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive => Pos.IsPos p~0
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | 1%positive =>
                                      match y with
                                      | 1%positive => Pos.IsNul
                                      | _ => Pos.IsNeg
                                      end
                                  end
                                with sub_mask_carry
                                  (x y : positive) {struct y} : Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          match p with
                                          | (p0~1)%positive =>
                                              Pos.IsPos p0~0~0
                                          | (p0~0)%positive =>
                                              Pos.IsPos ((... ...) p0)~0
                                          | 1%positive => Pos.IsNul
                                          end
                                      end
                                  | 1%positive => Pos.IsNeg
                                  end
                                for
                                sub_mask) n' m'
                             with
                             | Pos.IsPos p => N.pos p
                             | _ => 0%N
                             end
                         end
                     end)
                   else
                    (match q with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end,
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end)
               | (a'~0)%positive =>
                   let (q, r) := pos_div_eucl a' b in
                   if
                    match
                      match b with
                      | 0%N =>
                          match
                            match r with
                            | 0%N => 0%N
                            | N.pos p => N.pos p~0
                            end
                          with
                          | 0%N => Eq
                          | N.pos _ => Lt
                          end
                      | N.pos n' =>
                          match
                            match r with
                            | 0%N => 0%N
                            | N.pos p => N.pos p~0
                            end
                          with
                          | 0%N => Gt
                          | N.pos m' =>
                              (fix compare_cont
                                 (r0 : comparison) 
                                 (x y : positive) {struct y} : comparison :=
                                 match x with
                                 | (p~1)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont r0 p q0
                                     | (q0~0)%positive =>
                                         compare_cont Gt p q0
                                     | 1%positive => Gt
                                     end
                                 | (p~0)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont Lt p q0
                                     | (q0~0)%positive =>
                                         compare_cont r0 p q0
                                     | 1%positive => Gt
                                     end
                                 | 1%positive =>
                                     match y with
                                     | 1%positive => r0
                                     | _ => Lt
                                     end
                                 end) Eq n' m'
                          end
                      end
                    with
                    | Gt => false
                    | _ => true
                    end
                   then
                    (match q with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end,
                     match
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                     with
                     | 0%N => 0%N
                     | N.pos n' =>
                         match b with
                         | 0%N =>
                             match r with
                             | 0%N => 0%N
                             | N.pos p => N.pos p~0
                             end
                         | N.pos m' =>
                             match
                               (fix sub_mask (x y : positive) {struct y} :
                                    Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive => Pos.IsPos p~0
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | 1%positive =>
                                      match y with
                                      | 1%positive => Pos.IsNul
                                      | _ => Pos.IsNeg
                                      end
                                  end
                                with sub_mask_carry
                                  (x y : positive) {struct y} : Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          match p with
                                          | (p0~1)%positive =>
                                              Pos.IsPos p0~0~0
                                          | (p0~0)%positive =>
                                              Pos.IsPos ((... ...) p0)~0
                                          | 1%positive => Pos.IsNul
                                          end
                                      end
                                  | 1%positive => Pos.IsNeg
                                  end
                                for
                                sub_mask) n' m'
                             with
                             | Pos.IsPos p => N.pos p
                             | _ => 0%N
                             end
                         end
                     end)
                   else
                    (match q with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end,
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end)
               | 1%positive =>
                   match b with
                   | 1%N => (1%N, 0%N)
                   | _ => (0%N, 1%N)
                   end
               end) p (N.pos HA) in
          if
           match
             match match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end with
             | 0%N => Gt
             | N.pos m' =>
                 (fix compare_cont
                    (r0 : comparison) (x y : positive) {struct y} :
                      comparison :=
                    match x with
                    | (p~1)%positive =>
                        match y with
                        | (q0~1)%positive => compare_cont r0 p q0
                        | (q0~0)%positive => compare_cont Gt p q0
                        | 1%positive => Gt
                        end
                    | (p~0)%positive =>
                        match y with
                        | (q0~1)%positive => compare_cont Lt p q0
                        | (q0~0)%positive => compare_cont r0 p q0
                        | 1%positive => Gt
                        end
                    | 1%positive =>
                        match y with
                        | 1%positive => r0
                        | _ => Lt
                        end
                    end) Eq HA m'
             end
           with
           | Gt => false
           | _ => true
           end
          then
           (match q with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end,
            match match r with
                  | 0%N => 1%N
                  | N.pos p => N.pos p~1
                  end with
            | 0%N => 0%N
            | N.pos n' =>
                match
                  (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                     match x with
                     | (p~1)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive => Pos.IsPos p~0
                         end
                     | (p~0)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p0~1)%positive => (p0~0~1)%positive
                                   | (p0~0)%positive =>
                                       ((pred_double p0)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p)
                         end
                     | 1%positive =>
                         match y with
                         | 1%positive => Pos.IsNul
                         | _ => Pos.IsNeg
                         end
                     end
                   with sub_mask_carry (x y : positive) {struct y} :
                       Pos.mask :=
                     match x with
                     | (p~1)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p0~1)%positive => (p0~0~1)%positive
                                   | (p0~0)%positive =>
                                       ((pred_double p0)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p)
                         end
                     | (p~0)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             match p with
                             | (p0~1)%positive => Pos.IsPos p0~0~0
                             | (p0~0)%positive =>
                                 Pos.IsPos
                                   ((fix pred_double 
                                     (x0 : positive) : positive :=
                                       match x0 with
                                       | (p1~1)%positive => (p1~0~1)%positive
                                       | (p1~0)%positive =>
                                           ((pred_double p1)~1)%positive
                                       | 1%positive => 1%positive
                                       end) p0)~0
                             | 1%positive => Pos.IsNul
                             end
                         end
                     | 1%positive => Pos.IsNeg
                     end
                   for
                   sub_mask) n' HA
                with
                | Pos.IsPos p => N.pos p
                | _ => 0%N
                end
            end)
          else
           (match q with
            | 0%N => 0%N
            | N.pos p => N.pos p~0
            end, match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq HA m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' HA
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      let (q, r) :=
        (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
           match a with
           | (a'~1)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 1%N
                         | N.pos p => N.pos p~1
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                                | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end)
           | (a'~0)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 0%N
                         | N.pos p => N.pos p~0
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                                | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end)
           | 1%positive =>
               match b with
               | 1%N => (1%N, 0%N)
               | _ => (0%N, 1%N)
               end
           end) p (N.pos HA) in
      if
       match
         match match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end with
         | 0%N => Gt
         | N.pos m' =>
             (fix compare_cont
                (r0 : comparison) (x y : positive) {struct y} : comparison :=
                match x with
                | (p~1)%positive =>
                    match y with
                    | (q0~1)%positive => compare_cont r0 p q0
                    | (q0~0)%positive => compare_cont Gt p q0
                    | 1%positive => Gt
                    end
                | (p~0)%positive =>
                    match y with
                    | (q0~1)%positive => compare_cont Lt p q0
                    | (q0~0)%positive => compare_cont r0 p q0
                    | 1%positive => Gt
                    end
                | 1%positive => match y with
                                | 1%positive => r0
                                | _ => Lt
                                end
                end) Eq HA m'
         end
       with
       | Gt => false
       | _ => true
       end
      then
       (match q with
        | 0%N => 1%N
        | N.pos p => N.pos p~1
        end,
        match match r with
              | 0%N => 1%N
              | N.pos p => N.pos p~1
              end with
        | 0%N => 0%N
        | N.pos n' =>
            match
              (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive => Pos.IsPos p~0
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         Pos.IsPos
                           ((fix pred_double (x0 : positive) : positive :=
                               match x0 with
                               | (p0~1)%positive => (p0~0~1)%positive
                               | (p0~0)%positive =>
                                   ((pred_double p0)~1)%positive
                               | 1%positive => 1%positive
                               end) p)
                     end
                 | 1%positive =>
                     match y with
                     | 1%positive => Pos.IsNul
                     | _ => Pos.IsNeg
                     end
                 end
               with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         Pos.IsPos
                           ((fix pred_double (x0 : positive) : positive :=
                               match x0 with
                               | (p0~1)%positive => (p0~0~1)%positive
                               | (p0~0)%positive =>
                                   ((pred_double p0)~1)%positive
                               | 1%positive => 1%positive
                               end) p)
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         match p with
                         | (p0~1)%positive => Pos.IsPos p0~0~0
                         | (p0~0)%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p1~1)%positive => (p1~0~1)%positive
                                   | (p1~0)%positive =>
                                       ((pred_double p1)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p0)~0
                         | 1%positive => Pos.IsNul
                         end
                     end
                 | 1%positive => Pos.IsNeg
                 end
               for
               sub_mask) n' HA
            with
            | Pos.IsPos p => N.pos p
            | _ => 0%N
            end
        end)
      else
       (match q with
        | 0%N => 0%N
        | N.pos p => N.pos p~0
        end, match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq HA m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' HA
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          let (q, r) :=
            (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
               match a with
               | (a'~1)%positive =>
                   let (q, r) := pos_div_eucl a' b in
                   if
                    match
                      match b with
                      | 0%N =>
                          match
                            match r with
                            | 0%N => 1%N
                            | N.pos p => N.pos p~1
                            end
                          with
                          | 0%N => Eq
                          | N.pos _ => Lt
                          end
                      | N.pos n' =>
                          match
                            match r with
                            | 0%N => 1%N
                            | N.pos p => N.pos p~1
                            end
                          with
                          | 0%N => Gt
                          | N.pos m' =>
                              (fix compare_cont
                                 (r0 : comparison) 
                                 (x y : positive) {struct y} : comparison :=
                                 match x with
                                 | (p~1)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont r0 p q0
                                     | (q0~0)%positive =>
                                         compare_cont Gt p q0
                                     | 1%positive => Gt
                                     end
                                 | (p~0)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont Lt p q0
                                     | (q0~0)%positive =>
                                         compare_cont r0 p q0
                                     | 1%positive => Gt
                                     end
                                 | 1%positive =>
                                     match y with
                                     | 1%positive => r0
                                     | _ => Lt
                                     end
                                 end) Eq n' m'
                          end
                      end
                    with
                    | Gt => false
                    | _ => true
                    end
                   then
                    (match q with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end,
                     match
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                     with
                     | 0%N => 0%N
                     | N.pos n' =>
                         match b with
                         | 0%N =>
                             match r with
                             | 0%N => 1%N
                             | N.pos p => N.pos p~1
                             end
                         | N.pos m' =>
                             match
                               (fix sub_mask (x y : positive) {struct y} :
                                    Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive => Pos.IsPos p~0
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | 1%positive =>
                                      match y with
                                      | 1%positive => Pos.IsNul
                                      | _ => Pos.IsNeg
                                      end
                                  end
                                with sub_mask_carry
                                  (x y : positive) {struct y} : Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          match p with
                                          | (p0~1)%positive =>
                                              Pos.IsPos p0~0~0
                                          | (p0~0)%positive =>
                                              Pos.IsPos ((... ...) p0)~0
                                          | 1%positive => Pos.IsNul
                                          end
                                      end
                                  | 1%positive => Pos.IsNeg
                                  end
                                for
                                sub_mask) n' m'
                             with
                             | Pos.IsPos p => N.pos p
                             | _ => 0%N
                             end
                         end
                     end)
                   else
                    (match q with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end,
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end)
               | (a'~0)%positive =>
                   let (q, r) := pos_div_eucl a' b in
                   if
                    match
                      match b with
                      | 0%N =>
                          match
                            match r with
                            | 0%N => 0%N
                            | N.pos p => N.pos p~0
                            end
                          with
                          | 0%N => Eq
                          | N.pos _ => Lt
                          end
                      | N.pos n' =>
                          match
                            match r with
                            | 0%N => 0%N
                            | N.pos p => N.pos p~0
                            end
                          with
                          | 0%N => Gt
                          | N.pos m' =>
                              (fix compare_cont
                                 (r0 : comparison) 
                                 (x y : positive) {struct y} : comparison :=
                                 match x with
                                 | (p~1)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont r0 p q0
                                     | (q0~0)%positive =>
                                         compare_cont Gt p q0
                                     | 1%positive => Gt
                                     end
                                 | (p~0)%positive =>
                                     match y with
                                     | (q0~1)%positive =>
                                         compare_cont Lt p q0
                                     | (q0~0)%positive =>
                                         compare_cont r0 p q0
                                     | 1%positive => Gt
                                     end
                                 | 1%positive =>
                                     match y with
                                     | 1%positive => r0
                                     | _ => Lt
                                     end
                                 end) Eq n' m'
                          end
                      end
                    with
                    | Gt => false
                    | _ => true
                    end
                   then
                    (match q with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end,
                     match
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                     with
                     | 0%N => 0%N
                     | N.pos n' =>
                         match b with
                         | 0%N =>
                             match r with
                             | 0%N => 0%N
                             | N.pos p => N.pos p~0
                             end
                         | N.pos m' =>
                             match
                               (fix sub_mask (x y : positive) {struct y} :
                                    Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive => Pos.IsPos p~0
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | 1%positive =>
                                      match y with
                                      | 1%positive => Pos.IsNul
                                      | _ => Pos.IsNeg
                                      end
                                  end
                                with sub_mask_carry
                                  (x y : positive) {struct y} : Pos.mask :=
                                  match x with
                                  | (p~1)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          Pos.IsPos
                                            ((fix pred_double 
                                              ... : positive :=
                                                match ... with
                                                | ... ...%positive
                                                | ... ...%positive
                                                | ... 1%positive
                                                end) p)
                                      end
                                  | (p~0)%positive =>
                                      match y with
                                      | (q0~1)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsNul
                                          | Pos.IsPos p0 => Pos.IsPos p0~0
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | (q0~0)%positive =>
                                          match sub_mask_carry p q0 with
                                          | Pos.IsNul => Pos.IsPos 1
                                          | Pos.IsPos p0 => Pos.IsPos p0~1
                                          | Pos.IsNeg => Pos.IsNeg
                                          end
                                      | 1%positive =>
                                          match p with
                                          | (p0~1)%positive =>
                                              Pos.IsPos p0~0~0
                                          | (p0~0)%positive =>
                                              Pos.IsPos ((... ...) p0)~0
                                          | 1%positive => Pos.IsNul
                                          end
                                      end
                                  | 1%positive => Pos.IsNeg
                                  end
                                for
                                sub_mask) n' m'
                             with
                             | Pos.IsPos p => N.pos p
                             | _ => 0%N
                             end
                         end
                     end)
                   else
                    (match q with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end,
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end)
               | 1%positive =>
                   match b with
                   | 1%N => (1%N, 0%N)
                   | _ => (0%N, 1%N)
                   end
               end) p (N.pos HA) in
          if
           match
             match match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end with
             | 0%N => Gt
             | N.pos m' =>
                 (fix compare_cont
                    (r0 : comparison) (x y : positive) {struct y} :
                      comparison :=
                    match x with
                    | (p~1)%positive =>
                        match y with
                        | (q0~1)%positive => compare_cont r0 p q0
                        | (q0~0)%positive => compare_cont Gt p q0
                        | 1%positive => Gt
                        end
                    | (p~0)%positive =>
                        match y with
                        | (q0~1)%positive => compare_cont Lt p q0
                        | (q0~0)%positive => compare_cont r0 p q0
                        | 1%positive => Gt
                        end
                    | 1%positive =>
                        match y with
                        | 1%positive => r0
                        | _ => Lt
                        end
                    end) Eq HA m'
             end
           with
           | Gt => false
           | _ => true
           end
          then
           (match q with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end,
            match match r with
                  | 0%N => 1%N
                  | N.pos p => N.pos p~1
                  end with
            | 0%N => 0%N
            | N.pos n' =>
                match
                  (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                     match x with
                     | (p~1)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive => Pos.IsPos p~0
                         end
                     | (p~0)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p0~1)%positive => (p0~0~1)%positive
                                   | (p0~0)%positive =>
                                       ((pred_double p0)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p)
                         end
                     | 1%positive =>
                         match y with
                         | 1%positive => Pos.IsNul
                         | _ => Pos.IsNeg
                         end
                     end
                   with sub_mask_carry (x y : positive) {struct y} :
                       Pos.mask :=
                     match x with
                     | (p~1)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p0~1)%positive => (p0~0~1)%positive
                                   | (p0~0)%positive =>
                                       ((pred_double p0)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p)
                         end
                     | (p~0)%positive =>
                         match y with
                         | (q0~1)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsNul
                             | Pos.IsPos p0 => Pos.IsPos p0~0
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | (q0~0)%positive =>
                             match sub_mask_carry p q0 with
                             | Pos.IsNul => Pos.IsPos 1
                             | Pos.IsPos p0 => Pos.IsPos p0~1
                             | Pos.IsNeg => Pos.IsNeg
                             end
                         | 1%positive =>
                             match p with
                             | (p0~1)%positive => Pos.IsPos p0~0~0
                             | (p0~0)%positive =>
                                 Pos.IsPos
                                   ((fix pred_double 
                                     (x0 : positive) : positive :=
                                       match x0 with
                                       | (p1~1)%positive => (p1~0~1)%positive
                                       | (p1~0)%positive =>
                                           ((pred_double p1)~1)%positive
                                       | 1%positive => 1%positive
                                       end) p0)~0
                             | 1%positive => Pos.IsNul
                             end
                         end
                     | 1%positive => Pos.IsNeg
                     end
                   for
                   sub_mask) n' HA
                with
                | Pos.IsPos p => N.pos p
                | _ => 0%N
                end
            end)
          else
           (match q with
            | 0%N => 0%N
            | N.pos p => N.pos p~0
            end, match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq HA m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' HA
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      let (q, r) :=
        (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
           match a with
           | (a'~1)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 1%N
                         | N.pos p => N.pos p~1
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                                | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end)
           | (a'~0)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 0%N
                         | N.pos p => N.pos p~0
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                                | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end)
           | 1%positive =>
               match b with
               | 1%N => (1%N, 0%N)
               | _ => (0%N, 1%N)
               end
           end) p (N.pos HA) in
      if
       match
         match match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end with
         | 0%N => Gt
         | N.pos m' =>
             (fix compare_cont
                (r0 : comparison) (x y : positive) {struct y} : comparison :=
                match x with
                | (p~1)%positive =>
                    match y with
                    | (q0~1)%positive => compare_cont r0 p q0
                    | (q0~0)%positive => compare_cont Gt p q0
                    | 1%positive => Gt
                    end
                | (p~0)%positive =>
                    match y with
                    | (q0~1)%positive => compare_cont Lt p q0
                    | (q0~0)%positive => compare_cont r0 p q0
                    | 1%positive => Gt
                    end
                | 1%positive => match y with
                                | 1%positive => r0
                                | _ => Lt
                                end
                end) Eq HA m'
         end
       with
       | Gt => false
       | _ => true
       end
      then
       (match q with
        | 0%N => 1%N
        | N.pos p => N.pos p~1
        end,
        match match r with
              | 0%N => 1%N
              | N.pos p => N.pos p~1
              end with
        | 0%N => 0%N
        | N.pos n' =>
            match
              (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive => Pos.IsPos p~0
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         Pos.IsPos
                           ((fix pred_double (x0 : positive) : positive :=
                               match x0 with
                               | (p0~1)%positive => (p0~0~1)%positive
                               | (p0~0)%positive =>
                                   ((pred_double p0)~1)%positive
                               | 1%positive => 1%positive
                               end) p)
                     end
                 | 1%positive =>
                     match y with
                     | 1%positive => Pos.IsNul
                     | _ => Pos.IsNeg
                     end
                 end
               with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
                 match x with
                 | (p~1)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         Pos.IsPos
                           ((fix pred_double (x0 : positive) : positive :=
                               match x0 with
                               | (p0~1)%positive => (p0~0~1)%positive
                               | (p0~0)%positive =>
                                   ((pred_double p0)~1)%positive
                               | 1%positive => 1%positive
                               end) p)
                     end
                 | (p~0)%positive =>
                     match y with
                     | (q0~1)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsNul
                         | Pos.IsPos p0 => Pos.IsPos p0~0
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | (q0~0)%positive =>
                         match sub_mask_carry p q0 with
                         | Pos.IsNul => Pos.IsPos 1
                         | Pos.IsPos p0 => Pos.IsPos p0~1
                         | Pos.IsNeg => Pos.IsNeg
                         end
                     | 1%positive =>
                         match p with
                         | (p0~1)%positive => Pos.IsPos p0~0~0
                         | (p0~0)%positive =>
                             Pos.IsPos
                               ((fix pred_double (x0 : positive) :
                                     positive :=
                                   match x0 with
                                   | (p1~1)%positive => (p1~0~1)%positive
                                   | (p1~0)%positive =>
                                       ((pred_double p1)~1)%positive
                                   | 1%positive => 1%positive
                                   end) p0)~0
                         | 1%positive => Pos.IsNul
                         end
                     end
                 | 1%positive => Pos.IsNeg
                 end
               for
               sub_mask) n' HA
            with
            | Pos.IsPos p => N.pos p
            | _ => 0%N
            end
        end)
      else
       (match q with
        | 0%N => 0%N
        | N.pos p => N.pos p~0
        end, match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq HA m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' HA
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
(0 <= a -> False)
FlattenExpr: Entering slow lemmas section
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
find_witness Control.TimeoutCrunching: (update f f' k f' = k)
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
             match a with
             | (a'~1)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 1%N
                           | N.pos p => N.pos p~1
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end)
             | (a'~0)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 0%N
                           | N.pos p => N.pos p~0
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end)
             | 1%positive =>
                 match b with
                 | 1%N => (1%N, 0%N)
                 | _ => (0%N, 1%N)
                 end
             end) p (N.pos Hab) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq Hab m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' Hab
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
         match a with
         | (a'~1)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end)
         | (a'~0)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end)
         | 1%positive =>
             match b with
             | 1%N => (1%N, 0%N)
             | _ => (0%N, 1%N)
             end
         end) p (N.pos Hab) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq Hab m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' Hab
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
Crunching:
(match
   (let (_, y) :=
      let (q, r) :=
        let (q, r) :=
          (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
             match a with
             | (a'~1)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 1%N
                          | N.pos p => N.pos p~1
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 1%N
                           | N.pos p => N.pos p~1
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end)
             | (a'~0)%positive =>
                 let (q, r) := pos_div_eucl a' b in
                 if
                  match
                    match b with
                    | 0%N =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Eq
                        | N.pos _ => Lt
                        end
                    | N.pos n' =>
                        match
                          match r with
                          | 0%N => 0%N
                          | N.pos p => N.pos p~0
                          end
                        with
                        | 0%N => Gt
                        | N.pos m' =>
                            (fix compare_cont
                               (r0 : comparison) (x y : positive) {struct y} :
                                 comparison :=
                               match x with
                               | (p~1)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont r0 p q0
                                   | (q0~0)%positive => compare_cont Gt p q0
                                   | 1%positive => Gt
                                   end
                               | (p~0)%positive =>
                                   match y with
                                   | (q0~1)%positive => compare_cont Lt p q0
                                   | (q0~0)%positive => compare_cont r0 p q0
                                   | 1%positive => Gt
                                   end
                               | 1%positive =>
                                   match y with
                                   | 1%positive => r0
                                   | _ => Lt
                                   end
                               end) Eq n' m'
                        end
                    end
                  with
                  | Gt => false
                  | _ => true
                  end
                 then
                  (match q with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end,
                   match
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                   with
                   | 0%N => 0%N
                   | N.pos n' =>
                       match b with
                       | 0%N =>
                           match r with
                           | 0%N => 0%N
                           | N.pos p => N.pos p~0
                           end
                       | N.pos m' =>
                           match
                             (fix sub_mask (x y : positive) {struct y} :
                                  Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive => Pos.IsPos p~0
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | 1%positive =>
                                    match y with
                                    | 1%positive => Pos.IsNul
                                    | _ => Pos.IsNeg
                                    end
                                end
                              with sub_mask_carry
                                (x y : positive) {struct y} : Pos.mask :=
                                match x with
                                | (p~1)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | ...%positive =>
                                                 (p0~0~1)%positive
                                              | ...%positive =>
                                                 ((...)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p)
                                    end
                                | (p~0)%positive =>
                                    match y with
                                    | (q0~1)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsNul
                                        | Pos.IsPos p0 => Pos.IsPos p0~0
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | (q0~0)%positive =>
                                        match sub_mask_carry p q0 with
                                        | Pos.IsNul => Pos.IsPos 1
                                        | Pos.IsPos p0 => Pos.IsPos p0~1
                                        | Pos.IsNeg => Pos.IsNeg
                                        end
                                    | 1%positive =>
                                        match p with
                                        | (p0~1)%positive => Pos.IsPos p0~0~0
                                        | (p0~0)%positive =>
                                            Pos.IsPos
                                              ((fix pred_double 
                                                ... : positive :=
                                                 match ... with
                                                 | ... ...%positive
                                                 | ... ...%positive
                                                 | ... 1%positive
                                                 end) p0)~0
                                        | 1%positive => Pos.IsNul
                                        end
                                    end
                                | 1%positive => Pos.IsNeg
                                end
                              for
                              sub_mask) n' m'
                           with
                           | Pos.IsPos p => N.pos p
                           | _ => 0%N
                           end
                       end
                   end)
                 else
                  (match q with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end, match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end)
             | 1%positive =>
                 match b with
                 | 1%N => (1%N, 0%N)
                 | _ => (0%N, 1%N)
                 end
             end) p (N.pos Hab) in
        if
         match
           match match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end with
           | 0%N => Gt
           | N.pos m' =>
               (fix compare_cont
                  (r0 : comparison) (x y : positive) {struct y} :
                    comparison :=
                  match x with
                  | (p~1)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont r0 p q0
                      | (q0~0)%positive => compare_cont Gt p q0
                      | 1%positive => Gt
                      end
                  | (p~0)%positive =>
                      match y with
                      | (q0~1)%positive => compare_cont Lt p q0
                      | (q0~0)%positive => compare_cont r0 p q0
                      | 1%positive => Gt
                      end
                  | 1%positive =>
                      match y with
                      | 1%positive => r0
                      | _ => Lt
                      end
                  end) Eq Hab m'
           end
         with
         | Gt => false
         | _ => true
         end
        then
         (match q with
          | 0%N => 1%N
          | N.pos p => N.pos p~1
          end,
          match match r with
                | 0%N => 1%N
                | N.pos p => N.pos p~1
                end with
          | 0%N => 0%N
          | N.pos n' =>
              match
                (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive => Pos.IsPos p~0
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | 1%positive =>
                       match y with
                       | 1%positive => Pos.IsNul
                       | _ => Pos.IsNeg
                       end
                   end
                 with sub_mask_carry (x y : positive) {struct y} :
                     Pos.mask :=
                   match x with
                   | (p~1)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p0~1)%positive => (p0~0~1)%positive
                                 | (p0~0)%positive =>
                                     ((pred_double p0)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p)
                       end
                   | (p~0)%positive =>
                       match y with
                       | (q0~1)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsNul
                           | Pos.IsPos p0 => Pos.IsPos p0~0
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | (q0~0)%positive =>
                           match sub_mask_carry p q0 with
                           | Pos.IsNul => Pos.IsPos 1
                           | Pos.IsPos p0 => Pos.IsPos p0~1
                           | Pos.IsNeg => Pos.IsNeg
                           end
                       | 1%positive =>
                           match p with
                           | (p0~1)%positive => Pos.IsPos p0~0~0
                           | (p0~0)%positive =>
                               Pos.IsPos
                                 ((fix pred_double 
                                   (x0 : positive) : positive :=
                                     match x0 with
                                     | (p1~1)%positive => (p1~0~1)%positive
                                     | (p1~0)%positive =>
                                         ((pred_double p1)~1)%positive
                                     | 1%positive => 1%positive
                                     end) p0)~0
                           | 1%positive => Pos.IsNul
                           end
                       end
                   | 1%positive => Pos.IsNeg
                   end
                 for
                 sub_mask) n' Hab
              with
              | Pos.IsPos p => N.pos p
              | _ => 0%N
              end
          end)
        else
         (match q with
          | 0%N => 0%N
          | N.pos p => N.pos p~0
          end, match r with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    y)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (_, y) :=
    let (q, r) :=
      (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
         match a with
         | (a'~1)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 1%N
                       | N.pos p => N.pos p~1
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end)
         | (a'~0)%positive =>
             let (q, r) := pos_div_eucl a' b in
             if
              match
                match b with
                | 0%N =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Eq
                    | N.pos _ => Lt
                    end
                | N.pos n' =>
                    match
                      match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end
                    with
                    | 0%N => Gt
                    | N.pos m' =>
                        (fix compare_cont
                           (r0 : comparison) (x y : positive) {struct y} :
                             comparison :=
                           match x with
                           | (p~1)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont r0 p q0
                               | (q0~0)%positive => compare_cont Gt p q0
                               | 1%positive => Gt
                               end
                           | (p~0)%positive =>
                               match y with
                               | (q0~1)%positive => compare_cont Lt p q0
                               | (q0~0)%positive => compare_cont r0 p q0
                               | 1%positive => Gt
                               end
                           | 1%positive =>
                               match y with
                               | 1%positive => r0
                               | _ => Lt
                               end
                           end) Eq n' m'
                    end
                end
              with
              | Gt => false
              | _ => true
              end
             then
              (match q with
               | 0%N => 1%N
               | N.pos p => N.pos p~1
               end,
               match
                 match r with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end
               with
               | 0%N => 0%N
               | N.pos n' =>
                   match b with
                   | 0%N =>
                       match r with
                       | 0%N => 0%N
                       | N.pos p => N.pos p~0
                       end
                   | N.pos m' =>
                       match
                         (fix sub_mask (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive => Pos.IsPos p~0
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | 1%positive =>
                                match y with
                                | 1%positive => Pos.IsNul
                                | _ => Pos.IsNeg
                                end
                            end
                          with sub_mask_carry (x y : positive) {struct y} :
                              Pos.mask :=
                            match x with
                            | (p~1)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    Pos.IsPos
                                      ((fix pred_double 
                                        (x0 : positive) : positive :=
                                          match x0 with
                                          | (p0~1)%positive =>
                                              (p0~0~1)%positive
                                          | (p0~0)%positive =>
                                              ((pred_double p0)~1)%positive
                                          | 1%positive => 1%positive
                                          end) p)
                                end
                            | (p~0)%positive =>
                                match y with
                                | (q0~1)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsNul
                                    | Pos.IsPos p0 => Pos.IsPos p0~0
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | (q0~0)%positive =>
                                    match sub_mask_carry p q0 with
                                    | Pos.IsNul => Pos.IsPos 1
                                    | Pos.IsPos p0 => Pos.IsPos p0~1
                                    | Pos.IsNeg => Pos.IsNeg
                                    end
                                | 1%positive =>
                                    match p with
                                    | (p0~1)%positive => Pos.IsPos p0~0~0
                                    | (p0~0)%positive =>
                                        Pos.IsPos
                                          ((fix pred_double 
                                            (x0 : positive) : positive :=
                                              match x0 with
                                              | (p1~1)%positive =>
                                                 (p1~0~1)%positive
                                              | (p1~0)%positive =>
                                                 ((pred_double p1)~1)%positive
                                              | 1%positive => 1%positive
                                              end) p0)~0
                                    | 1%positive => Pos.IsNul
                                    end
                                end
                            | 1%positive => Pos.IsNeg
                            end
                          for
                          sub_mask) n' m'
                       with
                       | Pos.IsPos p => N.pos p
                       | _ => 0%N
                       end
                   end
               end)
             else
              (match q with
               | 0%N => 0%N
               | N.pos p => N.pos p~0
               end, match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end)
         | 1%positive =>
             match b with
             | 1%N => (1%N, 0%N)
             | _ => (0%N, 1%N)
             end
         end) p (N.pos Hab) in
    if
     match
       match match r with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end with
       | 0%N => Gt
       | N.pos m' =>
           (fix compare_cont (r0 : comparison) (x y : positive) {struct y} :
                comparison :=
              match x with
              | (p~1)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont r0 p q0
                  | (q0~0)%positive => compare_cont Gt p q0
                  | 1%positive => Gt
                  end
              | (p~0)%positive =>
                  match y with
                  | (q0~1)%positive => compare_cont Lt p q0
                  | (q0~0)%positive => compare_cont r0 p q0
                  | 1%positive => Gt
                  end
              | 1%positive => match y with
                              | 1%positive => r0
                              | _ => Lt
                              end
              end) Eq Hab m'
       end
     with
     | Gt => false
     | _ => true
     end
    then
     (match q with
      | 0%N => 1%N
      | N.pos p => N.pos p~1
      end,
      match match r with
            | 0%N => 1%N
            | N.pos p => N.pos p~1
            end with
      | 0%N => 0%N
      | N.pos n' =>
          match
            (fix sub_mask (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive => Pos.IsPos p~0
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | 1%positive =>
                   match y with
                   | 1%positive => Pos.IsNul
                   | _ => Pos.IsNeg
                   end
               end
             with sub_mask_carry (x y : positive) {struct y} : Pos.mask :=
               match x with
               | (p~1)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       Pos.IsPos
                         ((fix pred_double (x0 : positive) : positive :=
                             match x0 with
                             | (p0~1)%positive => (p0~0~1)%positive
                             | (p0~0)%positive =>
                                 ((pred_double p0)~1)%positive
                             | 1%positive => 1%positive
                             end) p)
                   end
               | (p~0)%positive =>
                   match y with
                   | (q0~1)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsNul
                       | Pos.IsPos p0 => Pos.IsPos p0~0
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | (q0~0)%positive =>
                       match sub_mask_carry p q0 with
                       | Pos.IsNul => Pos.IsPos 1
                       | Pos.IsPos p0 => Pos.IsPos p0~1
                       | Pos.IsNeg => Pos.IsNeg
                       end
                   | 1%positive =>
                       match p with
                       | (p0~1)%positive => Pos.IsPos p0~0~0
                       | (p0~0)%positive =>
                           Pos.IsPos
                             ((fix pred_double (x0 : positive) : positive :=
                                 match x0 with
                                 | (p1~1)%positive => (p1~0~1)%positive
                                 | (p1~0)%positive =>
                                     ((pred_double p1)~1)%positive
                                 | 1%positive => 1%positive
                                 end) p0)~0
                       | 1%positive => Pos.IsNul
                       end
                   end
               | 1%positive => Pos.IsNeg
               end
             for
             sub_mask) n' Hab
          with
          | Pos.IsPos p => N.pos p
          | _ => 0%N
          end
      end)
    else
     (match q with
      | 0%N => 0%N
      | N.pos p => N.pos p~0
      end, match r with
           | 0%N => 1%N
           | N.pos p => N.pos p~1
           end) in
  y))
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
More readable: initial segment:
implb
With remainder:
[Ast.tApp (Ast.tVar "eqb0") [Ast.tRel 5; Ast.tRel 1];
 Ast.tApp (Ast.tVar "eqb1") [Ast.tRel 4; Ast.tRel 0]]
Finished transaction in 175.198 secs (174.628u,0.367s) (successful)
out of reach
Tactic call ran for 0.008 secs (0.005u,0.002s) (failure)
out of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.01 secs (0.009u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.007 secs (0.006u,0.001s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
(map.only_differ locals1 vset locals2 ->
 Lift1Prop.iff1 (rep.equiv x (rep.rtype_of_ltype varnames) s locals1)
   (rep.equiv x (rep.rtype_of_ltype varnames) s locals2))
Chars 51124 - 51157 [(set~(ff~:=~@O_rec~O~_~_~_~_~_...] 40.149 secs (0.002u,0.031s)
Chars 51162 - 51185 [exists~(ff~(center~_)).] 0.002 secs (0.001u,0.001s)
Chars 51190 - 51199 [(intros~a).] 0. secs (0.u,0.s)
Chars 51200 - 51209 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 51214 - 51252 [refine~(ap~ff~(contr~(to~O~_~a...] 0.002 secs (0.002u,0.s)
Chars 51257 - 51274 [(apply~O_rec_beta).] 0.001 secs (0.001u,0.s)
Chars 51124 - 51157 [(set~(ff~:=~@O_rec~O~_~_~_~_~_...] 0. secs (0.u,0.s)
Chars 51162 - 51185 [exists~(ff~(center~_)).] 0. secs (0.u,0.s)
Chars 51190 - 51199 [(intros~a).] 0. secs (0.u,0.s)
Chars 51200 - 51209 [symmetry.] 0. secs (0.u,0.s)
Chars 51214 - 51252 [refine~(ap~ff~(contr~(to~O~_~a...] 0. secs (0.u,0.s)
Chars 51257 - 51274 [(apply~O_rec_beta).] 0. secs (0.u,0.s)
Chars 51277 - 51285 [Defined.] 0. secs (0.u,0.s)
Chars 51398 - 51492 [Definition~isconnected_from_el...] 0. secs (0.u,0.s)
Chars 51495 - 51501 [Proof.] 0. secs (0.u,0.s)
Case compile_stmt_correct/SStackalloc
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: (forall b : x, EQ <> Ha -> update x' EQ b Ha = x' Ha)
out of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.008 secs (0.006u,0.001s) (failure)
Crunching: (EQ <> q -> update x' EQ Hnd q = x' q)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.009 secs (0.009u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: Z
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.012 secs (0.007u,0.003s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update x' Temp a a0 = x' a0)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
find_witness Control.TimeoutCrunching: (n <> 0 -> update m n h 0 = m 0)
find_witness Control.TimeoutCrunching: (forall b : x, EQ <> Ha -> update x' EQ b Ha = x' Ha)
Case compile_stmt_correct/SLit
Case compile_stmt_correct/SOp
find_witness Control.TimeoutCrunching: (EQ <> q -> update x' EQ Hnd q = x' q)
Tactic call ran for 66.859 secs (65.776u,1.049s) (success)
Tactic call ran for 0.515 secs (0.514u,0.s) (success)
Crunching:
((forall (l1 lf1 : list R) (a b c : R) (f : R -> R),
  adapted_couple f a b l1 lf1 ->
  a <= c <= b -> {l : list R & {l0 : list R & adapted_couple f c b l l0}}) ->
 (pr_outcome_sum l (fun y : nat => f (S y)) + a)%R = sum_over_list (a :: l))
find_witness Control.TimeoutTactic call ran for 0.015 secs (0.011u,0.002s) (success)
find_witness Control.TimeoutCompiling decision tree...
Tactic call ran for 0.011 secs (0.011u,0.s) (success)
Splitting rewrite rules...
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Chars 51506 - 51516 [(intros~nh).] 40.137 secs (0.u,0.029s)
Chars 51521 - 51536 [exists~nh.1.] 0.001 secs (0.001u,0.s)
Chars 51541 - 51559 [rapply~O_indpaths.] 0.005 secs (0.003u,0.001s)
Proving Rewriter_Wf...
Chars 51564 - 51598 [(intros~x;~symmetry;~apply~nh.2).] 0.003 secs (0.003u,0.s)
Chars 51506 - 51516 [(intros~nh).] 0. secs (0.u,0.s)
Chars 51521 - 51536 [exists~nh.1.] 0. secs (0.u,0.s)
Chars 51541 - 51559 [rapply~O_indpaths.] 0. secs (0.u,0.s)
Chars 51564 - 51598 [(intros~x;~symmetry;~apply~nh.2).] 0.001 secs (0.001u,0.s)
Chars 51601 - 51609 [Defined.] 0.001 secs (0.u,0.s)
Chars 51652 - 51782 [Definition~isconnected_from_el...] 0. secs (0.u,0.s)
Chars 51785 - 51791 [Proof.] 0. secs (0.u,0.s)
Crunching:
(forall d1 d2 : R,
 d1 > R0 ->
 d2 > R0 ->
 (if Rcase_abs (l - P) then (- (l - P))%R else (l - P)%R) < Rmin d1 d2 ->
 P - d1 <= l <= P + d2)
Tactic call ran for 2.828 secs (2.787u,0.039s) (success)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching:
(forall d1 d2 : R,
 d1 > R0 ->
 d2 > R0 ->
 (if Rcase_abs (l - P) then (- (l - P))%R else (l - P)%R) < Rmin d1 d2 ->
 P - d1 <= l <= P + d2)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching:
(forall d1 d2 : R,
 d1 > R0 ->
 d2 > R0 ->
 (if Rcase_abs (l - P) then (- (l - P))%R else (l - P)%R) < Rmin d1 d2 ->
 P - d1 <= l <= P + d2)
Crunching:
(forall d1 d2 : R,
 d1 > R0 ->
 d2 > R0 ->
 (if Rcase_abs (l - P) then (- (l - P))%R else (l - P)%R) < Rmin d1 d2 ->
 P - d1 <= l <= P + d2)
Crunching: (R - n <= L <= R + d2)
Crunching: (R - n <= L <= R + d2)
Crunching: (R - n <= L <= R + d2)
Tactic call ran for 0.015 secs (0.015u,0.s) (success)
Crunching:
(PI / 4 < PI / 2 ->
 (forall x l1 l2 : R,
  derivable_pt_lim (id + fct_cte (PI / 2)) x l1 ->
  derivable_pt_lim sin ((id + fct_cte (PI / 2))%F x) l2 ->
  derivable_pt_lim (comp sin (id + fct_cte (PI / 2))) x (l2 * l1)%R) ->
 x - H <= y <= x + l)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching: (x - H <= y <= x + LE)
Crunching: (update e2 z1 z2 = e2)
find_witness Control.TimeoutCrunching: (update e2 z1 z2 = e2)
Case compile_stmt_correct/SSet
Crunching: (r - Hy <= y <= r + HnotA)
Crunching: (r - Hy <= y <= r + HnotA)
Tactic call ran for 14.705 secs (14.584u,0.108s) (success)
Crunching: (r - Hy <= y <= r + HnotA)
Case compile_stmt_correct/SIf/Then
Crunching: (Rabs (y - r) < Rmin Hy HnotA -> r - Hy <= y <= r + HnotA)
Crunching: (Rabs (y - r) < Rmin Hy del -> r - Hy <= y <= r + del)
Crunching: (Rabs (y - r) < Rmin Hy del -> r - Hy <= y <= r + del)
Crunching: (Rabs (y - r) < Rmin Hy del -> r - Hy <= y <= r + del)
Crunching: (Rabs (y - r) < Rmin Hy del -> r - Hy <= y <= r + del)
Tactic call ran for 0.01 secs (0.009u,0.001s) (success)
(forall (e : list Symbolic.expr) (v1 v2 : list Z),
 Forall2 (eval G1 d1) e v1 -> Forall2 (eval G2 d2) e v2 -> v1 = v2)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching: (r - a <= x <= r + b)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
find_witness Control.Timeout(type.related_hetero abstraction_relation'
   (fill_in_bottom_for_arrows
      (f
         match t1 with
         | type.base _ => y
         | (_ -> _)%etype => partial.bottom abstract_domain' bottom'
         end)) (v z))
Tactic call ran for 0.013 secs (0.011u,0.001s) (success)
Crunching:
(m > 0 -> H2 > 0 -> Rabs (x - r) < Rmin m H2 -> r - m <= x <= r + H2)
Case compile_stmt_correct/SIf/Else
Assembling rewrite_head...
Reducing rewrite_head...
Crunching: (Rabs (a - l) < Rmin b H0 -> l - b <= a <= l + H0)
Crunching: (l - b <= a <= l + n)
Tactic call ran for 3.794 secs (3.725u,0.06s) (success)
Proving Rewriter_Interp...
Case compile_stmt_correct/SLoop
(forall (e : list Symbolic.expr) (v1 v2 : list Z),
 Forall2 (eval G1 d1) e v1 -> Forall2 (eval G2 d2) e v2 -> v1 = v2)
Chars 51796 - 51805 [(intros~H).] 40.136 secs (0.u,0.029s)
Chars 51810 - 51874 [exact~(isconnected_from_elim_t...] 0.001 secs (0.u,0.s)
Chars 51796 - 51805 [(intros~H).] 0. secs (0.u,0.s)
Chars 51810 - 51874 [exact~(isconnected_from_elim_t...] 0. secs (0.u,0.s)
Chars 51877 - 51885 [Defined.] 0. secs (0.u,0.s)
Chars 51939 - 52095 [#[global]~Instance~isconnected...] 0.001 secs (0.u,0.001s)
Chars 52098 - 52104 [Proof.] 0. secs (0.u,0.s)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: False
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: False
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: False
Crunching: False
Crunching: False
Crunching:
(exp (pr_outcome_sum l H2) <
 exp (pr_outcome_sum l (fun rnd : nat => H2 rnd || f2 rnd)))
Crunching: False
Crunching: False
Crunching: False
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 29.577 secs (29.467u,0.08s) (success)
Crunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
Crunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
Crunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
Crunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
find_witness Control.TimeoutCrunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 update (update f i b) i b' = update f i b')
Tactic call ran for 10.85 secs (10.777u,0.06s) (success)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching:
(nat ->
 (fun j : nat =>
  if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) j 0
  then H'2
  else
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) j 0
   then H
   else m j) =
 (fun j : nat =>
  if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) j 0
  then H'2
  else m j))
Crunching: (update (update m 0 H) 0 a = update m 0 a)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching: False
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching:
(nat ->
 (fun j : nat =>
  if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) j 0
  then H'2
  else
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) j 0
   then H
   else m j) =
 (fun j : nat =>
  if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) j 0
  then H'2
  else m j))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: False
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
Crunching: (update m 0 a = update (update m 0 H) 0 a)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (update (update m 0 H) 0 a = update m 0 a)
bad
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
((forall x : nat, p x = true -> Heq x = true) ->
 pr_outcome_sum l p <= pr_outcome_sum l Heq * 1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Chars 52109 - 52151 [(apply~isconnected_from_elim;~...] 40.135 secs (0.001u,0.029s)
Chars 52156 - 52227 [(pose~(nB~:=~fun~a~=>~@isconne...] 0.002 secs (0.002u,0.s)
Chars 52232 - 52284 [(pose~(nA~:=~isconnected_elim~...] 0.002 secs (0.002u,0.s)
Chars 52289 - 52317 [(exists~nA.1;~intros~[a~b]).] 0.002 secs (0.001u,0.s)
Chars 52322 - 52350 [exact~((nB~a).2~b~@~nA.2~a).] 0.001 secs (0.001u,0.s)
Chars 52109 - 52151 [(apply~isconnected_from_elim;~...] 0. secs (0.u,0.s)
Chars 52156 - 52227 [(pose~(nB~:=~fun~a~=>~@isconne...] 0. secs (0.u,0.s)
Chars 52232 - 52284 [(pose~(nA~:=~isconnected_elim~...] 0. secs (0.u,0.s)
Chars 52289 - 52317 [(exists~nA.1;~intros~[a~b]).] 0. secs (0.u,0.s)
Chars 52322 - 52350 [exact~((nB~a).2~b~@~nA.2~a).] 0. secs (0.u,0.s)
Chars 52353 - 52361 [Defined.] 0.001 secs (0.001u,0.s)
Chars 52408 - 52486 [#[global]~Instance~isconnected...] 0. secs (0.u,0.s)
Chars 52489 - 52495 [Proof.] 0. secs (0.u,0.s)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.001s) (failure)
Chars 52500 - 52529 [(apply~contr_O_contr;~exact~_).] 0.058 secs (0.001u,0.025s)
Chars 52500 - 52529 [(apply~contr_O_contr;~exact~_).] 0. secs (0.u,0.s)
Chars 52532 - 52540 [Defined.] 0. secs (0.u,0.s)
Chars 52615 - 52695 [Definition~contr_trunc_conn~{A...] 0. secs (0.u,0.s)
Chars 52698 - 52704 [Proof.] 0. secs (0.u,0.s)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Case compile_stmt_correct/SSeq
Assembling verified rewriter...
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Refining with verified rewriter...
Crunching:
(P <> n -> update (update ep P a) n b = update (update ep n b) P a)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching:
(P <> n -> update (update ep P a) n b = update (update ep n b) P a)
find_witness Fun.Finally_raised: Control.TimeoutCrunching:
((forall x : nat, p x = true -> Heq x = true) ->
 pr_outcome_sum l p <= pr_outcome_sum l Heq * 1)
Crunching:
(P <> n -> update (update ep P a) n b = update (update ep n b) P a)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall b b' : eps,
 P <> n -> update (update ep P b) n b' = update (update ep n b') P b)
Crunching:
(forall b b' : eps,
 P <> n -> update (update ep P b) n b' = update (update ep n b') P b)
Crunching:
(forall b b' : eps,
 P <> n -> update (update ep P b) n b' = update (update ep n b') P b)
Crunching:
(forall b b' : eps,
 P <> n -> update (update ep P b) n b' = update (update ep n b') P b)
Crunching:
(forall b b' : eps,
 P <> n -> update (update ep P b) n b' = update (update ep n b') P b)
Crunching:
(forall (i j : nat) (b b' : eps),
 i <> j -> update (update ep i b) j b' = update (update ep j b') i b)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Case compile_stmt_correct/SSkip
Crunching:
((forall x : nat, p x = true -> Heq x = true) ->
 pr_outcome_sum l p <= pr_outcome_sum l Heq * 1)
Crunching: (update (update r fv lm) k H = update (update r k H) fv lm)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
FlattenExpr: flattenExpr_correct_aux done
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(forall b b' : eps,
 P <> 0 -> update (update ep P b) 0 b' = update (update ep 0 b') P b)
Tactic call ran for 188.889 secs (183.742u,4.966s) (success)
Tactic call ran for 0.555 secs (0.554u,0.s) (success)
Crunching: (update (update ep P Hxij') 0 z = update (update ep 0 z) P Hxij')
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Proving Rewriter_Wf...
(forall a b : nat, 0 <= a <= b -> b * a + a * b <= a * a + b * b)
find_witness Control.TimeoutTactic call ran for 3.496 secs (3.48u,0.009s) (success)
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Chars 52709 - 52743 [(apply~(contr_equiv~_~(to~O~A)...] 40.17 secs (0.004u,0.029s)
Chars 52709 - 52743 [(apply~(contr_equiv~_~(to~O~A)...] 0. secs (0.u,0.s)
Chars 52746 - 52754 [Defined.] 0. secs (0.u,0.s)
Chars 52817 - 52952 [#[global]~Instance~O_inverts_i...] 0. secs (0.u,0.s)
Chars 52955 - 52961 [Proof.] 0. secs (0.u,0.s)
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Chars 52966 - 52974 [exact~_.] 1.178 secs (0.035u,0.049s)
Chars 52966 - 52974 [exact~_.] 0. secs (0.u,0.s)
Chars 52977 - 52985 [Defined.] 0. secs (0.u,0.s)
Chars 53103 - 53288 [Definition~extendable_const_is...] 0. secs (0.u,0.s)
Chars 53291 - 53297 [Proof.] 0. secs (0.u,0.s)
Crunching: (0 < 0)%R
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (0 <= pr_outcome_sum n HP)
Tactic call ran for 6.099 secs (6.041u,0.048s) (success)
find_witness Control.Timeout"Did not find an instance for "
(extracted eqbX)
Crunching: (shift f 0 = f)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Crunching: (0 < 0)%R
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Crunching: (∣0⟩ = basis_vector 2 0)
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Crunching: (0 < 0)%nat
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Crunching: Type
Proving Rewriter_Interp...
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (0 <= pr_outcome_sum n a)
Crunching: (0 <= pr_outcome_sum n HP)
Crunching: (0 <= pr_outcome_sum n HP)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 7.441 secs (7.4u,0.026s) (success)
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Crunching: (shift f 0 = f)
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Crunching: (0 < 0)%R
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Crunching: (∣0⟩ = basis_vector 2 0)
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Tactic call ran for 8.504 secs (8.445u,0.045s) (success)
Crunching:
(0 <= 0 + big_sum (fun i : nat => if f i then nth i [] 0 else 0) (length []))
Crunching: (0 <= 0 + pr_outcome_sum [] f)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Crunching:
(0 <= 0 + big_sum (fun i : nat => if f i then nth i [] 0 else 0) (length []))
Crunching: (0 <= 0 + pr_outcome_sum [] f)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Crunching:
(0 <= 0 + big_sum (fun i : nat => if f i then nth i [] 0 else 0) (length []))
Crunching: (0 <= 0 + pr_outcome_sum [] f)
Finished transaction in 43.336 secs (3.068u,0.134s) (successful)
"Did not find an instance for "
(extracted eqbX)
"open obligation var_eqbX_term for it. You might want to register a instance before and rerun this."
Crunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.TimeoutCrunching: (0 < 0)%nat
find_witness Control.TimeoutAssembling verified rewriter...
Crunching: Type
Refining with verified rewriter...
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
find_witness Control.TimeoutCrunching: (forall j : nat, shift (shift y j) H = shift y (H + j))
Crunching: (shift (shift n b) a = shift n (a + b))
find_witness Control.TimeoutCrunching: (forall j : nat, shift (shift y j) H = shift y (H + j))
Crunching: (shift (shift n b) a = shift n (a + b))
Chars 53302 - 53397 [(generalize~dependent~C;~simpl...] 40.161 secs (0.005u,0.03s)
Chars 53402 - 53403 [-] 0. secs (0.u,0.s)
Chars 53404 - 53413 [(intros~f).] 0. secs (0.u,0.s)
Chars 53420 - 53480 [(exists~(fun~_~:~Unit~=>~(isco...] 0.002 secs (0.002u,0.s)
Chars 53487 - 53530 [(symmetry;~apply~(isconnected_...] 0.003 secs (0.003u,0.s)
Chars 53535 - 53536 [-] 0. secs (0.u,0.s)
Chars 53537 - 53548 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 53555 - 53638 [refine~~(extendable_postcompos...] 0.002 secs (0.002u,0.s)
Chars 53645 - 53674 [(intros~[];~apply~equiv_idmap).] 0.001 secs (0.001u,0.s)
Chars 53302 - 53397 [(generalize~dependent~C;~simpl...] 0.002 secs (0.002u,0.s)
Chars 53404 - 53413 [(intros~f).] 0. secs (0.u,0.s)
Chars 53420 - 53480 [(exists~(fun~_~:~Unit~=>~(isco...] 0. secs (0.u,0.s)
Chars 53487 - 53530 [(symmetry;~apply~(isconnected_...] 0. secs (0.u,0.s)
Chars 53537 - 53548 [(intros~h~k).] 0. secs (0.u,0.s)
Chars 53555 - 53638 [refine~~(extendable_postcompos...] 0. secs (0.u,0.s)
Chars 53645 - 53674 [(intros~[];~apply~equiv_idmap).] 0. secs (0.u,0.s)
Chars 53677 - 53685 [Defined.] 0.001 secs (0.001u,0.s)
Chars 53689 - 53933 [Definition~ooextendable_const_...] 0.001 secs (0.001u,0.s)
Chars 53937 - 54077 [Definition~isequiv_const_iscon...] 0. secs (0.u,0.s)
Chars 54080 - 54086 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutCrunching:
(interval_sum q x n Hqltx ->
 interval_sum (fun x : R => q (x + - s)%R) (x + s) (n + s) Hqltx)
Crunching: (shift (shift eps0_pos z') 0 = shift eps0_pos z')
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Crunching: (forall j : nat, shift (shift y j) H = shift y (H + j))
find_witness Control.Timeout(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Crunching: (shift (shift n b) a = shift n (a + b))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Crunching: (shift eps0_pos m = eps0_pos)
Crunching: (S m < n \/ S m = n -> False)
find_witness Control.Timeout(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
((forall n : nat, nextn <= n -> ~ varname_set_base Hn (varname_gen n)) ->
 (fix cmd (c : cmd) :
      Semantics.trace ->
      map.rep ->
      map.rep -> (Semantics.trace -> map.rep -> map.rep -> Prop) -> Prop :=
    WeakestPrecondition.cmd_body (WeakestPrecondition.call functions) cmd c)
   (snd (load_all_lists nextn Hn (list_lengths_from_value args) Hm)) tr mem0
   locals0
   (fun (tr' : Semantics.trace) (mem' locals' : map.rep) =>
    tr = tr' /\
    mem0 = mem' /\
    map.only_differ locals0
      (used_varnames nextn
         (fst
            (fst (load_all_lists nextn Hn (list_lengths_from_value args) Hm))))
      locals' /\
    (forall n : nat,
     nextn +
     fst (fst (load_all_lists nextn Hn (list_lengths_from_value args) Hm)) <=
     n ->
     ~
     varname_set_base
       (snd (fst (load_all_lists nextn Hn (list_lengths_from_value args) Hm)))
       (varname_gen n)) /\
    locally_equivalent_base args
      (base_rtype_of_ltype
         (snd
            (fst (load_all_lists nextn Hn (list_lengths_from_value args) Hm))))
      locals'))
find_witness Control.TimeoutCrunching:
(forall rl rr r1 r2 : R,
 rl <= r1 <= r2 /\ r2 <= rr ->
 (forall r : R, r1 < r < r2 -> del1 r) ->
 (forall r : R, rl < r < r1 -> ~ del1 r) ->
 (forall r : R, r2 < r < rr -> ~ del1 r) ->
 interval_sum (fun x : R => del1 (x - Na)%R) (rl + Na) (rr + Na) (r2 - r1))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Crunching:
(interval_sum (fun x : R => del1 (x + - N1)%R) (H + N1) (Hp + N1) w)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
find_witness Control.TimeoutCrunching: (shift eps0_pos j = eps0_pos)
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Crunching: (shift (shift eps0_pos z') 0 = shift eps0_pos z')
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (shift (shift eps0_pos z') 0 = shift eps0_pos z')
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
find_witness Control.Timeout(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
find_witness Control.Timeout(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
find_witness Control.Timeout(list_Z_bounded_by max_bounds (map Byte.byte.unsigned x))
Crunching: (m < p - 0 -> 0 + m < p)
Crunching: (forall j : nat, shift (shift y j) H = shift y (H + j))
Crunching:
(interval_sum q x n Hqltx ->
 interval_sum (fun x : R => q (x + - s)%R) (x + s) (n + s) Hqltx)
Crunching: (shift (shift y H0) H = shift y (H + H0))
Crunching: (shift (shift n b) a = shift n (a + b))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift f (i + j) x = shift (shift f j) i x)
Crunching: (shift f (i + j) x = shift (shift f j) i x)
Crunching: (forall j : nat, shift (shift H15 j) p = shift H15 (p + j))
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (shift eps0_pos m = eps0_pos)
Crunching: (shift eps0_pos m = eps0_pos)
Crunching: (shift eps0_pos m = eps0_pos)
Crunching: (shift eps0_pos m = eps0_pos)
Crunching: (shift eps0_pos m = eps0_pos)
Crunching: (S m < n \/ S m = n -> False)
Crunching: (S m < n \/ S m = n -> False)
find_witness Control.TimeoutTactic call ran for 0.01 secs (0.009u,0.001s) (success)
find_witness Control.TimeoutCrunching:
(forall rr r : R,
 interval_sum H7 H rr r ->
 (forall x : R, (H < x \/ H = x) /\ x < rr -> H7 x <-> Ha x) ->
 interval_sum Ha H rr r)
Crunching: (forall x y : nat, fswap abs x y x = abs y)
Crunching:
(forall (P2 : R -> Prop) (rl rr r : R),
 interval_sum Hcontra rl rr r ->
 (forall x : R, (rl < x \/ rl = x) /\ x < rr -> Hcontra x <-> P2 x) ->
 interval_sum P2 rl rr r)
Chars 54091 - 54288 [refine~~(@isequiv_compose~_~_~...] 40.165 secs (0.006u,0.031s)
Chars 54091 - 54288 [refine~~(@isequiv_compose~_~_~...] 0. secs (0.u,0.s)
Chars 54291 - 54299 [Defined.] 0. secs (0.u,0.s)
Chars 54301 - 54320 [End~ConnectedTypes.] 0.025 secs (0.024u,0.s)
Chars 54356 - 54374 [Section~ModalMaps.] 0. secs (0.u,0.s)
Chars 54377 - 54413 [Context~(O~:~ReflectiveSubuniv...] 0. secs (0.u,0.s)
Chars 54451 - 54539 [#[global]~Instance~mapinO_iseq...] 0. secs (0.u,0.s)
Chars 54542 - 54548 [Proof.] 0. secs (0.u,0.s)
Chars 54553 - 54571 [(intros~b;~exact~_).] 0.384 secs (0.004u,0.03s)
Chars 54553 - 54571 [(intros~b;~exact~_).] 0. secs (0.u,0.s)
Chars 54574 - 54582 [Defined.] 0. secs (0.u,0.s)
Chars 54721 - 54918 [#[global]~Instance~mapinO_hfib...] 0.001 secs (0.001u,0.s)
Chars 54921 - 54927 [Proof.] 0. secs (0.u,0.s)
FlattenExpr: flattenExprs_correct done
Crunching: (forall x y : nat, fswap abs x y x = abs y)
Crunching: (n < n)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (continue_in atan no_cond 1)
Crunching: (continue_in atan no_cond 1)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (continue_in atan no_cond 1)
Crunching:
(forall rr r : R,
 interval_sum H7 H rr r ->
 (forall x : R, (H < x \/ H = x) /\ x < rr -> H7 x <-> Ha x) ->
 interval_sum Ha H rr r)
Crunching:
((forall x : R, (b < x \/ b = x) /\ x < Hb -> Hcontra x <-> H0 x) ->
 interval_sum H0 b Hb IH)
Crunching: (continue_in atan no_cond 1)
Crunching: (continue_in atan no_cond 1)
Crunching: (Morphisms.respectful ?R2 eq (fswap N0 H4 abs) N0)
find_witness Control.Timeout(length (Partition.partition (UniformWeight.uweight width) n x) = n)
Crunching:
(forall (P2 : R -> Prop) (rl rr r : R),
 interval_sum Hcontra rl rr r ->
 (forall x : R, (rl < x \/ rl = x) /\ x < rr -> Hcontra x <-> P2 x) ->
 interval_sum P2 rl rr r)
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
Crunching:
(interval_sum f l2 m Hin ->
 (forall x : R, l2 <= x < m -> f x <-> H2 x) -> interval_sum H2 l2 m Hin)
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
(n = length (Partition.partition (UniformWeight.uweight width) n x))
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
out of reach
Tactic call ran for 0.009 secs (0.006u,0.002s) (failure)
More readable: initial segment:
optBind
With remainder:
Crunching: (rl <= r1 <= r2)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.01 secs (0.007u,0.003s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
(n = length (Partition.partition (UniformWeight.uweight width) n x))
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching:
((forall (x : nat) (x0 : ?T) (x1 : ?T0) (x2 : nat) (x3 : ?T1),
  ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} <= ?m ->
  reflect (?m < ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}) (x2 <=? x) ->
  Init.Nat.max ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} ?m = ?m) ->
 fswap N0 H4 abs H4 = N0 abs)
Crunching:
((forall (x : nat) (x0 : ?T) (x1 : ?T0) (x2 : nat) 
    (x3 : ?T1)
    (x4 : ?n0@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} <=
          ?n0@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}),
  reflect
    (?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3; H1:=x4} <
     ?m@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3; H1:=x4}) 
    (x2 <=? x) ->
  Init.Nat.max ?n0@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}
    ?n0@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} =
  ?n0@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}) -> fswap N0 H4 abs H4 = N0 abs)
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
More readable: initial segment:
optBind
With remainder:
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching:
((forall (x : nat) (x0 : ?T) (x1 : ?T0) (x2 : nat) (x3 : ?T1),
  ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} <= ?m ->
  reflect (?m < ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}) (x2 <=? x) ->
  Init.Nat.max ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} ?m = ?m) ->
 fswap N0 H4 abs H4 = N0 abs)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching:
((forall (x : nat) (x0 : ?T) (x1 : ?T0) (x2 : nat) (x3 : ?T1),
  ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} <= ?m ->
  reflect (?m < ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3}) (x2 <=? x) ->
  Init.Nat.max ?n@{y:=x; H:=x0; H':=x1; n:=x2; bv:=x3} ?m = ?m) ->
 fswap N0 H4 abs H4 = N0 abs)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (fswap n m y y = n m)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.006 secs (0.004u,0.001s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (forall x y : nat, fswap abs x y y = abs x)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (∣1⟩ = basis_vector 2 1)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Chars 54932 - 54941 [(intros~b).] 40.169 secs (0.u,0.031s)
Chars 54946 - 55001 [(destruct~(equiv_decidable_hpr...] 0.003 secs (0.003u,0.s)
Chars 55006 - 55007 [-] 0. secs (0.u,0.s)
Chars 55008 - 55040 [exact~(inO_equiv_inO~Unit~e^-1).] 0.008 secs (0.005u,0.s)
Chars 55045 - 55046 [-] 0. secs (0.u,0.s)
Chars 55047 - 55080 [exact~(inO_equiv_inO~Empty~e^-1).] 0.005 secs (0.004u,0.s)
Chars 54932 - 54941 [(intros~b).] 0. secs (0.u,0.s)
Chars 54946 - 55001 [(destruct~(equiv_decidable_hpr...] 0. secs (0.u,0.s)
Chars 55008 - 55040 [exact~(inO_equiv_inO~Unit~e^-1).] 0. secs (0.u,0.s)
Chars 55047 - 55080 [exact~(inO_equiv_inO~Empty~e^-1).] 0. secs (0.u,0.s)
More readable: initial segment:
optBind
With remainder:
Chars 55083 - 55091 [Defined.] 0.001 secs (0.001u,0.s)
Chars 55142 - 55250 [#[global]~Instance~mapinO_betw...] 0. secs (0.u,0.s)
Chars 55253 - 55259 [Proof.] 0. secs (0.u,0.s)
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Chars 55264 - 55282 [(intros~b;~exact~_).] 0.146 secs (0.019u,0.036s)
Chars 55264 - 55282 [(intros~b;~exact~_).] 0. secs (0.u,0.s)
Chars 55285 - 55293 [Defined.] 0.002 secs (0.u,0.s)
Chars 55336 - 55449 [Definition~cancelL_mapinO~{A~B...] 0.001 secs (0.001u,0.s)
Chars 55452 - 55458 [Proof.] 0. secs (0.u,0.s)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
find_witness Control.TimeoutMore readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
find_witness Control.TimeoutMore readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: ((if y =? x then f y else f x) = f x)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (fswap N0 H4 y y = N0 H4)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
(n = length (Partition.partition (UniformWeight.uweight width) n x))
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (n m = fswap n m y y)
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
(varname_gen (length (Partition.partition (UniformWeight.uweight width) n H)) =
 varname_gen n)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (fswap n m y y = n m)
Crunching: (interval_sum H l' n (Hab * 1))
out of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
(n = length (Partition.partition (UniformWeight.uweight width) n x))
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
(length (Partition.partition (UniformWeight.uweight width) n x) = n)
More readable: initial segment:
optBind
With remainder:
find_witness Control.Timeout[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (∣1⟩ = basis_vector 2 1)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (∣1⟩ = basis_vector 2 1)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (∣1⟩ = basis_vector 2 1)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
find_witness Control.TimeoutMore readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: (forall x y : nat, fswap abs x y y = abs x)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Tactic call ran for 0.012 secs (0.011u,0.001s) (success)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Crunching: ((if H =? m then n H else if H =? H then n m else n H) = n m)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((evalf H4 * evalf H5) mod m)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
find_witness Control.TimeoutMore readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Tactic call ran for 0.013 secs (0.013u,0.s) (success)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
Tactic call ran for 0.014 secs (0.014u,0.s) (success)
Crunching: ((if 0 =? x then f 0 else if 0 =? 0 then f x else f 0) = f x)
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
More readable: initial segment:
optBind
With remainder:
[Ast.tApp
   (Ast.tConst
      (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
       "cnfGetClause") []) [Ast.tRel 2; Ast.tRel 1];
 Ast.tLambda (BasicAst.mkBindAnn (BasicAst.nNamed "C") BasicAst.Relevant)
   (Ast.tApp
      (Ast.tInd
         (Kernames.mkInd
            (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "list") 0) [])
      [Ast.tApp
         (Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "prod") 0) [])
         [Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "bool") 0) [];
          Ast.tInd
            (Kernames.mkInd
               (Kernames.MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) []]])
   (Ast.tApp
      (Ast.tConst
         (Kernames.MPfile ["kSAT_to_Clique"; "Clique"; "NP"; "Complexity"],
          "clauseGetLiteral") []) [Ast.tRel 0; Ast.tRel 1])]
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (forall x0 : R, interval_sum x r s x0 -> R0 < x0 \/ x0 = R0)
Crunching: (r >= 0)
Crunching: (Hlen >= 0)
Crunching: (H1 >= 0)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((evalf k * evalf e) mod m)
Crunching: (R0 < m \/ m = R0)
Crunching: (forall rr r : R, interval_sum p H8 rr r -> r >= 0)
Chars 55463 - 55476 [(intros~?~?~b).] 40.162 secs (0.u,0.031s)
Chars 55481 - 55540 [refine~(inO_equiv_inO~_~(hfibe...] 0.226 secs (0.191u,0.029s)
Chars 55463 - 55476 [(intros~?~?~b).] 0. secs (0.u,0.s)
Chars 55481 - 55540 [refine~(inO_equiv_inO~_~(hfibe...] 0. secs (0.u,0.s)
Chars 55543 - 55551 [Defined.] 0.001 secs (0.001u,0.s)
Chars 55601 - 55713 [#[global]~Instance~mapinO_pull...] 0.001 secs (0.u,0.s)
Chars 55716 - 55722 [Proof.] 0. secs (0.u,0.s)
Chars 55727 - 55736 [(intros~b).] 0. secs (0.u,0.s)
Chars 55741 - 55799 [refine~(inO_equiv_inO~_~(hfibe...] 0.03 secs (0.024u,0.006s)
Chars 55727 - 55736 [(intros~b).] 0. secs (0.u,0.s)
Chars 55741 - 55799 [refine~(inO_equiv_inO~_~(hfibe...] 0. secs (0.u,0.s)
Chars 55802 - 55810 [Defined.] 0.001 secs (0.001u,0.s)
Chars 55814 - 55928 [#[global]~Instance~mapinO_pull...] 0.001 secs (0.001u,0.s)
Chars 55931 - 55937 [Proof.] 0. secs (0.u,0.s)
Chars 55942 - 55951 [(intros~c).] 0. secs (0.u,0.s)
Chars 55956 - 56015 [refine~(inO_equiv_inO~_~(hfibe...] 0.028 secs (0.026u,0.001s)
Chars 55942 - 55951 [(intros~c).] 0. secs (0.u,0.s)
Chars 55956 - 56015 [refine~(inO_equiv_inO~_~(hfibe...] 0. secs (0.u,0.s)
Chars 56018 - 56026 [Defined.] 0.001 secs (0.001u,0.s)
Chars 56075 - 56223 [#[global]~Instance~mapinO_func...] 0.001 secs (0.001u,0.s)
Chars 56226 - 56232 [Proof.] 0. secs (0.u,0.s)
Chars 56237 - 56250 [(intros~[a|~b]).] 0.001 secs (0.001u,0.s)
Chars 56255 - 56256 [-] 0. secs (0.u,0.s)
Chars 56257 - 56314 [refine~(inO_equiv_inO~_~(hfibe...] 0.042 secs (0.03u,0.012s)
Chars 56319 - 56320 [-] 0. secs (0.u,0.s)
Chars 56321 - 56378 [refine~(inO_equiv_inO~_~(hfibe...] 0.031 secs (0.024u,0.004s)
Chars 56237 - 56250 [(intros~[a|~b]).] 0. secs (0.u,0.s)
Chars 56257 - 56314 [refine~(inO_equiv_inO~_~(hfibe...] 0. secs (0.u,0.s)
Chars 56321 - 56378 [refine~(inO_equiv_inO~_~(hfibe...] 0. secs (0.u,0.s)
Chars 56381 - 56389 [Defined.] 0.001 secs (0.001u,0.s)
Chars 56536 - 56769 [Definition~mapinO_unfunctor_su...] 0.002 secs (0.002u,0.s)
Chars 56772 - 56778 [Proof.] 0. secs (0.u,0.s)
Chars 56783 - 56792 [(intros~a).] 0.001 secs (0.u,0.s)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((eval
    (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))
       (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))) 0 k *
  eval
    (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))
       (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))) 0 e) mod m)
Chars 56797 - 56860 [refine~(inO_equiv_inO~_~(hfibe...] 0.033 secs (0.03u,0.002s)
Chars 56783 - 56792 [(intros~a).] 0. secs (0.u,0.s)
Chars 56797 - 56860 [refine~(inO_equiv_inO~_~(hfibe...] 0. secs (0.u,0.s)
Chars 56863 - 56871 [Defined.] 0.001 secs (0.001u,0.s)
Chars 56875 - 57108 [Definition~mapinO_unfunctor_su...] 0.002 secs (0.002u,0.s)
Chars 57111 - 57117 [Proof.] 0. secs (0.u,0.s)
Chars 57122 - 57131 [(intros~b).] 0.001 secs (0.u,0.s)
Chars 57136 - 57199 [refine~(inO_equiv_inO~_~(hfibe...] 0.026 secs (0.026u,0.s)
Chars 57122 - 57131 [(intros~b).] 0. secs (0.u,0.s)
Chars 57136 - 57199 [refine~(inO_equiv_inO~_~(hfibe...] 0. secs (0.u,0.s)
Chars 57202 - 57210 [Defined.] 0. secs (0.u,0.s)
Chars 57212 - 57226 [End~ModalMaps.] 0.014 secs (0.014u,0.s)
Chars 57591 - 57828 [Class~IsConnMap~(O~:~Reflectiv...] 0.001 secs (0.001u,0.s)
Chars 57830 - 57883 [#[global]Existing~Instance~isc...] 0. secs (0.u,0.s)
Chars 57885 - 57907 [Section~ConnectedMaps.] 0. secs (0.u,0.s)
Chars 57910 - 57942 [Context~`{Univalence}~`{Funext}.] 0. secs (0.u,0.s)
Chars 57945 - 57981 [Context~(O~:~ReflectiveSubuniv...] 0. secs (0.u,0.s)
Chars 58023 - 58117 [#[global]~Instance~conn_map_is...] 0. secs (0.u,0.s)
Chars 58120 - 58126 [Proof.] 0. secs (0.u,0.s)
Chars 58131 - 58149 [(intros~b;~exact~_).] 0.004 secs (0.004u,0.s)
Chars 58131 - 58149 [(intros~b;~exact~_).] 0. secs (0.u,0.s)
Chars 58152 - 58160 [Defined.] 0. secs (0.u,0.s)
Chars 58225 - 58331 [Definition~conn_map_homotopic~...] 0. secs (0.u,0.s)
Chars 58334 - 58340 [Proof.] 0. secs (0.u,0.s)
Chars 58345 - 58356 [(intros~?~b).] 0. secs (0.u,0.s)
Chars 58361 - 58466 [exact~(isconnected_equiv~O~(hf...] 0.009 secs (0.009u,0.s)
Chars 58345 - 58356 [(intros~?~b).] 0. secs (0.u,0.s)
Chars 58361 - 58466 [exact~(isconnected_equiv~O~(hf...] 0. secs (0.u,0.s)
Chars 58469 - 58477 [Defined.] 0. secs (0.u,0.s)
Chars 58535 - 58657 [#[global]~Instance~conn_map_pu...] 0. secs (0.u,0.s)
Chars 58660 - 58666 [Proof.] 0. secs (0.u,0.s)
Chars 58671 - 58680 [(intros~b).] 0. secs (0.u,0.s)
Chars 58685 - 58751 [refine~(isconnected_equiv~_~_~...] 0.013 secs (0.013u,0.s)
Chars 58671 - 58680 [(intros~b).] 0. secs (0.u,0.s)
Chars 58685 - 58751 [refine~(isconnected_equiv~_~_~...] 0. secs (0.u,0.s)
Chars 58754 - 58762 [Defined.] 0. secs (0.u,0.s)
Chars 58766 - 58890 [#[global]~Instance~conn_map_pu...] 0. secs (0.u,0.s)
Chars 58893 - 58899 [Proof.] 0. secs (0.u,0.s)
Chars 58904 - 58913 [(intros~c).] 0. secs (0.u,0.s)
Chars 58918 - 58985 [refine~(isconnected_equiv~_~_~...] 0.024 secs (0.022u,0.001s)
Chars 58904 - 58913 [(intros~c).] 0. secs (0.u,0.s)
Chars 58918 - 58985 [refine~(isconnected_equiv~_~_~...] 0. secs (0.u,0.s)
Chars 58988 - 58996 [Defined.] 0. secs (0.u,0.s)
Chars 59071 - 59196 [#[global]~Instance~conn_map_pr...] 0. secs (0.u,0.s)
Chars 59199 - 59205 [Proof.] 0. secs (0.u,0.s)
Chars 59210 - 59219 [(intros~a).] 0. secs (0.u,0.s)
Chars 59224 - 59284 [refine~(isconnected_equiv~O~(B...] 0.004 secs (0.004u,0.s)
Chars 59210 - 59219 [(intros~a).] 0. secs (0.u,0.s)
Chars 59224 - 59284 [refine~(isconnected_equiv~O~(B...] 0. secs (0.u,0.s)
Chars 59287 - 59295 [Defined.] 0. secs (0.u,0.s)
Chars 59336 - 59434 [#[global]~Instance~ishprop_isc...] 0. secs (0.u,0.s)
Chars 59437 - 59443 [Proof.] 0. secs (0.u,0.s)
Chars 59448 - 59469 [(apply~istrunc_forall).] 0.005 secs (0.004u,0.s)
Chars 59448 - 59469 [(apply~istrunc_forall).] 0. secs (0.u,0.s)
Chars 59472 - 59480 [Defined.] 0. secs (0.u,0.s)
Chars 59568 - 59767 [Definition~conn_map_elim~{A~B~...] 0. secs (0.u,0.s)
Chars 59770 - 59776 [Proof.] 0. secs (0.u,0.s)
Chars 59781 - 59790 [(intros~b).] 0. secs (0.u,0.s)
Chars 59795 - 59833 [refine~(pr1~(isconnected_elim~...] 0.002 secs (0.002u,0.s)
Chars 59838 - 59851 [(intros~[a~p]).] 0.001 secs (0.001u,0.s)
Chars 59856 - 59884 [exact~(transport~P~p~(d~a)).] 0.001 secs (0.001u,0.s)
Chars 59781 - 59790 [(intros~b).] 0. secs (0.u,0.s)
Chars 59795 - 59833 [refine~(pr1~(isconnected_elim~...] 0. secs (0.u,0.s)
Chars 59838 - 59851 [(intros~[a~p]).] 0. secs (0.u,0.s)
Chars 59856 - 59884 [exact~(transport~P~p~(d~a)).] 0. secs (0.u,0.s)
Chars 59887 - 59895 [Defined.] 0. secs (0.u,0.s)
Chars 59899 - 60126 [Definition~conn_map_comp~{A~B~...] 0.001 secs (0.001u,0.s)
Chars 60129 - 60135 [Proof.] 0. secs (0.u,0.s)
Chars 60140 - 60149 [(intros~a).] 0. secs (0.u,0.s)
Chars 60150 - 60171 [(unfold~conn_map_elim).] 0. secs (0.u,0.s)
Chars 60176 - 60289 [(set~~~(fibermap~:=~~~~fun~a0p...] 0.002 secs (0.002u,0.s)
Chars 60294 - 60352 [(destruct~(isconnected_elim~O~...] 0.003 secs (0.003u,0.s)
Chars 60357 - 60392 [(change~(d~a)~with~(fibermap~(...] 0.002 secs (0.002u,0.s)
Chars 60397 - 60414 [(apply~inverse,~e).] 0.001 secs (0.001u,0.s)
Chars 60140 - 60149 [(intros~a).] 0. secs (0.u,0.s)
Chars 60150 - 60171 [(unfold~conn_map_elim).] 0. secs (0.u,0.s)
Chars 60176 - 60289 [(set~~~(fibermap~:=~~~~fun~a0p...] 0. secs (0.u,0.s)
Chars 60294 - 60352 [(destruct~(isconnected_elim~O~...] 0. secs (0.u,0.s)
Chars 60357 - 60392 [(change~(d~a)~with~(fibermap~(...] 0. secs (0.u,0.s)
Chars 60397 - 60414 [(apply~inverse,~e).] 0.001 secs (0.001u,0.s)
Chars 60417 - 60425 [Defined.] 0. secs (0.u,0.s)
Chars 60497 - 60620 [Definition~isequiv_conn_ino_ma...] 0. secs (0.u,0.s)
Chars 60623 - 60629 [Proof.] 0. secs (0.u,0.s)
Chars 60634 - 60658 [(apply~isequiv_contr_map).] 0. secs (0.u,0.s)
Chars 60659 - 60668 [(intros~b).] 0. secs (0.u,0.s)
Chars 60673 - 60700 [(apply~(contr_trunc_conn~O)).] 0.012 secs (0.012u,0.s)
Chars 60634 - 60658 [(apply~isequiv_contr_map).] 0. secs (0.u,0.s)
Chars 60659 - 60668 [(intros~b).] 0. secs (0.u,0.s)
Chars 60673 - 60700 [(apply~(contr_trunc_conn~O)).] 0. secs (0.u,0.s)
Chars 60703 - 60711 [Defined.] 0. secs (0.u,0.s)
Chars 60771 - 60965 [Lemma~extension_conn_map_elim~...] 0. secs (0.u,0.s)
Chars 60968 - 60974 [Proof.] 0. secs (0.u,0.s)
Chars 60979 - 61008 [exists~(conn_map_elim~f~P~d).] 0.001 secs (0.001u,0.s)
Chars 61013 - 61033 [(apply~conn_map_comp).] 0.001 secs (0.001u,0.s)
Chars 60979 - 61008 [exists~(conn_map_elim~f~P~d).] 0. secs (0.u,0.s)
Chars 61013 - 61033 [(apply~conn_map_comp).] 0. secs (0.u,0.s)
Chars 61036 - 61044 [Defined.] 0. secs (0.u,0.s)
Chars 61048 - 61234 [Definition~extendable_conn_map...] 0. secs (0.u,0.s)
Chars 61237 - 61243 [Proof.] 0. secs (0.u,0.s)
Chars 61248 - 61271 [generalize~dependent~P.] 0. secs (0.u,0.s)
Chars 61276 - 61335 [(simple_induction~n~n~IHn;~int...] 0.003 secs (0.003u,0.s)
Chars 61340 - 61341 [-] 0. secs (0.u,0.s)
Chars 61342 - 61391 [(intros~d;~apply~extension_con...] 0.003 secs (0.003u,0.s)
Chars 61396 - 61397 [-] 0. secs (0.u,0.s)
Chars 61398 - 61429 [(intros~h~k;~apply~IHn;~exact~_).] 0.003 secs (0.003u,0.s)
Chars 61248 - 61271 [generalize~dependent~P.] 0. secs (0.u,0.s)
Chars 61276 - 61335 [(simple_induction~n~n~IHn;~int...] 0.001 secs (0.001u,0.s)
Chars 61342 - 61391 [(intros~d;~apply~extension_con...] 0.001 secs (0.001u,0.s)
Chars 61398 - 61429 [(intros~h~k;~apply~IHn;~exact~_).] 0.001 secs (0.001u,0.s)
Chars 61432 - 61440 [Defined.] 0. secs (0.u,0.s)
Chars 61444 - 61668 [Definition~ooextendable_conn_m...] 0.001 secs (0.001u,0.s)
Chars 61672 - 61893 [Lemma~allpath_extension_conn_m...] 0.001 secs (0.001u,0.s)
Chars 61896 - 61902 [Proof.] 0. secs (0.u,0.s)
Chars 61907 - 61928 [(apply~path_extension).] 0.001 secs (0.001u,0.s)
Chars 61933 - 61972 [refine~(extension_conn_map_eli...] 0.003 secs (0.003u,0.s)
Chars 61907 - 61928 [(apply~path_extension).] 0. secs (0.u,0.s)
Chars 61933 - 61972 [refine~(extension_conn_map_eli...] 0. secs (0.u,0.s)
Chars 61975 - 61983 [Defined.] 0. secs (0.u,0.s)
Chars 62056 - 62243 [Theorem~isequiv_o_conn_map~{A~...] 0. secs (0.u,0.s)
Chars 62246 - 62252 [Proof.] 0. secs (0.u,0.s)
Chars 62257 - 62291 [(apply~isequiv_contr_map;~intr...] 0.001 secs (0.001u,0.s)
Chars 62296 - 62324 [(apply~contr_inhabited_hprop).] 0. secs (0.u,0.s)
Chars 62329 - 62330 [-] 0. secs (0.u,0.s)
Chars 62331 - 62406 [nrefine~(@istrunc_equiv_istrun...] 0.003 secs (0.003u,0.s)
Chars 62413 - 62414 [{] 0. secs (0.u,0.s)
Chars 62415 - 62459 [(refine~(equiv_functor_sigma_i...] 0.001 secs (0.001u,0.s)
Chars 62468 - 62492 [(apply~equiv_path_forall).] 0.001 secs (0.001u,0.s)
Chars 62493 - 62494 [}] 0. secs (0.u,0.s)
Chars 62501 - 62521 [(apply~hprop_allpath).] 0. secs (0.u,0.s)
Chars 62522 - 62533 [(intros~g~h).] 0. secs (0.u,0.s)
Chars 62540 - 62585 [exact~(allpath_extension_conn_...] 0.001 secs (0.001u,0.s)
Chars 62590 - 62591 [-] 0. secs (0.u,0.s)
Chars 62592 - 62621 [exists~(conn_map_elim~f~P~d).] 0.001 secs (0.001u,0.s)
Chars 62628 - 62677 [(apply~path_forall;~intros~x;~...] 0.005 secs (0.004u,0.s)
Chars 62257 - 62291 [(apply~isequiv_contr_map;~intr...] 0. secs (0.u,0.s)
Chars 62296 - 62324 [(apply~contr_inhabited_hprop).] 0. secs (0.u,0.s)
Chars 62331 - 62406 [nrefine~(@istrunc_equiv_istrun...] 0. secs (0.u,0.s)
Chars 62415 - 62459 [(refine~(equiv_functor_sigma_i...] 0.001 secs (0.001u,0.s)
Chars 62468 - 62492 [(apply~equiv_path_forall).] 0. secs (0.u,0.s)
Chars 62501 - 62521 [(apply~hprop_allpath).] 0. secs (0.u,0.s)
Chars 62522 - 62533 [(intros~g~h).] 0. secs (0.u,0.s)
Chars 62540 - 62585 [exact~(allpath_extension_conn_...] 0. secs (0.u,0.s)
Chars 62592 - 62621 [exists~(conn_map_elim~f~P~d).] 0. secs (0.u,0.s)
Chars 62628 - 62677 [(apply~path_forall;~intros~x;~...] 0.001 secs (0.001u,0.s)
Chars 62680 - 62688 [Defined.] 0.001 secs (0.001u,0.s)
Chars 62692 - 62921 [Definition~equiv_o_conn_map~{A...] 0.001 secs (0.001u,0.s)
Chars 63404 - 63643 [Definition~ooextendable_TypeO_...] 0.001 secs (0.001u,0.s)
Chars 63646 - 63652 [Proof.] 0. secs (0.u,0.s)
Chars 63847 - 63862 [(intros~[|~[|~n]]).] 0.001 secs (0.001u,0.s)
Chars 63867 - 63868 [-] 0. secs (0.u,0.s)
Chars 63869 - 63878 [exact~tt.] 0.001 secs (0.u,0.s)
Chars 64099 - 64100 [-] 0. secs (0.u,0.s)
Chars 64101 - 64142 [(split;~[~apply~extP~|~intros;...] 0.002 secs (0.002u,0.s)
Chars 64159 - 64160 [-] 0. secs (0.u,0.s)
Chars 64161 - 64185 [(split;~[~apply~extP~|~~]).] 0.001 secs (0.001u,0.s)
Chars 64279 - 64349 [(intros~P~Q;~rapply~(ooextenda...] 0.007 secs (0.007u,0.s)
Chars 64356 - 64357 [+] 0. secs (0.u,0.s)
Chars 64358 - 64427 [(intros~x;~refine~(equiv_path_...] 0.002 secs (0.002u,0.s)
Chars 64434 - 64435 [+] 0. secs (0.u,0.s)
Chars 64436 - 64469 [rapply~ooextendable_conn_map_inO.] 0.012 secs (0.012u,0.s)
Chars 63847 - 63862 [(intros~[|~[|~n]]).] 0. secs (0.u,0.s)
Chars 63869 - 63878 [exact~tt.] 0. secs (0.u,0.s)
Chars 64101 - 64142 [(split;~[~apply~extP~|~intros;...] 0.001 secs (0.001u,0.s)
Chars 64161 - 64185 [(split;~[~apply~extP~|~~]).] 0. secs (0.u,0.s)
Chars 64279 - 64349 [(intros~P~Q;~rapply~(ooextenda...] 0. secs (0.u,0.s)
Chars 64358 - 64427 [(intros~x;~refine~(equiv_path_...] 0. secs (0.u,0.s)
Chars 64436 - 64469 [rapply~ooextendable_conn_map_inO.] 0. secs (0.u,0.s)
Chars 64472 - 64480 [Defined.] 0.001 secs (0.001u,0.s)
Chars 64657 - 64868 [Lemma~conn_map_from_extension_...] 0. secs (0.u,0.s)
Chars 64871 - 64877 [Proof.] 0. secs (0.u,0.s)
Chars 64882 - 64894 [(intros~Hf~b).] 0. secs (0.u,0.s)
Chars 64895 - 64928 [(apply~isconnected_from_elim_t...] 0. secs (0.u,0.s)
Chars 64933 - 65002 [(pose~proof~(Hf~(fun~b~=>~O~(h...] 0.004 secs (0.004u,0.s)
Chars 65007 - 65022 [exists~(e.1~b).] 0.001 secs (0.001u,0.s)
Chars 65027 - 65040 [(intros~[a~p]).] 0.001 secs (0.001u,0.s)
Chars 65041 - 65052 [(destruct~p).] 0.002 secs (0.002u,0.s)
Chars 65057 - 65079 [(symmetry;~apply~e.2).] 0.004 secs (0.004u,0.s)
Chars 64882 - 64894 [(intros~Hf~b).] 0. secs (0.u,0.s)
Chars 64895 - 64928 [(apply~isconnected_from_elim_t...] 0. secs (0.u,0.s)
Chars 64933 - 65002 [(pose~proof~(Hf~(fun~b~=>~O~(h...] 0. secs (0.u,0.s)
Chars 65007 - 65022 [exists~(e.1~b).] 0. secs (0.u,0.s)
Chars 65027 - 65040 [(intros~[a~p]).] 0. secs (0.u,0.s)
Chars 65041 - 65052 [(destruct~p).] 0. secs (0.u,0.s)
Chars 65057 - 65079 [(symmetry;~apply~e.2).] 0.001 secs (0.001u,0.s)
Chars 65082 - 65090 [Defined.] 0.001 secs (0.001u,0.s)
Chars 65164 - 65313 [#[global]~Instance~conn_map_co...] 0.001 secs (0.001u,0.s)
Chars 65316 - 65322 [Proof.] 0. secs (0.u,0.s)
Chars 65327 - 65376 [(apply~conn_map_from_extension...] 0.001 secs (0.001u,0.s)
Chars 65381 - 65446 [(exists~(conn_map_elim~g~P~(co...] 0.024 secs (0.02u,0.003s)
Chars 65451 - 65511 [exact~(conn_map_comp~g~P~_~_~@...] 0.002 secs (0.002u,0.s)
Chars 65327 - 65376 [(apply~conn_map_from_extension...] 0. secs (0.u,0.s)
Chars 65381 - 65446 [(exists~(conn_map_elim~g~P~(co...] 0. secs (0.u,0.s)
Chars 65451 - 65511 [exact~(conn_map_comp~g~P~_~_~@...] 0. secs (0.u,0.s)
Chars 65514 - 65522 [Defined.] 0.001 secs (0.001u,0.s)
Chars 65532 - 65677 [Definition~cancelR_conn_map~{A...] 0.001 secs (0.u,0.s)
Chars 65680 - 65686 [Proof.] 0. secs (0.u,0.s)
Chars 65691 - 65740 [(apply~conn_map_from_extension...] 0.001 secs (0.001u,0.s)
Chars 65745 - 65797 [(exists~(conn_map_elim~(g~o~f)...] 0.003 secs (0.003u,0.s)
Chars 65802 - 65854 [(pattern~b;~refine~(conn_map_e...] 0.005 secs (0.005u,0.s)
Chars 65859 - 65902 [exact~(conn_map_comp~(g~o~f)~P...] 0.002 secs (0.002u,0.s)
Chars 65691 - 65740 [(apply~conn_map_from_extension...] 0. secs (0.u,0.s)
Chars 65745 - 65797 [(exists~(conn_map_elim~(g~o~f)...] 0.001 secs (0.001u,0.s)
Chars 65802 - 65854 [(pattern~b;~refine~(conn_map_e...] 0.001 secs (0.001u,0.s)
Chars 65859 - 65902 [exact~(conn_map_comp~(g~o~f)~P...] 0. secs (0.u,0.s)
Chars 65905 - 65913 [Defined.] 0.001 secs (0.001u,0.s)
Chars 65990 - 66140 [Definition~cancelR_isequiv_con...] 0.001 secs (0.001u,0.s)
Chars 66143 - 66149 [Proof.] 0. secs (0.u,0.s)
Chars 66154 - 66163 [(intros~b).] 0. secs (0.u,0.s)
Chars 66168 - 66226 [srefine~(isconnected_equiv'~O~...] 0.002 secs (0.002u,0.s)
Chars 66231 - 66308 [exact~(equiv_inverse~(equiv_fu...] 0.002 secs (0.002u,0.s)
Unrecognized (non-unfoldable) term: c
Chars 66154 - 66163 [(intros~b).] 0. secs (0.u,0.s)
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
Chars 66168 - 66226 [srefine~(isconnected_equiv'~O~...] 0. secs (0.u,0.s)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
Chars 66231 - 66308 [exact~(equiv_inverse~(equiv_fu...] 0. secs (0.u,0.s)
m
expr.reify_in_context: Failure in reifying:
Chars 66311 - 66319 [Defined.] 0. secs (0.u,0.s)
((eval
    (weight
       (Z.log2_up (- Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n k *
  eval
    (weight
       (Z.log2_up (- Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n e) mod m)
Chars 66323 - 66491 [Definition~cancelR_equiv_conn_...] 0.003 secs (0.003u,0.s)
Chars 66569 - 66691 [Definition~isconnected_conn_ma...] 0. secs (0.u,0.s)
Chars 66694 - 66700 [Proof.] 0. secs (0.u,0.s)
Chars 66705 - 66830 [refine~~(isconnected_equiv~O~(...] 0.009 secs (0.009u,0.s)
Chars 66705 - 66830 [refine~~(isconnected_equiv~O~(...] 0. secs (0.u,0.s)
Chars 66833 - 66841 [Defined.] 0. secs (0.u,0.s)
Chars 66845 - 66922 [#[local]Hint~Immediate~isconne...] 0. secs (0.u,0.s)
Chars 66926 - 67045 [#[global]~Instance~conn_map_to...] 0. secs (0.u,0.s)
Chars 67048 - 67054 [Proof.] 0. secs (0.u,0.s)
Chars 67059 - 67068 [(intros~u).] 0. secs (0.u,0.s)
Chars 67073 - 67171 [refine~~(isconnected_equiv~O~A...] 0.009 secs (0.009u,0.s)
Chars 67059 - 67068 [(intros~u).] 0. secs (0.u,0.s)
Chars 67073 - 67171 [refine~~(isconnected_equiv~O~A...] 0. secs (0.u,0.s)
Chars 67174 - 67182 [Defined.] 0. secs (0.u,0.s)
Chars 67371 - 67506 [Definition~isequiv_O_rec_conn_...] 0.001 secs (0.001u,0.s)
Chars 67509 - 67515 [Proof.] 0. secs (0.u,0.s)
Chars 67520 - 67596 [refine~(isequiv_adjointify~_~(...] 0.003 secs (0.003u,0.s)
Chars 67601 - 67602 [-] 0. secs (0.u,0.s)
Chars 67603 - 67612 [(intros~x).] 0. secs (0.u,0.s)
Crunching: (forall x0 : R, interval_sum x r s x0 -> R0 < x0 \/ x0 = R0)
Chars 67613 - 67623 [(pattern~x).] 0.001 secs (0.001u,0.s)
Chars 67630 - 67671 [(refine~(conn_map_elim~f~_~_~x...] 0.004 secs (0.004u,0.s)
Chars 67678 - 67792 [exact~~(ap~(O_rec~f)~(conn_map...] 0.003 secs (0.003u,0.s)
Chars 67797 - 67798 [-] 0. secs (0.u,0.s)
Chars 67799 - 67833 [(apply~O_indpaths;~intros~a;~s...] 0.003 secs (0.003u,0.s)
Chars 67840 - 67875 [refine~(ap~_~(O_rec_beta~f~a)~...] 0.002 secs (0.002u,0.s)
Chars 67882 - 67933 [refine~(conn_map_comp~f~(fun~_...] 0.001 secs (0.001u,0.s)
Chars 67520 - 67596 [refine~(isequiv_adjointify~_~(...] 0. secs (0.u,0.s)
Chars 67603 - 67612 [(intros~x).] 0. secs (0.u,0.s)
Chars 67613 - 67623 [(pattern~x).] 0. secs (0.u,0.s)
Chars 67630 - 67671 [(refine~(conn_map_elim~f~_~_~x...] 0.001 secs (0.001u,0.s)
Chars 67678 - 67792 [exact~~(ap~(O_rec~f)~(conn_map...] 0. secs (0.u,0.s)
Chars 67799 - 67833 [(apply~O_indpaths;~intros~a;~s...] 0.001 secs (0.001u,0.s)
Chars 67840 - 67875 [refine~(ap~_~(O_rec_beta~f~a)~...] 0. secs (0.u,0.s)
Chars 67882 - 67933 [refine~(conn_map_comp~f~(fun~_...] 0. secs (0.u,0.s)
Chars 67936 - 67944 [Defined.] 0.002 secs (0.002u,0.s)
Chars 67970 - 67998 [Section~ConnMapFunctorSigma.] 0. secs (0.u,0.s)
Chars 68004 - 68156 [Context~{A~B~:~Type}~{P~:~A~->...] 0. secs (0.u,0.s)
Chars 68162 - 68278 [Definition~equiv_O_hfiber_func...] 0.001 secs (0.001u,0.s)
Chars 68283 - 68289 [Proof.] 0. secs (0.u,0.s)
Chars 68296 - 68357 [(equiv_via~(O~{w~:~hfiber~f~b~...] 0.003 secs (0.003u,0.s)
Chars 68364 - 68365 [{] 0. secs (0.u,0.s)
Chars 68366 - 68410 [(apply~equiv_O_functor,~hfiber...] 0.002 secs (0.002u,0.s)
Chars 68411 - 68412 [}] 0. secs (0.u,0.s)
Chars 68419 - 68484 [(equiv_via~(O~{w~:~hfiber~f~b~...] 0.003 secs (0.003u,0.s)
Chars 68491 - 68492 [{] 0. secs (0.u,0.s)
Chars 68493 - 68525 [(symmetry;~apply~equiv_O_sigma...] 0.003 secs (0.003u,0.s)
Chars 68526 - 68527 [}] 0. secs (0.u,0.s)
Chars 68534 - 68556 [(apply~equiv_O_functor).] 0.001 secs (0.001u,0.s)
Chars 68563 - 68617 [(apply~equiv_sigma_contr;~intr...] 0.008 secs (0.008u,0.s)
Chars 68296 - 68357 [(equiv_via~(O~{w~:~hfiber~f~b~...] 0. secs (0.u,0.s)
Chars 68366 - 68410 [(apply~equiv_O_functor,~hfiber...] 0. secs (0.u,0.s)
Chars 68419 - 68484 [(equiv_via~(O~{w~:~hfiber~f~b~...] 0. secs (0.u,0.s)
Chars 68493 - 68525 [(symmetry;~apply~equiv_O_sigma...] 0.001 secs (0.u,0.s)
Chars 68534 - 68556 [(apply~equiv_O_functor).] 0. secs (0.u,0.s)
Chars 68563 - 68617 [(apply~equiv_sigma_contr;~intr...] 0.002 secs (0.002u,0.s)
Chars 68622 - 68630 [Defined.] 0.002 secs (0.002u,0.s)
Chars 68636 - 68734 [#[global]~Instance~conn_map_fu...] 0. secs (0.u,0.s)
Chars 68739 - 68745 [Proof.] 0. secs (0.u,0.s)
Chars 68752 - 68765 [(intros~[b~v]).] 0.001 secs (0.001u,0.s)
Chars 68772 - 68847 [refine~(contr_equiv'~_~(equiv_...] 0.004 secs (0.004u,0.s)
Chars 68752 - 68765 [(intros~[b~v]).] 0. secs (0.u,0.s)
Chars 68772 - 68847 [refine~(contr_equiv'~_~(equiv_...] 0. secs (0.u,0.s)
Chars 68852 - 68860 [Defined.] 0. secs (0.u,0.s)
Chars 68866 - 68997 [Definition~conn_map_base_inhab...] 0. secs (0.u,0.s)
Chars 69002 - 69008 [Proof.] 0. secs (0.u,0.s)
Chars 69015 - 69024 [(intros~b).] 0. secs (0.u,0.s)
Chars 69031 - 69095 [refine~(contr_equiv~_~(equiv_O...] 0.012 secs (0.012u,0.s)
Chars 69015 - 69024 [(intros~b).] 0. secs (0.u,0.s)
Chars 69031 - 69095 [refine~(contr_equiv~_~(equiv_O...] 0. secs (0.u,0.s)
Chars 69100 - 69108 [Defined.] 0. secs (0.u,0.s)
Chars 69112 - 69136 [End~ConnMapFunctorSigma.] 0.011 secs (0.011u,0.s)
Chars 69272 - 69455 [Definition~conn_map_fiber~{A~:...] 0.001 secs (0.001u,0.s)
Chars 69458 - 69464 [Proof.] 0. secs (0.u,0.s)
Chars 69469 - 69480 [(intros~a~q).] 0. secs (0.u,0.s)
Chars 69485 - 69558 [refine~(isconnected_equiv'~O~(...] 0.004 secs (0.004u,0.s)
Chars 69563 - 69608 [exact~(hfiber_functor_sigma_id...] 0.001 secs (0.001u,0.s)
Chars 69469 - 69480 [(intros~a~q).] 0. secs (0.u,0.s)
Chars 69485 - 69558 [refine~(isconnected_equiv'~O~(...] 0. secs (0.u,0.s)
Chars 69563 - 69608 [exact~(hfiber_functor_sigma_id...] 0. secs (0.u,0.s)
Chars 69611 - 69619 [Defined.] 0. secs (0.u,0.s)
Chars 69682 - 69793 [#[global]~Instance~O_inverts_c...] 0. secs (0.u,0.s)
Chars 69796 - 69802 [Proof.] 0. secs (0.u,0.s)
Chars 69807 - 69840 [rapply~O_inverts_from_extendable.] 0.002 secs (0.001u,0.s)
Chars 69845 - 69884 [(intros;~rapply~extendable_con...] 0.006 secs (0.006u,0.s)
Chars 69807 - 69840 [rapply~O_inverts_from_extendable.] 0. secs (0.u,0.s)
Chars 69845 - 69884 [(intros;~rapply~extendable_con...] 0. secs (0.u,0.s)
Chars 69887 - 69895 [Defined.] 0.026 secs (0.025u,0.001s)
Chars 69979 - 70181 [Definition~isequiv_conn_map_in...] 0.013 secs (0.013u,0.s)
Chars 70237 - 70346 [#[global]~Instance~conn_map_O_...] 0. secs (0.u,0.s)
Chars 70349 - 70355 [Proof.] 0. secs (0.u,0.s)
Chars 70360 - 70377 [(unfold~O_functor).] 0. secs (0.u,0.s)
Chars 70382 - 70406 [rapply~conn_map_compose.] 0.017 secs (0.017u,0.s)
Chars 70360 - 70377 [(unfold~O_functor).] 0. secs (0.u,0.s)
Chars 70382 - 70406 [rapply~conn_map_compose.] 0. secs (0.u,0.s)
Chars 70409 - 70417 [Defined.] 0.001 secs (0.001u,0.s)
Chars 70473 - 70628 [Definition~conn_map_sum~{A}~{B...] 0.001 secs (0.001u,0.s)
Chars 70631 - 70637 [Proof.] 0. secs (0.u,0.s)
Chars 70642 - 70685 [(apply~conn_map_from_extension...] 0.001 secs (0.001u,0.s)
Chars 70690 - 70752 [(apply~extension_functor_sum;~...] 0.026 secs (0.02u,0.006s)
Chars 70642 - 70685 [(apply~conn_map_from_extension...] 0.001 secs (0.u,0.s)
Chars 70690 - 70752 [(apply~extension_functor_sum;~...] 0.001 secs (0.001u,0.s)
Chars 70755 - 70763 [Defined.] 0. secs (0.u,0.s)
Chars 70821 - 71107 [Definition~conn_map_functor_co...] 0.006 secs (0.004u,0.001s)
Chars 71110 - 71116 [Proof.] 0. secs (0.u,0.s)
Chars 71121 - 71164 [(apply~conn_map_from_extension...] 0.003 secs (0.003u,0.s)
Chars 71169 - 71198 [(apply~extension_functor_coeq).] 0.003 secs (0.003u,0.s)
Chars 71203 - 71204 [-] 0. secs (0.u,0.s)
Chars 71205 - 71238 [rapply~ooextendable_conn_map_inO.] 0.012 secs (0.01u,0.001s)
Chars 71243 - 71244 [-] 0. secs (0.u,0.s)
Chars 71245 - 71286 [(intros;~rapply~ooextendable_c...] 0.016 secs (0.012u,0.003s)
Chars 71121 - 71164 [(apply~conn_map_from_extension...] 0.001 secs (0.001u,0.s)
Chars 71169 - 71198 [(apply~extension_functor_coeq).] 0.001 secs (0.001u,0.s)
Chars 71205 - 71238 [rapply~ooextendable_conn_map_inO.] 0. secs (0.u,0.s)
Chars 71245 - 71286 [(intros;~rapply~ooextendable_c...] 0.002 secs (0.002u,0.s)
Chars 71289 - 71297 [Defined.] 0.001 secs (0.u,0.s)
Chars 71326 - 71684 [Definition~conn_map_functor_pu...] 0.007 secs (0.005u,0.002s)
Chars 71687 - 71693 [Proof.] 0. secs (0.u,0.s)
Chars 71698 - 71741 [(apply~conn_map_from_extension...] 0.003 secs (0.002u,0.001s)
Chars 71746 - 71775 [(apply~extension_functor_coeq).] 0.005 secs (0.004u,0.s)
Chars 71780 - 71781 [-] 0. secs (0.u,0.s)
Chars 71782 - 71845 [(apply~extendable_functor_sum;...] 0.032 secs (0.029u,0.002s)
Chars 71850 - 71851 [-] 0. secs (0.u,0.s)
Chars 71852 - 71893 [(intros;~rapply~ooextendable_c...] 0.02 secs (0.018u,0.002s)
Chars 71698 - 71741 [(apply~conn_map_from_extension...] 0.002 secs (0.002u,0.s)
Chars 71746 - 71775 [(apply~extension_functor_coeq).] 0.001 secs (0.001u,0.s)
Chars 71782 - 71845 [(apply~extendable_functor_sum;...] 0.028 secs (0.021u,0.006s)
Chars 71852 - 71893 [(intros;~rapply~ooextendable_c...] 0.002 secs (0.002u,0.s)
Chars 71896 - 71904 [Defined.] 0.003 secs (0.003u,0.s)
Chars 71906 - 71924 [End~ConnectedMaps.] 0.109 secs (0.097u,0.011s)
Chars 72542 - 72669 [Class~O_leq@{i1~i2~j}~(O1~:~Su...] 0.001 secs (0.001u,0.s)
Chars 72671 - 72703 [Arguments~inO_leq~O1~O2~{_}~A~_.] 0. secs (0.u,0.s)
Chars 72705 - 72737 [Declare~Scope~subuniverse_scope.] 0. secs (0.u,0.s)
Chars 72738 - 72795 [Notation~"O1~<=~O2"~:=~(O_leq~...] 0. secs (0.u,0.s)
Chars 72796 - 72825 [Open~Scope~subuniverse_scope.] 0. secs (0.u,0.s)
Chars 72827 - 72882 [#[global]Instance~reflexive_O_...] 0. secs (0.u,0.s)
Chars 72883 - 72889 [Proof.] 0. secs (0.u,0.s)
Chars 72892 - 72917 [(intros~O~A~?;~assumption).] 0. secs (0.u,0.s)
Chars 72892 - 72917 [(intros~O~A~?;~assumption).] 0. secs (0.u,0.s)
Chars 72918 - 72926 [Defined.] 0. secs (0.u,0.s)
Chars 72928 - 72985 [#[global]Instance~transitive_O...] 0. secs (0.u,0.s)
Chars 72986 - 72992 [Proof.] 0. secs (0.u,0.s)
Chars 72995 - 73023 [(intros~O1~O2~O3~O12~O23~A~?).] 0. secs (0.u,0.s)
Chars 73026 - 73050 [rapply~(@inO_leq~O2~O3).] 0.003 secs (0.003u,0.s)
Chars 73053 - 73077 [rapply~(@inO_leq~O1~O2).] 0.002 secs (0.002u,0.s)
Chars 72995 - 73023 [(intros~O1~O2~O3~O12~O23~A~?).] 0. secs (0.u,0.s)
Chars 73026 - 73050 [rapply~(@inO_leq~O2~O3).] 0. secs (0.u,0.s)
Chars 73053 - 73077 [rapply~(@inO_leq~O1~O2).] 0. secs (0.u,0.s)
Chars 73078 - 73086 [Defined.] 0. secs (0.u,0.s)
Chars 73088 - 73216 [Definition~mapinO_O_leq~(O1~O2...] 0.001 secs (0.001u,0.s)
Chars 73217 - 73223 [Proof.] 0. secs (0.u,0.s)
Chars 73226 - 73259 [(intros~b;~rapply~(inO_leq~O1~...] 0.003 secs (0.002u,0.001s)
Chars 73226 - 73259 [(intros~b;~rapply~(inO_leq~O1~...] 0. secs (0.u,0.s)
Chars 73260 - 73268 [Defined.] 0. secs (0.u,0.s)
Chars 73695 - 73905 [Definition~isconnected_O_leq@{...] 0. secs (0.u,0.s)
Chars 73906 - 73912 [Proof.] 0. secs (0.u,0.s)
Chars 73915 - 73943 [(apply~isconnected_from_elim).] 0. secs (0.u,0.s)
Chars 73946 - 73960 [(intros~C~C1~f).] 0. secs (0.u,0.s)
Chars 73963 - 74017 [(apply~(isconnected_elim~O2);~...] 0.004 secs (0.004u,0.s)
Chars 73915 - 73943 [(apply~isconnected_from_elim).] 0. secs (0.u,0.s)
Chars 73946 - 73960 [(intros~C~C1~f).] 0. secs (0.u,0.s)
Chars 73963 - 74017 [(apply~(isconnected_elim~O2);~...] 0. secs (0.u,0.s)
Chars 74018 - 74026 [Defined.] 0. secs (0.u,0.s)
Chars 74089 - 74311 [Definition~conn_map_O_leq@{i1~...] 0. secs (0.u,0.s)
Chars 74312 - 74318 [Proof.] 0. secs (0.u,0.s)
Chars 74530 - 74565 [(apply~conn_map_from_extension...] 0.001 secs (0.u,0.s)
Chars 74568 - 74585 [(intros~P~P_inO~g).] 0. secs (0.u,0.s)
Chars 74588 - 74624 [rapply~(extension_conn_map_eli...] 0.01 secs (0.01u,0.s)
Chars 74627 - 74657 [(intros~b;~rapply~(inO_leq~O1)).] 0.004 secs (0.004u,0.s)
Chars 74530 - 74565 [(apply~conn_map_from_extension...] 0. secs (0.u,0.s)
Chars 74568 - 74585 [(intros~P~P_inO~g).] 0. secs (0.u,0.s)
Chars 74588 - 74624 [rapply~(extension_conn_map_eli...] 0. secs (0.u,0.s)
Chars 74627 - 74657 [(intros~b;~rapply~(inO_leq~O1)).] 0. secs (0.u,0.s)
Chars 74658 - 74666 [Defined.] 0. secs (0.u,0.s)
Chars 74758 - 74977 [Definition~O_inverts_O_leq@{i1...] 0.001 secs (0.001u,0.s)
Chars 74978 - 74984 [Proof.] 0. secs (0.u,0.s)
Chars 74987 - 75052 [(apply~O_inverts_from_extendab...] 0.001 secs (0.001u,0.s)
Chars 75055 - 75080 [(pose~(inO_leq~O1~O2~Z~_)).] 0.001 secs (0.001u,0.s)
Chars 75083 - 75147 [(apply~lift_extendablealong@{i...] 0. secs (0.u,0.s)
Chars 75150 - 75193 [(apply~(ooextendable_O_inverts...] 0.004 secs (0.004u,0.s)
Chars 74987 - 75052 [(apply~O_inverts_from_extendab...] 0. secs (0.u,0.s)
Chars 75055 - 75080 [(pose~(inO_leq~O1~O2~Z~_)).] 0. secs (0.u,0.s)
Chars 75083 - 75147 [(apply~lift_extendablealong@{i...] 0. secs (0.u,0.s)
Chars 75150 - 75193 [(apply~(ooextendable_O_inverts...] 0.001 secs (0.001u,0.s)
Chars 75194 - 75202 [Defined.] 0. secs (0.u,0.s)
Chars 75554 - 75700 [Class~O_eq@{i1~i2~j}~(O1~:~Sub...] 0.002 secs (0.002u,0.s)
Chars 75702 - 75742 [#[global]Existing~Instances~O_...] 0. secs (0.u,0.s)
Chars 75744 - 75784 [Infix~"<=>"~:=~O_eq~:~subunive...] 0. secs (0.u,0.s)
Chars 75786 - 75849 [Definition~issig_O_eq~O1~O2~:~...] 0.018 secs (0.016u,0.002s)
Chars 75851 - 75904 [#[global]Instance~reflexive_O_...] 0. secs (0.u,0.s)
Chars 75905 - 75911 [Proof.] 0. secs (0.u,0.s)
Chars 75914 - 75941 [(intros;~split;~reflexivity).] 0.003 secs (0.002u,0.s)
Chars 75914 - 75941 [(intros;~split;~reflexivity).] 0. secs (0.u,0.s)
Chars 75942 - 75950 [Defined.] 0. secs (0.u,0.s)
Chars 75952 - 76007 [#[global]Instance~transitive_O...] 0. secs (0.u,0.s)
Chars 76008 - 76014 [Proof.] 0. secs (0.u,0.s)
Chars 76017 - 76077 [(intros~O1~O2~O3;~split;~refin...] 0.006 secs (0.005u,0.s)
Chars 76017 - 76077 [(intros~O1~O2~O3;~split;~refin...] 0. secs (0.u,0.s)
Chars 76078 - 76086 [Defined.] 0. secs (0.u,0.s)
Chars 76088 - 76141 [#[global]Instance~symmetric_O_...] 0. secs (0.u,0.s)
Chars 76142 - 76148 [Proof.] 0. secs (0.u,0.s)
Chars 76151 - 76189 [(intros~O1~O2~[?~?];~split;~as...] 0.001 secs (0.u,0.s)
Chars 76151 - 76189 [(intros~O1~O2~[?~?];~split;~as...] 0. secs (0.u,0.s)
Chars 76190 - 76198 [Defined.] 0. secs (0.u,0.s)
Chars 76200 - 76265 [Definition~issig_subuniverse~:...] 0.064 secs (0.051u,0.012s)
Chars 76267 - 76367 [Definition~equiv_path_subunive...] 0. secs (0.u,0.s)
Chars 76368 - 76374 [Proof.] 0. secs (0.u,0.s)
Chars 76377 - 76413 [refine~(_~oE~(issig_O_eq~O1~O2...] 0.001 secs (0.001u,0.s)
Chars 76416 - 76482 [(revert~O1~O2;~refine~(equiv_p...] 0.001 secs (0.u,0.s)
Chars 76485 - 76503 [(cbn;~intros~O1~O2).] 0.002 secs (0.001u,0.s)
Chars 76506 - 76549 [refine~(equiv_path_sigma_hprop...] 0.062 secs (0.052u,0.009s)
Chars 76552 - 76614 [(destruct~O1~as~[O1~[O1h~?]];~...] 0.027 secs (0.026u,0.s)
Chars 76617 - 76652 [refine~(equiv_path_arrow~_~_~o...] 0.002 secs (0.002u,0.s)
Chars 76655 - 76681 [srapply~equiv_iff_hprop.] 0.137 secs (0.126u,0.004s)
Chars 76684 - 76685 [-] 0. secs (0.u,0.s)
Chars 76686 - 76731 [(srapply~istrunc_sigma;~unfold...] 0.049 secs (0.049u,0.s)
Chars 76734 - 76735 [-] 0. secs (0.u,0.s)
Chars 76736 - 76797 [(intros~[h~k]~A;~specialize~(h...] 0.004 secs (0.003u,0.s)
Chars 76802 - 76861 [(apply~path_universe_uncurried...] 0.005 secs (0.005u,0.s)
Chars 76864 - 76865 [-] 0. secs (0.u,0.s)
Chars 76866 - 76922 [(intros~h;~split;~intros~A~e;~...] 0.005 secs (0.005u,0.s)
Chars 76927 - 76942 [1:~(rewrite~<-~h).] 0. secs (0.u,0.s)
Chars 76947 - 76959 [2:~(rewrite~h).] 0. secs (0.u,0.s)
Chars 76964 - 76976 [all:~exact~e.] 0. secs (0.u,0.s)
Chars 76377 - 76413 [refine~(_~oE~(issig_O_eq~O1~O2...] 0. secs (0.u,0.s)
Chars 76416 - 76482 [(revert~O1~O2;~refine~(equiv_p...] 0. secs (0.u,0.s)
Chars 76485 - 76503 [(cbn;~intros~O1~O2).] 0.001 secs (0.001u,0.s)
Chars 76506 - 76549 [refine~(equiv_path_sigma_hprop...] 0. secs (0.u,0.s)
Chars 76552 - 76614 [(destruct~O1~as~[O1~[O1h~?]];~...] 0.005 secs (0.005u,0.s)
Chars 76617 - 76652 [refine~(equiv_path_arrow~_~_~o...] 0. secs (0.u,0.s)
Chars 76655 - 76681 [srapply~equiv_iff_hprop.] 0. secs (0.u,0.s)
Chars 76686 - 76731 [(srapply~istrunc_sigma;~unfold...] 0.002 secs (0.002u,0.s)
Chars 76736 - 76797 [(intros~[h~k]~A;~specialize~(h...] 0.001 secs (0.001u,0.s)
Chars 76802 - 76861 [(apply~path_universe_uncurried...] 0.001 secs (0.001u,0.s)
Chars 76866 - 76922 [(intros~h;~split;~intros~A~e;~...] 0.003 secs (0.003u,0.s)
Chars 76927 - 76942 [1:~(rewrite~<-~h).] 0. secs (0.u,0.s)
Chars 76947 - 76959 [2:~(rewrite~h).] 0. secs (0.u,0.s)
Chars 76964 - 76976 [all:~exact~e.] 0. secs (0.u,0.s)
Chars 76977 - 76985 [Defined.] 0.03 secs (0.029u,0.001s)
Chars 77398 - 77535 [Definition~prereflects_O_leq~(...] 0. secs (0.u,0.s)
Chars 77536 - 77542 [Proof.] 0. secs (0.u,0.s)
Chars 77545 - 77567 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 77570 - 77571 [-] 0. secs (0.u,0.s)
Chars 77572 - 77597 [exact~(O_reflector~O1~A).] 0. secs (0.u,0.s)
Chars 77600 - 77601 [-] 0. secs (0.u,0.s)
Chars 77602 - 77625 [rapply~(inO_leq~O1~O2).] 0.001 secs (0.001u,0.s)
Chars 77628 - 77629 [-] 0. secs (0.u,0.s)
Chars 77630 - 77646 [exact~(to~O1~A).] 0. secs (0.u,0.s)
Chars 77545 - 77567 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 77572 - 77597 [exact~(O_reflector~O1~A).] 0. secs (0.u,0.s)
Chars 77602 - 77625 [rapply~(inO_leq~O1~O2).] 0. secs (0.u,0.s)
Chars 77630 - 77646 [exact~(to~O1~A).] 0. secs (0.u,0.s)
Chars 77647 - 77655 [Defined.] 0. secs (0.u,0.s)
Chars 77657 - 77814 [Definition~reflects_O_eq~(O1~O...] 0.001 secs (0.001u,0.s)
Chars 77815 - 77821 [Proof.] 0. secs (0.u,0.s)
Chars 77824 - 77853 [(constructor;~intros~B~B_inO2).] 0.001 secs (0.001u,0.s)
Chars 77856 - 77892 [(pose~proof~(inO_leq~O2~O1~_~B...] 0.001 secs (0.001u,0.s)
Chars 77895 - 77922 [(apply~(extendable_to_O~O1)).] 0.001 secs (0.001u,0.s)
Chars 77824 - 77853 [(constructor;~intros~B~B_inO2).] 0. secs (0.u,0.s)
Chars 77856 - 77892 [(pose~proof~(inO_leq~O2~O1~_~B...] 0. secs (0.u,0.s)
Chars 77895 - 77922 [(apply~(extendable_to_O~O1)).] 0. secs (0.u,0.s)
Chars 77923 - 77931 [Defined.] 0. secs (0.u,0.s)
Chars 78180 - 78227 [Definition~Sep~(O~:~Subunivers...] 0. secs (0.u,0.s)
Chars 78228 - 78234 [Proof.] 0. secs (0.u,0.s)
Chars 78237 - 78259 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 78262 - 78263 [-] 0. secs (0.u,0.s)
Chars 78264 - 78311 [(intros~A;~exact~(forall~x~y~:...] 0.001 secs (0.001u,0.s)
Chars 78314 - 78315 [-] 0. secs (0.u,0.s)
Chars 78316 - 78324 [exact~_.] 0.016 secs (0.016u,0.s)
Chars 78327 - 78328 [-] 0. secs (0.u,0.s)
Chars 78329 - 78360 [(intros~T~U~?~f~?~x~y;~cbn~in~*).] 0. secs (0.u,0.s)
Chars 78365 - 78414 [refine~(inO_equiv_inO'~_~(equi...] 0.002 secs (0.002u,0.s)
Chars 78237 - 78259 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 78264 - 78311 [(intros~A;~exact~(forall~x~y~:...] 0. secs (0.u,0.s)
Chars 78316 - 78324 [exact~_.] 0. secs (0.u,0.s)
Chars 78329 - 78360 [(intros~T~U~?~f~?~x~y;~cbn~in~*).] 0. secs (0.u,0.s)
Chars 78365 - 78414 [refine~(inO_equiv_inO'~_~(equi...] 0. secs (0.u,0.s)
Chars 78415 - 78423 [Defined.] 0. secs (0.u,0.s)
Chars 78425 - 78557 [#[global]~Instance~inO_paths_S...] 0. secs (0.u,0.s)
Chars 79130 - 79490 [Definition~OO_inverts_functor_...] 0.005 secs (0.005u,0.s)
Chars 79491 - 79497 [Proof.] 0. secs (0.u,0.s)
Chars 79500 - 79532 [(apply~O_inverts_from_extendab...] 0.001 secs (0.001u,0.s)
Chars 79535 - 79550 [(intros~Z~Z_inO).] 0.001 secs (0.001u,0.s)
Chars 79553 - 79583 [(apply~extendable_functor_coeq).] 0.002 secs (0.002u,0.s)
Chars 79586 - 79587 [-] 0. secs (0.u,0.s)
Chars 79588 - 79636 [(nrapply~(ooextendable_O_inver...] 0.007 secs (0.007u,0.s)
Chars 79639 - 79640 [-] 0. secs (0.u,0.s)
Chars 79641 - 79667 [(pose~(inO_leq~O'~(Sep~O))).] 0.001 secs (0.001u,0.s)
Chars 79672 - 79719 [(intros~u~v;~rapply~(extendabl...] 0.011 secs (0.011u,0.s)
Chars 79500 - 79532 [(apply~O_inverts_from_extendab...] 0. secs (0.u,0.s)
Chars 79535 - 79550 [(intros~Z~Z_inO).] 0. secs (0.u,0.s)
Chars 79553 - 79583 [(apply~extendable_functor_coeq).] 0. secs (0.u,0.s)
Chars 79588 - 79636 [(nrapply~(ooextendable_O_inver...] 0.001 secs (0.001u,0.s)
Chars 79641 - 79667 [(pose~(inO_leq~O'~(Sep~O))).] 0. secs (0.u,0.s)
Chars 79672 - 79719 [(intros~u~v;~rapply~(extendabl...] 0.001 secs (0.001u,0.s)
Chars 79720 - 79728 [Defined.] 0.001 secs (0.001u,0.s)
Chars 79773 - 80186 [Definition~OO_inverts_functor_...] 0.006 secs (0.006u,0.s)
Chars 80187 - 80193 [Proof.] 0. secs (0.u,0.s)
Chars 80196 - 80235 [nrapply~(OO_inverts_functor_co...] 0.012 secs (0.011u,0.s)
Chars 80238 - 80250 [1,~3:~exact~_.] 0.002 secs (0.002u,0.s)
Chars 80253 - 80282 [rapply~O_inverts_functor_sum.] 0.015 secs (0.015u,0.s)
Chars 80196 - 80235 [nrapply~(OO_inverts_functor_co...] 0.001 secs (0.001u,0.s)
Chars 80238 - 80250 [1,~3:~exact~_.] 0.001 secs (0.001u,0.s)
Chars 80253 - 80282 [rapply~O_inverts_functor_sum.] 0. secs (0.u,0.s)
Chars 80283 - 80291 [Defined.] 0.002 secs (0.002u,0.s)
Chars 80342 - 80691 [Definition~OO_conn_map_functor...] 0.004 secs (0.004u,0.s)
Chars 80692 - 80698 [Proof.] 0. secs (0.u,0.s)
Chars 80701 - 80744 [(apply~conn_map_from_extension...] 0.002 secs (0.002u,0.s)
Chars 80747 - 80776 [(apply~extension_functor_coeq).] 0.003 secs (0.002u,0.s)
Chars 80779 - 80780 [-] 0. secs (0.u,0.s)
Chars 80781 - 80814 [rapply~ooextendable_conn_map_inO.] 0.011 secs (0.011u,0.s)
Chars 80817 - 80818 [-] 0. secs (0.u,0.s)
Chars 80819 - 80895 [(pose~(inO_leq~O'~(Sep~O));~in...] 0.028 secs (0.028u,0.s)
Chars 80701 - 80744 [(apply~conn_map_from_extension...] 0.001 secs (0.001u,0.s)
Chars 80747 - 80776 [(apply~extension_functor_coeq).] 0.001 secs (0.001u,0.s)
Chars 80781 - 80814 [rapply~ooextendable_conn_map_inO.] 0. secs (0.u,0.s)
Chars 80819 - 80895 [(pose~(inO_leq~O'~(Sep~O));~in...] 0.003 secs (0.003u,0.s)
Chars 80896 - 80904 [Defined.] 0.001 secs (0.001u,0.s)
Chars 80906 - 81328 [Definition~OO_conn_map_functor...] 0.006 secs (0.005u,0.s)
Chars 81329 - 81335 [Proof.] 0. secs (0.u,0.s)
Chars 81338 - 81381 [(apply~conn_map_from_extension...] 0.002 secs (0.002u,0.s)
Chars 81384 - 81413 [(apply~extension_functor_coeq).] 0.004 secs (0.004u,0.s)
Chars 81416 - 81417 [-] 0. secs (0.u,0.s)
Chars 81418 - 81481 [(apply~extendable_functor_sum;...] 0.028 secs (0.028u,0.s)
Chars 81484 - 81485 [-] 0. secs (0.u,0.s)
Chars 81486 - 81558 [(pose~(inO_leq~O'~(Sep~O));~in...] 0.022 secs (0.022u,0.s)
Chars 81338 - 81381 [(apply~conn_map_from_extension...] 0.001 secs (0.001u,0.s)
Chars 81384 - 81413 [(apply~extension_functor_coeq).] 0.001 secs (0.001u,0.s)
Chars 81418 - 81481 [(apply~extendable_functor_sum;...] 0.003 secs (0.003u,0.s)
Chars 81486 - 81558 [(pose~(inO_leq~O'~(Sep~O));~in...] 0.004 secs (0.004u,0.s)
Chars 81559 - 81567 [Defined.] 0.004 secs (0.004u,0.s)
Chars 81569 - 81633 [#[export]Hint~Immediate~inO_is...] 0. secs (0.u,0.s)
Chars 81634 - 81693 [#[export]Hint~Immediate~inO_un...] 0. secs (0.u,0.s)
Chars 81694 - 81770 [#[export]Hint~Immediate~isconn...] 0. secs (0.u,0.s)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((eval
    (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))
       (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))) 0 k *
  eval
    (weight (Qnum (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))
       (QDen (UnsaturatedSolinasHeuristics.limbwidth 0 0 c))) 0 e) mod m)
Unrecognized (non-unfoldable) term: c
expr.reify_in_context: Failure in reifying:
c
expr.reify_in_context: Failure in reifying:
(Associational.eval c)
expr.reify_in_context: Failure in reifying:
(s - Associational.eval c)
Failed to reify m via unfolding to (s - Associational.eval c)
expr.reify_in_context: Failure in reifying:
m
expr.reify_in_context: Failure in reifying:
((eval
    (weight
       (Z.log2_up (- Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n k *
  eval
    (weight
       (Z.log2_up (- Associational.eval c) * Qnum (/ inject_Z (Z.of_nat n)))
       (QDen (/ inject_Z (Z.of_nat n)))) n e) mod m)
Crunching: (r >= 0)
Crunching: (Hlen >= 0)
Crunching:
(cos_term (7 / 8) 0 + cos_term (7 / 8) 1 <= cos (7 / 8) ->
 cos (7 / 8) <= cos_term (7 / 8) 0 + cos_term (7 / 8) 1 + cos_term (7 / 8) 2 ->
 0 < cos (7 / 8))
Crunching: False
Crunching: (H1 >= 0)
Crunching: (interval_sum x H10 n H1 -> H1 >= 0)
Crunching: (n >= 0)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
(match ?m@{width:=32} with
 | Z.pos y' =>
     (fix compare_cont (r : comparison) (x y : positive) {struct y} :
          comparison :=
        match x with
        | (p~1)%positive =>
            match y with
            | (q~1)%positive => compare_cont r p q
            | (q~0)%positive => compare_cont Gt p q
            | 1%positive => Gt
            end
        | (p~0)%positive =>
            match y with
            | (q~1)%positive => compare_cont Lt p q
            | (q~0)%positive => compare_cont r p q
            | 1%positive => Gt
            end
        | 1%positive => match y with
                        | 1%positive => r
                        | _ => Lt
                        end
        end) Eq 8%positive y'
 | _ => Gt
 end = Gt -> False)
Crunching: (R0 < m \/ m = R0)
Crunching: (forall rr r : R, interval_sum p H8 rr r -> r >= 0)
find_witness Control.TimeoutCrunching: (k >= 0)
Section Variables:
field_parameters
: FieldParameters
Section Variables:
word
: Interface.word width
width
: Z
field_parameters
: FieldParameters
Crunching: (k >= 0)
Crunching: (k >= 0)
clear  H0a'  :  (False -> cmpA a a' <> Lt)
Compilation incomplete.
You may need to add new compilation lemmas using `Hint Extern 1 => simple eapply … : compiler` or to tell Rupicola about your custom bindings using `Hint Extern 2 (IsRupicolaBinding (xlet (A := ?A) ?vars _ _)) => exact (RupicolaBinding A vars) : typeclass_instances`.
Crunching: (forall x0 : R, interval_sum x r s x0 -> R0 < x0 \/ x0 = R0)
find_witness Control.TimeoutCrunching:
(1 + 0 < 1 + 1 -> forall rr r : R, interval_sum x eps rr r -> r >= 0)
Crunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
Finished transaction in 4.467 secs (4.431u,0.034s) (successful)
Finished transaction in 10.618 secs (10.269u,0.347s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
Finished transaction in 4.551 secs (4.514u,0.036s) (successful)
Axioms:
ClassicalDedekindReals.sig_not_dec : forall P : Prop, {~ ~ P} + {~ P}
ClassicalDedekindReals.sig_forall_dec
  : forall P : nat -> Prop,
    (forall n : nat, {P n} + {~ P n}) ->
    {n : nat | ~ P n} + {forall n : nat, P n}
prop_ext : ClassicalFacts.prop_extensionality
lib.Axioms.proof_irr : ClassicalFacts.proof_irrelevance
Clight_core.inline_external_call_mem_events
  : forall (ef : external_function) (ge : Senv.t) 
      (vargs : list val) (m : mem) (t : Events.trace) 
      (vres : val) (m' : mem),
    ef_inline ef = true ->
    Events.external_call ef ge vargs m t vres m' ->
    {trace : list event_semantics.mem_event
    | event_semantics.ev_elim m trace m'}
Events.inline_assembly_sem : string -> signature -> Events.extcall_sem
functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Events.external_functions_sem : string -> signature -> Events.extcall_sem
Eqdep.Eq_rect_eq.eq_rect_eq
  : forall (U : Type) (p : U) (Q : U -> Type) (x : Q p) (h : p = p),
    x = eq_rect p Q x p h
Classical_Prop.classic : forall P : Prop, P \/ ~ P
Finished transaction in 4.895 secs (4.865u,0.029s) (successful)
Tactic call ran for 312.941 secs (305.823u,6.863s) (success)
Tactic call ran for 0.497 secs (0.486u,0.009s) (success)
Crunching:
(∣0⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 4.464 secs (3.963u,0.496s) (success)
     = (0, 1, (0, 0))
     : vect p p
     = (0, 0, (1, 0))
     : vect p p
     = (1, 0, (0, 0))
     : Vect p
     = (0, -1, (1, 0))
     : Vect p
     = (2, 0, (0, 0))
     : Vect p
     = (0, 0, (0, 1), (0, 0, (0, 0)))
     : vect p p
     = (0, 0, (0, 0), (0, 1, (0, 0)))
     : vect p p
     = (0, 0, (0, 0), (0, 0, (1, 0)))
     : vect p p
     = (1, 0, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = (0, 0, (0, 0), (0, 0, (1, 0)))
     : Vect p
     = (1, 0, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = (2, 0, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = Some ((0, 0, (0, 0), (0, 1, (0, 0))) :: nil)
     : option (list (Vect p))
     = Some
         ((0, 0, (0, 0), (0, -1, (1, 0)))
          :: (0, 0, (0, -1), (0, -1, (0, 0))) :: nil)
     : option (list (Vect p))
     = Some
         ((0, 0, (0, 0), (0, 0, (1, 0)))
          :: (0, 0, (0, 0), (0, 1, (0, 0)))
             :: (0, 0, (0, -1), (0, 0, (0, 0))) :: nil)
     : option (list (Vect p))
     = Some
         ((0, 0, (0, 0), (0, 1, (1, 0)))
          :: (0, 0, (0, -1), (0, -1, (0, 0))) :: nil)
     : option (list (Vect p))
     = (0, 0, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = (0, 0, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = (0, 0, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = (0, 0, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = (-1, 0, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = (0, 0, (1, 0), (0, 0, (0, 0)))
     : Vect p
     = (0, 0, (-1, 0), (0, 0, (0, 0)))
     : Vect p
     = (1, 0, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = (1, 0, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = (-1, 0, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = (0, -1, (0, 0), (0, 0, (0, 0)))
     : Vect p
     = [[ X: 1, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : vect p p
     = [[ X: 0, Y: 1, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : vect p p
     = [[ X: 0, Y: 0, Z: 1, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : vect p p
     = [[ X: 0, Y: 0, Z: 0, T: 1, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : vect p p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 1,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 2, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 1, X**T: 0, Y**Z: 1,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: -1, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 1, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: -1, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 1, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 1, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: -1, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: -1, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 1, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: -1, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 1, K: 0 ]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, X**Y: 0, X**Z: 0, X**T: 0, Y**Z: 0,
       Y**T: 0, Z**T: 0, X**Y**Z: 0, X**Y**T: 0, X**Z**T: 0, Y**Z**T: 0,
       X**Y**Z**T: 0, K: 0 ]]
     : Vect p
     = [[ X: 1, Y: 0, Z: 0, T: 0, U: 0, X**Y: 0, X**Z: 0, X**T: 0, X**U: 0,
       Y**Z: 0, Y**T: 0, Y**U: 0, Z**T: 0, Z**U: 0, T**U: 0, X**Y**Z: 0,
       X**Y**T: 0, X**Y**U: 0, X**Z**T: 0, X**Z**U: 0, X**T**U: 0,
       Y**Z**T: 0, Y**Z**U: 0, Y**T**U: 0, Z**T**U: 0, X**Y**Z**T: 0,
       X**Y**Z**U: 0, X**Y**T**U: 0, X**Z**T**U: 0, Y**Z**T**U: 0,
       X**Y**Z**T**U: 0, K: 0]]
     : vect p p
     = [[ X: 0, Y: 1, Z: 0, T: 0, U: 0, X**Y: 0, X**Z: 0, X**T: 0, X**U: 0,
       Y**Z: 0, Y**T: 0, Y**U: 0, Z**T: 0, Z**U: 0, T**U: 0, X**Y**Z: 0,
       X**Y**T: 0, X**Y**U: 0, X**Z**T: 0, X**Z**U: 0, X**T**U: 0,
       Y**Z**T: 0, Y**Z**U: 0, Y**T**U: 0, Z**T**U: 0, X**Y**Z**T: 0,
       X**Y**Z**U: 0, X**Y**T**U: 0, X**Z**T**U: 0, Y**Z**T**U: 0,
       X**Y**Z**T**U: 0, K: 0]]
     : vect p p
     = [[ X: 0, Y: 0, Z: 1, T: 0, U: 0, X**Y: 0, X**Z: 0, X**T: 0, X**U: 0,
       Y**Z: 0, Y**T: 0, Y**U: 0, Z**T: 0, Z**U: 0, T**U: 0, X**Y**Z: 0,
       X**Y**T: 0, X**Y**U: 0, X**Z**T: 0, X**Z**U: 0, X**T**U: 0,
       Y**Z**T: 0, Y**Z**U: 0, Y**T**U: 0, Z**T**U: 0, X**Y**Z**T: 0,
       X**Y**Z**U: 0, X**Y**T**U: 0, X**Z**T**U: 0, Y**Z**T**U: 0,
       X**Y**Z**T**U: 0, K: 0]]
     : vect p p
     = [[ X: 0, Y: 0, Z: 0, T: 1, U: 0, X**Y: 0, X**Z: 0, X**T: 0, X**U: 0,
       Y**Z: 0, Y**T: 0, Y**U: 0, Z**T: 0, Z**U: 0, T**U: 0, X**Y**Z: 0,
       X**Y**T: 0, X**Y**U: 0, X**Z**T: 0, X**Z**U: 0, X**T**U: 0,
       Y**Z**T: 0, Y**Z**U: 0, Y**T**U: 0, Z**T**U: 0, X**Y**Z**T: 0,
       X**Y**Z**U: 0, X**Y**T**U: 0, X**Z**T**U: 0, Y**Z**T**U: 0,
       X**Y**Z**T**U: 0, K: 0]]
     : vect p p
     = [[ X: 0, Y: 0, Z: 0, T: 0, U: 1, X**Y: 0, X**Z: 0, X**T: 0, X**U: 0,
       Y**Z: 0, Y**T: 0, Y**U: 0, Z**T: 0, Z**U: 0, T**U: 0, X**Y**Z: 0,
       X**Y**T: 0, X**Y**U: 0, X**Z**T: 0, X**Z**U: 0, X**T**U: 0,
       Y**Z**T: 0, Y**Z**U: 0, Y**T**U: 0, Z**T**U: 0, X**Y**Z**T: 0,
       X**Y**Z**U: 0, X**Y**T**U: 0, X**Z**T**U: 0, Y**Z**T**U: 0,
       X**Y**Z**T**U: 0, K: 0]]
     : vect p p
     = [[ X: 0, Y: 0, Z: 0, T: 0, U: 0, X**Y: 0, X**Z: 0, X**T: 0, X**U: 0,
       Y**Z: 0, Y**T: 0, Y**U: 0, Z**T: 0, Z**U: 0, T**U: 0, X**Y**Z: 0,
       X**Y**T: 0, X**Y**U: 0, X**Z**T: 0, X**Z**U: 0, X**T**U: 0,
       Y**Z**T: 0, Y**Z**U: 0, Y**T**U: 0, Z**T**U: 0, X**Y**Z**T: 0,
       X**Y**Z**U: 0, X**Y**T**U: 0, X**Z**T**U: 0, Y**Z**T**U: 0,
       X**Y**Z**T**U: 1, K: 0]]
     : Vect p
     = [[ X: 0, Y: 0, Z: 0, T: 0, U: 0, X**Y: 0, X**Z: 0, X**T: 0, X**U: 0,
       Y**Z: 0, Y**T: 0, Y**U: 0, Z**T: 0, Z**U: 0, T**U: 0, X**Y**Z: 0,
       X**Y**T: 0, X**Y**U: 0, X**Z**T: 0, X**Z**U: 0, X**T**U: 0,
       Y**Z**T: 0, Y**Z**U: 0, Y**T**U: 0, Z**T**U: 0, X**Y**Z**T: 0,
       X**Y**Z**U: 0, X**Y**T**U: 0, X**Z**T**U: 0, Y**Z**T**U: 0,
       X**Y**Z**T**U: -1, K: 0]]
     : Vect p
     = (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 1)))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
         (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))))))
     : vect p p
     = (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0)))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 1))),
         (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))))))
     : vect p p
     = (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0)))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
         (0, 0, (0, 0), (0, 0, (0, 1)), (0, 0, (0, 0), (0, 0, (0, 0))))))
     : vect p p
     = (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0)))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
         (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 1), (0, 0, (0, 0))))))
     : vect p p
     = (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0)))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
         (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 1, (0, 0))))))
     : vect p p
     = (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0)))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
         (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (1, 0))))))
     : vect p p
     = (2, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0)))),
        (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))),
         (0, 0, (0, 0), (0, 0, (0, 0)), (0, 0, (0, 0), (0, 0, (0, 0))))))
     : Vect p
