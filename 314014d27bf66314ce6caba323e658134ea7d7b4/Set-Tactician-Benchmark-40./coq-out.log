Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 36 - 81 [Require~Import~Category.Core~C...] 0.038 secs (0.019u,0.018s)
Chars 82 - 110 [Require~Import~Types.Forall.] 0.506 secs (0.396u,0.108s)
Chars 112 - 138 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 139 - 162 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 163 - 191 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 192 - 216 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 218 - 250 [#[local]Open~Scope~category_sc...] 0. secs (0.u,0.s)
Chars 251 - 283 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 341 - 352 [Section~pi.] 0. secs (0.u,0.s)
Chars 355 - 373 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 376 - 394 [Variable~(A~:~Type).] 0. secs (0.u,0.s)
Chars 397 - 427 [Variable~(P~:~A~->~PreCategory).] 0. secs (0.u,0.s)
Chars 431 - 459 [Definition~pi~:~PreCategory.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 45 - 67 [Require~Import~Basics.] 0.328 secs (0.247u,0.079s)
Chars 68 - 96 [Require~Import~WildCat.Core.] 0.072 secs (0.055u,0.016s)
Chars 124 - 202 [#[global]~Instance~isgraph_sum...] 0. secs (0.u,0.s)
Chars 203 - 209 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 19 - 83 [Require~Import~Category.Core~C...] 1.947 secs (1.748u,0.196s)
Chars 84 - 147 [Require~Import~Trunc~Types.For...] 0.006 secs (0.006u,0.s)
Chars 149 - 175 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 176 - 199 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 200 - 228 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 229 - 253 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 256 - 288 [#[local]Open~Scope~category_sc...] 0. secs (0.u,0.s)
Chars 528 - 650 [Class~IsGroupoid~(C~:~PreCateg...] 0.001 secs (0.001u,0.s)
Chars 652 - 742 [#[global]~Instance~trunc_isgro...] 0.007 secs (0.006u,0.001s)
Chars 833 - 866 [Module~GroupoidCategoryInternals.] 0. secs (0.u,0.s)
Chars 869 - 895 [Section~groupoid_category.] 0. secs (0.u,0.s)
Chars 900 - 918 [Variable~(X~:~Type).] 0. secs (0.u,0.s)
Chars 923 - 946 [Context~`{IsTrunc~1~X}.] 0. secs (0.u,0.s)
Chars 952 - 990 [#[local]Notation~morphism~:=~(...] 0. secs (0.u,0.s)
Chars 996 - 1109 [Definition~compose~s~d~d'~(m~:...] 0.001 secs (0.001u,0.s)
Chars 1115 - 1175 [Definition~identity~x~:~morphi...] 0. secs (0.u,0.s)
Chars 1181 - 1223 [#[global]Arguments~compose~[s~...] 0. secs (0.u,0.s)
Chars 1228 - 1259 [#[global]Arguments~identity~x~/.] 0. secs (0.u,0.s)
Chars 1262 - 1284 [End~groupoid_category.] 0. secs (0.u,0.s)
Chars 1285 - 1315 [End~GroupoidCategoryInternals.] 0. secs (0.u,0.s)
Chars 1372 - 1432 [Definition~groupoid_category~X...] 0. secs (0.u,0.s)
Chars 1433 - 1439 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.323 secs (0.231u,0.09s)
Chars 23 - 44 [Require~Import~Types.] 1.622 secs (1.48u,0.128s)
Chars 45 - 77 [Require~Import~Diagrams.Diagram.] 0.118 secs (0.112u,0.006s)
Chars 78 - 108 [Require~Import~Diagrams.Graph.] 0. secs (0.u,0.s)
Chars 109 - 140 [Require~Import~Diagrams.Cocone.] 0.079 secs (0.078u,0.s)
find_witness Control.TimeoutChars 141 - 173 [Require~Import~Colimits.Colimit.] 0.934 secs (0.865u,0.067s)
Chars 450 - 471 [Section~ColimitSigma.] 0. secs (0.u,0.s)
Chars 475 - 537 [Context~`{Funext}~{G~:~Graph}~...] 0. secs (0.u,0.s)
Chars 578 - 615 [Definition~sigma_diagram~:~Dia...] 0. secs (0.u,0.s)
Chars 618 - 624 [Proof.] 0. secs (0.u,0.s)
Chars 629 - 651 [srapply~Build_Diagram.] 1.068 secs (0.001u,0.025s)
Chars 656 - 657 [-] 0. secs (0.u,0.s)
Chars 658 - 690 [exact~(fun~i~=>~{y~:~Y~&~D~y~i}).] 0.001 secs (0.001u,0.s)
Chars 695 - 696 [-] 0. secs (0.u,0.s)
Chars 697 - 719 [(simpl;~intros~i~j~g~x).] 0.001 secs (0.001u,0.s)
Chars 726 - 754 [exact~(x.1;~((D~x.1)~_f~g)~x.2).] 0.002 secs (0.002u,0.s)
Chars 629 - 651 [srapply~Build_Diagram.] 0. secs (0.u,0.s)
Chars 658 - 690 [exact~(fun~i~=>~{y~:~Y~&~D~y~i}).] 0. secs (0.u,0.s)
Chars 697 - 719 [(simpl;~intros~i~j~g~x).] 0. secs (0.u,0.s)
Chars 726 - 754 [exact~(x.1;~((D~x.1)~_f~g)~x.2).] 0. secs (0.u,0.s)
Chars 757 - 765 [Defined.] 0. secs (0.u,0.s)
Chars 848 - 917 [Definition~sigma_diagram_map~(...] 0. secs (0.u,0.s)
Chars 920 - 926 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 36 [Require~Import~Basics~Types~Pa...] 1.954 secs (1.758u,0.191s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 31 - 100 [Require~Import~Category.Core~F...] 0.029 secs (0.021u,0.007s)
Chars 101 - 133 [Require~Import~Functor.Identity.] 0. secs (0.u,0.s)
Chars 212 - 225 [econstructor.] 20.376 secs (0.u,0.011s)
Chars 228 - 255 [(intros~[a1|~b1]~[a2|~b2]).] 0.002 secs (0.u,0.001s)
Chars 258 - 259 [+] 0. secs (0.u,0.s)
Chars 260 - 278 [exact~(a1~$->~a2).] 0.001 secs (0.001u,0.s)
Chars 281 - 282 [+] 0. secs (0.u,0.s)
Chars 283 - 295 [exact~Empty.] 0. secs (0.u,0.s)
Chars 298 - 299 [+] 0. secs (0.u,0.s)
Chars 300 - 312 [exact~Empty.] 0. secs (0.u,0.s)
Chars 315 - 316 [+] 0. secs (0.u,0.s)
Chars 317 - 335 [exact~(b1~$->~b2).] 0. secs (0.u,0.s)
Chars 212 - 225 [econstructor.] 0. secs (0.u,0.s)
Chars 228 - 255 [(intros~[a1|~b1]~[a2|~b2]).] 0. secs (0.u,0.s)
Chars 260 - 278 [exact~(a1~$->~a2).] 0. secs (0.u,0.s)
Chars 283 - 295 [exact~Empty.] 0. secs (0.u,0.s)
Chars 300 - 312 [exact~Empty.] 0. secs (0.u,0.s)
Chars 317 - 335 [exact~(b1~$->~b2).] 0. secs (0.u,0.s)
Chars 336 - 344 [Defined.] 0.001 secs (0.001u,0.s)
Chars 346 - 427 [#[global]~Instance~is01cat_sum...] 0.001 secs (0.u,0.001s)
Chars 428 - 434 [Proof.] 0. secs (0.u,0.s)
Chars 37 - 65 [Require~Import~Pointed.Core.] 1.904 secs (1.797u,0.102s)
Chars 66 - 99 [Require~Import~Pointed.pHomotopy.] 0.019 secs (0.019u,0.s)
Chars 100 - 123 [Require~Import~WildCat.] 0.011 secs (0.009u,0.001s)
Chars 125 - 156 [#[local]Open~Scope~pointed_scope.] 0. secs (0.u,0.s)
Chars 355 - 525 [Definition~pmap_from_point~{A~...] 0.001 secs (0.001u,0.s)
Chars 619 - 779 [Definition~pmap_from_pointed~{...] 0.002 secs (0.001u,0.s)
Chars 827 - 987 [Definition~pforall_from_pointe...] 0.002 secs (0.002u,0.s)
Chars 1037 - 1123 [Lemma~precompose_pconst~{A~B~C...] 0.001 secs (0.001u,0.s)
Chars 1124 - 1130 [Proof.] 0. secs (0.u,0.s)
Chars 134 - 168 [Require~Import~Category.Morphi...] 1.946 secs (1.74u,0.192s)
Chars 169 - 248 [Require~Import~Functor.Composi...] 0. secs (0.u,0.s)
Chars 249 - 324 [Require~Import~Adjoint.Core~Ad...] 0.024 secs (0.023u,0.001s)
Chars 325 - 363 [Require~Import~Functor.Pointwi...] 0.088 secs (0.086u,0.001s)
Chars 364 - 404 [Require~NaturalTransformation....] 0.002 secs (0.002u,0.s)
Chars 405 - 442 [Require~Functor.Pointwise.Prop...] 0.012 secs (0.012u,0.s)
Chars 443 - 503 [Require~Import~Category.Morphi...] 0.019 secs (0.019u,0.s)
Chars 504 - 540 [Require~Import~FunctorCategory...] 0. secs (0.u,0.s)
Chars 541 - 580 [Require~NaturalTransformation....] 0. secs (0.u,0.s)
Chars 581 - 628 [Require~NaturalTransformation....] 0. secs (0.u,0.s)
Chars 629 - 706 [Import~NaturalTransformation.I...] 0. secs (0.u,0.s)
Chars 707 - 764 [Require~Import~NaturalTransfor...] 0. secs (0.u,0.s)
Chars 765 - 845 [Require~Import~Basics.PathGrou...] 0.007 secs (0.005u,0.001s)
Chars 847 - 873 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 874 - 897 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 898 - 926 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 927 - 951 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 953 - 985 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 986 - 1017 [#[local]Open~Scope~functor_scope.] 0. secs (0.u,0.s)
Chars 1018 - 1064 [#[local]Open~Scope~natural_tra...] 0. secs (0.u,0.s)
Chars 1066 - 1091 [Section~AdjointPointwise.] 0. secs (0.u,0.s)
Chars 1094 - 1112 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 1116 - 1144 [Variables~(C~D~:~PreCategory).] 0. secs (0.u,0.s)
Chars 1188 - 1198 [Section~l.] 0. secs (0.u,0.s)
Chars 1203 - 1228 [Variable~(E~:~PreCategory).] 0. secs (0.u,0.s)
Chars 1234 - 1259 [Variable~(F~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 1264 - 1289 [Variable~(G~:~Functor~D~C).] 0. secs (0.u,0.s)
Chars 1295 - 1315 [Variable~(A~:~F~-|~G).] 0. secs (0.u,0.s)
Chars 1321 - 1473 [Definition~unit_l~:~~~NaturalT...] 0.002 secs (0.002u,0.s)
Chars 1478 - 1484 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.327 secs (0.233u,0.093s)
Chars 23 - 52 [Require~Import~Cubical.DPath.] 1.631 secs (1.51u,0.117s)
Chars 53 - 87 [Require~Import~Cubical.PathSqu...] 0.087 secs (0.084u,0.002s)
Chars 88 - 123 [Require~Import~Cubical.DPathSq...] 0.038 secs (0.037u,0.001s)
Chars 124 - 156 [Require~Import~Cubical.PathCube.] 1.611 secs (1.503u,0.104s)
Chars 158 - 184 [Declare~Scope~dcube_scope.] 0. secs (0.u,0.s)
Chars 185 - 222 [Delimit~Scope~dcube_scope~with...] 0. secs (0.u,0.s)
Chars 293 - 1826 [Definition~DPathCube~{A}~(B~:~...] 0.02 secs (0.02u,0.s)
Chars 1827 - 1833 [Proof.] 0. secs (0.u,0.s)
Chars 1836 - 1850 [(destruct~cube).] 0.174 secs (0.015u,0.027s)
Chars 1853 - 1906 [exact~(PathCube~bs0ii~bs1ii~bs...] 0.003 secs (0.002u,0.s)
Chars 1836 - 1850 [(destruct~cube).] 0.024 secs (0.012u,0.011s)
Chars 1853 - 1906 [exact~(PathCube~bs0ii~bs1ii~bs...] 0. secs (0.u,0.s)
Chars 1907 - 1915 [Defined.] 0.008 secs (0.008u,0.s)
Chars 1917 - 3786 [Definition~equiv_dc_const'~{A~...] 0.671 secs (0.613u,0.057s)
Chars 3787 - 3793 [Proof.] 0. secs (0.u,0.s)
Chars 1491 - 1534 [(pose~proof~(A~:~AdjunctionUni...] 7.055 secs (4.449u,0.274s)
Chars 1133 - 1157 [srapply~Build_pHomotopy.] 10.419 secs (0.001u,0.023s)
Chars 1160 - 1185 [1:~(intro;~apply~point_eq).] 0.002 secs (0.002u,0.s)
Chars 1188 - 1223 [exact~(concat_p1~_~@~concat_1p...] 0.003 secs (0.003u,0.s)
Chars 1133 - 1157 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 1160 - 1185 [1:~(intro;~apply~point_eq).] 0. secs (0.u,0.s)
Chars 1188 - 1223 [exact~(concat_p1~_~@~concat_1p...] 0. secs (0.u,0.s)
Chars 1224 - 1232 [Defined.] 0.005 secs (0.003u,0.001s)
Chars 1283 - 1370 [Lemma~postcompose_pconst~{A~B~...] 0.001 secs (0.001u,0.s)
Chars 1371 - 1377 [Proof.] 0. secs (0.u,0.s)
Chars 3796 - 3813 [by~destruct~cube.] 6.478 secs (0.037u,0.027s)
Chars 3796 - 3813 [by~destruct~cube.] 0.003 secs (0.003u,0.s)
Chars 3814 - 3822 [Defined.] 0.013 secs (0.012u,0.s)
Chars 3824 - 3862 [Notation~dc_const'~:=~equiv_dc...] 0. secs (0.u,0.s)
Chars 3864 - 5313 [Definition~equiv_dc_const~{A~B...] 0.325 secs (0.282u,0.042s)
Chars 5314 - 5320 [Proof.] 0. secs (0.u,0.s)
Chars 5323 - 5340 [by~destruct~cube.] 0.161 secs (0.03u,0.025s)
Chars 5323 - 5340 [by~destruct~cube.] 0.003 secs (0.003u,0.s)
Chars 5341 - 5349 [Defined.] 0.01 secs (0.009u,0.001s)
Chars 5351 - 5387 [Notation~dc_const~:=~equiv_dc_...] 0. secs (0.u,0.s)
Chars 5419 - 5431 [Section~Kan.] 0. secs (0.u,0.s)
Chars 5434 - 6523 [Context~{A}~{x000~x010~x100~x1...] 0.018 secs (0.013u,0.004s)
Chars 6527 - 6903 [Definition~dc_fill_left~(t1ii~...] 0.017 secs (0.016u,0.s)
Chars 6906 - 6912 [Proof.] 0. secs (0.u,0.s)
Chars 464 - 860 [(refine~~~(@Build_PreCategory~...] 40.108 secs (0.013u,0.022s)
Chars 464 - 860 [(refine~~~(@Build_PreCategory~...] 0.001 secs (0.001u,0.s)
Chars 863 - 871 [Defined.] 0.001 secs (0.u,0.s)
Chars 872 - 879 [End~pi.] 0.003 secs (0.003u,0.s)
Chars 881 - 967 [#[local]~Notation~"'forall'~~x...] 0. secs (0.u,0.s)
Chars 968 - 1067 [#[local]~Notation~"'forall'~~x...] 0. secs (0.u,0.s)
Chars 1122 - 1258 [#[global]~Instance~isstrict_ca...] 0.001 secs (0.u,0.s)
Chars 1259 - 1265 [Proof.] 0. secs (0.u,0.s)
Chars 1268 - 1286 [typeclasses~eauto.] 0.054 secs (0.002u,0.015s)
Chars 1268 - 1286 [typeclasses~eauto.] 0. secs (0.u,0.s)
Chars 1287 - 1291 [Qed.] 0.002 secs (0.002u,0.s)
Chars 1293 - 1342 [#[local]Set~Warnings~Append~"-...] 0. secs (0.u,0.s)
Chars 1343 - 1377 [Module~Export~CategoryPiNotati...] 0. secs (0.u,0.s)
Chars 1380 - 1465 [Notation~"'forall'~~x~..~y~,~P...] 0. secs (0.u,0.s)
Chars 1468 - 1561 [Notation~"'forall'~~x~..~y~,~P...] 0. secs (0.u,0.s)
Chars 1562 - 1586 [End~CategoryPiNotations.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.344 secs (0.268u,0.075s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 23 - 44 [Require~Import~Types.] 1.629 secs (1.494u,0.13s)
Chars 45 - 77 [Require~Import~Diagrams.Diagram.] 0.123 secs (0.121u,0.002s)
Chars 78 - 108 [Require~Import~Diagrams.Graph.] 0. secs (0.u,0.s)
Chars 109 - 140 [Require~Import~Diagrams.Cocone.] 0.083 secs (0.08u,0.002s)
Chars 141 - 174 [Require~Import~Diagrams.DDiagram.] 0.003 secs (0.003u,0.s)
Chars 175 - 207 [Require~Import~Colimits.Colimit.] 0.946 secs (0.86u,0.084s)
Chars 209 - 237 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 625 - 644 [Section~Flattening.] 0. secs (0.u,0.s)
Chars 681 - 773 [Context~`{Univalence}~{G~:~Gra...] 0.001 secs (0.u,0.s)
Chars 777 - 895 [Let~E_f~{i~j~:~G}~(g~:~G~i~j)~...] 0.004 secs (0.004u,0.s)
Chars 1048 - 1082 [Definition~E'~:~Colimit~D~->~T...] 0. secs (0.u,0.s)
Chars 1085 - 1091 [Proof.] 0. secs (0.u,0.s)
Chars 68 - 119 [Require~Import~HoTT.Basics~HoT...] 3.649 secs (3.336u,0.305s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 1442 - 1819 [(refine~~~(@Build_PreCategory~...] 40.104 secs (0.016u,0.018s)
Chars 1442 - 1819 [(refine~~~(@Build_PreCategory~...] 0.003 secs (0.003u,0.s)
Chars 1820 - 1828 [Defined.] 0.002 secs (0.001u,0.s)
Chars 1830 - 1864 [Arguments~groupoid_category~X~...] 0. secs (0.u,0.s)
Chars 1866 - 1963 [#[global]~Instance~isgroupoid_...] 0. secs (0.u,0.s)
Chars 1965 - 1971 [Proof.] 0. secs (0.u,0.s)
Chars 120 - 146 [Require~Import~Extensions.] 3.214 secs (3.059u,0.147s)
Chars 0 - 28 [Require~Import~Basics~Types.] 1.897 secs (1.707u,0.183s)
Chars 147 - 182 [Require~Import~Modality~Access...] 1.988 secs (1.902u,0.052s)
Chars 183 - 211 [Require~Export~Localization.] 0.26 secs (0.233u,0.026s)
Chars 270 - 305 [Require~Import~Homotopy.Suspen...] 0.421 secs (0.403u,0.017s)
Chars 307 - 335 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 29 - 52 [Require~Import~Cubical.] 1.862 secs (1.741u,0.114s)
Chars 735 - 1093 [Definition~extendable_over_uni...] 0.051 secs (0.047u,0.003s)
Chars 1094 - 1100 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 931 - 956 [srapply~Build_DiagramMap.] 40.112 secs (0.u,0.027s)
Chars 961 - 962 [{] 0. secs (0.u,0.s)
Chars 963 - 974 [(intros~i~x).] 0. secs (0.u,0.s)
Chars 981 - 990 [exists~y.] 0. secs (0.u,0.s)
Chars 997 - 1005 [exact~x.] 0. secs (0.u,0.s)
Chars 1006 - 1007 [}] 0. secs (0.u,0.s)
Chars 1012 - 1024 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 931 - 956 [srapply~Build_DiagramMap.] 0. secs (0.u,0.s)
Chars 963 - 974 [(intros~i~x).] 0. secs (0.u,0.s)
Chars 981 - 990 [exists~y.] 0. secs (0.u,0.s)
Chars 997 - 1005 [exact~x.] 0. secs (0.u,0.s)
Chars 1012 - 1024 [reflexivity.] 0. secs (0.u,0.s)
Chars 1027 - 1035 [Defined.] 0. secs (0.u,0.s)
Chars 1039 - 1063 [Context~{Q~:~Y~->~Type}.] 0. secs (0.u,0.s)
Chars 1111 - 1205 [Definition~sigma_cocone~(C~:~f...] 0. secs (0.u,0.s)
Chars 1208 - 1214 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 38 [Require~Import~HoTT.Basics~HoT...] 1.862 secs (1.674u,0.185s)
Chars 1974 - 1999 [(intros~s~d~m;~simpl~in~*).] 8.578 secs (0.001u,0.016s)
Chars 2002 - 2149 [exact~~(Build_IsIsomorphism~(g...] 0.004 secs (0.004u,0.s)
Chars 1974 - 1999 [(intros~s~d~m;~simpl~in~*).] 0. secs (0.u,0.s)
Chars 2002 - 2149 [exact~~(Build_IsIsomorphism~(g...] 0. secs (0.u,0.s)
Chars 2150 - 2158 [Defined.] 0.002 secs (0.002u,0.s)
Chars 2220 - 2308 [Lemma~isstrict_groupoid_catego...] 0.001 secs (0.001u,0.s)
Chars 2309 - 2315 [Proof.] 0. secs (0.u,0.s)
Chars 2318 - 2336 [typeclasses~eauto.] 0.052 secs (0.001u,0.016s)
Chars 2318 - 2336 [typeclasses~eauto.] 0. secs (0.u,0.s)
Chars 2337 - 2345 [Defined.] 0.001 secs (0.001u,0.s)
Chars 53 - 82 [Require~Import~Spaces.Circle.] 6.412 secs (6.157u,0.235s)
Chars 186 - 215 [Notation~hr~:=~(sq_refl_h~_).] 0. secs (0.u,0.s)
Chars 216 - 245 [Notation~vr~:=~(sq_refl_v~_).] 0. secs (0.u,0.s)
Chars 247 - 267 [Module~Export~Torus.] 0. secs (0.u,0.s)
Chars 271 - 310 [#[private(matching)]Inductive~...] 0. secs (0.u,0.s)
Chars 314 - 343 [Axiom~(loop_a~:~tbase~=~tbase).] 0. secs (0.u,0.s)
Chars 346 - 375 [Axiom~(loop_b~:~tbase~=~tbase).] 0. secs (0.u,0.s)
Chars 378 - 430 [Axiom~(surf~:~PathSquare~loop_...] 0. secs (0.u,0.s)
Chars 486 - 668 [Definition~Torus_ind~(P~:~Toru...] 0.001 secs (0.001u,0.s)
Chars 671 - 677 [Proof.] 0. secs (0.u,0.s)
Chars 437 - 459 [srapply~Build_Is01Cat.] 40.09 secs (0.u,0.013s)
Chars 462 - 463 [-] 0. secs (0.u,0.s)
Chars 464 - 494 [(intros~[a|~b];~cbn;~apply~Id).] 0.003 secs (0.003u,0.s)
Chars 497 - 498 [-] 0. secs (0.u,0.s)
Chars 499 - 578 [(intros~[a|~b]~[a1|~b1]~[a2|~b...] 0.017 secs (0.014u,0.002s)
Chars 437 - 459 [srapply~Build_Is01Cat.] 0. secs (0.u,0.s)
Chars 464 - 494 [(intros~[a|~b];~cbn;~apply~Id).] 0.001 secs (0.001u,0.s)
Chars 499 - 578 [(intros~[a|~b]~[a1|~b1]~[a2|~b...] 0.004 secs (0.003u,0.s)
Chars 579 - 587 [Defined.] 0.005 secs (0.005u,0.s)
Chars 589 - 669 [#[global]~Instance~is2graph_su...] 0.001 secs (0.001u,0.s)
Chars 670 - 676 [Proof.] 0. secs (0.u,0.s)
Chars 1491 - 1534 [(pose~proof~(A~:~AdjunctionUni...] 40.044 secs (0.003u,0.021s)
Chars 1541 - 1660 [refine~~(_~~~o~(((idtoiso~(C:=...] 0.085 secs (0.073u,0.012s)
Chars 1667 - 1766 [refine~~(_~~~o~NaturalTransfor...] 0.003 secs (0.003u,0.s)
Chars 1773 - 2035 [refine~~((idtoiso~(C:=_~->~_)~...] 0.007 secs (0.006u,0.s)
Chars 2042 - 2099 [refine~(NaturalTransformation....] 0.002 secs (0.001u,0.s)
Chars 2106 - 2194 [exact~~(NaturalTransformation....] 0.001 secs (0.u,0.001s)
Chars 1491 - 1534 [(pose~proof~(A~:~AdjunctionUni...] 0. secs (0.u,0.s)
Chars 1541 - 1660 [refine~~(_~~~o~(((idtoiso~(C:=...] 0. secs (0.u,0.s)
Chars 1667 - 1766 [refine~~(_~~~o~NaturalTransfor...] 0. secs (0.u,0.s)
Chars 1773 - 2035 [refine~~((idtoiso~(C:=_~->~_)~...] 0. secs (0.u,0.s)
Chars 2042 - 2099 [refine~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 2106 - 2194 [exact~~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 2199 - 2207 [Defined.] 0.004 secs (0.002u,0.001s)
Chars 2213 - 2363 [Definition~counit_l~:~~~Natura...] 0.002 secs (0.002u,0.s)
Chars 2368 - 2374 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 679 - 711 [(intros~x~y;~apply~Build_IsGra...] 2.472 secs (0.002u,0.012s)
Chars 714 - 791 [(destruct~x~as~[a1|~b1],~y~as~...] 0.01 secs (0.006u,0.003s)
Chars 679 - 711 [(intros~x~y;~apply~Build_IsGra...] 0. secs (0.u,0.s)
Chars 714 - 791 [(destruct~x~as~[a1|~b1],~y~as~...] 0.002 secs (0.001u,0.s)
Chars 792 - 800 [Defined.] 0.002 secs (0.002u,0.s)
Chars 858 - 935 [#[global]Instance~is1cat_sum~~...] 0.005 secs (0.004u,0.001s)
Chars 936 - 942 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 93 [Require~Import~HoTT.Types.Univ...] 0.965 secs (0.804u,0.159s)
Chars 43 - 81 [Require~Import~HoTT.Basics~HoT...] 1.917 secs (1.731u,0.183s)
Chars 45 - 83 [Require~Import~HoTT.Basics~HoT...] 1.952 secs (1.756u,0.189s)
Chars 39 - 103 [Require~Import~HSet~HFiber~Fac...] 7.875 secs (7.462u,0.374s)
Chars 104 - 178 [Require~Import~Pointed.Core~Po...] 0.355 secs (0.334u,0.02s)
Chars 179 - 202 [Require~Import~WildCat.] 0.01 secs (0.009u,0.001s)
Chars 204 - 235 [#[local]Open~Scope~pointed_scope.] 0. secs (0.u,0.s)
Chars 236 - 264 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 325 - 392 [#[global]Instance~ispointed_lo...] 0. secs (0.u,0.s)
Chars 394 - 470 [Definition~loops~(A~:~pType)~:...] 0.001 secs (0.001u,0.s)
Chars 472 - 612 [Fixpoint~iterated_loops~(n~:~n...] 0. secs (0.u,0.s)
Chars 655 - 760 [Lemma~unfold_iterated_loops~(n...] 0. secs (0.u,0.s)
Chars 761 - 767 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
     = 89
     : nat
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 84 - 126 [Require~Import~HProp~TruncType...] 3.697 secs (3.497u,0.191s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 94 - 152 [Require~Export~HoTT.Classes.in...] 6.971 secs (6.632u,0.314s)
Chars 153 - 194 [Require~Import~HoTT.Classes.th...] 0.167 secs (0.16u,0.007s)
Chars 197 - 214 [Module~SemiRings.] 0. secs (0.u,0.s)
Chars 216 - 304 [Class~Operations~:=~~~~~operat...] 0.002 secs (0.001u,0.001s)
Chars 306 - 434 [Definition~BuildOperations~(T~...] 0.003 secs (0.003u,0.s)
Chars 436 - 487 [Coercion~SR_carrier~(s~:~Opera...] 0. secs (0.u,0.s)
Chars 488 - 561 [#[global]~Instance~SR_plus~~(s...] 0.001 secs (0.001u,0.s)
Chars 562 - 635 [#[global]~Instance~SR_mult~~(s...] 0.001 secs (0.001u,0.s)
Chars 636 - 703 [#[global]Instance~SR_zero~~(s~...] 0.001 secs (0.001u,0.s)
Chars 704 - 763 [#[global]Instance~SR_one~~(s~:...] 0. secs (0.u,0.s)
Chars 765 - 792 [Arguments~SR_plus~!_~/~_~_.] 0. secs (0.u,0.s)
Chars 793 - 820 [Arguments~SR_mult~!_~/~_~_.] 0. secs (0.u,0.s)
Chars 821 - 844 [Arguments~SR_zero~!_~/.] 0. secs (0.u,0.s)
Chars 845 - 867 [Arguments~SR_one~!_~/.] 0. secs (0.u,0.s)
Chars 870 - 887 [Section~contents.] 0. secs (0.u,0.s)
Chars 888 - 901 [Universe~U,V.] 0. secs (0.u,0.s)
Chars 902 - 934 [Context~`{Funext}~`{Univalence}.] 0. secs (0.u,0.s)
Chars 935 - 968 [Context~(A~B~:~Operations@{U~V}).] 0. secs (0.u,0.s)
Chars 970 - 1032 [Context~(f~:~A~->~B)~`{!IsEqui...] 0.002 secs (0.002u,0.s)
Chars 1034 - 1067 [Lemma~iso_same_semirings~:~A~=~B.] 0. secs (0.u,0.s)
Chars 1068 - 1074 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 1380 - 1404 [srapply~Build_pHomotopy.] 40.116 secs (0.001u,0.023s)
Chars 1407 - 1422 [1:~reflexivity.] 0.002 secs (0.002u,0.s)
Chars 1425 - 1475 [exact~((concat_p1~_~@~concat_p...] 0.004 secs (0.004u,0.s)
Chars 1380 - 1404 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 1407 - 1422 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 1425 - 1475 [exact~((concat_p1~_~@~concat_p...] 0. secs (0.u,0.s)
Chars 1476 - 1484 [Defined.] 0.008 secs (0.008u,0.s)
Chars 1486 - 1578 [Lemma~pconst_factor~{A~B~:~pTy...] 0.001 secs (0.001u,0.s)
Chars 1579 - 1585 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 87 [Require~Import~HoTT.Classes.in...] 10.011 secs (9.423u,0.579s)
Chars 89 - 125 [Generalizable~Variables~A~B~C~...] 0. secs (0.u,0.s)
Chars 127 - 204 [#[global]~Instance~bounded_sl_...] 0. secs (0.u,0.s)
Chars 205 - 211 [Proof.] 0. secs (0.u,0.s)
Chars 1219 - 1259 [(srapply~Build_Cocone;~simpl;~...] 15.876 secs (12.107u,0.331s)
Chars 82 - 133 [Require~Import~Modalities.Moda...] 8.308 secs (7.922u,0.372s)
Chars 135 - 163 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 1086 - 1609 [Record~CoreflectiveSubuniverse...] 0.006 secs (0.005u,0.s)
Chars 1611 - 1673 [Coercion~F_coreflector~:~Coref...] 0. secs (0.u,0.s)
Chars 1675 - 1707 [Section~CoreflectiveSubuniverse.] 0. secs (0.u,0.s)
Chars 1710 - 1732 [Context~`{Univalence}.] 0. secs (0.u,0.s)
Chars 1735 - 1773 [Context~{F~:~CoreflectiveSubun...] 0. secs (0.u,0.s)
Chars 1871 - 1931 [Definition~F_corec~{Y}~{X}~`(i...] 0. secs (0.u,0.s)
Chars 1934 - 1940 [Proof.] 0. secs (0.u,0.s)
Chars 127 - 192 [Require~Import~Modality~Access...] 4.924 secs (4.728u,0.184s)
Chars 193 - 239 [Require~Import~Colimits.Pushou...] 0.141 secs (0.14u,0.001s)
Chars 241 - 268 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 269 - 297 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 379 - 404 [Section~ClosedModalTypes.] 0. secs (0.u,0.s)
Chars 407 - 427 [Context~(U~:~HProp).] 0. secs (0.u,0.s)
Chars 431 - 538 [Definition~equiv_inO_closed~(A...] 0.001 secs (0.u,0.s)
Chars 541 - 547 [Proof.] 0. secs (0.u,0.s)
Chars 43 - 81 [Require~Import~HoTT.Basics~HoT...] 1.889 secs (1.687u,0.202s)
Chars 6917 - 6928 [(destruct~c).] 40.148 secs (0.027u,0.028s)
Chars 6933 - 6952 [(apply~cu_fill_left).] 0.006 secs (0.003u,0.003s)
Chars 6917 - 6928 [(destruct~c).] 0.002 secs (0.002u,0.s)
Chars 6933 - 6952 [(apply~cu_fill_left).] 0.001 secs (0.001u,0.s)
Chars 6955 - 6963 [Defined.] 0.006 secs (0.004u,0.001s)
Chars 6967 - 7344 [Definition~dc_fill_right~(t0ii...] 0.016 secs (0.013u,0.002s)
Chars 7347 - 7353 [Proof.] 0. secs (0.u,0.s)
Chars 116 - 167 [Require~Export~HoTT.Classes.th...] 10.193 secs (9.58u,0.6s)
Chars 169 - 239 [Require~Import~HoTT.Basics~HoT...] 0.018 secs (0.017u,0.s)
Chars 349 - 588 [Record~Isomorphic~{σ~:~Signatu...] 0.035 secs (0.028u,0.007s)
Chars 590 - 709 [Arguments~BuildIsomorphic~{σ~A...] 0. secs (0.u,0.s)
Chars 711 - 745 [Arguments~def_isomorphic~{σ~A~B}.] 0. secs (0.u,0.s)
Chars 746 - 792 [Arguments~is_homomorphism_isom...] 0. secs (0.u,0.s)
Chars 793 - 838 [Arguments~is_isomorphism_isomo...] 0. secs (0.u,0.s)
Chars 840 - 892 [#[global]Existing~Instance~is_...] 0. secs (0.u,0.s)
Chars 893 - 944 [#[global]Existing~Instance~is_...] 0. secs (0.u,0.s)
Chars 946 - 974 [Module~isomorphic_notations.] 0. secs (0.u,0.s)
Chars 977 - 1039 [#[global]Notation~"A~≅~B"~:=~(...] 0. secs (0.u,0.s)
Chars 1040 - 1065 [End~isomorphic_notations.] 0. secs (0.u,0.s)
Chars 1067 - 1095 [Import~isomorphic_notations.] 0. secs (0.u,0.s)
Chars 1097 - 1254 [Definition~SigIsomorphic~{σ~:~...] 0.002 secs (0.002u,0.s)
Chars 1256 - 1349 [Lemma~issig_isomorphic~{σ~:~Si...] 0.001 secs (0.001u,0.s)
Chars 1350 - 1356 [Proof.] 0. secs (0.u,0.s)
Chars 1359 - 1365 [issig.] 0.167 secs (0.033u,0.03s)
Chars 1359 - 1365 [issig.] 0. secs (0.u,0.s)
Chars 1366 - 1374 [Defined.] 0.006 secs (0.006u,0.s)
Chars 1443 - 1529 [Corollary~id_isomorphic~`{Univ...] 0. secs (0.u,0.s)
Chars 1530 - 1536 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 53 [Require~Export~HoTT.Classes.in...] 10.503 secs (9.868u,0.624s)
Chars 55 - 277 [Require~Import~HoTT.Basics~HoT...] 0.752 secs (0.738u,0.012s)
Chars 279 - 322 [Import~algebra_notations~ne_li...] 0. secs (0.u,0.s)
Chars 324 - 349 [Section~quotient_algebra.] 0. secs (0.u,0.s)
Chars 352 - 463 [Context~`{Funext}~{σ~:~Signatu...] 0.001 secs (0.001u,0.s)
Chars 557 - 637 [Definition~carriers_quotient_a...] 0.007 secs (0.007u,0.s)
Chars 1003 - 1609 [Fixpoint~quotient_ind_prop_fam...] 0.04 secs (0.04u,0.s)
Chars 2023 - 2321 [Definition~ComputeOpQuotient~{...] 0.003 secs (0.003u,0.s)
Chars 2325 - 2506 [#[local]~Notation~QuotOp~w:=~~...] 0. secs (0.u,0.s)
Chars 2510 - 2616 [#[local]~Notation~op_qalg_cons...] 0. secs (0.u,0.s)
Chars 2620 - 2872 [Lemma~op_quotient_algebra_well...] 0.005 secs (0.005u,0.s)
Chars 2875 - 2881 [Proof.] 0. secs (0.u,0.s)
Chars 254 - 300 [Require~Export~HoTT.Algebra.Un...] 11.111 secs (10.494u,0.585s)
Chars 302 - 424 [Require~Import~HoTT.Basics~HoT...] 0.024 secs (0.023u,0.001s)
Chars 426 - 457 [#[local]Open~Scope~Algebra_scope.] 0. secs (0.u,0.s)
Chars 458 - 485 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 627 - 912 [#[universes(polymorphic=no)]~D...] 0.004 secs (0.003u,0.001s)
Chars 914 - 1082 [#[universes(polymorphic=no)]~D...] 0.002 secs (0.001u,0.s)
Chars 1210 - 1488 [#[universes(polymorphic=no)]~D...] 0.002 secs (0.002u,0.s)
Chars 1490 - 1668 [#[universes(polymorphic=no)]~D...] 0.001 secs (0.001u,0.s)
Chars 1794 - 2221 [#[universes(polymorphic=no)]~D...] 0.012 secs (0.012u,0.s)
Chars 2223 - 2434 [Definition~cons_dom~{σ}~(A~:~C...] 0.002 secs (0.002u,0.s)
Chars 2462 - 2585 [Definition~nil_dom~{σ}~(A~:~Ca...] 0.001 secs (0.001u,0.s)
Chars 2652 - 2843 [Definition~FiniteOperation~{σ~...] 0.001 secs (0.001u,0.s)
Chars 2954 - 3198 [Fixpoint~CurriedOperation~{σ}~...] 0.002 secs (0.002u,0.s)
Chars 3479 - 3819 [Fixpoint~operation_uncurry~{σ}...] 0.006 secs (0.006u,0.s)
Chars 3821 - 4146 [#[local]~Example~computation_e...] 0.012 secs (0.012u,0.s)
Chars 4147 - 4153 [Proof.] 0. secs (0.u,0.s)
Chars 4156 - 4168 [reflexivity.] 0.101 secs (0.001u,0.037s)
Chars 4156 - 4168 [reflexivity.] 0. secs (0.u,0.s)
Chars 4169 - 4173 [Qed.] 0.008 secs (0.008u,0.s)
Chars 4452 - 4794 [Fixpoint~operation_curry~{σ}~(...] 0.009 secs (0.007u,0.002s)
Chars 82 - 141 [Require~Import~HoTT.Spaces.No....] 8.347 secs (7.912u,0.424s)
Chars 143 - 171 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 172 - 203 [#[local]Open~Scope~surreal_scope.] 0. secs (0.u,0.s)
Chars 317 - 507 [Class~HasAddition~(S~:~OptionS...] 0.003 secs (0.003u,0.s)
Chars 508 - 547 [#[global]Existing~Instance~emp...] 0. secs (0.u,0.s)
Chars 548 - 585 [#[global]Existing~Instance~sum...] 0. secs (0.u,0.s)
Chars 587 - 720 [#[global]~Instance~hasaddition...] 0. secs (0.u,0.s)
Chars 722 - 869 [#[global]~Instance~hasaddition...] 0. secs (0.u,0.s)
Chars 871 - 929 [#[global]Instance~hasaddition_...] 0. secs (0.u,0.s)
Chars 930 - 936 [Proof.] 0. secs (0.u,0.s)
Chars 4796 - 5142 [#[local]~Example~computation_e...] 0.016 secs (0.014u,0.001s)
Chars 5143 - 5149 [Proof.] 0. secs (0.u,0.s)
Chars 5152 - 5164 [reflexivity.] 0.929 secs (0.001u,0.038s)
Chars 5152 - 5164 [reflexivity.] 0. secs (0.u,0.s)
Chars 5165 - 5169 [Qed.] 0.007 secs (0.006u,0.s)
Chars 5171 - 5398 [Lemma~expand_cons_dom'~{σ}~(A~...] 0.002 secs (0.002u,0.s)
Chars 5399 - 5405 [Proof.] 0. secs (0.u,0.s)
Chars 1096 - 1114 [(apply~Colimit_rec).] 40.112 secs (0.001u,0.023s)
Chars 1115 - 1148 [simple~refine~(Build_Cocone~_~_).] 0.002 secs (0.002u,0.s)
Chars 1153 - 1154 [-] 0. secs (0.u,0.s)
Chars 1155 - 1183 [exact~(fun~i~x~=>~E~(i;~x)).] 0.002 secs (0.002u,0.s)
Chars 1188 - 1189 [-] 0. secs (0.u,0.s)
Chars 1190 - 1210 [(intros~i~j~g~x;~cbn).] 0.003 secs (0.003u,0.s)
Chars 1217 - 1226 [symmetry.] 0.003 secs (0.002u,0.s)
Chars 1233 - 1267 [srapply~(path_universe~(E_f~_~...] 0.013 secs (0.011u,0.001s)
Chars 1096 - 1114 [(apply~Colimit_rec).] 0.001 secs (0.001u,0.s)
Chars 1115 - 1148 [simple~refine~(Build_Cocone~_~_).] 0.001 secs (0.001u,0.s)
Chars 1155 - 1183 [exact~(fun~i~x~=>~E~(i;~x)).] 0.001 secs (0.001u,0.s)
Chars 1190 - 1210 [(intros~i~j~g~x;~cbn).] 0.002 secs (0.002u,0.s)
Chars 1217 - 1226 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 1233 - 1267 [srapply~(path_universe~(E_f~_~...] 0.001 secs (0.001u,0.s)
Chars 1270 - 1278 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1309 - 1433 [Definition~transport_E'~{i~j~:...] 0.003 secs (0.002u,0.s)
Chars 1436 - 1442 [Proof.] 0. secs (0.u,0.s)
Chars 1103 - 1196 [(generalize~dependent~C;~simpl...] 40.165 secs (0.006u,0.035s)
Chars 1199 - 1200 [-] 0. secs (0.u,0.s)
Chars 1201 - 1213 [(intros~g~g').] 0.001 secs (0.u,0.s)
Chars 1218 - 1335 [(exists~(fst~(ext'~(fst~ext~g)...] 0.01 secs (0.01u,0.s)
Chars 1340 - 1364 [(apply~moveR_transport_p).] 0.003 secs (0.003u,0.s)
Chars 1369 - 1463 [exact~((fst~(ext'~(fst~ext~g)....] 0.006 secs (0.005u,0.001s)
Chars 1466 - 1467 [-] 0. secs (0.u,0.s)
Chars 1468 - 1485 [(intros~h~k~h'~k').] 0.001 secs (0.001u,0.s)
Chars 1490 - 1509 [(apply~IH;~intros~g).] 0.003 secs (0.003u,0.s)
Chars 1514 - 1560 [exact~(snd~(ext'~k)~(fun~u~=>~...] 0.003 secs (0.003u,0.s)
Chars 1103 - 1196 [(generalize~dependent~C;~simpl...] 0.003 secs (0.003u,0.s)
Chars 1201 - 1213 [(intros~g~g').] 0.001 secs (0.001u,0.s)
Chars 1218 - 1335 [(exists~(fst~(ext'~(fst~ext~g)...] 0.004 secs (0.003u,0.s)
Chars 1340 - 1364 [(apply~moveR_transport_p).] 0.001 secs (0.u,0.s)
Chars 1369 - 1463 [exact~((fst~(ext'~(fst~ext~g)....] 0.001 secs (0.001u,0.s)
Chars 1468 - 1485 [(intros~h~k~h'~k').] 0.001 secs (0.001u,0.s)
Chars 1490 - 1509 [(apply~IH;~intros~g).] 0.002 secs (0.002u,0.s)
Chars 1514 - 1560 [exact~(snd~(ext'~k)~(fun~u~=>~...] 0.001 secs (0.u,0.s)
Chars 1561 - 1569 [Defined.] 0.008 secs (0.005u,0.002s)
Chars 1571 - 1988 [Definition~ooextendable_over_u...] 0.002 secs (0.002u,0.s)
Chars 1990 - 2063 [#[local]Hint~Extern~4~~=>~(pro...] 0. secs (0.u,0.s)
Chars 2065 - 2126 [Definition~Nul@{a~i}~(S~:~Null...] 0. secs (0.u,0.s)
Chars 2127 - 2133 [Proof.] 0. secs (0.u,0.s)
Chars 1219 - 1259 [(srapply~Build_Cocone;~simpl;~...] 40.05 secs (0.004u,0.021s)
Chars 1264 - 1299 [1:~exact~(x.1;~legs~(C~x.1)~i~...] 0.001 secs (0.001u,0.s)
Chars 1304 - 1323 [(simpl;~intros~g~x').] 0.002 secs (0.002u,0.s)
Chars 1328 - 1348 [srapply~path_sigma'.] 0.004 secs (0.003u,0.s)
Chars 1353 - 1368 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 1373 - 1389 [(apply~legs_comm).] 0.001 secs (0.001u,0.s)
Chars 1219 - 1259 [(srapply~Build_Cocone;~simpl;~...] 0.002 secs (0.001u,0.s)
Chars 1264 - 1299 [1:~exact~(x.1;~legs~(C~x.1)~i~...] 0. secs (0.u,0.s)
Chars 1304 - 1323 [(simpl;~intros~g~x').] 0.001 secs (0.001u,0.s)
Chars 1328 - 1348 [srapply~path_sigma'.] 0. secs (0.u,0.s)
Chars 1353 - 1368 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 1373 - 1389 [(apply~legs_comm).] 0. secs (0.u,0.s)
Chars 1392 - 1400 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1483 - 1580 [Lemma~iscolimit_sigma~(HQ~:~fo...] 0.001 secs (0.001u,0.s)
Chars 1583 - 1589 [Proof.] 0. secs (0.u,0.s)
Chars 682 - 696 [by~destruct~x.] 40.161 secs (0.u,0.029s)
Chars 682 - 696 [by~destruct~x.] 0. secs (0.u,0.s)
Chars 699 - 707 [Defined.] 0. secs (0.u,0.s)
Chars 785 - 1055 [Axiom~~~(Torus_ind_beta_loop_a...] 0.007 secs (0.007u,0.s)
Chars 1059 - 1329 [Axiom~~~(Torus_ind_beta_loop_b...] 0.006 secs (0.005u,0.001s)
Chars 1554 - 1963 [Axiom~~~(Torus_ind_beta_surf~:...] 0.014 secs (0.012u,0.001s)
Chars 1965 - 1975 [End~Torus.] 0. secs (0.u,0.s)
Chars 2054 - 2228 [Definition~Torus_rec~(P~:~Type...] 0.006 secs (0.006u,0.s)
Chars 2296 - 2463 [Lemma~Torus_rec_beta_loop_a~(P...] 0.001 secs (0.001u,0.s)
Chars 2464 - 2470 [Proof.] 0. secs (0.u,0.s)
Chars 2381 - 2426 [(pose~proof~(A~:~AdjunctionCou...] 40.106 secs (0.u,0.022s)
Chars 2433 - 2549 [refine~~(((idtoiso~(C:=_~->~_)...] 0.006 secs (0.005u,0.001s)
Chars 2556 - 2655 [refine~~(NaturalTransformation...] 0.003 secs (0.003u,0.s)
Chars 2662 - 2950 [refine~~(_~~~o~(((idtoiso~(C:=...] 0.009 secs (0.009u,0.s)
Chars 2957 - 3014 [refine~(NaturalTransformation....] 0.002 secs (0.002u,0.s)
Chars 3021 - 3109 [exact~~(NaturalTransformation....] 0.001 secs (0.001u,0.s)
Chars 2381 - 2426 [(pose~proof~(A~:~AdjunctionCou...] 0. secs (0.u,0.s)
Chars 2433 - 2549 [refine~~(((idtoiso~(C:=_~->~_)...] 0. secs (0.u,0.s)
Chars 2556 - 2655 [refine~~(NaturalTransformation...] 0. secs (0.u,0.s)
Chars 2662 - 2950 [refine~~(_~~~o~(((idtoiso~(C:=...] 0. secs (0.u,0.s)
Chars 2957 - 3014 [refine~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 3021 - 3109 [exact~~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 3114 - 3122 [Defined.] 0.004 secs (0.001u,0.002s)
Chars 3128 - 3174 [Create~HintDb~adjoint_pointwis...] 0. secs (0.u,0.s)
Chars 3179 - 3395 [Hint~Rewrite~~identity_of~left...] 0.002 secs (0.002u,0.s)
Chars 3401 - 3479 [Definition~pointwise_l~:~point...] 0.002 secs (0.002u,0.s)
Chars 3484 - 3490 [Proof.] 0. secs (0.u,0.s)
Chars 945 - 966 [srapply~Build_Is1Cat.] 40.204 secs (0.066u,0.059s)
Chars 969 - 970 [-] 0. secs (0.u,0.s)
Chars 971 - 982 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 987 - 1130 [(srapply~Build_Is01Cat;~destru...] 0.087 secs (0.065u,0.021s)
Chars 1133 - 1134 [-] 0. secs (0.u,0.s)
Chars 1135 - 1168 [(intros~x~y;~srapply~Build_Is0...] 0.027 secs (0.026u,0.001s)
Chars 1173 - 1268 [(destruct~x~as~[a1|~b1],~y~as~...] 0.019 secs (0.015u,0.004s)
Chars 1271 - 1272 [-] 0. secs (0.u,0.s)
Chars 1273 - 1314 [(intros~x~y~z~h;~srapply~Build...] 0.006 secs (0.004u,0.001s)
Chars 1319 - 1332 [(intros~f~g~p).] 0.001 secs (0.001u,0.s)
Chars 1337 - 1466 [(destruct~x~as~[a1|~b1],~y~as~...] 0.05 secs (0.048u,0.002s)
Chars 1469 - 1470 [-] 0. secs (0.u,0.s)
Chars 1471 - 1512 [(intros~x~y~z~h;~srapply~Build...] 0.006 secs (0.004u,0.001s)
Chars 1517 - 1530 [(intros~f~g~p).] 0.001 secs (0.001u,0.s)
Chars 1535 - 1664 [(destruct~x~as~[a1|~b1],~y~as~...] 0.055 secs (0.05u,0.005s)
Chars 1667 - 1668 [-] 0. secs (0.u,0.s)
Chars 1669 - 1767 [(intros~[a1|~b1]~[a2|~b2]~[a3|...] 0.42 secs (0.396u,0.023s)
Chars 1770 - 1771 [-] 0. secs (0.u,0.s)
Chars 1772 - 1844 [(intros~[a1|~b1]~[a2|~b2]~f;~t...] 0.112 secs (0.106u,0.005s)
Chars 1847 - 1848 [-] 0. secs (0.u,0.s)
Chars 1849 - 1921 [(intros~[a1|~b1]~[a2|~b2]~f;~t...] 0.125 secs (0.114u,0.01s)
Chars 945 - 966 [srapply~Build_Is1Cat.] 0. secs (0.u,0.s)
Chars 971 - 982 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 987 - 1130 [(srapply~Build_Is01Cat;~destru...] 0.01 secs (0.009u,0.s)
Chars 1135 - 1168 [(intros~x~y;~srapply~Build_Is0...] 0.009 secs (0.009u,0.s)
Chars 1173 - 1268 [(destruct~x~as~[a1|~b1],~y~as~...] 0.005 secs (0.005u,0.s)
Chars 1273 - 1314 [(intros~x~y~z~h;~srapply~Build...] 0.001 secs (0.u,0.s)
Chars 1319 - 1332 [(intros~f~g~p).] 0. secs (0.u,0.s)
Chars 1337 - 1466 [(destruct~x~as~[a1|~b1],~y~as~...] 0.013 secs (0.011u,0.001s)
Chars 1471 - 1512 [(intros~x~y~z~h;~srapply~Build...] 0.001 secs (0.001u,0.s)
Chars 1517 - 1530 [(intros~f~g~p).] 0.001 secs (0.001u,0.s)
Chars 1535 - 1664 [(destruct~x~as~[a1|~b1],~y~as~...] 0.013 secs (0.013u,0.s)
Chars 1669 - 1767 [(intros~[a1|~b1]~[a2|~b2]~[a3|...] 0.057 secs (0.053u,0.003s)
Chars 552 - 558 [split.] 31.15 secs (19.706u,0.438s)
Chars 1772 - 1844 [(intros~[a1|~b1]~[a2|~b2]~f;~t...] 0.021 secs (0.02u,0.001s)
Chars 1849 - 1921 [(intros~[a1|~b1]~[a2|~b2]~f;~t...] 0.021 secs (0.018u,0.002s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 1922 - 1930 [Defined.] 0.366 secs (0.352u,0.012s)
Chars 770 - 782 [(induction~n).] 40.126 secs (0.u,0.026s)
Chars 785 - 800 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 803 - 875 [(change~(iterated_loops~n.+2~X...] 0.001 secs (0.001u,0.s)
Chars 878 - 907 [by~refine~(ap~loops~IHn~@~_).] 0.002 secs (0.002u,0.s)
Chars 770 - 782 [(induction~n).] 0. secs (0.u,0.s)
Chars 785 - 800 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 803 - 875 [(change~(iterated_loops~n.+2~X...] 0. secs (0.u,0.s)
Chars 878 - 907 [by~refine~(ap~loops~IHn~@~_).] 0. secs (0.u,0.s)
Chars 908 - 916 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1131 - 1219 [Definition~istrunc_loops~{n}~(...] 0.003 secs (0.003u,0.s)
Chars 1257 - 1371 [Definition~isconnected_loops~`...] 0.039 secs (0.031u,0.006s)
Chars 1373 - 1423 [Lemma~pequiv_loops_punit~:~loo...] 0. secs (0.u,0.s)
Chars 1424 - 1430 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 51 [Require~Import~HoTT.Basics~HoT...] 3.303 secs (3.012u,0.273s)
find_witness Control.TimeoutChars 1075 - 1102 [(apply~path_sigma_uncurried).] 40.16 secs (0.001u,0.032s)
Chars 1588 - 1622 [refine~(_~@*~precompose_pconst...] 40.098 secs (0.u,0.022s)
Chars 1625 - 1648 [(apply~pmap_postwhisker).] 0.001 secs (0.u,0.s)
Chars 1651 - 1660 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 1663 - 1687 [(apply~pmap_punit_pconst).] 0. secs (0.u,0.s)
Chars 1103 - 1184 [(destruct~A~as~[TA~[[[plA~mlA]...] 0.107 secs (0.082u,0.024s)
Chars 1588 - 1622 [refine~(_~@*~precompose_pconst...] 0. secs (0.u,0.s)
Chars 1625 - 1648 [(apply~pmap_postwhisker).] 0. secs (0.u,0.s)
Chars 1651 - 1660 [symmetry.] 0. secs (0.u,0.s)
Chars 1663 - 1687 [(apply~pmap_punit_pconst).] 0. secs (0.u,0.s)
Chars 1688 - 1696 [Defined.] 0. secs (0.u,0.s)
Chars 1835 - 1970 [Definition~equiv_inverse_path_...] 0.005 secs (0.004u,0.001s)
Chars 2145 - 2457 [Definition~fiberwise_pointed_m...] 0.001 secs (0.001u,0.s)
Chars 2458 - 2464 [Proof.] 0. secs (0.u,0.s)
Chars 1185 - 1426 [(change~plA~with~(@plus~TA~plA...] 0.012 secs (0.011u,0.s)
Chars 1427 - 1452 [exists~(path_universe~f).] 0.004 secs (0.004u,0.s)
Chars 1453 - 1483 [(rewrite~!transport_prod;~simpl).] 0.027 secs (0.017u,0.003s)
Chars 1484 - 1510 [(unfold~Plus,~Mult,~Zero,~One).] 0.002 secs (0.001u,0.s)
Chars 1511 - 1713 [(repeat~apply~path_prod;~simpl...] 0.065 secs (0.053u,0.009s)
Chars 1714 - 1715 [-] 0. secs (0.u,0.s)
Chars 1716 - 1748 [(rewrite~(preserves_plus~(f:=f...] 0.004 secs (0.003u,0.001s)
Chars 1751 - 1777 [(apply~ap011;~apply~eisretr).] 0.004 secs (0.004u,0.s)
Chars 1778 - 1779 [-] 0. secs (0.u,0.s)
Chars 1780 - 1812 [(rewrite~(preserves_mult~(f:=f...] 0.004 secs (0.004u,0.s)
Chars 1815 - 1841 [(apply~ap011;~apply~eisretr).] 0.003 secs (0.003u,0.s)
Chars 1842 - 1843 [-] 0. secs (0.u,0.s)
Chars 1844 - 1862 [(apply~preserves_0).] 0.003 secs (0.003u,0.s)
Chars 1863 - 1864 [-] 0. secs (0.u,0.s)
Chars 1865 - 1883 [(apply~preserves_1).] 0.002 secs (0.u,0.001s)
Chars 1075 - 1102 [(apply~path_sigma_uncurried).] 0. secs (0.u,0.s)
Chars 1103 - 1184 [(destruct~A~as~[TA~[[[plA~mlA]...] 0.005 secs (0.005u,0.s)
Chars 1185 - 1426 [(change~plA~with~(@plus~TA~plA...] 0.009 secs (0.007u,0.001s)
Chars 1427 - 1452 [exists~(path_universe~f).] 0.001 secs (0.001u,0.s)
Chars 1453 - 1483 [(rewrite~!transport_prod;~simpl).] 0.003 secs (0.003u,0.s)
Chars 1484 - 1510 [(unfold~Plus,~Mult,~Zero,~One).] 0.001 secs (0.001u,0.s)
Chars 1511 - 1713 [(repeat~apply~path_prod;~simpl...] 0.016 secs (0.016u,0.s)
Chars 1716 - 1748 [(rewrite~(preserves_plus~(f:=f...] 0. secs (0.u,0.s)
Chars 1751 - 1777 [(apply~ap011;~apply~eisretr).] 0.001 secs (0.001u,0.s)
Chars 1780 - 1812 [(rewrite~(preserves_mult~(f:=f...] 0. secs (0.u,0.s)
Chars 1815 - 1841 [(apply~ap011;~apply~eisretr).] 0.001 secs (0.001u,0.s)
Chars 1844 - 1862 [(apply~preserves_0).] 0. secs (0.u,0.s)
Chars 1865 - 1883 [(apply~preserves_1).] 0. secs (0.u,0.s)
Chars 1884 - 1888 [Qed.] 0.077 secs (0.06u,0.014s)
Chars 1890 - 1953 [Lemma~iso_leibnitz~:~forall~P~...] 0. secs (0.u,0.s)
Chars 1954 - 1960 [Proof.] 0. secs (0.u,0.s)
Chars 212 - 240 [(repeat~(split;~try~apply~_)).] 40.152 secs (0.009u,0.03s)
Chars 212 - 240 [(repeat~(split;~try~apply~_)).] 0. secs (0.u,0.s)
Chars 241 - 245 [Qed.] 0. secs (0.u,0.s)
Chars 247 - 342 [#[global]~Instance~bounded_joi...] 0. secs (0.u,0.s)
Chars 343 - 349 [Proof.] 0. secs (0.u,0.s)
Chars 1945 - 1997 [refine~((fun~g~:~Y~->~F~X~=>~f...] 40.276 secs (0.109u,0.049s)
Chars 2002 - 2037 [by~apply~isequiv_fromF_postcom...] 0.001 secs (0.001u,0.s)
Chars 1945 - 1997 [refine~((fun~g~:~Y~->~F~X~=>~f...] 0. secs (0.u,0.s)
Chars 2002 - 2037 [by~apply~isequiv_fromF_postcom...] 0. secs (0.u,0.s)
Chars 2040 - 2048 [Defined.] 0. secs (0.u,0.s)
Chars 2052 - 2144 [Definition~F_corec_beta~{Y}~{X...] 0.002 secs (0.002u,0.s)
Chars 2147 - 2153 [Proof.] 0. secs (0.u,0.s)
Chars 552 - 558 [split.] 40.057 secs (0.002u,0.026s)
Chars 563 - 564 [-] 0. secs (0.u,0.s)
Chars 565 - 576 [(intros~uac).] 0. secs (0.u,0.s)
Chars 583 - 626 [simple~refine~(isequiv_adjoint...] 0.001 secs (0.u,0.001s)
Chars 633 - 634 [*] 0. secs (0.u,0.s)
Chars 635 - 671 [simple~refine~(Pushout_rec~A~_...] 0.001 secs (0.001u,0.s)
Chars 680 - 681 [+] 0. secs (0.u,0.s)
Chars 682 - 723 [(intros~u;~pose~(uac~u);~exact...] 0.003 secs (0.003u,0.s)
Chars 732 - 733 [+] 0. secs (0.u,0.s)
Chars 734 - 755 [(intros~a;~assumption).] 0. secs (0.u,0.s)
Chars 764 - 765 [+] 0. secs (0.u,0.s)
Chars 766 - 779 [(intros~[u~a]).] 0.001 secs (0.001u,0.s)
Chars 780 - 786 [(simpl).] 0. secs (0.u,0.s)
Chars 797 - 810 [(pose~(uac~u)).] 0. secs (0.u,0.s)
Chars 811 - 823 [(apply~contr).] 0.001 secs (0.001u,0.s)
Chars 830 - 831 [*] 0. secs (0.u,0.s)
Chars 832 - 841 [(intros~z).] 0.001 secs (0.001u,0.s)
Chars 842 - 852 [(pattern~z).] 0.002 secs (0.002u,0.s)
Chars 861 - 899 [simple~refine~(Pushout_ind~_~_...] 0.002 secs (0.002u,0.s)
Chars 908 - 909 [+] 0. secs (0.u,0.s)
Chars 910 - 919 [(intros~u).] 0.001 secs (0.u,0.s)
Chars 930 - 963 [(pose~(contr_inhabited_hprop~U...] 0.004 secs (0.003u,0.s)
Chars 974 - 991 [(apply~path_contr).] 0.003 secs (0.003u,0.s)
Chars 1000 - 1001 [+] 0. secs (0.u,0.s)
Chars 1002 - 1024 [(intros~a;~reflexivity).] 0.003 secs (0.002u,0.s)
Chars 1033 - 1034 [+] 0. secs (0.u,0.s)
Chars 1035 - 1082 [(intros~[u~a];~pose~(contr_inh...] 0.014 secs (0.013u,0.s)
Chars 1093 - 1110 [(apply~path_contr).] 0.027 secs (0.025u,0.001s)
Chars 1117 - 1118 [*] 0. secs (0.u,0.s)
Chars 1119 - 1128 [(intros~a).] 0.001 secs (0.001u,0.s)
Chars 1129 - 1141 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 1146 - 1147 [-] 0. secs (0.u,0.s)
Chars 1148 - 1159 [(intros~?~u).] 0. secs (0.u,0.s)
Chars 1166 - 1227 [refine~(contr_equiv~(Join~U~A)...] 0.06 secs (0.054u,0.006s)
Chars 1234 - 1267 [(pose~(contr_inhabited_hprop~U...] 0.003 secs (0.002u,0.001s)
Chars 1274 - 1282 [exact~_.] 0.002 secs (0.002u,0.s)
Chars 552 - 558 [split.] 0. secs (0.u,0.s)
Chars 565 - 576 [(intros~uac).] 0. secs (0.u,0.s)
Chars 583 - 626 [simple~refine~(isequiv_adjoint...] 0. secs (0.u,0.s)
Chars 635 - 671 [simple~refine~(Pushout_rec~A~_...] 0. secs (0.u,0.s)
Chars 682 - 723 [(intros~u;~pose~(uac~u);~exact...] 0. secs (0.u,0.s)
Chars 734 - 755 [(intros~a;~assumption).] 0. secs (0.u,0.s)
Chars 766 - 779 [(intros~[u~a]).] 0. secs (0.u,0.s)
Chars 780 - 786 [(simpl).] 0. secs (0.u,0.s)
Chars 797 - 810 [(pose~(uac~u)).] 0. secs (0.u,0.s)
Chars 811 - 823 [(apply~contr).] 0. secs (0.u,0.s)
Chars 832 - 841 [(intros~z).] 0.001 secs (0.001u,0.s)
Chars 842 - 852 [(pattern~z).] 0. secs (0.u,0.s)
Chars 861 - 899 [simple~refine~(Pushout_ind~_~_...] 0. secs (0.u,0.s)
Chars 910 - 919 [(intros~u).] 0. secs (0.u,0.s)
Chars 930 - 963 [(pose~(contr_inhabited_hprop~U...] 0.001 secs (0.001u,0.s)
Chars 974 - 991 [(apply~path_contr).] 0.001 secs (0.001u,0.s)
Chars 1002 - 1024 [(intros~a;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 1035 - 1082 [(intros~[u~a];~pose~(contr_inh...] 0.004 secs (0.004u,0.s)
Chars 1093 - 1110 [(apply~path_contr).] 0.002 secs (0.002u,0.s)
Chars 1119 - 1128 [(intros~a).] 0.001 secs (0.001u,0.s)
Chars 1129 - 1141 [reflexivity.] 0. secs (0.u,0.s)
Chars 1148 - 1159 [(intros~?~u).] 0. secs (0.u,0.s)
Chars 1166 - 1227 [refine~(contr_equiv~(Join~U~A)...] 0. secs (0.u,0.s)
Chars 1234 - 1267 [(pose~(contr_inhabited_hprop~U...] 0. secs (0.u,0.s)
Chars 1274 - 1282 [exact~_.] 0. secs (0.u,0.s)
Chars 1285 - 1293 [Defined.] 0.009 secs (0.007u,0.001s)
Chars 1295 - 1316 [End~ClosedModalTypes.] 0.029 secs (0.024u,0.004s)
Chars 1362 - 1399 [Definition~Cl~(U~:~HProp)~:~Mo...] 0. secs (0.u,0.s)
Chars 1400 - 1406 [Proof.] 0. secs (0.u,0.s)
Chars 7358 - 7369 [(destruct~c).] 40.19 secs (0.041u,0.04s)
Chars 7374 - 7394 [(apply~cu_fill_right).] 0.005 secs (0.005u,0.s)
Chars 7358 - 7369 [(destruct~c).] 0.002 secs (0.002u,0.s)
Chars 7374 - 7394 [(apply~cu_fill_right).] 0.001 secs (0.001u,0.s)
Chars 7397 - 7405 [Defined.] 0.006 secs (0.004u,0.001s)
Chars 7409 - 7832 [Definition~dc_fill_top~(t0ii~:...] 0.014 secs (0.013u,0.001s)
Chars 7835 - 7841 [Proof.] 0. secs (0.u,0.s)
     = 1 :: 2 :: 3 :: 5 :: 6 :: 7 :: nil
     : list nat
     = Some 3
     : option nat
     = 3 :: 5 :: nil
     : list nat
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 1539 - 1583 [exact~(path_isomorphism~(def_i...] 40.142 secs (0.003u,0.03s)
Chars 1539 - 1583 [exact~(path_isomorphism~(def_i...] 0. secs (0.u,0.s)
Chars 1584 - 1592 [Defined.] 0. secs (0.u,0.s)
Chars 1658 - 1724 [Lemma~isomorphic_id~{σ}~{A~B~:...] 0. secs (0.u,0.s)
Chars 1725 - 1731 [Proof.] 0. secs (0.u,0.s)
Chars 2886 - 2925 [(apply~(@path_forall_ap_operat...] 40.145 secs (0.002u,0.031s)
Chars 2930 - 2979 [(apply~quotient_ind_prop_famil...] 0.018 secs (0.018u,0.s)
Chars 2984 - 2992 [intro~a.] 0.001 secs (0.001u,0.s)
Chars 2997 - 3059 [(destruct~(q~_~_~(op_compatibl...] 0.01 secs (0.01u,0.s)
Chars 3064 - 3126 [(destruct~(q~_~_~(op_compatibl...] 0.011 secs (0.011u,0.s)
Chars 3131 - 3161 [refine~((P1~a~@~_)~@~(P2~a)^).] 0.004 secs (0.003u,0.s)
Chars 3166 - 3191 [(apply~related_classes_eq).] 0.002 secs (0.002u,0.s)
Chars 3196 - 3262 [exact~(P~(x,~a)~(y,~a)~(C,~ref...] 0.009 secs (0.009u,0.s)
Chars 2886 - 2925 [(apply~(@path_forall_ap_operat...] 0.001 secs (0.001u,0.s)
Chars 2930 - 2979 [(apply~quotient_ind_prop_famil...] 0.002 secs (0.001u,0.001s)
Chars 2984 - 2992 [intro~a.] 0.001 secs (0.u,0.001s)
Chars 2997 - 3059 [(destruct~(q~_~_~(op_compatibl...] 0.001 secs (0.u,0.001s)
Chars 3064 - 3126 [(destruct~(q~_~_~(op_compatibl...] 0.001 secs (0.u,0.001s)
Chars 3131 - 3161 [refine~((P1~a~@~_)~@~(P2~a)^).] 0.001 secs (0.001u,0.s)
Chars 3166 - 3191 [(apply~related_classes_eq).] 0.001 secs (0.001u,0.s)
Chars 3196 - 3262 [exact~(P~(x,~a)~(y,~a)~(C,~ref...] 0.001 secs (0.001u,0.s)
Chars 3265 - 3273 [Defined.] 0.008 secs (0.007u,0.001s)
Chars 4124 - 4184 [Fixpoint~op_quotient_algebra~{...] 0.001 secs (0.001u,0.s)
Chars 4187 - 4193 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 75 [Require~Import~Basics~Types~HS...] 2.653 secs (2.407u,0.241s)
Chars 52 - 96 [Require~Import~Groups~AbGroups...] 12.453 secs (11.993u,0.439s)
Chars 97 - 143 [Require~Import~Homotopy.ExactS...] 0.004 secs (0.004u,0.s)
Chars 145 - 176 [#[local]Open~Scope~pointed_scope.] 0. secs (0.u,0.s)
Chars 177 - 205 [#[local]Open~Scope~type_scope.] 0. secs (0.u,0.s)
Chars 206 - 236 [#[local]Open~Scope~mc_add_scope.] 0. secs (0.u,0.s)
Chars 643 - 669 [Declare~Scope~abses_scope.] 0. secs (0.u,0.s)
Chars 670 - 699 [#[local]Open~Scope~abses_scope.] 0. secs (0.u,0.s)
Chars 859 - 1163 [Record~AbSES'~{B~A~:~AbGroup}~...] 0.01 secs (0.009u,0.s)
Chars 1249 - 1286 [Coercion~middle~:~AbSES'~>->~A...] 0. secs (0.u,0.s)
Chars 1288 - 1389 [#[global]~Existing~Instances~i...] 0. secs (0.u,0.s)
Chars 1391 - 1430 [Arguments~AbSES'~B~A~:~clear~i...] 0. secs (0.u,0.s)
Chars 1431 - 1460 [Arguments~Build_AbSES'~{B~A}.] 0. secs (0.u,0.s)
Chars 1462 - 1522 [Definition~Build_AbSES~{B~A~:~...] 0. secs (0.u,0.s)
Chars 1609 - 1702 [#[local]~Definition~issig_abse...] 0.375 secs (0.369u,0.004s)
Chars 1822 - 2200 [#[local]~Definition~issig_abse...] 0.088 secs (0.081u,0.007s)
Chars 2265 - 2551 [Definition~issig_abses~{B~A~:~...] 0.015 secs (0.011u,0.004s)
Chars 2553 - 2672 [Definition~iscomplex_abses~{A~...] 0.003 secs (0.003u,0.s)
Chars 2744 - 2817 [#[global]Instance~ispointed_ab...] 0. secs (0.u,0.s)
Chars 2818 - 2824 [Proof.] 0. secs (0.u,0.s)
Chars 939 - 951 [constructor.] 40.139 secs (0.u,0.025s)
Chars 954 - 955 [-] 0. secs (0.u,0.s)
Chars 956 - 977 [(apply~insort_decsort).] 0.002 secs (0.002u,0.s)
Chars 980 - 981 [-] 0. secs (0.u,0.s)
Chars 982 - 1027 [(intros~L~R~L'~R'~[?~?]~[?~?];...] 0.008 secs (0.006u,0.001s)
Chars 939 - 951 [constructor.] 0. secs (0.u,0.s)
Chars 956 - 977 [(apply~insort_decsort).] 0. secs (0.u,0.s)
Chars 982 - 1027 [(intros~L~R~L'~R'~[?~?]~[?~?];...] 0. secs (0.u,0.s)
Chars 1028 - 1032 [Qed.] 0. secs (0.u,0.s)
Chars 1034 - 1051 [Section~Addition.] 0. secs (0.u,0.s)
Chars 1054 - 1076 [Context~`{Univalence}.] 0. secs (0.u,0.s)
Chars 1079 - 1125 [Context~{S~:~OptionSort@{i}}~`...] 0. secs (0.u,0.s)
Chars 1128 - 1146 [Let~No~:=~GenNo~S.] 0. secs (0.u,0.s)
Chars 1150 - 1164 [Section~Inner.] 0. secs (0.u,0.s)
Chars 1170 - 1319 [Context~{L~R~:~Type@{i}}~{Sx~:...] 0. secs (0.u,0.s)
Chars 1325 - 1459 [Let~A~:=~~~{g~:~No~->~No~&~~~(...] 0.001 secs (0.001u,0.s)
Chars 1465 - 1639 [Context~(xL_plus~:~L~->~A)~(xR...] 0.001 secs (0.001u,0.s)
Chars 1645 - 1960 [Definition~plus_inner~:~~~{g~~...] 0.004 secs (0.004u,0.s)
Chars 1965 - 1971 [Proof.] 0. secs (0.u,0.s)
Chars 5408 - 5416 [intro~i.] 40.195 secs (0.001u,0.036s)
Chars 5419 - 5460 [(induction~i~using~fin_ind;~in...] 0.009 secs (0.008u,0.001s)
Chars 5463 - 5464 [-] 0. secs (0.u,0.s)
Chars 5465 - 5482 [(unfold~cons_dom').] 0.001 secs (0.001u,0.s)
Chars 5487 - 5520 [(rewrite~compute_fin_ind_fin_z...] 0.023 secs (0.019u,0.003s)
Chars 5525 - 5537 [reflexivity.] 0. secs (0.u,0.s)
Chars 5540 - 5541 [-] 0. secs (0.u,0.s)
Chars 5542 - 5559 [(unfold~cons_dom').] 0.001 secs (0.001u,0.s)
Chars 5564 - 5597 [by~rewrite~compute_fin_ind_fsucc.] 0.048 secs (0.042u,0.005s)
Chars 5408 - 5416 [intro~i.] 0. secs (0.u,0.s)
Chars 5419 - 5460 [(induction~i~using~fin_ind;~in...] 0.001 secs (0.001u,0.s)
Chars 5465 - 5482 [(unfold~cons_dom').] 0. secs (0.u,0.s)
Chars 5487 - 5520 [(rewrite~compute_fin_ind_fin_z...] 0.001 secs (0.001u,0.s)
Chars 5525 - 5537 [reflexivity.] 0. secs (0.u,0.s)
Chars 5542 - 5559 [(unfold~cons_dom').] 0. secs (0.u,0.s)
Chars 5564 - 5597 [by~rewrite~compute_fin_ind_fsucc.] 0.001 secs (0.001u,0.s)
Chars 5598 - 5602 [Qed.] 0.051 secs (0.043u,0.007s)
Chars 5604 - 5783 [Lemma~expand_cons_dom~`{Funext...] 0.002 secs (0.002u,0.s)
Chars 5784 - 5790 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 1447 - 1491 [refine~(transport_idmap_ap~_~_...] 40.109 secs (0.004u,0.023s)
Chars 1496 - 1531 [srefine~(transport2~idmap~_~_~...] 0.004 secs (0.004u,0.s)
Chars 1536 - 1574 [2:~(apply~Colimit_rec_beta_col...] 0.006 secs (0.005u,0.001s)
Chars 1579 - 1611 [(apply~(moveR_transport_V~idma...] 0.005 secs (0.003u,0.002s)
Chars 1616 - 1656 [(symmetry;~apply~transport_pat...] 0.011 secs (0.011u,0.s)
Chars 1447 - 1491 [refine~(transport_idmap_ap~_~_...] 0.001 secs (0.u,0.s)
Chars 1496 - 1531 [srefine~(transport2~idmap~_~_~...] 0.001 secs (0.001u,0.s)
Chars 1536 - 1574 [2:~(apply~Colimit_rec_beta_col...] 0.001 secs (0.001u,0.s)
Chars 1579 - 1611 [(apply~(moveR_transport_V~idma...] 0.002 secs (0.002u,0.s)
Chars 1616 - 1656 [(symmetry;~apply~transport_pat...] 0.003 secs (0.003u,0.s)
Chars 1659 - 1667 [Defined.] 0.013 secs (0.01u,0.002s)
Chars 1671 - 1796 [Definition~transport_E'_V~{i~j...] 0.003 secs (0.001u,0.001s)
Chars 1799 - 1805 [Proof.] 0. secs (0.u,0.s)
Chars 1978 - 2309 [simple~refine~~(No_ind_package...] 6.486 secs (-3.855u,-0.152s)
     = (-3)%Z :: (-2)%Z :: (-1)%Z :: 5%Z :: 6%Z :: 7%Z :: nil
     : list Z
     = Some (-3)%Z
     : option Z
     = (-3)%Z :: 5%Z :: nil
     : list Z
Chars 76 - 130 [Require~Import~WildCat~Pointed...] 11.126 secs (10.668u,0.441s)
Chars 131 - 199 [Require~Import~AbGroups.Abelia...] 3.493 secs (3.375u,0.114s)
Chars 201 - 230 [#[local]Open~Scope~abses_scope.] 0. secs (0.u,0.s)
Chars 430 - 519 [Definition~abses_pullback0~{A~...] 0.001 secs (0.001u,0.s)
Chars 520 - 526 [Proof.] 0. secs (0.u,0.s)
Chars 2225 - 2296 [simple~refine~(Build_Modality'...] 40.166 secs (0.003u,0.036s)
Chars 2299 - 2300 [-] 0. secs (0.u,0.s)
Chars 2301 - 2309 [exact~_.] 0. secs (0.u,0.s)
Chars 2312 - 2313 [-] 0. secs (0.u,0.s)
Chars 2314 - 2323 [(intros~A).] 0. secs (0.u,0.s)
Chars 2368 - 2430 [simple~notypeclasses~refine~(r...] 0.001 secs (0.001u,0.s)
Chars 2435 - 2436 [+] 0. secs (0.u,0.s)
Chars 2437 - 2454 [(intros~B~B_inO~g).] 0. secs (0.u,0.s)
Chars 2461 - 2540 [(refine~(Localize_ind@{a~i~i~i...] 0.002 secs (0.002u,0.s)
Chars 2547 - 2586 [(apply~ooextendable_over_unit;...] 0.002 secs (0.002u,0.s)
Chars 2593 - 2765 [refine~~(ooextendable_postcomp...] 0.018 secs (0.017u,0.s)
Chars 2772 - 2806 [refine~(ooextendable_islocal~_...] 0.002 secs (0.002u,0.s)
Chars 2811 - 2812 [+] 0. secs (0.u,0.s)
Chars 2813 - 2825 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 2830 - 2831 [+] 0. secs (0.u,0.s)
Chars 2832 - 2856 [(apply~inO_paths@{i~i~i}).] 0. secs (0.u,0.s)
Chars 2225 - 2296 [simple~refine~(Build_Modality'...] 0. secs (0.u,0.s)
Chars 2301 - 2309 [exact~_.] 0. secs (0.u,0.s)
Chars 2314 - 2323 [(intros~A).] 0. secs (0.u,0.s)
Chars 2368 - 2430 [simple~notypeclasses~refine~(r...] 0. secs (0.u,0.s)
Chars 2437 - 2454 [(intros~B~B_inO~g).] 0. secs (0.u,0.s)
Chars 2461 - 2540 [(refine~(Localize_ind@{a~i~i~i...] 0. secs (0.u,0.s)
Chars 2547 - 2586 [(apply~ooextendable_over_unit;...] 0. secs (0.u,0.s)
Chars 2593 - 2765 [refine~~(ooextendable_postcomp...] 0. secs (0.u,0.s)
Chars 2772 - 2806 [refine~(ooextendable_islocal~_...] 0. secs (0.u,0.s)
Chars 2813 - 2825 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 2832 - 2856 [(apply~inO_paths@{i~i~i}).] 0. secs (0.u,0.s)
Chars 2859 - 2867 [Defined.] 0.003 secs (0.003u,0.s)
Chars 2936 - 2970 [Notation~IsNull~f:=~(In~(Nul~f)).] 0. secs (0.u,0.s)
Chars 3090 - 3167 [#[global]~Instance~accmodality...] 0. secs (0.u,0.s)
Chars 3168 - 3174 [Proof.] 0. secs (0.u,0.s)
Chars 1594 - 1640 [(pose~(SigmaC~:=~sigma_cocone~...] 40.139 secs (0.001u,0.025s)
Chars 1645 - 1678 [srapply~(Build_IsColimit~SigmaC).] 0.004 secs (0.004u,0.s)
Chars 1683 - 1713 [srapply~Build_UniversalCocone.] 0.024 secs (0.021u,0.002s)
Chars 1718 - 1755 [(intros~X;~srapply~isequiv_adj...] 0.003 secs (0.002u,0.001s)
Chars 1760 - 1761 [-] 0. secs (0.u,0.s)
Chars 1762 - 1774 [(intros~CX~x).] 0. secs (0.u,0.s)
Chars 1781 - 1829 [srapply~(cocone_postcompose_in...] 0.003 secs (0.003u,0.s)
Chars 1836 - 1869 [srapply~(cocone_precompose~_~CX).] 0.001 secs (0.001u,0.s)
Chars 1876 - 1900 [(apply~sigma_diagram_map).] 0. secs (0.u,0.s)
Chars 1905 - 1906 [-] 0. secs (0.u,0.s)
Chars 1907 - 1916 [intro~CX.] 0.001 secs (0.001u,0.s)
Chars 1923 - 1989 [(pose~(CXy~:=~fun~y~=>~cocone_...] 0.002 secs (0.002u,0.s)
Chars 1996 - 2101 [(change~~~~(cocone_postcompose...] 0.004 secs (0.003u,0.s)
Chars 2108 - 2135 [(srapply~path_cocone;~simpl).] 0.016 secs (0.012u,0.001s)
Chars 2142 - 2143 [+] 0. secs (0.u,0.s)
Chars 2144 - 2155 [(intros~i~x).] 0.001 secs (0.001u,0.s)
Chars 2164 - 2284 [(change~~~~(legs~~~~~~~(cocone...] 0.004 secs (0.004u,0.s)
Chars 2293 - 2388 [exact~~(ap10~(apD10~(ap~legs~(...] 0.005 secs (0.005u,0.s)
Chars 2395 - 2396 [+] 0. secs (0.u,0.s)
Chars 2397 - 2423 [(intros~i~j~g~[y~x];~simpl).] 0.029 secs (0.023u,0.005s)
Chars 2432 - 2490 [(set~(py~:=~eisretr~(cocone_po...] 0.021 secs (0.02u,0.001s)
Chars 2499 - 2523 [(set~(py1~:=~ap~legs~py)).] 0.009 secs (0.007u,0.001s)
Chars 2532 - 2573 [(specialize~(apD~legs_comm~py)...] 0.011 secs (0.008u,0.002s)
Chars 2584 - 2595 [(simpl~in~*).] 0.009 secs (0.008u,0.001s)
Chars 2606 - 2670 [(rewrite~(path_forall~_~_~(tra...] 0.014 secs (0.013u,0.s)
Chars 2681 - 2734 [(apply~apD10~in~py2;~specializ...] 0.018 secs (0.016u,0.002s)
Chars 2745 - 2809 [(rewrite~(path_forall~_~_~(tra...] 0.014 secs (0.014u,0.s)
Chars 2820 - 2873 [(apply~apD10~in~py2;~specializ...] 0.018 secs (0.016u,0.002s)
Chars 2884 - 2948 [(rewrite~(path_forall~_~_~(tra...] 0.013 secs (0.011u,0.002s)
Chars 2959 - 3012 [(apply~apD10~in~py2;~specializ...] 0.018 secs (0.016u,0.002s)
Chars 3023 - 3087 [(rewrite~(path_forall~_~_~(tra...] 0.014 secs (0.014u,0.s)
Chars 3098 - 3151 [(apply~apD10~in~py2;~specializ...] 0.017 secs (0.016u,0.s)
Chars 3162 - 3198 [(rewrite~transport_paths_FlFr~...] 0.012 secs (0.01u,0.001s)
Chars 3209 - 3247 [(rewrite~concat_1p,~concat_pp_...] 0.017 secs (0.014u,0.002s)
Chars 3258 - 3280 [(apply~moveL_Mp~in~py2).] 0.03 secs (0.025u,0.004s)
Chars 3289 - 3389 [(rewrite~~~(ap_path_sigma_1p~~...] 0.014 secs (0.014u,0.s)
Chars 3471 - 3481 [subst~py1.] 0.004 secs (0.003u,0.s)
Chars 3490 - 3504 [etransitivity.] 0.009 secs (0.007u,0.001s)
Chars 3513 - 3514 [*] 0. secs (0.u,0.s)
Chars 3515 - 3529 [etransitivity.] 0.008 secs (0.007u,0.s)
Chars 3540 - 3552 [2:~exact~py2.] 0.003 secs (0.003u,0.s)
Chars 3563 - 3572 [(apply~ap).] 0.006 secs (0.006u,0.s)
Chars 3583 - 3628 [(rewrite~(ap_compose~legs~(fun...] 0.012 secs (0.01u,0.001s)
Chars 3639 - 3668 [(rewrite~(ap_apply_lD2~_~i~x)).] 0.011 secs (0.01u,0.001s)
Chars 3679 - 3691 [reflexivity.] 0.004 secs (0.004u,0.s)
Chars 3700 - 3701 [*] 0. secs (0.u,0.s)
Chars 3702 - 3717 [(apply~ap10,~ap).] 0.008 secs (0.007u,0.001s)
Chars 3728 - 3773 [(rewrite~(ap_compose~legs~(fun...] 0.013 secs (0.012u,0.s)
Chars 3784 - 3813 [(rewrite~(ap_apply_lD2~_~j~_)).] 0.009 secs (0.009u,0.s)
Chars 3824 - 3836 [reflexivity.] 0.005 secs (0.004u,0.s)
Chars 3841 - 3842 [-] 0. secs (0.u,0.s)
Chars 3843 - 3852 [(intros~f).] 0.001 secs (0.001u,0.s)
Chars 3859 - 3898 [(apply~path_forall;~intros~[y~...] 0.005 secs (0.005u,0.s)
Chars 3905 - 3946 [(rewrite~<-~cocone_precompose_...] 0.004 secs (0.004u,0.s)
Chars 3953 - 3998 [srapply~(apD10~(g:=fun~x~=>~f~...] 0.002 secs (0.002u,0.s)
Chars 4005 - 4033 [srapply~equiv_moveR_equiv_V.] 0.056 secs (0.054u,0.001s)
Chars 4040 - 4060 [srapply~path_cocone.] 0.004 secs (0.004u,0.s)
Chars 4067 - 4082 [1:~reflexivity.] 0.003 secs (0.003u,0.s)
Chars 4089 - 4112 [(intros~i~j~g~x';~simpl).] 0.007 secs (0.007u,0.s)
Chars 4119 - 4130 [hott_simpl.] 0.273 secs (0.231u,0.035s)
Chars 4137 - 4163 [exact~(ap_compose~_~_~_)^.] 0.012 secs (0.004u,0.002s)
Chars 1594 - 1640 [(pose~(SigmaC~:=~sigma_cocone~...] 0. secs (0.u,0.s)
Chars 1645 - 1678 [srapply~(Build_IsColimit~SigmaC).] 0. secs (0.u,0.s)
Chars 1683 - 1713 [srapply~Build_UniversalCocone.] 0. secs (0.u,0.s)
Chars 1718 - 1755 [(intros~X;~srapply~isequiv_adj...] 0.001 secs (0.001u,0.s)
Chars 1762 - 1774 [(intros~CX~x).] 0. secs (0.u,0.s)
Chars 1781 - 1829 [srapply~(cocone_postcompose_in...] 0. secs (0.u,0.s)
Chars 1836 - 1869 [srapply~(cocone_precompose~_~CX).] 0. secs (0.u,0.s)
Chars 1876 - 1900 [(apply~sigma_diagram_map).] 0. secs (0.u,0.s)
Chars 1907 - 1916 [intro~CX.] 0.001 secs (0.u,0.s)
Chars 1923 - 1989 [(pose~(CXy~:=~fun~y~=>~cocone_...] 0. secs (0.u,0.s)
Chars 1996 - 2101 [(change~~~~(cocone_postcompose...] 0. secs (0.u,0.s)
Chars 2108 - 2135 [(srapply~path_cocone;~simpl).] 0.002 secs (0.002u,0.s)
Chars 2144 - 2155 [(intros~i~x).] 0. secs (0.u,0.s)
Chars 2164 - 2284 [(change~~~~(legs~~~~~~~(cocone...] 0. secs (0.u,0.s)
Chars 2293 - 2388 [exact~~(ap10~(apD10~(ap~legs~(...] 0. secs (0.u,0.s)
Chars 2397 - 2423 [(intros~i~j~g~[y~x];~simpl).] 0.009 secs (0.009u,0.s)
Chars 2432 - 2490 [(set~(py~:=~eisretr~(cocone_po...] 0.002 secs (0.002u,0.s)
Chars 2499 - 2523 [(set~(py1~:=~ap~legs~py)).] 0.002 secs (0.002u,0.s)
Chars 2532 - 2573 [(specialize~(apD~legs_comm~py)...] 0.005 secs (0.005u,0.s)
Chars 2584 - 2595 [(simpl~in~*).] 0.003 secs (0.003u,0.s)
Chars 2606 - 2670 [(rewrite~(path_forall~_~_~(tra...] 0.002 secs (0.002u,0.s)
Chars 2681 - 2734 [(apply~apD10~in~py2;~specializ...] 0.01 secs (0.01u,0.s)
Chars 2745 - 2809 [(rewrite~(path_forall~_~_~(tra...] 0.004 secs (0.004u,0.s)
Chars 2820 - 2873 [(apply~apD10~in~py2;~specializ...] 0.011 secs (0.011u,0.s)
Chars 2884 - 2948 [(rewrite~(path_forall~_~_~(tra...] 0.003 secs (0.003u,0.s)
Chars 2959 - 3012 [(apply~apD10~in~py2;~specializ...] 0.011 secs (0.011u,0.s)
Chars 3023 - 3087 [(rewrite~(path_forall~_~_~(tra...] 0.003 secs (0.003u,0.s)
Chars 3098 - 3151 [(apply~apD10~in~py2;~specializ...] 0.011 secs (0.011u,0.s)
Chars 3162 - 3198 [(rewrite~transport_paths_FlFr~...] 0.043 secs (0.032u,0.01s)
Chars 3209 - 3247 [(rewrite~concat_1p,~concat_pp_...] 0.004 secs (0.004u,0.s)
Chars 3258 - 3280 [(apply~moveL_Mp~in~py2).] 0.003 secs (0.003u,0.s)
Chars 3289 - 3389 [(rewrite~~~(ap_path_sigma_1p~~...] 0.003 secs (0.003u,0.s)
Chars 3471 - 3481 [subst~py1.] 0.003 secs (0.003u,0.s)
Chars 3490 - 3504 [etransitivity.] 0.002 secs (0.002u,0.s)
Chars 3515 - 3529 [etransitivity.] 0.003 secs (0.003u,0.s)
Chars 3540 - 3552 [2:~exact~py2.] 0.002 secs (0.002u,0.s)
Chars 3563 - 3572 [(apply~ap).] 0.003 secs (0.003u,0.s)
Chars 3583 - 3628 [(rewrite~(ap_compose~legs~(fun...] 0.003 secs (0.003u,0.s)
Chars 3639 - 3668 [(rewrite~(ap_apply_lD2~_~i~x)).] 0.003 secs (0.003u,0.s)
Chars 3679 - 3691 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 3702 - 3717 [(apply~ap10,~ap).] 0.003 secs (0.003u,0.s)
Chars 3728 - 3773 [(rewrite~(ap_compose~legs~(fun...] 0.003 secs (0.003u,0.s)
Chars 3784 - 3813 [(rewrite~(ap_apply_lD2~_~j~_)).] 0.003 secs (0.003u,0.s)
Chars 3824 - 3836 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 3843 - 3852 [(intros~f).] 0. secs (0.u,0.s)
Chars 3859 - 3898 [(apply~path_forall;~intros~[y~...] 0.002 secs (0.002u,0.s)
Chars 3905 - 3946 [(rewrite~<-~cocone_precompose_...] 0. secs (0.u,0.s)
Chars 3953 - 3998 [srapply~(apD10~(g:=fun~x~=>~f~...] 0. secs (0.u,0.s)
Chars 4005 - 4033 [srapply~equiv_moveR_equiv_V.] 0. secs (0.u,0.s)
Chars 4040 - 4060 [srapply~path_cocone.] 0. secs (0.u,0.s)
Chars 4067 - 4082 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 4089 - 4112 [(intros~i~j~g~x';~simpl).] 0.003 secs (0.003u,0.s)
Chars 4119 - 4130 [hott_simpl.] 0.001 secs (0.001u,0.s)
Chars 4137 - 4163 [exact~(ap_compose~_~_~_)^.] 0.001 secs (0.001u,0.s)
Chars 4166 - 4174 [Defined.] 0.218 secs (0.214u,0.s)
Chars 4176 - 4193 [End~ColimitSigma.] 0.269 secs (0.263u,0.006s)
Chars 4253 - 4274 [Section~SigmaDiagram.] 0. secs (0.u,0.s)
Chars 4278 - 4334 [Context~{G~:~Graph}~{Y~:~Type}...] 0. secs (0.u,0.s)
Chars 4338 - 4465 [Definition~sigma_diagram_funct...] 0. secs (0.u,0.s)
Chars 4468 - 4474 [Proof.] 0. secs (0.u,0.s)
Chars 2473 - 2559 [refine~~(sq_GGcc~_~(eissect~_~...] 40.202 secs (0.036u,0.037s)
Chars 2562 - 2596 [(apply~moveR_equiv_V,~dp_apD_c...] 0.04 secs (0.03u,0.009s)
Chars 2473 - 2559 [refine~~(sq_GGcc~_~(eissect~_~...] 0. secs (0.u,0.s)
Chars 2562 - 2596 [(apply~moveR_equiv_V,~dp_apD_c...] 0.001 secs (0.001u,0.s)
Chars 2597 - 2605 [Defined.] 0.009 secs (0.007u,0.001s)
Chars 2607 - 2774 [Lemma~Torus_rec_beta_loop_b~(P...] 0.001 secs (0.001u,0.s)
Chars 2775 - 2781 [Proof.] 0. secs (0.u,0.s)
Finished failing transaction in 39.171 secs (35.749u,0.657s) (failure)
Chars 3497 - 4711 [Time~(exists~unit_l~counit_l;~...] 39.171 secs (35.749u,0.657s)
Chars 1734 - 1745 [(destruct~p).] 24.729 secs (13.766u,0.247s)
Chars 1433 - 1456 [snrapply~Build_pEquiv'.] 40.127 secs (0.002u,0.024s)
Chars 1459 - 1460 [{] 0. secs (0.u,0.s)
Chars 1461 - 1520 [srapply~(equiv_adjointify~(fun...] 0.002 secs (0.002u,0.s)
Chars 1525 - 1541 [1:~by~intros~[].] 0.001 secs (0.001u,0.s)
Chars 1546 - 1564 [rapply~path_contr.] 0.01 secs (0.008u,0.001s)
Chars 1565 - 1566 [}] 0. secs (0.u,0.s)
Chars 1569 - 1581 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 1433 - 1456 [snrapply~Build_pEquiv'.] 0. secs (0.u,0.s)
Chars 1461 - 1520 [srapply~(equiv_adjointify~(fun...] 0. secs (0.u,0.s)
Chars 1525 - 1541 [1:~by~intros~[].] 0. secs (0.u,0.s)
Chars 1546 - 1564 [rapply~path_contr.] 0. secs (0.u,0.s)
Chars 1569 - 1581 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 1582 - 1590 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1658 - 1710 [#[global]Instance~is0functor_l...] 0. secs (0.u,0.s)
Chars 1711 - 1717 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 45.662 secs (5.343u,0.249s) (successful)
Chars 3497 - 4711 [Time~(exists~unit_l~counit_l;~...] 45.662 secs (5.343u,0.249s)
Finished transaction in 0.001 secs (0.001u,0.s) (successful)
Chars 3497 - 4711 [Time~(exists~unit_l~counit_l;~...] 0.001 secs (0.001u,0.s)
Chars 4731 - 4739 [Defined.] 0.262 secs (0.258u,0.002s)
Chars 4742 - 4748 [End~l.] 0.011 secs (0.01u,0.s)
Chars 4794 - 4804 [Section~r.] 0.002 secs (0.u,0.002s)
Chars 4809 - 4834 [Variable~(F~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 4839 - 4864 [Variable~(G~:~Functor~D~C).] 0. secs (0.u,0.s)
Chars 4870 - 4890 [Variable~(A~:~F~-|~G).] 0.001 secs (0.001u,0.s)
Chars 4896 - 4921 [Variable~(E~:~PreCategory).] 0. secs (0.u,0.s)
Chars 4927 - 5079 [Definition~unit_r~:~~~NaturalT...] 0.002 secs (0.002u,0.s)
Chars 5084 - 5090 [Proof.] 0. secs (0.u,0.s)
Chars 2467 - 2560 [equiv_intros~~(equiv_functor_a...] 40.106 secs (0.003u,0.022s)
Chars 2563 - 2584 [(destruct~C~as~[C~c0]).] 0.003 secs (0.003u,0.s)
Chars 2587 - 2723 [equiv_intros~~(@equiv_functor_...] 0.01 secs (0.008u,0.001s)
Chars 2726 - 2737 [(simpl~in~*).] 0.003 secs (0.003u,0.s)
Chars 2738 - 2759 [(destruct~g~as~[g~g0]).] 0.005 secs (0.005u,0.s)
Chars 2762 - 2781 [(unfold~point~in~g0).] 0.002 secs (0.001u,0.s)
Chars 2782 - 2825 [(unfold~functor_forall,~sig_co...] 0.002 secs (0.002u,0.s)
Chars 2826 - 2832 [(simpl).] 0.002 secs (0.001u,0.s)
Chars 2898 - 2925 [(pose~(path_forall~_~c0~g0)).] 0.002 secs (0.002u,0.s)
Chars 2928 - 3001 [(assert~(p~=~path_forall~(fun~...] 0.003 secs (0.003u,0.s)
Chars 3004 - 3019 [1:~reflexivity.] 0.001 secs (0.001u,0.s)
Chars 3022 - 3034 [(induction~p).] 0.004 secs (0.003u,0.s)
Chars 3037 - 3062 [(apply~moveR_equiv_V~in~X).] 0.004 secs (0.004u,0.s)
Chars 3063 - 3075 [(induction~X).] 0.004 secs (0.002u,0.s)
Chars 3078 - 3086 [(apply~H).] 0.001 secs (0.001u,0.s)
Chars 2467 - 2560 [equiv_intros~~(equiv_functor_a...] 0. secs (0.u,0.s)
Chars 2563 - 2584 [(destruct~C~as~[C~c0]).] 0.001 secs (0.001u,0.s)
Chars 2587 - 2723 [equiv_intros~~(@equiv_functor_...] 0.001 secs (0.001u,0.s)
Chars 2726 - 2737 [(simpl~in~*).] 0.002 secs (0.002u,0.s)
Chars 2738 - 2759 [(destruct~g~as~[g~g0]).] 0.001 secs (0.001u,0.s)
Chars 2762 - 2781 [(unfold~point~in~g0).] 0.001 secs (0.001u,0.s)
Chars 2782 - 2825 [(unfold~functor_forall,~sig_co...] 0.001 secs (0.001u,0.s)
Chars 2826 - 2832 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 2898 - 2925 [(pose~(path_forall~_~c0~g0)).] 0. secs (0.u,0.s)
Chars 2928 - 3001 [(assert~(p~=~path_forall~(fun~...] 0.001 secs (0.001u,0.s)
Chars 3004 - 3019 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 3022 - 3034 [(induction~p).] 0. secs (0.u,0.s)
Chars 3037 - 3062 [(apply~moveR_equiv_V~in~X).] 0.001 secs (0.001u,0.s)
Chars 3063 - 3075 [(induction~X).] 0.001 secs (0.001u,0.s)
Chars 3078 - 3086 [(apply~H).] 0. secs (0.u,0.s)
Chars 3087 - 3095 [Defined.] 0.018 secs (0.014u,0.003s)
Chars 3177 - 3412 [Definition~Build_pHomotopy_pFo...] 0.007 secs (0.007u,0.s)
Chars 3413 - 3419 [Proof.] 0. secs (0.u,0.s)
Chars 1961 - 1986 [(intros~P;~apply~transport).] 40.112 secs (0.001u,0.032s)
Chars 2058 - 2122 [(first~[~exact~iso_same_semiri...] 0. secs (0.u,0.s)
Chars 1961 - 1986 [(intros~P;~apply~transport).] 0. secs (0.u,0.s)
Chars 2058 - 2122 [(first~[~exact~iso_same_semiri...] 0. secs (0.u,0.s)
Chars 2123 - 2127 [Qed.] 0. secs (0.u,0.s)
Chars 2129 - 2142 [End~contents.] 0.031 secs (0.025u,0.006s)
Chars 2144 - 2158 [End~SemiRings.] 0.026 secs (0.023u,0.002s)
Chars 2160 - 2173 [Module~Rings.] 0. secs (0.u,0.s)
Chars 2175 - 2274 [Class~Operations~:=~~~~~operat...] 0.001 secs (0.001u,0.s)
Chars 2276 - 2425 [Definition~BuildOperations~(T~...] 0.003 secs (0.003u,0.s)
Chars 2427 - 2477 [Coercion~R_carrier~(s~:~Operat...] 0. secs (0.u,0.s)
Chars 2478 - 2556 [#[global]~Instance~R_plus~~(s~...] 0.001 secs (0.001u,0.s)
Chars 2557 - 2635 [#[global]~Instance~R_mult~~(s~...] 0.001 secs (0.001u,0.s)
Chars 2636 - 2708 [#[global]~Instance~R_zero~~(s~...] 0.001 secs (0.u,0.s)
Chars 2709 - 2773 [#[global]Instance~R_one~~(s~:~...] 0. secs (0.u,0.s)
Chars 2774 - 2838 [#[global]Instance~R_negate~~(s...] 0. secs (0.u,0.s)
Chars 2840 - 2866 [Arguments~R_plus~!_~/~_~_.] 0. secs (0.u,0.s)
Chars 2867 - 2893 [Arguments~R_mult~!_~/~_~_.] 0. secs (0.u,0.s)
Chars 2894 - 2916 [Arguments~R_zero~!_~/.] 0. secs (0.u,0.s)
Chars 2917 - 2938 [Arguments~R_one~!_~/.] 0. secs (0.u,0.s)
Chars 2939 - 2965 [Arguments~R_negate~!_~/~_.] 0. secs (0.u,0.s)
Chars 2967 - 2984 [Section~contents.] 0. secs (0.u,0.s)
Chars 2985 - 2998 [Universe~U,V.] 0. secs (0.u,0.s)
Chars 2999 - 3031 [Context~`{Funext}~`{Univalence}.] 0. secs (0.u,0.s)
Chars 3032 - 3065 [Context~(A~B~:~Operations@{U~V}).] 0. secs (0.u,0.s)
Chars 3128 - 3216 [Context~(f~:~A~->~B)~`{!IsEqui...] 0.004 secs (0.003u,0.001s)
Chars 3218 - 3247 [Lemma~iso_same_rings~:~A~=~B.] 0. secs (0.u,0.s)
Chars 3248 - 3254 [Proof.] 0. secs (0.u,0.s)
Chars 350 - 378 [(repeat~(split;~try~apply~_)).] 40.165 secs (0.005u,0.031s)
Chars 350 - 378 [(repeat~(split;~try~apply~_)).] 0. secs (0.u,0.s)
Chars 379 - 383 [Qed.] 0. secs (0.u,0.s)
Chars 385 - 480 [#[global]~Instance~bounded_mee...] 0. secs (0.u,0.s)
Chars 481 - 487 [Proof.] 0. secs (0.u,0.s)
Chars 488 - 516 [(repeat~(split;~try~apply~_)).] 0.087 secs (0.006u,0.028s)
Chars 488 - 516 [(repeat~(split;~try~apply~_)).] 0. secs (0.u,0.s)
Chars 517 - 521 [Qed.] 0. secs (0.u,0.s)
Chars 523 - 602 [#[global]~Instance~bounded_lat...] 0.001 secs (0.001u,0.s)
Chars 603 - 609 [Proof.] 0. secs (0.u,0.s)
Chars 610 - 632 [(repeat~split;~apply~_).] 0.127 secs (0.042u,0.031s)
Chars 610 - 632 [(repeat~split;~apply~_).] 0.003 secs (0.002u,0.001s)
Chars 633 - 637 [Qed.] 0.001 secs (0.001u,0.s)
Chars 639 - 740 [#[global]~Instance~bounded_sl_...] 0.001 secs (0.001u,0.s)
Chars 741 - 747 [Proof.] 0. secs (0.u,0.s)
Chars 2158 - 2205 [(apply~ap10,~(eisretr~(fun~g~=...] 40.17 secs (0.004u,0.025s)
Chars 2158 - 2205 [(apply~ap10,~(eisretr~(fun~g~=...] 0. secs (0.u,0.s)
Chars 2208 - 2216 [Defined.] 0. secs (0.u,0.s)
Chars 2220 - 2339 [Definition~F_coindpaths~{Y}~{X...] 0.004 secs (0.003u,0.001s)
Chars 2342 - 2348 [Proof.] 0. secs (0.u,0.s)
Chars 1409 - 1433 [snrapply~Build_Modality.] 40.165 secs (0.007u,0.028s)
Chars 1436 - 1437 [-] 0. secs (0.u,0.s)
Chars 1438 - 1469 [(intros~X;~exact~(U~->~Contr~X)).] 0.001 secs (0.001u,0.s)
Chars 1472 - 1473 [-] 0. secs (0.u,0.s)
Chars 1474 - 1482 [exact~_.] 0.017 secs (0.011u,0.005s)
Chars 1485 - 1486 [-] 0. secs (0.u,0.s)
Chars 1487 - 1510 [(intros~T~B~T_inO~f~feq).] 0. secs (0.u,0.s)
Chars 1515 - 1545 [(cbn;~intros~u;~pose~(T_inO~u)).] 0.001 secs (0.001u,0.s)
Chars 1550 - 1584 [(refine~(contr_equiv~_~f);~exa...] 0.001 secs (0.u,0.s)
Chars 1587 - 1588 [-] 0. secs (0.u,0.s)
Chars 1589 - 1615 [(intros;~exact~(Join~U~X)).] 0.001 secs (0.001u,0.s)
Chars 1618 - 1619 [-] 0. secs (0.u,0.s)
Chars 1620 - 1631 [(intros~T~u).] 0. secs (0.u,0.s)
Chars 1636 - 1669 [(pose~(contr_inhabited_hprop~_...] 0.004 secs (0.004u,0.s)
Chars 1674 - 1682 [exact~_.] 0.002 secs (0.001u,0.s)
Chars 1685 - 1686 [-] 0. secs (0.u,0.s)
Chars 1687 - 1698 [(intros~T~x).] 0. secs (0.u,0.s)
Chars 1703 - 1724 [exact~(push~(inr~x)).] 0.001 secs (0.001u,0.s)
Chars 1727 - 1728 [-] 0. secs (0.u,0.s)
Chars 1729 - 1750 [(intros~A~B~B_inO~f~z).] 0. secs (0.u,0.s)
Chars 1755 - 1787 [srefine~(Pushout_ind~B~_~_~_~z).] 0.002 secs (0.001u,0.s)
Chars 1792 - 1793 [+] 0. secs (0.u,0.s)
Chars 1794 - 1827 [(intros~u;~apply~center,~B_inO...] 0.002 secs (0.002u,0.s)
Chars 1832 - 1833 [+] 0. secs (0.u,0.s)
Chars 1834 - 1852 [(intros~a;~apply~f).] 0.001 secs (0.001u,0.s)
Chars 1857 - 1858 [+] 0. secs (0.u,0.s)
Chars 1859 - 1872 [(intros~[u~a]).] 0.004 secs (0.004u,0.s)
Chars 1879 - 1909 [(pose~(B_inO~(push~(inr~a))~u)).] 0.002 secs (0.002u,0.s)
Chars 1916 - 1933 [(apply~path_contr).] 0.002 secs (0.002u,0.s)
Chars 1936 - 1937 [-] 0. secs (0.u,0.s)
Chars 1938 - 1958 [(intros;~reflexivity).] 0.006 secs (0.006u,0.s)
Chars 1961 - 1962 [-] 0. secs (0.u,0.s)
Chars 1963 - 1985 [(intros~A~A_inO~z~z'~u).] 0. secs (0.u,0.s)
Chars 1990 - 2005 [(pose~(A_inO~u)).] 0. secs (0.u,0.s)
Chars 2010 - 2034 [(apply~contr_paths_contr).] 0.001 secs (0.001u,0.s)
Chars 1409 - 1433 [snrapply~Build_Modality.] 0. secs (0.u,0.s)
Chars 1438 - 1469 [(intros~X;~exact~(U~->~Contr~X)).] 0. secs (0.u,0.s)
Chars 1474 - 1482 [exact~_.] 0. secs (0.u,0.s)
Chars 1487 - 1510 [(intros~T~B~T_inO~f~feq).] 0. secs (0.u,0.s)
Chars 1515 - 1545 [(cbn;~intros~u;~pose~(T_inO~u)).] 0. secs (0.u,0.s)
Chars 1550 - 1584 [(refine~(contr_equiv~_~f);~exa...] 0. secs (0.u,0.s)
Chars 1589 - 1615 [(intros;~exact~(Join~U~X)).] 0. secs (0.u,0.s)
Chars 1620 - 1631 [(intros~T~u).] 0. secs (0.u,0.s)
Chars 1636 - 1669 [(pose~(contr_inhabited_hprop~_...] 0. secs (0.u,0.s)
Chars 1674 - 1682 [exact~_.] 0. secs (0.u,0.s)
Chars 1687 - 1698 [(intros~T~x).] 0. secs (0.u,0.s)
Chars 1703 - 1724 [exact~(push~(inr~x)).] 0. secs (0.u,0.s)
Chars 1729 - 1750 [(intros~A~B~B_inO~f~z).] 0. secs (0.u,0.s)
Chars 1755 - 1787 [srefine~(Pushout_ind~B~_~_~_~z).] 0. secs (0.u,0.s)
Chars 1794 - 1827 [(intros~u;~apply~center,~B_inO...] 0. secs (0.u,0.s)
Chars 1834 - 1852 [(intros~a;~apply~f).] 0. secs (0.u,0.s)
Chars 1859 - 1872 [(intros~[u~a]).] 0.001 secs (0.001u,0.s)
Chars 1879 - 1909 [(pose~(B_inO~(push~(inr~a))~u)).] 0.001 secs (0.001u,0.s)
Chars 1916 - 1933 [(apply~path_contr).] 0.001 secs (0.001u,0.s)
Chars 1938 - 1958 [(intros;~reflexivity).] 0.004 secs (0.004u,0.s)
Chars 1963 - 1985 [(intros~A~A_inO~z~z'~u).] 0. secs (0.u,0.s)
Chars 1990 - 2005 [(pose~(A_inO~u)).] 0. secs (0.u,0.s)
Chars 2010 - 2034 [(apply~contr_paths_contr).] 0. secs (0.u,0.s)
Chars 2035 - 2043 [Defined.] 0.004 secs (0.004u,0.s)
Chars 2087 - 2159 [#[global]Instance~accmodality_...] 0. secs (0.u,0.s)
Chars 2160 - 2166 [Proof.] 0. secs (0.u,0.s)
Chars 7846 - 7857 [(destruct~c).] 40.168 secs (0.023u,0.03s)
Chars 7862 - 7880 [(apply~cu_fill_top).] 0.006 secs (0.006u,0.s)
Chars 7846 - 7857 [(destruct~c).] 0.002 secs (0.002u,0.s)
Chars 7862 - 7880 [(apply~cu_fill_top).] 0.002 secs (0.002u,0.s)
Chars 7883 - 7891 [Defined.] 0.007 secs (0.002u,0.004s)
Chars 7895 - 8273 [Definition~dc_fill_bottom~(t0i...] 0.016 secs (0.015u,0.s)
Chars 8276 - 8282 [Proof.] 0. secs (0.u,0.s)
Chars 1720 - 1743 [(apply~Build_Is0Functor).] 11.002 secs (0.001u,0.028s)
Chars 1746 - 1759 [(intros~A~B~f).] 0. secs (0.u,0.s)
Chars 1762 - 1865 [refine~~(Build_pMap~(loops~A)~...] 0.004 secs (0.004u,0.s)
Chars 1868 - 1904 [refine~(_~@~concat_Vp~(point_e...] 0.002 secs (0.002u,0.s)
Chars 1907 - 1922 [(apply~whiskerL).] 0.002 secs (0.002u,0.s)
Chars 1923 - 1939 [(apply~concat_1p).] 0.001 secs (0.001u,0.s)
Chars 1720 - 1743 [(apply~Build_Is0Functor).] 0. secs (0.u,0.s)
Chars 1746 - 1759 [(intros~A~B~f).] 0. secs (0.u,0.s)
Chars 1762 - 1865 [refine~~(Build_pMap~(loops~A)~...] 0. secs (0.u,0.s)
Chars 1868 - 1904 [refine~(_~@~concat_Vp~(point_e...] 0. secs (0.u,0.s)
Chars 1907 - 1922 [(apply~whiskerL).] 0. secs (0.u,0.s)
Chars 1923 - 1939 [(apply~concat_1p).] 0. secs (0.u,0.s)
Chars 1940 - 1948 [Defined.] 0.004 secs (0.004u,0.s)
Chars 1950 - 2002 [#[global]Instance~is1functor_l...] 0.032 secs (0.018u,0.013s)
Chars 2003 - 2009 [Proof.] 0. secs (0.u,0.s)
Chars 1734 - 1745 [(destruct~p).] 40.064 secs (0.001u,0.03s)
Chars 1746 - 1781 [exact~(BuildIsomorphic~(hom_id...] 0.003 secs (0.001u,0.002s)
Chars 1734 - 1745 [(destruct~p).] 0. secs (0.u,0.s)
Chars 1746 - 1781 [exact~(BuildIsomorphic~(hom_id...] 0. secs (0.u,0.s)
Chars 1782 - 1790 [Defined.] 0. secs (0.u,0.s)
Chars 1973 - 2183 [Lemma~path_isomorphic~`{Funext...] 0.003 secs (0.002u,0.s)
Chars 2184 - 2190 [Proof.] 0. secs (0.u,0.s)
Chars 4194 - 4553 [refine~~match~w~return~(QuotOp...] 40.248 secs (0.064u,0.055s)
Chars 4558 - 4571 [(intros~[x~a]).] 0.006 secs (0.006u,0.s)
Chars 4576 - 4648 [(apply~(op_quotient_algebra~w'...] 0.007 secs (0.006u,0.001s)
Chars 4194 - 4553 [refine~~match~w~return~(QuotOp...] 0. secs (0.u,0.s)
Chars 4558 - 4571 [(intros~[x~a]).] 0.001 secs (0.001u,0.s)
Chars 4576 - 4648 [(apply~(op_quotient_algebra~w'...] 0.002 secs (0.002u,0.s)
Chars 4651 - 4659 [Defined.] 0.007 secs (0.004u,0.003s)
Chars 4663 - 4825 [Definition~ops_quotient_algebr...] 0.002 secs (0.002u,0.s)
Chars 4968 - 5075 [Definition~QuotientAlgebra~:~A...] 0. secs (0.u,0.s)
Chars 5134 - 5208 [#[global]Instance~hset_quotien...] 0. secs (0.u,0.s)
Chars 5211 - 5217 [Proof.] 0. secs (0.u,0.s)
Chars 5222 - 5230 [intro~s.] 0.615 secs (0.001u,0.031s)
Chars 5231 - 5239 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 5222 - 5230 [intro~s.] 0. secs (0.u,0.s)
Chars 5231 - 5239 [exact~_.] 0. secs (0.u,0.s)
Chars 5242 - 5246 [Qed.] 0. secs (0.u,0.s)
Chars 5644 - 5734 [Lemma~compute_op_quotient~(u~:...] 0.001 secs (0.001u,0.s)
Chars 5737 - 5743 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 2827 - 2892 [rapply~(Build_AbSES~(ab_biprod...] 40.163 secs (0.027u,0.04s)
Chars 2895 - 2918 [snrapply~Build_IsExact.] 0.007 secs (0.007u,0.s)
Chars 2921 - 2922 [-] 0. secs (0.u,0.s)
Chars 2923 - 2947 [srapply~Build_pHomotopy.] 0.002 secs (0.002u,0.s)
Chars 2952 - 2953 [+] 0. secs (0.u,0.s)
Chars 2954 - 2966 [reflexivity.] 0.003 secs (0.002u,0.001s)
Chars 2971 - 2972 [+] 0. secs (0.u,0.s)
Chars 2973 - 2992 [(apply~path_ishprop).] 0.068 secs (0.055u,0.012s)
Chars 2995 - 2996 [-] 0. secs (0.u,0.s)
Chars 2997 - 3029 [(intros~[[a~b]~p];~cbn;~cbn~in...] 0.036 secs (0.025u,0.01s)
Chars 3034 - 3063 [rapply~contr_inhabited_hprop.] 0.036 secs (0.024u,0.012s)
Chars 3068 - 3077 [(apply~tr).] 0.002 secs (0.002u,0.s)
Chars 3082 - 3091 [exists~a.] 0.002 secs (0.001u,0.s)
Chars 3096 - 3125 [(rapply~path_sigma_hprop;~cbn).] 0.093 secs (0.067u,0.021s)
Chars 3130 - 3159 [exact~(path_prod'~idpath~p^).] 0.002 secs (0.002u,0.s)
Chars 2827 - 2892 [rapply~(Build_AbSES~(ab_biprod...] 0. secs (0.u,0.s)
Chars 2895 - 2918 [snrapply~Build_IsExact.] 0. secs (0.u,0.s)
Chars 2923 - 2947 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 2954 - 2966 [reflexivity.] 0. secs (0.u,0.s)
Chars 2973 - 2992 [(apply~path_ishprop).] 0.001 secs (0.001u,0.s)
Chars 2997 - 3029 [(intros~[[a~b]~p];~cbn;~cbn~in...] 0.007 secs (0.007u,0.s)
Chars 3034 - 3063 [rapply~contr_inhabited_hprop.] 0.001 secs (0.001u,0.s)
Chars 3068 - 3077 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 3082 - 3091 [exists~a.] 0. secs (0.u,0.s)
Chars 3096 - 3125 [(rapply~path_sigma_hprop;~cbn).] 0.001 secs (0.001u,0.s)
Chars 3130 - 3159 [exact~(path_prod'~idpath~p^).] 0. secs (0.u,0.s)
Chars 3160 - 3168 [Defined.] 0.036 secs (0.027u,0.008s)
Chars 3220 - 3291 [Definition~AbSES~(B~A~:~AbGrou...] 0.001 secs (0.u,0.001s)
Chars 3325 - 3528 [Definition~abses_path_data_iso...] 0.01 secs (0.007u,0.002s)
Chars 3625 - 3908 [#[local]~Lemma~shuffle_abses_p...] 0.009 secs (0.007u,0.001s)
Chars 3909 - 3915 [Proof.] 0. secs (0.u,0.s)
Chars 1978 - 2309 [simple~refine~~(No_ind_package...] 40.115 secs (0.056u,0.031s)
Chars 2316 - 2317 [-] 0. secs (0.u,0.s)
Chars 2318 - 2380 [(intros~L'~R'~?~yL~yR~ycut~x_p...] 0.002 secs (0.u,0.001s)
Chars 2389 - 2410 [(pose~(L''~:=~L~+~L')).] 0.002 secs (0.002u,0.s)
Chars 2412 - 2433 [(pose~(R''~:=~R~+~R')).] 0.002 secs (0.002u,0.s)
Chars 2442 - 2639 [(pose~~~(zL~:=~~~~sum_ind~(fun...] 0.006 secs (0.006u,0.s)
Chars 2648 - 2845 [(pose~~~(zR~:=~~~~sum_ind~(fun...] 0.006 secs (0.006u,0.s)
Chars 2854 - 2906 [(assert~(zcut~:~forall~(l~:~L'...] 0.003 secs (0.003u,0.s)
Chars 2915 - 2916 [{] 0. secs (0.u,0.s)
Chars 2917 - 3338 [(abstract~(intros~[l|~l]~[r|~r...] 0.035 secs (0.028u,0.005s)
Chars 3339 - 3340 [}] 0. secs (0.u,0.s)
Chars 3349 - 3407 [(assert~(InSort~S~L''~R'')~by~...] 0.005 secs (0.004u,0.s)
Chars 3416 - 3454 [(exists~{{~zL~|~zR~//~zcut~}};...] 0.007 secs (0.006u,0.s)
Chars 3463 - 3464 [+] 0. secs (0.u,0.s)
Chars 3465 - 3474 [(intros~l).] 0.002 secs (0.002u,0.s)
Chars 3485 - 3521 [refine~(lt_lopt~zL~zR~zcut~(in...] 0.007 secs (0.006u,0.s)
Chars 3530 - 3531 [+] 0. secs (0.u,0.s)
Chars 3532 - 3541 [(intros~r).] 0.002 secs (0.002u,0.s)
Chars 3552 - 3588 [refine~(lt_ropt~zL~zR~zcut~(in...] 0.007 secs (0.006u,0.s)
Chars 3595 - 3596 [-] 0. secs (0.u,0.s)
Chars 3597 - 3782 [(abstract~(intros~x~y~[a~?]~[b...] 0.077 secs (0.062u,0.012s)
Chars 3789 - 3790 [-] 0. secs (0.u,0.s)
Chars 3791 - 4507 [(abstract~(intros~L'~R'~?~yL~y...] 0.098 secs (0.072u,0.024s)
Chars 4514 - 4515 [-] 0. secs (0.u,0.s)
Chars 4516 - 4779 [(abstract~(intros~L'~R'~?~yL~y...] 0.036 secs (0.034u,0.001s)
Chars 4786 - 4787 [-] 0. secs (0.u,0.s)
Chars 4788 - 5050 [(abstract~(intros~L'~R'~?~yL~y...] 0.039 secs (0.033u,0.003s)
Chars 1978 - 2309 [simple~refine~~(No_ind_package...] 0.001 secs (0.001u,0.s)
Chars 2318 - 2380 [(intros~L'~R'~?~yL~yR~ycut~x_p...] 0.001 secs (0.001u,0.s)
Chars 2389 - 2410 [(pose~(L''~:=~L~+~L')).] 0.001 secs (0.001u,0.s)
Chars 2412 - 2433 [(pose~(R''~:=~R~+~R')).] 0.001 secs (0.001u,0.s)
Chars 2442 - 2639 [(pose~~~(zL~:=~~~~sum_ind~(fun...] 0.001 secs (0.001u,0.s)
Chars 2648 - 2845 [(pose~~~(zR~:=~~~~sum_ind~(fun...] 0.001 secs (0.001u,0.s)
Chars 2854 - 2906 [(assert~(zcut~:~forall~(l~:~L'...] 0.002 secs (0.002u,0.s)
Chars 2917 - 3338 [(abstract~(intros~[l|~l]~[r|~r...] 0.001 secs (0.001u,0.s)
Chars 3349 - 3407 [(assert~(InSort~S~L''~R'')~by~...] 0.001 secs (0.001u,0.s)
Chars 3416 - 3454 [(exists~{{~zL~|~zR~//~zcut~}};...] 0.004 secs (0.003u,0.001s)
Chars 3465 - 3474 [(intros~l).] 0.002 secs (0.002u,0.s)
Chars 3485 - 3521 [refine~(lt_lopt~zL~zR~zcut~(in...] 0.001 secs (0.001u,0.s)
Chars 3532 - 3541 [(intros~r).] 0.002 secs (0.002u,0.s)
Chars 3552 - 3588 [refine~(lt_ropt~zL~zR~zcut~(in...] 0.002 secs (0.001u,0.001s)
Chars 3597 - 3782 [(abstract~(intros~x~y~[a~?]~[b...] 0.001 secs (0.001u,0.s)
Chars 3791 - 4507 [(abstract~(intros~L'~R'~?~yL~y...] 0.008 secs (0.006u,0.001s)
Chars 4516 - 4779 [(abstract~(intros~L'~R'~?~yL~y...] 0.006 secs (0.006u,0.s)
Chars 4788 - 5050 [(abstract~(intros~L'~R'~?~yL~y...] 0.006 secs (0.006u,0.s)
Chars 5055 - 5063 [Defined.] 0.034 secs (0.03u,0.003s)
Chars 5567 - 6394 [Definition~plus_inner_cut~{L'~...] 0.013 secs (0.013u,0.s)
Chars 6399 - 6405 [Proof.] 0. secs (0.u,0.s)
Chars 5793 - 5802 [funext~i.] 40.213 secs (0.002u,0.036s)
Chars 5805 - 5828 [(apply~expand_cons_dom').] 0.005 secs (0.003u,0.002s)
Chars 5793 - 5802 [funext~i.] 0. secs (0.u,0.s)
Chars 5805 - 5828 [(apply~expand_cons_dom').] 0. secs (0.u,0.s)
Chars 5829 - 5837 [Defined.] 0.002 secs (0.002u,0.s)
Chars 5839 - 6025 [Lemma~path_operation_curry_to_...] 0.003 secs (0.003u,0.s)
Chars 6026 - 6032 [Proof.] 0. secs (0.u,0.s)
Chars 748 - 760 [(red;~apply~_).] 10.778 secs (0.001u,0.03s)
Chars 748 - 760 [(red;~apply~_).] 0. secs (0.u,0.s)
Chars 761 - 765 [Qed.] 0.001 secs (0.001u,0.s)
Chars 767 - 848 [Lemma~preserves_join~`{IsJoinP...] 0.001 secs (0.001u,0.s)
Chars 849 - 855 [Proof.] 0. secs (0.u,0.s)
Chars 1810 - 1834 [(apply~moveR_transport_V).] 40.126 secs (0.003u,0.022s)
Chars 1839 - 1848 [symmetry.] 0.005 secs (0.004u,0.001s)
Chars 1853 - 1872 [(apply~transport_E').] 0.003 secs (0.001u,0.s)
Chars 1810 - 1834 [(apply~moveR_transport_V).] 0.001 secs (0.001u,0.s)
Chars 1839 - 1848 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 1853 - 1872 [(apply~transport_E').] 0.001 secs (0.001u,0.s)
Chars 1875 - 1883 [Defined.] 0.002 secs (0.002u,0.s)
Chars 1887 - 2101 [Definition~transport_E'_V_E'~{...] 0.011 secs (0.008u,0.003s)
Chars 2104 - 2110 [Proof.] 0. secs (0.u,0.s)
Chars 529 - 537 [intro~E.] 40.215 secs (0.u,0.047s)
Chars 540 - 734 [snrapply~~(Build_AbSES~(ab_pul...] 0.017 secs (0.015u,0.s)
Chars 737 - 738 [-] 0. secs (0.u,0.s)
Chars 739 - 747 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 752 - 785 [nrefine~(_~@~(grp_homo_unit~f)^).] 0.003 secs (0.002u,0.s)
Chars 790 - 825 [(apply~isexact_inclusion_proje...] 0.006 secs (0.006u,0.s)
Chars 828 - 829 [-] 0. secs (0.u,0.s)
Chars 830 - 885 [exact~(cancelL_isembedding~(g:...] 0.046 secs (0.04u,0.005s)
Chars 888 - 889 [-] 0. secs (0.u,0.s)
Chars 890 - 916 [rapply~conn_map_pullback'.] 0.007 secs (0.006u,0.001s)
Chars 919 - 920 [-] 0. secs (0.u,0.s)
Chars 921 - 944 [snrapply~Build_IsExact.] 0.04 secs (0.035u,0.004s)
Chars 949 - 950 [+] 0. secs (0.u,0.s)
Chars 951 - 975 [srapply~Build_pHomotopy.] 0.005 secs (0.004u,0.001s)
Chars 982 - 983 [*] 0. secs (0.u,0.s)
Chars 984 - 996 [reflexivity.] 0.005 secs (0.005u,0.s)
Chars 1003 - 1004 [*] 0. secs (0.u,0.s)
Chars 1005 - 1024 [(apply~path_ishprop).] 0.075 secs (0.064u,0.01s)
Chars 1029 - 1030 [+] 0. secs (0.u,0.s)
Chars 1031 - 1152 [nrefine~~(cancelR_equiv_conn_m...] 0.028 secs (0.025u,0.002s)
Chars 1159 - 1257 [nrefine~~(conn_map_homotopic~_...] 0.029 secs (0.026u,0.002s)
Chars 1264 - 1272 [intro~a.] 0.008 secs (0.007u,0.001s)
Chars 1279 - 1305 [by~apply~path_sigma_hprop.] 0.1 secs (0.087u,0.013s)
Chars 529 - 537 [intro~E.] 0. secs (0.u,0.s)
Chars 540 - 734 [snrapply~~(Build_AbSES~(ab_pul...] 0. secs (0.u,0.s)
Chars 739 - 747 [intro~x.] 0. secs (0.u,0.s)
Chars 752 - 785 [nrefine~(_~@~(grp_homo_unit~f)^).] 0. secs (0.u,0.s)
Chars 790 - 825 [(apply~isexact_inclusion_proje...] 0. secs (0.u,0.s)
Chars 830 - 885 [exact~(cancelL_isembedding~(g:...] 0.001 secs (0.u,0.s)
Chars 890 - 916 [rapply~conn_map_pullback'.] 0. secs (0.u,0.s)
Chars 921 - 944 [snrapply~Build_IsExact.] 0.001 secs (0.001u,0.s)
Chars 951 - 975 [srapply~Build_pHomotopy.] 0.001 secs (0.001u,0.s)
Chars 984 - 996 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 1005 - 1024 [(apply~path_ishprop).] 0.004 secs (0.003u,0.s)
Chars 1031 - 1152 [nrefine~~(cancelR_equiv_conn_m...] 0.007 secs (0.006u,0.s)
Chars 1159 - 1257 [nrefine~~(conn_map_homotopic~_...] 0.007 secs (0.006u,0.001s)
Chars 1264 - 1272 [intro~a.] 0.006 secs (0.006u,0.s)
Chars 1279 - 1305 [by~apply~path_sigma_hprop.] 0.007 secs (0.007u,0.s)
Chars 1306 - 1314 [Defined.] 0.11 secs (0.104u,0.005s)
Chars 1433 - 1560 [Definition~abses_pullback_morp...] 0.002 secs (0.002u,0.s)
Chars 1561 - 1567 [Proof.] 0. secs (0.u,0.s)
Chars 3177 - 3199 [unshelve~econstructor.] 40.173 secs (0.u,0.033s)
Chars 3202 - 3203 [-] 0. secs (0.u,0.s)
Chars 3204 - 3212 [exact~S.] 0. secs (0.u,0.s)
Chars 3215 - 3216 [-] 0. secs (0.u,0.s)
Chars 3217 - 3237 [(intros;~reflexivity).] 0.002 secs (0.001u,0.s)
Chars 3177 - 3199 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 3204 - 3212 [exact~S.] 0. secs (0.u,0.s)
Chars 3217 - 3237 [(intros;~reflexivity).] 0. secs (0.u,0.s)
Chars 3238 - 3246 [Defined.] 0. secs (0.u,0.s)
Chars 3316 - 3444 [Definition~lift_accmodality@{a...] 0. secs (0.u,0.s)
Chars 3446 - 3560 [#[global]~Instance~O_eq_lift_a...] 0. secs (0.u,0.s)
Chars 3561 - 3567 [Proof.] 0. secs (0.u,0.s)
Chars 6547 - 6555 [eexists.] 11.725 secs (0.002u,0.025s)
Chars 6795 - 6803 [rel_hnf.] 0.022 secs (0.017u,0.004s)
Chars 6804 - 6816 [reflexivity.] 0.048 secs (0.042u,0.005s)
Chars 6547 - 6555 [eexists.] 0.001 secs (0.001u,0.s)
Chars 6795 - 6803 [rel_hnf.] 0.001 secs (0.001u,0.s)
Chars 6804 - 6816 [reflexivity.] 0.016 secs (0.014u,0.001s)
Chars 6821 - 6825 [Qed.] 0.108 secs (0.094u,0.013s)
Chars 6829 - 6839 [End~Inner.] 0.087 secs (0.075u,0.011s)
Chars 6843 - 7140 [Definition~plus_outer~:~~~{f~~...] 0.004 secs (0.001u,0.002s)
Chars 7143 - 7149 [Proof.] 0. secs (0.u,0.s)
Chars 4479 - 4504 [srapply~Build_DiagramMap.] 40.144 secs (0.001u,0.027s)
Chars 4509 - 4510 [-] 0. secs (0.u,0.s)
Chars 4511 - 4520 [(intros~i).] 0. secs (0.u,0.s)
Chars 4527 - 4559 [srapply~(functor_sigma~idmap~_).] 0.001 secs (0.u,0.s)
Chars 4566 - 4584 [(intros~y;~apply~m).] 0.001 secs (0.001u,0.s)
Chars 4589 - 4590 [-] 0. secs (0.u,0.s)
Chars 4591 - 4618 [(intros~i~j~g~x;~simpl~in~*).] 0.002 secs (0.002u,0.s)
Chars 4623 - 4643 [srapply~path_sigma'.] 0.005 secs (0.003u,0.001s)
Chars 4648 - 4663 [1:~reflexivity.] 0.001 secs (0.001u,0.s)
Chars 4668 - 4674 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 4679 - 4711 [(apply~(DiagramMap_comm~(m~x.1...] 0.002 secs (0.002u,0.s)
Chars 4479 - 4504 [srapply~Build_DiagramMap.] 0. secs (0.u,0.s)
Chars 4511 - 4520 [(intros~i).] 0. secs (0.u,0.s)
Chars 4527 - 4559 [srapply~(functor_sigma~idmap~_).] 0. secs (0.u,0.s)
Chars 4566 - 4584 [(intros~y;~apply~m).] 0. secs (0.u,0.s)
Chars 4591 - 4618 [(intros~i~j~g~x;~simpl~in~*).] 0.001 secs (0.001u,0.s)
Chars 4623 - 4643 [srapply~path_sigma'.] 0. secs (0.u,0.s)
Chars 4648 - 4663 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 4668 - 4674 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 4679 - 4711 [(apply~(DiagramMap_comm~(m~x.1...] 0. secs (0.u,0.s)
Chars 4714 - 4722 [Defined.] 0.002 secs (0.002u,0.s)
Chars 4726 - 4844 [Definition~sigma_diag_functor_...] 0.001 secs (0.001u,0.s)
Chars 4847 - 4853 [Proof.] 0. secs (0.u,0.s)
Chars 6035 - 6043 [intro~a.] 15.653 secs (3.946u,-0.13s)
Chars 2784 - 2870 [refine~~(sq_GGcc~_~(eissect~_~...] 40.217 secs (0.044u,0.032s)
Chars 2873 - 2907 [(apply~moveR_equiv_V,~dp_apD_c...] 0.005 secs (0.005u,0.s)
Chars 2784 - 2870 [refine~~(sq_GGcc~_~(eissect~_~...] 0. secs (0.u,0.s)
Chars 2873 - 2907 [(apply~moveR_equiv_V,~dp_apD_c...] 0.001 secs (0.u,0.s)
Chars 2908 - 2916 [Defined.] 0.011 secs (0.009u,0.001s)
Chars 3104 - 3453 [Definition~Torus_rec_beta_surf...] 0.005 secs (0.004u,0.s)
Chars 3454 - 3460 [Proof.] 0. secs (0.u,0.s)
Chars 3461 - 3470 [Admitted.] 0.001 secs (0.001u,0.s)
Chars 3501 - 3560 [#[global]Instance~ispointed_to...] 0. secs (0.u,0.s)
Chars 2169 - 2191 [unshelve~econstructor.] 31.083 secs (19.269u,0.356s)
Chars 5097 - 5140 [(pose~proof~(A~:~AdjunctionUni...] 40.117 secs (0.001u,0.022s)
Chars 5147 - 5266 [refine~~(_~~~o~(((idtoiso~(C:=...] 0.007 secs (0.007u,0.s)
Chars 5273 - 5372 [refine~~(_~~~o~NaturalTransfor...] 0.003 secs (0.001u,0.001s)
Chars 5379 - 5641 [refine~~((idtoiso~(C:=_~->~_)~...] 0.007 secs (0.005u,0.001s)
Chars 5648 - 5705 [refine~(NaturalTransformation....] 0.002 secs (0.002u,0.s)
Chars 5712 - 5800 [exact~~(NaturalTransformation....] 0.001 secs (0.001u,0.s)
Chars 5097 - 5140 [(pose~proof~(A~:~AdjunctionUni...] 0. secs (0.u,0.s)
Chars 5147 - 5266 [refine~~(_~~~o~(((idtoiso~(C:=...] 0. secs (0.u,0.s)
Chars 5273 - 5372 [refine~~(_~~~o~NaturalTransfor...] 0. secs (0.u,0.s)
Chars 5379 - 5641 [refine~~((idtoiso~(C:=_~->~_)~...] 0. secs (0.u,0.s)
Chars 5648 - 5705 [refine~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 5712 - 5800 [exact~~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 5805 - 5813 [Defined.] 0.004 secs (0.003u,0.s)
Chars 5819 - 5969 [Definition~counit_r~:~~~Natura...] 0.002 secs (0.002u,0.s)
Chars 5974 - 5980 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 3422 - 3447 [snrapply~Build_pHomotopy.] 40.098 secs (0.003u,0.02s)
Chars 3450 - 3489 [1:~(intro~a;~exact~(path_pfora...] 0.003 secs (0.002u,0.s)
Chars 3492 - 3519 [(hnf;~rapply~moveR_equiv_M').] 0.004 secs (0.004u,0.s)
Chars 3522 - 3545 [refine~(_^~@~ap10~_~_).] 0.002 secs (0.002u,0.s)
Chars 3548 - 3596 [2:~exact~path_equiv_path_pfora...] 0.029 secs (0.027u,0.002s)
Chars 3599 - 3618 [(apply~path_pforall).] 0.002 secs (0.002u,0.s)
Chars 3621 - 3664 [refine~((phomotopy_path_pp~_~_...] 0.024 secs (0.014u,0.01s)
Chars 3667 - 3694 [(apply~phomotopy_prewhisker).] 0.003 secs (0.002u,0.s)
Chars 3697 - 3720 [(apply~phomotopy_path_V).] 0.002 secs (0.002u,0.s)
Chars 3422 - 3447 [snrapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 3450 - 3489 [1:~(intro~a;~exact~(path_pfora...] 0.001 secs (0.001u,0.s)
Chars 3492 - 3519 [(hnf;~rapply~moveR_equiv_M').] 0.002 secs (0.002u,0.s)
Chars 3522 - 3545 [refine~(_^~@~ap10~_~_).] 0.001 secs (0.001u,0.s)
Chars 3548 - 3596 [2:~exact~path_equiv_path_pfora...] 0.001 secs (0.001u,0.s)
Chars 3599 - 3618 [(apply~path_pforall).] 0.001 secs (0.001u,0.s)
Chars 3621 - 3664 [refine~((phomotopy_path_pp~_~_...] 0.001 secs (0.001u,0.s)
Chars 3667 - 3694 [(apply~phomotopy_prewhisker).] 0.001 secs (0.001u,0.s)
Chars 3697 - 3720 [(apply~phomotopy_path_V).] 0.001 secs (0.001u,0.s)
Chars 3721 - 3729 [Defined.] 0.017 secs (0.013u,0.003s)
Chars 3824 - 4077 [Definition~functor_pforall_rig...] 0.003 secs (0.003u,0.s)
Chars 4079 - 4455 [Definition~functor2_pforall_ri...] 0.005 secs (0.005u,0.s)
Chars 4456 - 4462 [Proof.] 0. secs (0.u,0.s)
Chars 3255 - 3282 [(apply~path_sigma_uncurried).] 40.152 secs (0.002u,0.024s)
Chars 3283 - 3376 [(destruct~A~as~[TA~[[[[plA~mlA...] 0.164 secs (0.14u,0.023s)
Chars 3377 - 3681 [(change~plA~with~(@plus~TA~plA...] 0.021 secs (0.019u,0.001s)
Chars 3682 - 3707 [exists~(path_universe~f).] 0.005 secs (0.005u,0.s)
Chars 3708 - 3738 [(rewrite~!transport_prod;~simpl).] 0.034 secs (0.03u,0.004s)
Chars 3739 - 3772 [(unfold~Plus,~Mult,~Zero,~One,...] 0.002 secs (0.002u,0.s)
Chars 3773 - 3981 [(repeat~apply~path_prod;~simpl...] 0.105 secs (0.093u,0.011s)
Chars 3982 - 3983 [-] 0. secs (0.u,0.s)
Chars 3984 - 4016 [(rewrite~(preserves_plus~(f:=f...] 0.004 secs (0.003u,0.001s)
Chars 4019 - 4045 [(apply~ap011;~apply~eisretr).] 0.004 secs (0.003u,0.001s)
Chars 4046 - 4047 [-] 0. secs (0.u,0.s)
Chars 4048 - 4080 [(rewrite~(preserves_mult~(f:=f...] 0.004 secs (0.004u,0.s)
Chars 4083 - 4109 [(apply~ap011;~apply~eisretr).] 0.004 secs (0.004u,0.s)
Chars 4110 - 4111 [-] 0. secs (0.u,0.s)
Chars 4112 - 4130 [(apply~preserves_0).] 0.003 secs (0.003u,0.s)
Chars 4131 - 4132 [-] 0. secs (0.u,0.s)
Chars 4133 - 4151 [(apply~preserves_1).] 0.007 secs (0.003u,0.003s)
Chars 4152 - 4153 [-] 0. secs (0.u,0.s)
Chars 4154 - 4188 [(rewrite~(preserves_negate~(f:...] 0.005 secs (0.004u,0.001s)
Chars 4191 - 4208 [(apply~ap,~eisretr).] 0.002 secs (0.002u,0.s)
Chars 3255 - 3282 [(apply~path_sigma_uncurried).] 0. secs (0.u,0.s)
Chars 3283 - 3376 [(destruct~A~as~[TA~[[[[plA~mlA...] 0.007 secs (0.006u,0.001s)
Chars 3377 - 3681 [(change~plA~with~(@plus~TA~plA...] 0.014 secs (0.014u,0.s)
Chars 3682 - 3707 [exists~(path_universe~f).] 0.001 secs (0.u,0.s)
Chars 3708 - 3738 [(rewrite~!transport_prod;~simpl).] 0.004 secs (0.004u,0.s)
Chars 3739 - 3772 [(unfold~Plus,~Mult,~Zero,~One,...] 0.001 secs (0.001u,0.s)
Chars 3773 - 3981 [(repeat~apply~path_prod;~simpl...] 0.024 secs (0.024u,0.s)
Chars 3984 - 4016 [(rewrite~(preserves_plus~(f:=f...] 0. secs (0.u,0.s)
Chars 4019 - 4045 [(apply~ap011;~apply~eisretr).] 0.001 secs (0.001u,0.s)
Chars 4048 - 4080 [(rewrite~(preserves_mult~(f:=f...] 0. secs (0.u,0.s)
Chars 4083 - 4109 [(apply~ap011;~apply~eisretr).] 0.001 secs (0.001u,0.s)
Chars 4112 - 4130 [(apply~preserves_0).] 0. secs (0.u,0.s)
Chars 4133 - 4151 [(apply~preserves_1).] 0. secs (0.u,0.s)
Chars 4154 - 4188 [(rewrite~(preserves_negate~(f:...] 0. secs (0.u,0.s)
Chars 4191 - 4208 [(apply~ap,~eisretr).] 0. secs (0.u,0.s)
Chars 4209 - 4213 [Qed.] 0.06 secs (0.059u,0.s)
Chars 4215 - 4278 [Lemma~iso_leibnitz~:~forall~P~...] 0. secs (0.u,0.s)
Chars 4279 - 4285 [Proof.] 0. secs (0.u,0.s)
Chars 2353 - 2364 [(apply~ap10).] 40.15 secs (0.001u,0.027s)
Chars 2369 - 2415 [refine~(equiv_inj~(fun~k~=>~fr...] 0.121 secs (0.098u,0.02s)
Chars 2420 - 2421 [-] 0. secs (0.u,0.s)
Chars 2422 - 2457 [by~apply~isequiv_fromF_postcom...] 0.001 secs (0.001u,0.s)
Chars 2462 - 2463 [-] 0. secs (0.u,0.s)
Chars 2464 - 2484 [by~apply~path_arrow.] 0.002 secs (0.002u,0.s)
Chars 2353 - 2364 [(apply~ap10).] 0. secs (0.u,0.s)
Chars 2369 - 2415 [refine~(equiv_inj~(fun~k~=>~fr...] 0. secs (0.u,0.s)
Chars 2422 - 2457 [by~apply~isequiv_fromF_postcom...] 0.019 secs (0.009u,0.009s)
Chars 2464 - 2484 [by~apply~path_arrow.] 0. secs (0.u,0.s)
Chars 2487 - 2495 [Defined.] 0. secs (0.u,0.s)
Chars 2550 - 2646 [Definition~F_functor~{X}~{Y}~(...] 0.002 secs (0.002u,0.s)
Chars 2749 - 2816 [#[local]Instance~ishprop_coref...] 0. secs (0.u,0.s)
Chars 2819 - 2825 [Proof.] 0. secs (0.u,0.s)
Chars 2169 - 2191 [unshelve~econstructor.] 40.057 secs (0.001u,0.026s)
Chars 2194 - 2195 [-] 0. secs (0.u,0.s)
Chars 2196 - 2209 [econstructor.] 0. secs (0.u,0.s)
Chars 2214 - 2239 [exact~(fun~_~:~U~=>~Empty).] 0. secs (0.u,0.s)
Chars 2242 - 2243 [-] 0. secs (0.u,0.s)
Chars 2244 - 2260 [(intros~X;~split).] 0.001 secs (0.001u,0.s)
Chars 2265 - 2266 [+] 0. secs (0.u,0.s)
Chars 2267 - 2282 [(intros~X_inO~u).] 0. secs (0.u,0.s)
Chars 2289 - 2304 [(pose~(X_inO~u)).] 0.001 secs (0.u,0.s)
Chars 2311 - 2345 [(apply~ooextendable_contr;~exa...] 0.004 secs (0.003u,0.s)
Chars 2350 - 2351 [+] 0. secs (0.u,0.s)
Chars 2352 - 2365 [(intros~ext~u).] 0.001 secs (0.001u,0.s)
Chars 2372 - 2426 [(exists~((fst~(ext~u~1%nat)~Em...] 0.003 secs (0.003u,0.s)
Chars 2433 - 2453 [(unfold~const~in~ext).] 0. secs (0.u,0.s)
Chars 2460 - 2577 [exact~~((fst~(snd~(ext~u~2)~(f...] 0.005 secs (0.005u,0.s)
Chars 2169 - 2191 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 2196 - 2209 [econstructor.] 0. secs (0.u,0.s)
Chars 2214 - 2239 [exact~(fun~_~:~U~=>~Empty).] 0. secs (0.u,0.s)
Chars 2244 - 2260 [(intros~X;~split).] 0. secs (0.u,0.s)
Chars 2267 - 2282 [(intros~X_inO~u).] 0. secs (0.u,0.s)
Chars 2289 - 2304 [(pose~(X_inO~u)).] 0. secs (0.u,0.s)
Chars 2311 - 2345 [(apply~ooextendable_contr;~exa...] 0.001 secs (0.001u,0.s)
Chars 2352 - 2365 [(intros~ext~u).] 0. secs (0.u,0.s)
Chars 2372 - 2426 [(exists~((fst~(ext~u~1%nat)~Em...] 0. secs (0.u,0.s)
Chars 2433 - 2453 [(unfold~const~in~ext).] 0. secs (0.u,0.s)
Chars 2460 - 2577 [exact~~((fst~(snd~(ext~u~2)~(f...] 0. secs (0.u,0.s)
Chars 2578 - 2586 [Defined.] 0.003 secs (0.001u,0.001s)
Chars 2816 - 2892 [#[local]Instance~topological_c...] 0.007 secs (0.007u,0.s)
Chars 2894 - 2962 [#[global]Instance~lex_closed~~...] 0. secs (0.u,0.s)
Chars 2963 - 2969 [Proof.] 0. secs (0.u,0.s)
Chars 2972 - 2995 [rapply~lex_topological.] 0.097 secs (0.008u,0.028s)
Chars 2972 - 2995 [rapply~lex_topological.] 0. secs (0.u,0.s)
Chars 2996 - 3004 [Defined.] 0.001 secs (0.u,0.s)
Chars 3066 - 3155 [Definition~Cl'~(U~:~HProp)~:~M...] 0. secs (0.u,0.s)
Chars 8287 - 8298 [(destruct~c).] 40.166 secs (0.026u,0.028s)
Chars 8303 - 8324 [(apply~cu_fill_bottom).] 0.006 secs (0.004u,0.002s)
Chars 8287 - 8298 [(destruct~c).] 0.002 secs (0.002u,0.s)
Chars 8303 - 8324 [(apply~cu_fill_bottom).] 0.002 secs (0.002u,0.s)
Chars 8327 - 8335 [Defined.] 0.016 secs (0.015u,0.s)
Chars 8339 - 8764 [Definition~dc_fill_front~(t0ii...] 0.016 secs (0.013u,0.002s)
Chars 8767 - 8773 [Proof.] 0. secs (0.u,0.s)
Chars 2012 - 2035 [(apply~Build_Is1Functor).] 40.156 secs (0.001u,0.028s)
Chars 2065 - 2066 [-] 0. secs (0.u,0.s)
Chars 2067 - 2084 [(intros~A~B~f~g~p).] 0. secs (0.u,0.s)
Chars 2193 - 2233 [(apply~(ap~(issig_isomorphic~A...] 40.185 secs (0.028u,0.032s)
Chars 2236 - 2255 [srapply~path_sigma.] 0.003 secs (0.002u,0.s)
Chars 2258 - 2259 [-] 0. secs (0.u,0.s)
Chars 2260 - 2268 [exact~a.] 0.001 secs (0.001u,0.s)
Chars 2271 - 2272 [-] 0. secs (0.u,0.s)
Chars 2273 - 2296 [(apply~path_sigma_hprop).] 0.013 secs (0.012u,0.s)
Chars 2301 - 2341 [refine~(ap~_~(transport_sigma~...] 0.004 secs (0.004u,0.s)
Chars 2346 - 2354 [(apply~b).] 0.002 secs (0.u,0.001s)
Chars 2193 - 2233 [(apply~(ap~(issig_isomorphic~A...] 0. secs (0.u,0.s)
Chars 2236 - 2255 [srapply~path_sigma.] 0. secs (0.u,0.s)
Chars 2260 - 2268 [exact~a.] 0. secs (0.u,0.s)
Chars 2273 - 2296 [(apply~path_sigma_hprop).] 0.001 secs (0.u,0.s)
Chars 2301 - 2341 [refine~(ap~_~(transport_sigma~...] 0.001 secs (0.u,0.s)
Chars 2346 - 2354 [(apply~b).] 0.001 secs (0.001u,0.s)
Chars 2355 - 2363 [Defined.] 0.009 secs (0.009u,0.s)
Chars 2544 - 2708 [Lemma~path_hset_isomorphic~`{F...] 0.002 secs (0.002u,0.s)
Chars 2709 - 2715 [Proof.] 0. secs (0.u,0.s)
Chars 2089 - 2104 [pointed_reduce.] 0.119 secs (0.097u,0.021s)
Chars 2109 - 2138 [(srapply~Build_pHomotopy;~cbn).] 0.013 secs (0.012u,0.s)
Chars 2143 - 2144 [{] 0. secs (0.u,0.s)
Chars 2145 - 2153 [intro~q.] 0.001 secs (0.001u,0.s)
Chars 2160 - 2205 [refine~((_~@~(concat_p1~_)^)~@...] 0.003 secs (0.002u,0.s)
Chars 2212 - 2227 [(apply~moveR_Vp).] 0.002 secs (0.001u,0.s)
Chars 2234 - 2271 [(apply~(concat_Ap~(fun~x~=>~p~...] 0.002 secs (0.002u,0.s)
Chars 2272 - 2273 [}] 0. secs (0.u,0.s)
Chars 2278 - 2284 [(simpl).] 0.007 secs (0.004u,0.002s)
Chars 2285 - 2307 [(generalize~(p~point0)).] 0.007 secs (0.006u,0.s)
Chars 2308 - 2330 [(generalize~(g~point0)).] 0.007 secs (0.005u,0.002s)
Chars 2335 - 2347 [(intros~_~[]).] 0.009 secs (0.008u,0.s)
Chars 2348 - 2360 [reflexivity.] 0.005 secs (0.005u,0.s)
Chars 2398 - 2399 [-] 0. secs (0.u,0.s)
Chars 2400 - 2409 [(intros~A).] 0. secs (0.u,0.s)
Chars 2414 - 2438 [srapply~Build_pHomotopy.] 0.002 secs (0.002u,0.s)
Chars 2443 - 2444 [{] 0. secs (0.u,0.s)
Chars 2445 - 2453 [intro~p.] 0. secs (0.u,0.s)
Chars 2460 - 2508 [refine~((concat_1p~_~@~concat_...] 0.003 secs (0.002u,0.001s)
Chars 2509 - 2510 [}] 0. secs (0.u,0.s)
Chars 2515 - 2527 [reflexivity.] 0.004 secs (0.004u,0.s)
Chars 2567 - 2568 [-] 0. secs (0.u,0.s)
Chars 2569 - 2586 [(intros~A~B~c~g~f).] 0.001 secs (0.001u,0.s)
Chars 2591 - 2615 [srapply~Build_pHomotopy.] 0.035 secs (0.027u,0.007s)
Chars 2620 - 2621 [{] 0. secs (0.u,0.s)
Chars 2622 - 2631 [(intros~p).] 0. secs (0.u,0.s)
Chars 2632 - 2636 [(cbn).] 0.003 secs (0.002u,0.001s)
Chars 2643 - 2694 [refine~(((inv_pp~_~_~@@~1)~@~c...] 0.005 secs (0.005u,0.s)
Chars 2701 - 2716 [(apply~whiskerL).] 0.003 secs (0.002u,0.s)
Chars 2723 - 2799 [refine~~(((((ap_V~_~_)^~@@~1)~...] 0.008 secs (0.006u,0.002s)
Chars 2806 - 2821 [(apply~whiskerL).] 0.002 secs (0.u,0.001s)
Chars 2828 - 2883 [refine~((_~@~concat_p_pp~_~_~_...] 0.006 secs (0.006u,0.s)
Chars 2890 - 2905 [(apply~whiskerR).] 0.002 secs (0.u,0.001s)
Chars 2912 - 2929 [(apply~ap_compose).] 0.002 secs (0.002u,0.s)
Chars 2930 - 2931 [}] 0. secs (0.u,0.s)
Chars 2718 - 2748 [(apply~(path_isomorphic~F~G~a)).] 0.757 secs (0.002u,0.03s)
Chars 2749 - 2768 [(apply~path_ishprop).] 0.005 secs (0.004u,0.s)
Chars 2718 - 2748 [(apply~(path_isomorphic~F~G~a)).] 0. secs (0.u,0.s)
Chars 2749 - 2768 [(apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 2769 - 2777 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2779 - 2820 [Section~path_def_isomorphic_id...] 0. secs (0.u,0.s)
Chars 2823 - 2867 [Context~{σ~:~Signature}~{A~B~:...] 0. secs (0.u,0.s)
Chars 2871 - 3038 [Lemma~path_def_isomorphic_id_t...] 0.002 secs (0.002u,0.s)
Chars 3041 - 3047 [Proof.] 0. secs (0.u,0.s)
Chars 3052 - 3070 [by~path_induction.] 0.108 secs (0.001u,0.032s)
Chars 3052 - 3070 [by~path_induction.] 0. secs (0.u,0.s)
Chars 3073 - 3081 [Defined.] 0. secs (0.u,0.s)
Chars 3085 - 3251 [Lemma~path_def_isomorphic_id_t...] 0.002 secs (0.002u,0.s)
Chars 3254 - 3260 [Proof.] 0. secs (0.u,0.s)
Chars 3265 - 3283 [by~path_induction.] 0.07 secs (0.001u,0.03s)
Chars 3265 - 3283 [by~path_induction.] 0. secs (0.u,0.s)
Chars 3286 - 3294 [Defined.] 0.001 secs (0.001u,0.s)
Chars 3295 - 3332 [End~path_def_isomorphic_id_tra...] 0.003 secs (0.003u,0.s)
Chars 3665 - 3815 [Lemma~path_path_isomorphism_ho...] 0.003 secs (0.003u,0.s)
Chars 3816 - 3822 [Proof.] 0. secs (0.u,0.s)
Chars 2936 - 2954 [by~pointed_reduce.] 0.864 secs (0.821u,0.034s)
Chars 2012 - 2035 [(apply~Build_Is1Functor).] 0. secs (0.u,0.s)
Chars 2067 - 2084 [(intros~A~B~f~g~p).] 0. secs (0.u,0.s)
Chars 2089 - 2104 [pointed_reduce.] 0. secs (0.u,0.s)
Chars 2109 - 2138 [(srapply~Build_pHomotopy;~cbn).] 0.005 secs (0.005u,0.s)
Chars 2145 - 2153 [intro~q.] 0. secs (0.u,0.s)
Chars 2160 - 2205 [refine~((_~@~(concat_p1~_)^)~@...] 0. secs (0.u,0.s)
Chars 2212 - 2227 [(apply~moveR_Vp).] 0. secs (0.u,0.s)
Chars 2234 - 2271 [(apply~(concat_Ap~(fun~x~=>~p~...] 0. secs (0.u,0.s)
Chars 2278 - 2284 [(simpl).] 0.002 secs (0.002u,0.s)
Chars 2285 - 2307 [(generalize~(p~point0)).] 0.001 secs (0.001u,0.s)
Chars 2308 - 2330 [(generalize~(g~point0)).] 0.001 secs (0.001u,0.s)
Chars 2335 - 2347 [(intros~_~[]).] 0.001 secs (0.001u,0.s)
Chars 2348 - 2360 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 2400 - 2409 [(intros~A).] 0. secs (0.u,0.s)
Chars 2414 - 2438 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 2445 - 2453 [intro~p.] 0. secs (0.u,0.s)
Chars 2460 - 2508 [refine~((concat_1p~_~@~concat_...] 0. secs (0.u,0.s)
Chars 2515 - 2527 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 2569 - 2586 [(intros~A~B~c~g~f).] 0. secs (0.u,0.s)
Chars 2591 - 2615 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 2622 - 2631 [(intros~p).] 0. secs (0.u,0.s)
Chars 2632 - 2636 [(cbn).] 0. secs (0.u,0.s)
Chars 2643 - 2694 [refine~(((inv_pp~_~_~@@~1)~@~c...] 0.001 secs (0.001u,0.s)
Chars 2701 - 2716 [(apply~whiskerL).] 0.001 secs (0.001u,0.s)
Chars 2723 - 2799 [refine~~(((((ap_V~_~_)^~@@~1)~...] 0.001 secs (0.001u,0.s)
Chars 2806 - 2821 [(apply~whiskerL).] 0.001 secs (0.001u,0.s)
Chars 2828 - 2883 [refine~((_~@~concat_p_pp~_~_~_...] 0. secs (0.u,0.s)
Chars 2890 - 2905 [(apply~whiskerR).] 0. secs (0.u,0.s)
Chars 2912 - 2929 [(apply~ap_compose).] 0. secs (0.u,0.s)
Chars 2936 - 2954 [by~pointed_reduce.] 0.009 secs (0.009u,0.s)
Chars 2955 - 2963 [Defined.] 0.477 secs (0.457u,0.005s)
Chars 3057 - 3180 [Lemma~fmap_loops_pp~{X~Y~:~pTy...] 0.005 secs (0.005u,0.s)
Chars 3181 - 3187 [Proof.] 0. secs (0.u,0.s)
Chars 5748 - 5774 [(apply~op_quotient_algebra).] 40.143 secs (0.002u,0.031s)
Chars 5748 - 5774 [(apply~op_quotient_algebra).] 0. secs (0.u,0.s)
Chars 5777 - 5785 [Defined.] 0. secs (0.u,0.s)
Chars 5786 - 5807 [End~quotient_algebra.] 0.035 secs (0.034u,0.s)
Chars 5809 - 5843 [Module~quotient_algebra_notati...] 0. secs (0.u,0.s)
Chars 5846 - 5913 [#[global]Notation~"A~/~Φ"~:=~(...] 0. secs (0.u,0.s)
Chars 5914 - 5945 [End~quotient_algebra_notations.] 0. secs (0.u,0.s)
Chars 5947 - 5981 [Import~quotient_algebra_notati...] 0. secs (0.u,0.s)
Chars 6091 - 6121 [Section~path_quotient_algebra.] 0. secs (0.u,0.s)
Chars 6124 - 6288 [Context~{σ~:~Signature}~(A~:~A...] 0.002 secs (0.001u,0.s)
Chars 6292 - 6358 [Lemma~path_quotient_algebra~`{...] 0.002 secs (0.001u,0.s)
Chars 6361 - 6367 [Proof.] 0. secs (0.u,0.s)
Chars 3918 - 3960 [(srapply~equiv_functor_sigma_i...] 40.139 secs (0.003u,0.033s)
Chars 3963 - 3991 [srapply~equiv_functor_prod'.] 0.003 secs (0.002u,0.s)
Chars 3994 - 4015 [1:~exact~equiv_idmap.] 0.001 secs (0.001u,0.s)
Chars 4018 - 4071 [(srapply~(equiv_functor_forall...] 0.006 secs (0.006u,0.s)
Chars 4074 - 4095 [(apply~equiv_concat_r).] 0.001 secs (0.u,0.s)
Chars 4098 - 4125 [exact~(ap~_~(eisretr~_~_)).] 0.002 secs (0.001u,0.001s)
Chars 3918 - 3960 [(srapply~equiv_functor_sigma_i...] 0.001 secs (0.001u,0.s)
Chars 3963 - 3991 [srapply~equiv_functor_prod'.] 0. secs (0.u,0.s)
Chars 3994 - 4015 [1:~exact~equiv_idmap.] 0. secs (0.u,0.s)
Chars 4018 - 4071 [(srapply~(equiv_functor_forall...] 0.002 secs (0.002u,0.s)
Chars 4074 - 4095 [(apply~equiv_concat_r).] 0. secs (0.u,0.s)
Chars 4098 - 4125 [exact~(ap~_~(eisretr~_~_)).] 0. secs (0.u,0.s)
Chars 4126 - 4134 [Defined.] 0.008 secs (0.005u,0.002s)
Chars 4332 - 4451 [Proposition~equiv_path_abses_i...] 0.001 secs (0.001u,0.s)
Chars 4452 - 4458 [Proof.] 0. secs (0.u,0.s)
Chars 6035 - 6043 [intro~a.] 40.084 secs (0.001u,0.036s)
Chars 6046 - 6071 [(induction~n~as~[|~n~IHn]).] 0.002 secs (0.002u,0.s)
Chars 6074 - 6075 [-] 0. secs (0.u,0.s)
Chars 6076 - 6085 [funext~d.] 0.001 secs (0.001u,0.s)
Chars 6086 - 6102 [refine~(ap~a~_).] 0.001 secs (0.001u,0.s)
Chars 6103 - 6120 [(apply~path_contr).] 0.003 secs (0.002u,0.s)
Chars 6123 - 6124 [-] 0. secs (0.u,0.s)
Chars 6125 - 6135 [funext~a'.] 0.002 secs (0.002u,0.s)
Chars 6140 - 6181 [refine~(ap~(fun~x~=>~x~_)~(IHn...] 0.004 secs (0.004u,0.s)
Chars 6186 - 6202 [refine~(ap~a~_).] 0.002 secs (0.002u,0.s)
Chars 6207 - 6229 [(apply~expand_cons_dom).] 0.004 secs (0.003u,0.s)
Chars 6035 - 6043 [intro~a.] 0. secs (0.u,0.s)
Chars 6046 - 6071 [(induction~n~as~[|~n~IHn]).] 0. secs (0.u,0.s)
Chars 6076 - 6085 [funext~d.] 0. secs (0.u,0.s)
Chars 6086 - 6102 [refine~(ap~a~_).] 0. secs (0.u,0.s)
Chars 6103 - 6120 [(apply~path_contr).] 0. secs (0.u,0.s)
Chars 6125 - 6135 [funext~a'.] 0. secs (0.u,0.s)
Chars 6140 - 6181 [refine~(ap~(fun~x~=>~x~_)~(IHn...] 0.001 secs (0.001u,0.s)
Chars 6186 - 6202 [refine~(ap~a~_).] 0.001 secs (0.001u,0.s)
Chars 6207 - 6229 [(apply~expand_cons_dom).] 0.001 secs (0.001u,0.s)
Chars 6230 - 6234 [Qed.] 0.012 secs (0.01u,0.001s)
Chars 6236 - 6422 [Lemma~path_operation_uncurry_t...] 0.003 secs (0.002u,0.001s)
Chars 6423 - 6429 [Proof.] 0. secs (0.u,0.s)
Chars 856 - 878 [(apply~preserves_sg_op).] 40.165 secs (0.u,0.03s)
Chars 856 - 878 [(apply~preserves_sg_op).] 0. secs (0.u,0.s)
Chars 879 - 883 [Qed.] 0. secs (0.u,0.s)
Chars 885 - 957 [Lemma~preserves_bottom~`{IsBou...] 0.001 secs (0.001u,0.s)
Chars 958 - 964 [Proof.] 0. secs (0.u,0.s)
Chars 965 - 990 [(apply~preserves_mon_unit).] 0.089 secs (0.002u,0.028s)
Chars 965 - 990 [(apply~preserves_mon_unit).] 0. secs (0.u,0.s)
Chars 991 - 995 [Qed.] 0. secs (0.u,0.s)
Chars 997 - 1078 [Lemma~preserves_meet~`{IsMeetP...] 0.001 secs (0.001u,0.s)
Chars 1079 - 1085 [Proof.] 0. secs (0.u,0.s)
Chars 1086 - 1108 [(apply~preserves_sg_op).] 0.094 secs (0.001u,0.028s)
Chars 1086 - 1108 [(apply~preserves_sg_op).] 0. secs (0.u,0.s)
Chars 1109 - 1113 [Qed.] 0. secs (0.u,0.s)
Chars 1115 - 1145 [Section~bounded_join_sl_props.] 0. secs (0.u,0.s)
Chars 1148 - 1186 [Context~`{IsBoundedJoinSemiLat...] 0. secs (0.u,0.s)
Chars 1190 - 1242 [Instance~join_bottom_l~:~(Left...] 0.003 secs (0.002u,0.s)
Chars 1245 - 1298 [Instance~join_bottom_r~:~(Righ...] 0.005 secs (0.002u,0.001s)
Chars 1299 - 1325 [End~bounded_join_sl_props.] 0. secs (0.u,0.s)
Chars 1327 - 1349 [Section~lattice_props.] 0. secs (0.u,0.s)
Chars 1352 - 1375 [Context~`{IsLattice~L}.] 0. secs (0.u,0.s)
Chars 1379 - 1455 [Definition~meet_join_absorptio...] 0.002 secs (0.001u,0.s)
Chars 1458 - 1534 [Definition~join_meet_absorptio...] 0.003 secs (0.002u,0.s)
Chars 1535 - 1553 [End~lattice_props.] 0. secs (0.u,0.s)
Chars 1555 - 1590 [Section~distributive_lattice_p...] 0. secs (0.u,0.s)
Chars 1593 - 1628 [Context~`{IsDistributiveLattic...] 0. secs (0.u,0.s)
Chars 1632 - 1687 [Instance~join_meet_distr_l~:~(...] 0. secs (0.u,0.s)
Chars 1690 - 1696 [Proof.] 0. secs (0.u,0.s)
Chars 1697 - 1725 [exact~(join_meet_distr_l~_).] 0.075 secs (0.001u,0.027s)
Chars 1697 - 1725 [exact~(join_meet_distr_l~_).] 0. secs (0.u,0.s)
Chars 1726 - 1730 [Qed.] 0. secs (0.u,0.s)
Chars 1734 - 1797 [#[global]Instance~join_meet_di...] 0. secs (0.u,0.s)
Chars 1800 - 1806 [Proof.] 0. secs (0.u,0.s)
Chars 2115 - 2150 [(rewrite~moveR_transport_V_V,~...] 40.164 secs (0.026u,0.023s)
Chars 2155 - 2197 [(symmetry;~apply~ap_transport_...] 0.015 secs (0.015u,0.s)
Chars 2115 - 2150 [(rewrite~moveR_transport_V_V,~...] 0.002 secs (0.002u,0.s)
Chars 2155 - 2197 [(symmetry;~apply~ap_transport_...] 0.005 secs (0.004u,0.001s)
Chars 2200 - 2208 [Defined.] 0.031 secs (0.028u,0.002s)
Chars 2304 - 2361 [Definition~cocone_E'~:~Cocone~...] 0.001 secs (0.001u,0.s)
Chars 2364 - 2370 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 1570 - 1617 [snrapply~(Build_AbSESMorphism~...] 40.222 secs (0.005u,0.047s)
Chars 1620 - 1621 [-] 0. secs (0.u,0.s)
Chars 1622 - 1645 [(apply~grp_pullback_pr1).] 0.003 secs (0.003u,0.s)
Chars 1648 - 1649 [-] 0. secs (0.u,0.s)
Chars 1650 - 1662 [reflexivity.] 0.008 secs (0.006u,0.001s)
Chars 1665 - 1666 [-] 0. secs (0.u,0.s)
Chars 1667 - 1689 [(apply~pullback_commsq).] 0.034 secs (0.029u,0.004s)
Chars 1570 - 1617 [snrapply~(Build_AbSESMorphism~...] 0. secs (0.u,0.s)
Chars 1622 - 1645 [(apply~grp_pullback_pr1).] 0. secs (0.u,0.s)
Chars 1650 - 1662 [reflexivity.] 0. secs (0.u,0.s)
Chars 1667 - 1689 [(apply~pullback_commsq).] 0. secs (0.u,0.s)
Chars 1690 - 1698 [Defined.] 0.009 secs (0.007u,0.002s)
Chars 1803 - 1986 [Definition~abses_pullback_morp...] 0.003 secs (0.003u,0.s)
Chars 1987 - 1993 [Proof.] 0. secs (0.u,0.s)
Chars 3570 - 3608 [(split;~intros~A;~apply~inO_if...] 40.167 secs (0.005u,0.033s)
Chars 3570 - 3608 [(split;~intros~A;~apply~inO_if...] 0. secs (0.u,0.s)
Chars 3609 - 3617 [Defined.] 0.001 secs (0.001u,0.s)
Chars 7154 - 7630 [refine~~(No_rec_package~~~~~{g...] 40.201 secs (0.056u,0.036s)
Chars 7635 - 7636 [-] 0. secs (0.u,0.s)
Chars 7637 - 7797 [(abstract~(intros~[g~?]~[h~?]~...] 0.102 secs (0.094u,0.007s)
Chars 7802 - 7803 [-] 0. secs (0.u,0.s)
Chars 7804 - 9006 [(abstract~(intros~L~R~?~xL~xR~...] 0.226 secs (0.201u,0.021s)
Chars 9011 - 9012 [-] 0. secs (0.u,0.s)
Chars 9013 - 9703 [(abstract~(intros~L~R~?~xL~xR~...] 0.158 secs (0.152u,0.006s)
Chars 9708 - 9709 [-] 0. secs (0.u,0.s)
Chars 9710 - 10400 [(abstract~(intros~L~R~?~xL~xR~...] 0.134 secs (0.129u,0.s)
Chars 7154 - 7630 [refine~~(No_rec_package~~~~~{g...] 0. secs (0.u,0.s)
Chars 7637 - 7797 [(abstract~(intros~[g~?]~[h~?]~...] 0. secs (0.u,0.s)
Chars 7804 - 9006 [(abstract~(intros~L~R~?~xL~xR~...] 0.002 secs (0.002u,0.s)
Chars 9013 - 9703 [(abstract~(intros~L~R~?~xL~xR~...] 0.001 secs (0.001u,0.s)
Chars 9710 - 10400 [(abstract~(intros~L~R~?~xL~xR~...] 0.001 secs (0.001u,0.s)
Chars 10403 - 10411 [Defined.] 0.021 secs (0.02u,0.s)
Chars 10415 - 10475 [Definition~plus~(x~y~:~No)~:~N...] 0.003 secs (0.003u,0.s)
Chars 10479 - 10513 [Infix~"+"~:=~plus~:~surreal_sc...] 0. secs (0.u,0.s)
Chars 10517 - 10625 [Definition~plus_le_l~(x~x'~y~:...] 0.017 secs (0.016u,0.s)
Chars 10629 - 10735 [Definition~plus_lt_l~(x~x'~y~:...] 0.012 secs (0.012u,0.s)
Chars 10739 - 10849 [Definition~plus_le_r~(x~y~y'~:...] 0.014 secs (0.014u,0.s)
Chars 10853 - 10961 [Definition~plus_lt_r~(x~y~y'~:...] 0.013 secs (0.013u,0.s)
Chars 11048 - 12125 [Definition~plus_cut~{L~R~:~Typ...] 0.231 secs (0.227u,0.003s)
Chars 12360 - 12650 [Ltac~~do_plus_cut~:=~~~repeat~...] 0. secs (0.u,0.s)
Chars 13425 - 13450 [#[local]Opaque~No_cut~plus.] 0. secs (0.u,0.s)
Chars 13499 - 13529 [#[local]Unset~Keyed~Unification.] 0. secs (0.u,0.s)
Chars 13584 - 15414 [Tactic~Notation~"one_line_proo...] 0. secs (0.u,0.s)
Chars 15524 - 15569 [Theorem~plus_comm~(x~y~:~No)~:...] 0.004 secs (0.004u,0.s)
Chars 15572 - 15578 [Proof.] 0. secs (0.u,0.s)
Chars 4858 - 4914 [srapply~(Build_diagram_equiv~(...] 40.218 secs (0.054u,0.038s)
Chars 4919 - 4928 [(intros~i).] 0. secs (0.u,0.s)
Chars 4933 - 4963 [srapply~isequiv_functor_sigma.] 0.04 secs (0.032u,0.002s)
Chars 4968 - 4986 [(intros~y;~apply~m).] 0.002 secs (0.002u,0.s)
Chars 4858 - 4914 [srapply~(Build_diagram_equiv~(...] 0. secs (0.u,0.s)
Chars 4919 - 4928 [(intros~i).] 0. secs (0.u,0.s)
Chars 4933 - 4963 [srapply~isequiv_functor_sigma.] 0. secs (0.u,0.s)
Chars 4968 - 4986 [(intros~y;~apply~m).] 0.001 secs (0.001u,0.s)
Chars 4989 - 4997 [Defined.] 0. secs (0.u,0.s)
Chars 4999 - 5016 [End~SigmaDiagram.] 0.012 secs (0.011u,0.s)
find_witness Control.TimeoutChars 5987 - 6032 [(pose~proof~(A~:~AdjunctionCou...] 40.132 secs (0.002u,0.021s)
Chars 6039 - 6155 [refine~~(((idtoiso~(C:=_~->~_)...] 0.006 secs (0.006u,0.s)
Chars 6162 - 6261 [refine~~(NaturalTransformation...] 0.003 secs (0.002u,0.s)
Chars 6268 - 6556 [refine~~(_~~~o~(((idtoiso~(C:=...] 0.01 secs (0.01u,0.s)
Chars 6563 - 6620 [refine~(NaturalTransformation....] 0.002 secs (0.001u,0.s)
Chars 6627 - 6715 [exact~~(NaturalTransformation....] 0.001 secs (0.001u,0.s)
Chars 5987 - 6032 [(pose~proof~(A~:~AdjunctionCou...] 0. secs (0.u,0.s)
Chars 6039 - 6155 [refine~~(((idtoiso~(C:=_~->~_)...] 0. secs (0.u,0.s)
Chars 6162 - 6261 [refine~~(NaturalTransformation...] 0. secs (0.u,0.s)
Chars 6268 - 6556 [refine~~(_~~~o~(((idtoiso~(C:=...] 0. secs (0.u,0.s)
Chars 6563 - 6620 [refine~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 6627 - 6715 [exact~~(NaturalTransformation....] 0. secs (0.u,0.s)
Chars 6720 - 6728 [Defined.] 0.004 secs (0.003u,0.s)
Chars 6734 - 6780 [Create~HintDb~adjoint_pointwis...] 0. secs (0.u,0.s)
Chars 6785 - 7001 [Hint~Rewrite~~identity_of~left...] 0.002 secs (0.001u,0.s)
Chars 7007 - 7085 [Definition~pointwise_r~:~point...] 0.002 secs (0.001u,0.001s)
Chars 7090 - 7096 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 4465 - 4489 [srapply~Build_pHomotopy.] 40.129 secs (0.002u,0.019s)
Chars 4492 - 4496 [1:~{] 0. secs (0.u,0.s)
Chars 4497 - 4505 [intro~a.] 0.001 secs (0.001u,0.s)
Chars 4506 - 4543 [refine~(p~a~(f~a)~@~ap~(g'~a)~...] 0.005 secs (0.003u,0.s)
Chars 4544 - 4545 [}] 0. secs (0.u,0.s)
Chars 4548 - 4571 [pointed_reduce_rewrite.] 0.182 secs (0.141u,0.039s)
Chars 4572 - 4581 [symmetry.] 0.002 secs (0.002u,0.s)
Chars 4582 - 4598 [(apply~concat_Ap).] 0.002 secs (0.002u,0.s)
Chars 4465 - 4489 [srapply~Build_pHomotopy.] 0.001 secs (0.u,0.s)
Chars 4497 - 4505 [intro~a.] 0.001 secs (0.u,0.001s)
Chars 4506 - 4543 [refine~(p~a~(f~a)~@~ap~(g'~a)~...] 0.001 secs (0.001u,0.s)
Chars 4548 - 4571 [pointed_reduce_rewrite.] 0.002 secs (0.002u,0.s)
Chars 4572 - 4581 [symmetry.] 0. secs (0.u,0.s)
Chars 4582 - 4598 [(apply~concat_Ap).] 0. secs (0.u,0.s)
Chars 4599 - 4607 [Defined.] 0.067 secs (0.049u,0.017s)
Chars 4609 - 4928 [Definition~functor2_pforall_ri...] 0.008 secs (0.007u,0.s)
Chars 4929 - 4935 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 4286 - 4311 [(intros~P;~apply~transport).] 40.16 secs (0.u,0.034s)
Chars 4383 - 4439 [(first~[~exact~iso_same_rings~...] 0.001 secs (0.001u,0.s)
Chars 4286 - 4311 [(intros~P;~apply~transport).] 0.001 secs (0.001u,0.s)
Chars 4383 - 4439 [(first~[~exact~iso_same_rings~...] 0. secs (0.u,0.s)
Chars 4440 - 4444 [Qed.] 0. secs (0.u,0.s)
Chars 4446 - 4459 [End~contents.] 0.098 secs (0.076u,0.02s)
Chars 4461 - 4471 [End~Rings.] 0.073 secs (0.063u,0.009s)
Chars 2830 - 2862 [(apply~hprop_allpath;~intros~x...] 40.144 secs (0.001u,0.027s)
Chars 2867 - 2974 [exact~~(F_coindpaths~(F_inF~F~...] 0.003 secs (0.003u,0.s)
Chars 2830 - 2862 [(apply~hprop_allpath;~intros~x...] 0. secs (0.u,0.s)
Chars 2867 - 2974 [exact~~(F_coindpaths~(F_inF~F~...] 0. secs (0.u,0.s)
Chars 2977 - 2985 [Defined.] 0. secs (0.u,0.s)
Chars 3054 - 3138 [Definition~inF_fromF_sect~X~(s...] 0.002 secs (0.002u,0.s)
Chars 3141 - 3147 [Proof.] 0. secs (0.u,0.s)
Chars 8778 - 8789 [(destruct~c).] 40.163 secs (0.022u,0.031s)
Chars 8794 - 8814 [(apply~cu_fill_front).] 0.006 secs (0.006u,0.s)
Chars 8778 - 8789 [(destruct~c).] 0.002 secs (0.001u,0.s)
Chars 8794 - 8814 [(apply~cu_fill_front).] 0.001 secs (0.001u,0.s)
Chars 8817 - 8825 [Defined.] 0.006 secs (0.003u,0.001s)
Chars 8829 - 9205 [Definition~dc_fill_back~(t0ii~...] 0.015 secs (0.013u,0.001s)
Chars 9208 - 9214 [Proof.] 0. secs (0.u,0.s)
Chars 15583 - 15640 [one_line_proof~(equiv_sum_symm...] 20.882 secs (0.142u,0.055s)
Chars 15583 - 15640 [one_line_proof~(equiv_sum_symm...] 0. secs (0.u,0.s)
Chars 15643 - 15651 [Defined.] 0.036 secs (0.035u,0.001s)
Chars 15655 - 15715 [Theorem~plus_assoc~(x~y~z~:~No...] 0.01 secs (0.01u,0.s)
Chars 15718 - 15724 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 3825 - 3854 [(apply~path_path_hset_algebra).] 40.164 secs (0.003u,0.029s)
Chars 3857 - 3895 [(rewrite~path_ap_carriers_path...] 0.004 secs (0.001u,0.002s)
Chars 3898 - 3968 [(apply~(paths_ind~(λ~s,~idpath...] 0.004 secs (0.003u,0.001s)
Chars 3971 - 3972 [-] 0. secs (0.u,0.s)
Chars 3973 - 3993 [(apply~path_forall_1).] 0.001 secs (0.001u,0.s)
Chars 3996 - 3997 [-] 0. secs (0.u,0.s)
Chars 3998 - 4005 [(intros).] 0. secs (0.u,0.s)
Chars 4010 - 4019 [funext~s.] 0.002 secs (0.002u,0.s)
Chars 4024 - 4033 [symmetry.] 0.002 secs (0.002u,0.s)
Chars 4038 - 4085 [(rewrite~(path_ishprop~_~(iseq...] 0.009 secs (0.009u,0.s)
Chars 4090 - 4112 [(apply~path_universe_1).] 0.001 secs (0.001u,0.s)
Chars 3825 - 3854 [(apply~path_path_hset_algebra).] 0. secs (0.u,0.s)
Chars 3857 - 3895 [(rewrite~path_ap_carriers_path...] 0. secs (0.u,0.s)
Chars 3898 - 3968 [(apply~(paths_ind~(λ~s,~idpath...] 0. secs (0.u,0.s)
Chars 3973 - 3993 [(apply~path_forall_1).] 0. secs (0.u,0.s)
Chars 3998 - 4005 [(intros).] 0. secs (0.u,0.s)
Chars 4010 - 4019 [funext~s.] 0. secs (0.u,0.s)
Chars 4024 - 4033 [symmetry.] 0. secs (0.u,0.s)
Chars 4038 - 4085 [(rewrite~(path_ishprop~_~(iseq...] 0. secs (0.u,0.s)
Chars 4090 - 4112 [(apply~path_universe_1).] 0. secs (0.u,0.s)
Chars 4113 - 4117 [Qed.] 0.007 secs (0.005u,0.s)
Chars 4228 - 4258 [Section~isequiv_isomorphic_id.] 0. secs (0.u,0.s)
Chars 4261 - 4326 [Context~`{Univalence}~{σ}~(A~B...] 0. secs (0.u,0.s)
Chars 4330 - 4406 [Lemma~sect_id_isomorphic~:~@is...] 0.003 secs (0.002u,0.s)
Chars 4409 - 4415 [Proof.] 0. secs (0.u,0.s)
Chars 3190 - 3213 [pointed_reduce_rewrite.] 40.18 secs (0.034u,0.038s)
Chars 3216 - 3228 [(apply~ap_pp).] 0.001 secs (0.001u,0.s)
Chars 3190 - 3213 [pointed_reduce_rewrite.] 0. secs (0.u,0.s)
Chars 3216 - 3228 [(apply~ap_pp).] 0. secs (0.u,0.s)
Chars 3229 - 3237 [Defined.] 0.033 secs (0.023u,0.009s)
Chars 3273 - 3337 [#[global]Instance~ispointedfun...] 0.002 secs (0.001u,0.001s)
Chars 3338 - 3344 [Proof.] 0. secs (0.u,0.s)
Chars 6372 - 6410 [by~destruct~p,~(path_ishprop~C...] 40.166 secs (0.008u,0.035s)
Chars 6372 - 6410 [by~destruct~p,~(path_ishprop~C...] 0. secs (0.u,0.s)
Chars 6413 - 6421 [Defined.] 0.001 secs (0.001u,0.s)
Chars 6425 - 6532 [Lemma~path_quotient_algebra_if...] 0.002 secs (0.u,0.001s)
Chars 6535 - 6541 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 4461 - 4507 [refine~(_~oE~shuffle_abses_pat...] 40.14 secs (0.001u,0.033s)
Chars 4510 - 4553 [refine~(equiv_ap_inv~issig_abs...] 0.015 secs (0.011u,0.003s)
Chars 4556 - 4597 [refine~(equiv_path_sigma_hprop...] 0.088 secs (0.074u,0.013s)
Chars 4600 - 4637 [refine~(equiv_path_sigma~_~_~_...] 0.002 secs (0.002u,0.s)
Chars 4640 - 4669 [srapply~equiv_functor_sigma'.] 0.003 secs (0.002u,0.s)
Chars 4672 - 4700 [1:~exact~equiv_path_abgroup.] 0.003 secs (0.002u,0.s)
Chars 4703 - 4722 [(intro~q;~lazy~beta).] 0.002 secs (0.002u,0.s)
Chars 4725 - 4760 [snrefine~(equiv_concat_l~_~_~o...] 0.012 secs (0.011u,0.s)
Chars 4763 - 4826 [1:~exact~(q~$o~inclusion~_,~pr...] 0.006 secs (0.005u,0.001s)
Chars 4829 - 4833 [2:~{] 0. secs (0.u,0.s)
Chars 4834 - 4868 [refine~(equiv_path_prod~_~_~oE...] 0.004 secs (0.003u,0.s)
Chars 4876 - 4994 [exact~~(equiv_functor_prod'~eq...] 0.006 secs (0.005u,0.s)
Chars 4995 - 4996 [}] 0. secs (0.u,0.s)
Chars 4999 - 5031 [refine~(transport_prod~_~_~@~_).] 0.009 secs (0.008u,0.s)
Chars 5034 - 5051 [(apply~path_prod').] 0.019 secs (0.019u,0.s)
Chars 5054 - 5055 [-] 0. secs (0.u,0.s)
Chars 5056 - 5107 [(apply~transport_iso_abgroupho...] 0.025 secs (0.021u,0.003s)
Chars 5110 - 5111 [-] 0. secs (0.u,0.s)
Chars 5112 - 5161 [(apply~transport_iso_abgroupho...] 0.029 secs (0.024u,0.005s)
Chars 4461 - 4507 [refine~(_~oE~shuffle_abses_pat...] 0. secs (0.u,0.s)
Chars 4510 - 4553 [refine~(equiv_ap_inv~issig_abs...] 0. secs (0.u,0.s)
Chars 4556 - 4597 [refine~(equiv_path_sigma_hprop...] 0.001 secs (0.001u,0.s)
Chars 4600 - 4637 [refine~(equiv_path_sigma~_~_~_...] 0. secs (0.u,0.s)
Chars 4640 - 4669 [srapply~equiv_functor_sigma'.] 0.001 secs (0.u,0.s)
Chars 4672 - 4700 [1:~exact~equiv_path_abgroup.] 0. secs (0.u,0.s)
Chars 4703 - 4722 [(intro~q;~lazy~beta).] 0.002 secs (0.002u,0.s)
Chars 4725 - 4760 [snrefine~(equiv_concat_l~_~_~o...] 0.001 secs (0.001u,0.s)
Chars 4763 - 4826 [1:~exact~(q~$o~inclusion~_,~pr...] 0. secs (0.u,0.s)
Chars 4834 - 4868 [refine~(equiv_path_prod~_~_~oE...] 0.001 secs (0.u,0.s)
Chars 4876 - 4994 [exact~~(equiv_functor_prod'~eq...] 0.001 secs (0.001u,0.s)
Chars 4999 - 5031 [refine~(transport_prod~_~_~@~_).] 0. secs (0.u,0.s)
Chars 5034 - 5051 [(apply~path_prod').] 0. secs (0.u,0.s)
Chars 5056 - 5107 [(apply~transport_iso_abgroupho...] 0. secs (0.u,0.s)
Chars 5112 - 5161 [(apply~transport_iso_abgroupho...] 0. secs (0.u,0.s)
Chars 5162 - 5170 [Defined.] 0.078 secs (0.071u,0.006s)
Chars 5223 - 5307 [#[global]~Instance~istrunc_abs...] 0. secs (0.u,0.s)
Chars 5308 - 5314 [Proof.] 0. secs (0.u,0.s)
Chars 6432 - 6440 [intro~a.] 40.197 secs (0.u,0.036s)
Chars 6443 - 6471 [(induction~n;~[~reflexivity~|~...] 0.002 secs (0.002u,0.s)
Chars 6474 - 6483 [funext~x.] 0.002 secs (0.002u,0.s)
Chars 6486 - 6521 [refine~(_~@~IHn~(fstail~ss)~(a...] 0.003 secs (0.003u,0.s)
Chars 6524 - 6572 [refine~(ap~(operation_curry~A~...] 0.003 secs (0.002u,0.s)
Chars 6575 - 6585 [funext~a'.] 0.002 secs (0.001u,0.001s)
Chars 6588 - 6594 [(simpl).] 0.002 secs (0.002u,0.s)
Chars 6597 - 6624 [(unfold~cons_dom,~cons_dom').] 0.001 secs (0.001u,0.s)
Chars 6627 - 6660 [(rewrite~compute_fin_ind_fin_z...] 0.048 secs (0.045u,0.002s)
Chars 6663 - 6719 [refine~(ap~(operation_uncurry~...] 0.004 secs (0.004u,0.s)
Chars 6722 - 6732 [funext~i'.] 0.003 secs (0.003u,0.s)
Chars 6735 - 6769 [now~rewrite~compute_fin_ind_fs...] 0.05 secs (0.042u,0.007s)
Chars 6432 - 6440 [intro~a.] 0. secs (0.u,0.s)
Chars 6443 - 6471 [(induction~n;~[~reflexivity~|~...] 0. secs (0.u,0.s)
Chars 6474 - 6483 [funext~x.] 0. secs (0.u,0.s)
Chars 6486 - 6521 [refine~(_~@~IHn~(fstail~ss)~(a...] 0.001 secs (0.001u,0.s)
Chars 6524 - 6572 [refine~(ap~(operation_curry~A~...] 0. secs (0.u,0.s)
Chars 6575 - 6585 [funext~a'.] 0. secs (0.u,0.s)
Chars 6588 - 6594 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 6597 - 6624 [(unfold~cons_dom,~cons_dom').] 0.001 secs (0.001u,0.s)
Chars 6627 - 6660 [(rewrite~compute_fin_ind_fin_z...] 0.002 secs (0.002u,0.s)
Chars 6663 - 6719 [refine~(ap~(operation_uncurry~...] 0.002 secs (0.001u,0.s)
Chars 6722 - 6732 [funext~i'.] 0.002 secs (0.002u,0.s)
Chars 6735 - 6769 [now~rewrite~compute_fin_ind_fs...] 0.002 secs (0.002u,0.s)
Chars 6770 - 6774 [Qed.] 0.065 secs (0.056u,0.008s)
Chars 6776 - 6938 [#[global]~Instance~isequiv_ope...] 0.001 secs (0.001u,0.s)
Chars 6939 - 6945 [Proof.] 0. secs (0.u,0.s)
Chars 1809 - 1822 [(intros~x~y~z).] 40.151 secs (0.u,0.027s)
Chars 1823 - 1852 [(rewrite~!(commutativity~_~z)).] 0.022 secs (0.019u,0.s)
Chars 1855 - 1874 [(apply~distribute_l).] 0.001 secs (0.001u,0.s)
Chars 1809 - 1822 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 1823 - 1852 [(rewrite~!(commutativity~_~z)).] 0. secs (0.u,0.s)
Chars 1855 - 1874 [(apply~distribute_l).] 0. secs (0.u,0.s)
Chars 1877 - 1881 [Qed.] 0.001 secs (0.u,0.s)
Chars 1885 - 1947 [#[global]Instance~meet_join_di...] 0. secs (0.u,0.s)
Chars 1950 - 1956 [Proof.] 0. secs (0.u,0.s)
Chars 2375 - 2401 [(srapply~Build_Cocone;~cbn).] 40.126 secs (0.007u,0.023s)
Chars 2406 - 2407 [-] 0. secs (0.u,0.s)
Chars 2408 - 2419 [(intros~i~w).] 0.001 secs (0.001u,0.s)
Chars 2426 - 2452 [(exists~(colim~i~w.1);~cbn).] 0.005 secs (0.003u,0.001s)
Chars 2459 - 2469 [exact~w.2.] 0.002 secs (0.001u,0.s)
Chars 2474 - 2475 [-] 0. secs (0.u,0.s)
Chars 2476 - 2496 [(intros~i~j~g~x;~cbn).] 0.008 secs (0.007u,0.s)
Chars 2503 - 2523 [srapply~path_sigma'.] 0.007 secs (0.005u,0.001s)
Chars 2530 - 2531 [+] 0. secs (0.u,0.s)
Chars 2532 - 2545 [(apply~colimp).] 0.002 secs (0.002u,0.s)
Chars 2552 - 2553 [+] 0. secs (0.u,0.s)
Chars 2554 - 2573 [(apply~transport_E').] 0.003 secs (0.003u,0.s)
Chars 2375 - 2401 [(srapply~Build_Cocone;~cbn).] 0.003 secs (0.003u,0.s)
Chars 2408 - 2419 [(intros~i~w).] 0.001 secs (0.001u,0.s)
Chars 2426 - 2452 [(exists~(colim~i~w.1);~cbn).] 0.002 secs (0.001u,0.s)
Chars 2459 - 2469 [exact~w.2.] 0.001 secs (0.001u,0.s)
Chars 2476 - 2496 [(intros~i~j~g~x;~cbn).] 0.004 secs (0.003u,0.s)
Chars 2503 - 2523 [srapply~path_sigma'.] 0.001 secs (0.001u,0.s)
Chars 2532 - 2545 [(apply~colimp).] 0.001 secs (0.001u,0.s)
Chars 2554 - 2573 [(apply~transport_E').] 0.002 secs (0.002u,0.s)
Chars 2576 - 2584 [Defined.] 0.008 secs (0.005u,0.002s)
Chars 2642 - 2671 [#[local]Opaque~path_sigma~ap11.] 0. secs (0.u,0.s)
Chars 2708 - 2772 [#[global]Instance~unicocone_co...] 0. secs (0.u,0.s)
Chars 2775 - 2781 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 1996 - 2056 [snrapply~(Build_AbSESMorphism~...] 40.226 secs (0.008u,0.048s)
Chars 2059 - 2060 [-] 0. secs (0.u,0.s)
Chars 2061 - 2178 [(apply~~~(grp_pullback_corec~(...] 0.006 secs (0.004u,0.001s)
Chars 2183 - 2202 [(apply~right_square).] 0.005 secs (0.004u,0.s)
Chars 2205 - 2206 [-] 0. secs (0.u,0.s)
Chars 2207 - 2220 [(intro~x;~cbn).] 0.011 secs (0.01u,0.001s)
Chars 2225 - 2250 [(snrapply~path_sigma;~cbn).] 0.019 secs (0.018u,0.s)
Chars 2255 - 2256 [+] 0. secs (0.u,0.s)
Chars 2257 - 2275 [(apply~left_square).] 0.005 secs (0.005u,0.s)
Chars 2280 - 2281 [+] 0. secs (0.u,0.s)
Chars 2282 - 2321 [(refine~(transport_sigma'~_~_~...] 0.008 secs (0.007u,0.s)
Chars 2328 - 2366 [(apply~path_sigma_hprop;~cbn;~...] 0.065 secs (0.057u,0.008s)
Chars 2373 - 2395 [(apply~iscomplex_abses).] 0.006 secs (0.006u,0.s)
Chars 2398 - 2399 [-] 0. secs (0.u,0.s)
Chars 2400 - 2412 [reflexivity.] 0.006 secs (0.005u,0.s)
Chars 1996 - 2056 [snrapply~(Build_AbSESMorphism~...] 0. secs (0.u,0.s)
Chars 2061 - 2178 [(apply~~~(grp_pullback_corec~(...] 0. secs (0.u,0.s)
Chars 2183 - 2202 [(apply~right_square).] 0. secs (0.u,0.s)
Chars 2207 - 2220 [(intro~x;~cbn).] 0.001 secs (0.001u,0.s)
Chars 2225 - 2250 [(snrapply~path_sigma;~cbn).] 0.006 secs (0.005u,0.001s)
Chars 2257 - 2275 [(apply~left_square).] 0. secs (0.u,0.s)
Chars 2282 - 2321 [(refine~(transport_sigma'~_~_~...] 0.004 secs (0.004u,0.s)
Chars 2328 - 2366 [(apply~path_sigma_hprop;~cbn;~...] 0.003 secs (0.002u,0.s)
Chars 2373 - 2395 [(apply~iscomplex_abses).] 0. secs (0.u,0.s)
Chars 2400 - 2412 [reflexivity.] 0. secs (0.u,0.s)
Chars 2413 - 2421 [Defined.] 0.044 secs (0.037u,0.006s)
Chars 2476 - 2756 [Definition~abses_pullback_morp...] 0.005 secs (0.005u,0.s)
Chars 2757 - 2763 [Proof.] 0. secs (0.u,0.s)
Chars 6546 - 6574 [(apply~path_quotient_algebra).] 25.935 secs (13.649u,0.014s)
Chars 4938 - 4953 [pointed_reduce.] 40.181 secs (0.042u,0.032s)
Chars 4954 - 4966 [reflexivity.] 0.01 secs (0.006u,0.003s)
Chars 4938 - 4953 [pointed_reduce.] 0.001 secs (0.001u,0.s)
Chars 4954 - 4966 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 4967 - 4975 [Defined.] 0.04 secs (0.029u,0.01s)
Chars 5040 - 5177 [Definition~pmap_compose_ppfora...] 0.001 secs (0.001u,0.s)
Chars 5178 - 5184 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 44.972 secs (4.684u,0.151s) (successful)
Chars 7103 - 8388 [Time~(exists~unit_r~counit_r;~...] 44.972 secs (4.684u,0.151s)
Finished transaction in 0.001 secs (0.001u,0.s) (successful)
Chars 7103 - 8388 [Time~(exists~unit_r~counit_r;~...] 0.001 secs (0.001u,0.s)
Chars 8406 - 8414 [Defined.] 0.186 secs (0.185u,0.s)
Chars 8417 - 8423 [End~r.] 0.011 secs (0.011u,0.s)
Chars 8424 - 8445 [End~AdjointPointwise.] 0.028 secs (0.028u,0.s)
Chars 3152 - 3219 [refine~(transport~(inF~F)~(pat...] 40.164 secs (0.01u,0.029s)
Chars 3224 - 3260 [refine~(isequiv_adjointify~_~s...] 0.001 secs (0.u,0.s)
Chars 3265 - 3297 [(change~(s~o~fromF~F~X~==~idma...] 0.002 secs (0.002u,0.s)
Chars 3302 - 3338 [(apply~F_coindpaths;~try~apply...] 0.002 secs (0.002u,0.s)
Chars 3343 - 3361 [(intros~x;~apply~p).] 0.001 secs (0.001u,0.s)
Chars 3152 - 3219 [refine~(transport~(inF~F)~(pat...] 0. secs (0.u,0.s)
Chars 3224 - 3260 [refine~(isequiv_adjointify~_~s...] 0. secs (0.u,0.s)
Chars 3265 - 3297 [(change~(s~o~fromF~F~X~==~idma...] 0. secs (0.u,0.s)
Chars 3302 - 3338 [(apply~F_coindpaths;~try~apply...] 0. secs (0.u,0.s)
Chars 3343 - 3361 [(intros~x;~apply~p).] 0. secs (0.u,0.s)
Chars 3364 - 3372 [Defined.] 0. secs (0.u,0.s)
Chars 3626 - 3693 [Definition~inF_equiv_implies_f...] 0. secs (0.u,0.s)
Chars 3696 - 3702 [Proof.] 0. secs (0.u,0.s)
Chars 9219 - 9230 [(destruct~c).] 40.171 secs (0.024u,0.03s)
Chars 9235 - 9254 [(apply~cu_fill_back).] 0.006 secs (0.004u,0.001s)
Chars 9219 - 9230 [(destruct~c).] 0.002 secs (0.002u,0.s)
Chars 9235 - 9254 [(apply~cu_fill_back).] 0.001 secs (0.001u,0.s)
Chars 9257 - 9265 [Defined.] 0.006 secs (0.004u,0.002s)
Chars 9267 - 9275 [End~Kan.] 0.072 secs (0.062u,0.01s)
Chars 4420 - 4428 [intro~F.] 40.177 secs (0.001u,0.03s)
Chars 4433 - 4460 [(apply~path_hset_isomorphic).] 0.001 secs (0.001u,0.s)
Chars 4465 - 4510 [(rewrite~path_def_isomorphic_i...] 0.034 secs (0.03u,0.003s)
Chars 4515 - 4526 [funext~s~x.] 0.003 secs (0.003u,0.s)
Chars 4531 - 4566 [(rewrite~!transport_forall_con...] 0.008 secs (0.007u,0.s)
Chars 4571 - 4609 [(rewrite~path_ap_carriers_path...] 0.004 secs (0.003u,0.s)
Chars 4614 - 4643 [transport_path_forall_hammer.] 0.009 secs (0.007u,0.001s)
Chars 4648 - 4678 [(apply~transport_path_universe).] 0.002 secs (0.002u,0.s)
Chars 4420 - 4428 [intro~F.] 0. secs (0.u,0.s)
Chars 4433 - 4460 [(apply~path_hset_isomorphic).] 0. secs (0.u,0.s)
Chars 4465 - 4510 [(rewrite~path_def_isomorphic_i...] 0. secs (0.u,0.s)
Chars 4515 - 4526 [funext~s~x.] 0. secs (0.u,0.s)
Chars 4531 - 4566 [(rewrite~!transport_forall_con...] 0. secs (0.u,0.s)
Chars 4571 - 4609 [(rewrite~path_ap_carriers_path...] 0. secs (0.u,0.s)
Chars 4614 - 4643 [transport_path_forall_hammer.] 0. secs (0.u,0.s)
Chars 4648 - 4678 [(apply~transport_path_universe).] 0. secs (0.u,0.s)
Chars 4681 - 4685 [Qed.] 0.015 secs (0.012u,0.002s)
Chars 4689 - 4765 [Lemma~sect_isomorphic_id~:~id_...] 0.002 secs (0.002u,0.s)
Chars 4768 - 4774 [Proof.] 0. secs (0.u,0.s)
Chars 15729 - 15830 [(one_line_proof~(equiv_sum_ass...] 41.823 secs (1.599u,0.091s)
Chars 15729 - 15830 [(one_line_proof~(equiv_sum_ass...] 0.014 secs (0.014u,0.s)
Chars 6546 - 6574 [(apply~path_quotient_algebra).] 40.065 secs (0.u,0.034s)
Chars 6579 - 6592 [funext~s~x~y.] 0.004 secs (0.004u,0.s)
Chars 6597 - 6632 [refine~(path_universe_uncurrie...] 0.001 secs (0.001u,0.s)
Chars 6637 - 6668 [(apply~equiv_iff_hprop;~apply~R).] 0.016 secs (0.013u,0.002s)
Chars 6546 - 6574 [(apply~path_quotient_algebra).] 0. secs (0.u,0.s)
Chars 6579 - 6592 [funext~s~x~y.] 0. secs (0.u,0.s)
Chars 6597 - 6632 [refine~(path_universe_uncurrie...] 0. secs (0.u,0.s)
Chars 6637 - 6668 [(apply~equiv_iff_hprop;~apply~R).] 0.001 secs (0.001u,0.s)
Chars 6671 - 6679 [Defined.] 0.001 secs (0.001u,0.s)
Chars 6680 - 6706 [End~path_quotient_algebra.] 0.006 secs (0.004u,0.002s)
Chars 6816 - 6837 [Section~hom_quotient.] 0. secs (0.u,0.s)
Chars 6840 - 6939 [Context~`{Funext}~{σ}~{A~:~Alg...] 0.001 secs (0.001u,0.s)
Chars 6943 - 7042 [Definition~def_hom_quotient~:~...] 0.002 secs (0.002u,0.s)
Chars 7046 - 7239 [Lemma~oppreserving_quotient~`{...] 0.002 secs (0.002u,0.s)
Chars 7242 - 7248 [Proof.] 0. secs (0.u,0.s)
Chars 15833 - 15841 [Defined.] 0.29 secs (0.282u,0.007s)
Chars 15845 - 15887 [Theorem~plus_zero~(x~:~No)~:~x...] 0.002 secs (0.002u,0.s)
Chars 15890 - 15896 [Proof.] 0. secs (0.u,0.s)
Chars 3347 - 3378 [rapply~Build_IsPointedFunctor'.] 40.322 secs (0.126u,0.059s)
Chars 3381 - 3406 [(apply~pequiv_loops_punit).] 0. secs (0.u,0.s)
Chars 3347 - 3378 [rapply~Build_IsPointedFunctor'.] 0. secs (0.u,0.s)
Chars 3381 - 3406 [(apply~pequiv_loops_punit).] 0. secs (0.u,0.s)
Chars 3407 - 3415 [Defined.] 0. secs (0.u,0.s)
Chars 3417 - 3493 [Lemma~fmap_loops_pconst~{A~B~:...] 0.002 secs (0.001u,0.s)
Chars 3494 - 3500 [Proof.] 0. secs (0.u,0.s)
Chars 5317 - 5328 [(intros~E~F).] 40.163 secs (0.u,0.033s)
Chars 5331 - 5392 [refine~(istrunc_equiv_istrunc~...] 0.215 secs (0.186u,0.027s)
Chars 5395 - 5416 [rapply~istrunc_sigma.] 0.344 secs (0.302u,0.035s)
Chars 5419 - 5449 [(apply~ishset_groupisomorphism).] 0.001 secs (0.001u,0.s)
Chars 5317 - 5328 [(intros~E~F).] 0. secs (0.u,0.s)
Chars 5331 - 5392 [refine~(istrunc_equiv_istrunc~...] 0. secs (0.u,0.s)
Chars 5395 - 5416 [rapply~istrunc_sigma.] 0. secs (0.u,0.s)
Chars 5419 - 5449 [(apply~ishset_groupisomorphism).] 0. secs (0.u,0.s)
Chars 5450 - 5458 [Defined.] 0.003 secs (0.003u,0.s)
Chars 5460 - 5714 [Definition~path_abses_iso~`{Un...] 0.012 secs (0.012u,0.s)
Chars 5950 - 6143 [Lemma~short_five_lemma~{B~A~:~...] 0.005 secs (0.005u,0.s)
Chars 6144 - 6150 [Proof.] 0. secs (0.u,0.s)
Chars 6948 - 6975 [srapply~isequiv_adjointify.] 40.192 secs (0.001u,0.037s)
Chars 6978 - 6979 [-] 0. secs (0.u,0.s)
Chars 6980 - 7004 [(apply~operation_uncurry).] 0.001 secs (0.001u,0.s)
Chars 7007 - 7008 [-] 0. secs (0.u,0.s)
Chars 7009 - 7047 [(apply~path_operation_uncurry_...] 0.003 secs (0.003u,0.s)
Chars 7050 - 7051 [-] 0. secs (0.u,0.s)
Chars 7052 - 7090 [(apply~path_operation_curry_to...] 0.003 secs (0.002u,0.s)
Chars 6948 - 6975 [srapply~isequiv_adjointify.] 0. secs (0.u,0.s)
Chars 6980 - 7004 [(apply~operation_uncurry).] 0. secs (0.u,0.s)
Chars 7009 - 7047 [(apply~path_operation_uncurry_...] 0. secs (0.u,0.s)
Chars 7052 - 7090 [(apply~path_operation_curry_to...] 0. secs (0.u,0.s)
Chars 7091 - 7099 [Defined.] 0.002 secs (0.001u,0.s)
Chars 7101 - 7322 [Definition~equiv_operation_cur...] 0.018 secs (0.016u,0.001s)
Chars 3503 - 3529 [rapply~fmap_zero_morphism.] 5.392 secs (0.183u,0.066s)
Chars 3503 - 3529 [rapply~fmap_zero_morphism.] 0. secs (0.u,0.s)
Chars 3530 - 3538 [Defined.] 0.001 secs (0.001u,0.s)
Chars 3600 - 3676 [#[global]~Instance~is0functor_...] 0. secs (0.u,0.s)
Chars 3677 - 3683 [Proof.] 0. secs (0.u,0.s)
Chars 1959 - 1972 [(intros~x~y~z).] 40.165 secs (0.u,0.027s)
Chars 1975 - 2015 [(rewrite~(simple_distribute_l~...] 0.003 secs (0.003u,0.s)
Chars 2018 - 2058 [(rewrite~(simple_distribute_r~...] 0.003 secs (0.003u,0.s)
Chars 2061 - 2091 [(rewrite~(idempotency~(⊔)~x)).] 0.006 secs (0.004u,0.001s)
Chars 2094 - 2154 [(rewrite~(commutativity~(f:=jo...] 0.067 secs (0.041u,0.025s)
Chars 2157 - 2200 [(path_via~((x~⊓~(x~⊔~z))~⊓~(y~...] 0.009 secs (0.007u,0.s)
Chars 2203 - 2204 [-] 0. secs (0.u,0.s)
Chars 2205 - 2240 [(rewrite~(meet_join_absorption...] 0.003 secs (0.u,0.002s)
Chars 2241 - 2253 [reflexivity.] 0. secs (0.u,0.s)
Chars 2256 - 2257 [-] 0. secs (0.u,0.s)
Chars 2258 - 2289 [(rewrite~<-~simple_associativi...] 0.008 secs (0.008u,0.s)
Chars 2294 - 2317 [(rewrite~<-~distribute_r).] 0.003 secs (0.003u,0.s)
Chars 2322 - 2334 [reflexivity.] 0. secs (0.u,0.s)
Chars 1959 - 1972 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 1975 - 2015 [(rewrite~(simple_distribute_l~...] 0. secs (0.u,0.s)
Chars 2018 - 2058 [(rewrite~(simple_distribute_r~...] 0. secs (0.u,0.s)
Chars 2061 - 2091 [(rewrite~(idempotency~(⊔)~x)).] 0. secs (0.u,0.s)
Chars 2094 - 2154 [(rewrite~(commutativity~(f:=jo...] 0. secs (0.u,0.s)
Chars 2157 - 2200 [(path_via~((x~⊓~(x~⊔~z))~⊓~(y~...] 0. secs (0.u,0.s)
Chars 2205 - 2240 [(rewrite~(meet_join_absorption...] 0. secs (0.u,0.s)
Chars 2241 - 2253 [reflexivity.] 0. secs (0.u,0.s)
Chars 2258 - 2289 [(rewrite~<-~simple_associativi...] 0. secs (0.u,0.s)
Chars 2294 - 2317 [(rewrite~<-~distribute_r).] 0. secs (0.u,0.s)
Chars 2322 - 2334 [reflexivity.] 0. secs (0.u,0.s)
Chars 2337 - 2341 [Qed.] 0.003 secs (0.003u,0.s)
Chars 2345 - 2408 [#[global]Instance~meet_join_di...] 0. secs (0.u,0.s)
Chars 2411 - 2417 [Proof.] 0. secs (0.u,0.s)
Chars 2786 - 2816 [srapply~Build_UniversalCocone.] 40.156 secs (0.031u,0.026s)
Chars 2821 - 2857 [(intro~Z;~srapply~isequiv_adjo...] 0.005 secs (0.004u,0.s)
Chars 2862 - 2863 [-] 0. secs (0.u,0.s)
Chars 2864 - 2888 [(intros~[q~qq];~cbn~in~*).] 0.005 secs (0.005u,0.s)
Chars 2895 - 2920 [(intros~[x~y];~revert~x~y).] 0.004 secs (0.003u,0.s)
Chars 2927 - 2952 [(srapply~Colimit_ind;~cbn).] 0.013 secs (0.007u,0.003s)
Chars 2959 - 2960 [+] 0. secs (0.u,0.s)
Chars 2961 - 2994 [(intros~i~x~y;~exact~(q~i~(x;~...] 0.01 secs (0.008u,0.s)
Chars 3001 - 3002 [+] 0. secs (0.u,0.s)
Chars 3003 - 3023 [(intros~i~j~g~x;~cbn).] 0.035 secs (0.027u,0.007s)
Chars 3032 - 3041 [funext~y.] 0.005 secs (0.004u,0.s)
Chars 3050 - 3093 [refine~(transport_arrow_tocons...] 0.004 secs (0.002u,0.001s)
Chars 3102 - 3131 [refine~(_~@~qq~i~j~g~(x;~y)).] 0.009 secs (0.009u,0.s)
Chars 3140 - 3150 [(cbn;~f_ap).] 0.013 secs (0.012u,0.s)
Chars 3159 - 3191 [(refine~(path_sigma'~_~1~_);~c...] 0.008 secs (0.007u,0.s)
Chars 3200 - 3221 [(apply~transport_E'_V).] 0.007 secs (0.006u,0.s)
Chars 3226 - 3227 [-] 0. secs (0.u,0.s)
Chars 3228 - 3242 [(intros~[q~qq]).] 0.051 secs (0.045u,0.005s)
Chars 3249 - 3269 [srapply~path_cocone.] 0.032 secs (0.027u,0.005s)
Chars 3276 - 3277 [+] 0. secs (0.u,0.s)
Chars 3278 - 3302 [(intros~i~x;~reflexivity).] 0.017 secs (0.016u,0.s)
Chars 3309 - 3310 [+] 0. secs (0.u,0.s)
Chars 3311 - 3330 [(intros~i~j~g~[x~y]).] 0.269 secs (0.222u,0.043s)
Chars 3339 - 3368 [(rewrite~concat_1p,~concat_p1).] 0.401 secs (0.379u,0.016s)
find_witness Control.TimeoutChars 3377 - 3404 [(cbn;~rewrite~ap_path_sigma).] 0.139 secs (0.139u,0.s)
Chars 3413 - 3450 [(cbn;~rewrite~Colimit_ind_beta...] 0.562 secs (0.548u,0.011s)
Chars 3459 - 3484 [(rewrite~ap10_path_forall).] 0.313 secs (0.269u,0.04s)
Chars 2420 - 2433 [(intros~x~y~z).] 5.146 secs (0.u,0.028s)
Chars 2434 - 2463 [(rewrite~!(commutativity~_~z)).] 0.016 secs (0.011u,0.005s)
Chars 2466 - 2485 [(apply~distribute_l).] 0.002 secs (0.002u,0.s)
Chars 2420 - 2433 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 2434 - 2463 [(rewrite~!(commutativity~_~z)).] 0. secs (0.u,0.s)
Chars 2466 - 2485 [(apply~distribute_l).] 0. secs (0.u,0.s)
Chars 2488 - 2492 [Qed.] 0.001 secs (0.001u,0.s)
Chars 2496 - 2607 [Lemma~distribute_alt~x~y~z~:~~...] 0.004 secs (0.003u,0.s)
Chars 2610 - 2616 [Proof.] 0. secs (0.u,0.s)
Chars 3493 - 3504 [hott_simpl.] 3.564 secs (3.514u,0.028s)
Chars 3513 - 3538 [refine~(_~@~concat_1p~_).] 0.015 secs (0.015u,0.s)
Chars 3547 - 3563 [refine~(_~@@~1).] 0.023 secs (0.023u,0.s)
Chars 3572 - 3620 [(match~goal~with~~|~|-~ap~_~?X...] 0.031 secs (0.031u,0.s)
Chars 3629 - 3664 [(assert~(transport_E'_V~g~x~y~...] 0.013 secs (0.013u,0.s)
Chars 3673 - 3674 [{] 0. secs (0.u,0.s)
Chars 3675 - 3683 [subst~p.] 0.003 secs (0.003u,0.s)
Chars 3694 - 3734 [exact~(moveL_transport_V_V~E'~...] 0.005 secs (0.005u,0.s)
Chars 3735 - 3736 [}] 0. secs (0.u,0.s)
Chars 3745 - 3755 [(rewrite~X).] 0.093 secs (0.09u,0.001s)
Chars 3764 - 3783 [(clearbody~p;~clear).] 0.086 secs (0.085u,0.s)
Chars 3792 - 3813 [(set~(E_f~g~x~y)~in~*).] 0.039 secs (0.039u,0.s)
Chars 3822 - 3833 [(destruct~p).] 0.087 secs (0.087u,0.s)
Chars 3842 - 3854 [reflexivity.] 0.018 secs (0.017u,0.s)
Chars 3859 - 3860 [-] 0. secs (0.u,0.s)
Chars 3861 - 3869 [intro~f.] 0.017 secs (0.017u,0.s)
Chars 3876 - 3889 [funext~[x~y].] 0.046 secs (0.045u,0.001s)
Chars 3896 - 3912 [(revert~x~y;~cbn).] 0.037 secs (0.037u,0.s)
Chars 3919 - 3944 [(srapply~Colimit_ind;~cbn).] 0.088 secs (0.088u,0.s)
Chars 3951 - 3952 [+] 0. secs (0.u,0.s)
Chars 3953 - 3965 [reflexivity.] 0.005 secs (0.005u,0.s)
Chars 3972 - 3973 [+] 0. secs (0.u,0.s)
Chars 3974 - 3994 [(intros~i~j~g~x;~cbn).] 0.064 secs (0.062u,0.001s)
Chars 4003 - 4012 [funext~y.] 0.015 secs (0.015u,0.s)
Chars 4021 - 4051 [(rewrite~transport_forall;~cbn).] 0.153 secs (0.15u,0.001s)
Chars 4060 - 4089 [(rewrite~transport_paths_FlFr).] 0.075 secs (0.074u,0.s)
Chars 4098 - 4149 [(match~goal~with~~|~|-~(_~@~?p...] 0.061 secs (0.061u,0.s)
Chars 4158 - 4167 [(cbn~in~p).] 0.077 secs (0.076u,0.001s)
Chars 4176 - 4191 [(assert~(p~=~1)).] 0.029 secs (0.029u,0.s)
Chars 4200 - 4201 [{] 0. secs (0.u,0.s)
Chars 4202 - 4210 [subst~p.] 0.014 secs (0.014u,0.s)
Chars 4221 - 4286 [(match~goal~with~~|~|-~transpo...] 0.025 secs (0.025u,0.s)
Chars 4297 - 4355 [(rewrite~(transportD_is_transp...] 0.064 secs (0.064u,0.s)
Chars 4366 - 4380 [(subst~C2;~cbn).] 0.102 secs (0.102u,0.s)
Chars 4391 - 4420 [(rewrite~transport_paths_FlFr).] 0.118 secs (0.115u,0.002s)
Chars 4431 - 4449 [(rewrite~concat_p1).] 0.177 secs (0.177u,0.s)
Chars 4460 - 4475 [(apply~moveR_Vp).] 0.037 secs (0.035u,0.001s)
Chars 4486 - 4504 [(rewrite~concat_p1).] 0.062 secs (0.062u,0.s)
Chars 4515 - 4537 [(rewrite~ap_path_sigma).] 0.115 secs (0.103u,0.011s)
Chars 4548 - 4552 [(cbn).] 0.415 secs (0.376u,0.038s)
Chars 4563 - 4595 [(rewrite~Colimit_ind_beta_coli...] 0.328 secs (0.322u,0.004s)
Chars 2766 - 2810 [(apply~(equiv_ap~issig_AbSESMo...] 40.273 secs (0.039u,0.06s)
Chars 2813 - 2838 [srapply~path_sigma_hprop.] 0.219 secs (0.189u,0.028s)
Chars 2841 - 2857 [(apply~path_prod).] 0.002 secs (0.002u,0.s)
Chars 2860 - 2879 [1:~(apply~path_prod).] 0.002 secs (0.002u,0.s)
Chars 4606 - 4631 [(rewrite~ap10_path_forall).] 0.25 secs (0.247u,0.s)
Chars 2882 - 2925 [all:~by~apply~equiv_path_group...] 0.038 secs (0.034u,0.003s)
Chars 2766 - 2810 [(apply~(equiv_ap~issig_AbSESMo...] 0. secs (0.u,0.s)
Chars 2813 - 2838 [srapply~path_sigma_hprop.] 0.001 secs (0.001u,0.s)
Chars 2841 - 2857 [(apply~path_prod).] 0. secs (0.u,0.s)
Chars 2860 - 2879 [1:~(apply~path_prod).] 0. secs (0.u,0.s)
Chars 2882 - 2925 [all:~by~apply~equiv_path_group...] 0.002 secs (0.002u,0.s)
Chars 2926 - 2934 [Defined.] 0.035 secs (0.032u,0.002s)
Chars 2936 - 3167 [Definition~abses_component1_tr...] 0.007 secs (0.006u,0.001s)
Chars 3168 - 3174 [Proof.] 0. secs (0.u,0.s)
Chars 4642 - 4653 [hott_simpl.] 5.054 secs (4.95u,0.066s)
Chars 4664 - 4690 [(rewrite~ap11_is_ap10_ap01).] 0.104 secs (0.104u,0.s)
Chars 4701 - 4705 [(cbn).] 0.145 secs (0.14u,0.005s)
Chars 4716 - 4734 [(rewrite~concat_1p).] 0.112 secs (0.111u,0.s)
Chars 4745 - 4805 [(rewrite~(ap_compose~(fun~y~=>...] 0.101 secs (0.097u,0.001s)
Chars 4816 - 4820 [(cbn).] 0.122 secs (0.122u,0.s)
Chars 4831 - 4934 [(rewrite~~~(ap_compose~~~~~~(f...] 0.106 secs (0.105u,0.s)
Chars 4945 - 4968 [(rewrite~<-~!(ap_pp~f)).] 0.122 secs (0.121u,0.s)
Chars 4979 - 4997 [(apply~(ap~(ap~f))).] 0.012 secs (0.012u,0.s)
Chars 5008 - 5094 [(match~goal~with~~|~|-~_~=~(ap...] 0.024 secs (0.024u,0.s)
Chars 5105 - 5205 [(assert~~~(p1~=~~~~ap~(transpo...] 0.019 secs (0.019u,0.s)
Chars 5216 - 5217 [{] 0. secs (0.u,0.s)
Chars 5218 - 5234 [(subst~p1;~clear).] 0.006 secs (0.006u,0.s)
Chars 5247 - 5261 [etransitivity.] 0.01 secs (0.01u,0.s)
Chars 5274 - 5305 [1:~srapply~moveL_transport_V_1.] 0.006 secs (0.006u,0.s)
Chars 5318 - 5332 [etransitivity.] 0.009 secs (0.009u,0.s)
Chars 5345 - 5346 [{] 0. secs (0.u,0.s)
Chars 5347 - 5364 [srapply~inverse2.] 0.004 secs (0.004u,0.s)
Chars 5379 - 5404 [2:~srapply~transport_VpV.] 0.005 secs (0.005u,0.s)
Chars 5405 - 5406 [}] 0. secs (0.u,0.s)
Chars 5419 - 5440 [(symmetry;~apply~ap_V).] 0.014 secs (0.014u,0.s)
Chars 5441 - 5442 [}] 0. secs (0.u,0.s)
Chars 5453 - 5475 [(rewrite~X;~clear~X~p1).] 0.051 secs (0.051u,0.s)
Chars 5486 - 5513 [(rewrite~<-~ap_compose;~cbn).] 0.1 secs (0.095u,0.005s)
Chars 5524 - 5608 [(rewrite~(ap_path_sigma~(fun~x...] 0.059 secs (0.058u,0.s)
Chars 5619 - 5662 [(cbn;~rewrite~!concat_p1,~conc...] 0.192 secs (0.19u,0.s)
Chars 5673 - 5688 [(apply~moveL_Vp).] 0.018 secs (0.016u,0.001s)
Chars 5699 - 5800 [(match~goal~with~~|~|-~?pp1~@~...] 0.079 secs (0.079u,0.s)
Chars 5811 - 5863 [(assert~(p1~=~path_sigma'~E'~1...] 0.008 secs (0.007u,0.s)
Chars 5874 - 5875 [{] 0. secs (0.u,0.s)
Chars 5877 - 5886 [subst~p1.] 0.005 secs (0.005u,0.s)
Chars 5899 - 5919 [(rewrite~<-~ap_exist).] 0.017 secs (0.016u,0.s)
Chars 5932 - 6037 [(rewrite~~~(ap_compose~(transp...] 0.024 secs (0.024u,0.s)
Chars 6050 - 6077 [(f_ap;~set~(colimp~i~j~g~x)).] 0.026 secs (0.025u,0.s)
Chars 6090 - 6106 [(clear;~symmetry).] 0.013 secs (0.013u,0.s)
Chars 6119 - 6139 [(apply~transport_VpV).] 0.005 secs (0.005u,0.s)
Chars 6140 - 6141 [}] 0. secs (0.u,0.s)
Chars 6152 - 6174 [(rewrite~X;~clear~p1~X).] 0.041 secs (0.041u,0.s)
Chars 6185 - 6266 [(assert~(p2~=~path_sigma'~E'~1...] 0.024 secs (0.024u,0.s)
Chars 6277 - 6299 [(rewrite~X;~clear~p2~X).] 0.046 secs (0.046u,0.s)
Chars 6310 - 6346 [(rewrite~<-~!path_sigma_pp_pp'...] 0.142 secs (0.141u,0.s)
Chars 6357 - 6388 [(rewrite~concat_p1,~concat_pp_p).] 0.078 secs (0.078u,0.s)
Chars 6399 - 6415 [refine~(1~@@~_).] 0.009 secs (0.009u,0.s)
Chars 6426 - 6441 [(apply~moveL_Mp).] 0.007 secs (0.007u,0.s)
Chars 6452 - 6478 [(rewrite~<-~ap_V,~<-~ap_pp).] 0.059 secs (0.055u,0.004s)
Chars 6489 - 6505 [srefine~(_~@~_).] 0.005 secs (0.005u,0.s)
Chars 6516 - 6517 [-] 0. secs (0.u,0.s)
Chars 6518 - 6564 [refine~(ap~(transport~E'~(coli...] 0.004 secs (0.004u,0.s)
Chars 6577 - 6614 [refine~((transport_E'_V~_~_~_)...] 0.005 secs (0.004u,0.s)
Chars 6627 - 6662 [refine~(ap~_~(transport_pV~_~_...] 0.003 secs (0.003u,0.s)
Chars 6673 - 6674 [-] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 6675 - 6680 [f_ap.] 0.014 secs (0.013u,0.s)
Chars 6693 - 6709 [refine~(1~@@~_).] 0.016 secs (0.016u,0.s)
Chars 6722 - 6742 [(apply~transport_VpV).] 0.005 secs (0.005u,0.s)
Chars 6753 - 6754 [-] 0. secs (0.u,0.s)
Chars 6755 - 6840 [(set~(transport~E'~(colimp~i~j...] 0.014 secs (0.014u,0.s)
Chars 6853 - 6882 [(rewrite~ap_pp,~<-~ap_compose).] 0.032 secs (0.032u,0.s)
Chars 6895 - 6935 [refine~(_~@~(transport_E'_V_E'...] 0.008 secs (0.008u,0.s)
Chars 6948 - 6964 [refine~(1~@@~_).] 0.005 secs (0.005u,0.s)
Chars 6977 - 6985 [subst~e.] 0.002 secs (0.001u,0.s)
Chars 6998 - 7034 [refine~(_~@~(transport_pVp~_~_...] 0.005 secs (0.005u,0.s)
Chars 7047 - 7066 [(rewrite~ap_compose).] 0.013 secs (0.013u,0.s)
Chars 7079 - 7094 [(f_ap;~symmetry).] 0.017 secs (0.017u,0.s)
Chars 7107 - 7127 [(apply~transport_VpV).] 0.005 secs (0.004u,0.s)
Chars 7128 - 7129 [}] 0. secs (0.u,0.s)
Chars 7138 - 7167 [(rewrite~X;~simpl;~hott_simpl).] 1.574 secs (1.502u,0.047s)
Chars 2786 - 2816 [srapply~Build_UniversalCocone.] 0.001 secs (0.001u,0.s)
Chars 2821 - 2857 [(intro~Z;~srapply~isequiv_adjo...] 0.002 secs (0.002u,0.s)
Chars 2864 - 2888 [(intros~[q~qq];~cbn~in~*).] 0.001 secs (0.001u,0.s)
Chars 2895 - 2920 [(intros~[x~y];~revert~x~y).] 0.002 secs (0.002u,0.s)
Chars 2927 - 2952 [(srapply~Colimit_ind;~cbn).] 0.003 secs (0.003u,0.s)
Chars 2961 - 2994 [(intros~i~x~y;~exact~(q~i~(x;~...] 0.002 secs (0.002u,0.s)
Chars 3003 - 3023 [(intros~i~j~g~x;~cbn).] 0.005 secs (0.005u,0.s)
Chars 3032 - 3041 [funext~y.] 0.001 secs (0.001u,0.s)
Chars 3050 - 3093 [refine~(transport_arrow_tocons...] 0.001 secs (0.001u,0.s)
Chars 3102 - 3131 [refine~(_~@~qq~i~j~g~(x;~y)).] 0.001 secs (0.001u,0.s)
Chars 3140 - 3150 [(cbn;~f_ap).] 0.009 secs (0.006u,0.s)
Chars 3159 - 3191 [(refine~(path_sigma'~_~1~_);~c...] 0.004 secs (0.004u,0.s)
Chars 3200 - 3221 [(apply~transport_E'_V).] 0.002 secs (0.002u,0.s)
Chars 3228 - 3242 [(intros~[q~qq]).] 0.016 secs (0.016u,0.s)
Chars 3249 - 3269 [srapply~path_cocone.] 0.006 secs (0.006u,0.s)
Chars 3278 - 3302 [(intros~i~x;~reflexivity).] 0.013 secs (0.013u,0.s)
Chars 3311 - 3330 [(intros~i~j~g~[x~y]).] 0.024 secs (0.024u,0.s)
Chars 3339 - 3368 [(rewrite~concat_1p,~concat_p1).] 0.075 secs (0.071u,0.003s)
Chars 3377 - 3404 [(cbn;~rewrite~ap_path_sigma).] 0.017 secs (0.017u,0.s)
Chars 3413 - 3450 [(cbn;~rewrite~Colimit_ind_beta...] 0.048 secs (0.048u,0.s)
Chars 3459 - 3484 [(rewrite~ap10_path_forall).] 0.023 secs (0.023u,0.s)
Chars 3493 - 3504 [hott_simpl.] 0.019 secs (0.019u,0.s)
Chars 3513 - 3538 [refine~(_~@~concat_1p~_).] 0.022 secs (0.019u,0.003s)
Chars 3547 - 3563 [refine~(_~@@~1).] 0.014 secs (0.014u,0.s)
Chars 3572 - 3620 [(match~goal~with~~|~|-~ap~_~?X...] 0.009 secs (0.009u,0.s)
Chars 3629 - 3664 [(assert~(transport_E'_V~g~x~y~...] 0.011 secs (0.011u,0.s)
Chars 3675 - 3683 [subst~p.] 0.003 secs (0.003u,0.s)
Chars 3694 - 3734 [exact~(moveL_transport_V_V~E'~...] 0.002 secs (0.002u,0.s)
Chars 3745 - 3755 [(rewrite~X).] 0.011 secs (0.011u,0.s)
Chars 3764 - 3783 [(clearbody~p;~clear).] 0.023 secs (0.023u,0.s)
Chars 3792 - 3813 [(set~(E_f~g~x~y)~in~*).] 0.011 secs (0.011u,0.s)
Chars 3822 - 3833 [(destruct~p).] 0.01 secs (0.01u,0.s)
Chars 3842 - 3854 [reflexivity.] 0.01 secs (0.01u,0.s)
Chars 3861 - 3869 [intro~f.] 0.015 secs (0.015u,0.s)
Chars 3876 - 3889 [funext~[x~y].] 0.006 secs (0.006u,0.s)
Chars 3896 - 3912 [(revert~x~y;~cbn).] 0.014 secs (0.014u,0.s)
Chars 3919 - 3944 [(srapply~Colimit_ind;~cbn).] 0.015 secs (0.015u,0.s)
Chars 3953 - 3965 [reflexivity.] 0.004 secs (0.004u,0.s)
Chars 3974 - 3994 [(intros~i~j~g~x;~cbn).] 0.013 secs (0.013u,0.s)
Chars 4003 - 4012 [funext~y.] 0.006 secs (0.006u,0.s)
Chars 3707 - 3729 [(apply~equiv_iff_hprop).] 30.336 secs (18.854u,0.265s)
Chars 4021 - 4051 [(rewrite~transport_forall;~cbn).] 0.015 secs (0.015u,0.s)
Chars 4060 - 4089 [(rewrite~transport_paths_FlFr).] 0.008 secs (0.008u,0.s)
Chars 4098 - 4149 [(match~goal~with~~|~|-~(_~@~?p...] 0.02 secs (0.02u,0.s)
Chars 4158 - 4167 [(cbn~in~p).] 0.022 secs (0.021u,0.s)
Chars 4176 - 4191 [(assert~(p~=~1)).] 0.024 secs (0.024u,0.s)
Chars 4202 - 4210 [subst~p.] 0.032 secs (0.028u,0.003s)
Chars 4221 - 4286 [(match~goal~with~~|~|-~transpo...] 0.009 secs (0.009u,0.s)
Chars 4297 - 4355 [(rewrite~(transportD_is_transp...] 0.009 secs (0.009u,0.s)
Chars 4366 - 4380 [(subst~C2;~cbn).] 0.019 secs (0.019u,0.s)
Chars 4391 - 4420 [(rewrite~transport_paths_FlFr).] 0.009 secs (0.009u,0.s)
Chars 4431 - 4449 [(rewrite~concat_p1).] 0.017 secs (0.017u,0.s)
Chars 4460 - 4475 [(apply~moveR_Vp).] 0.014 secs (0.014u,0.s)
Chars 4486 - 4504 [(rewrite~concat_p1).] 0.011 secs (0.011u,0.s)
Chars 4515 - 4537 [(rewrite~ap_path_sigma).] 0.006 secs (0.006u,0.s)
Chars 4548 - 4552 [(cbn).] 0.03 secs (0.03u,0.s)
Chars 4563 - 4595 [(rewrite~Colimit_ind_beta_coli...] 0.028 secs (0.028u,0.s)
Chars 4606 - 4631 [(rewrite~ap10_path_forall).] 0.03 secs (0.03u,0.s)
Chars 4642 - 4653 [hott_simpl.] 0.025 secs (0.025u,0.s)
Chars 4664 - 4690 [(rewrite~ap11_is_ap10_ap01).] 0.012 secs (0.012u,0.s)
Chars 4701 - 4705 [(cbn).] 0.015 secs (0.015u,0.s)
Chars 4716 - 4734 [(rewrite~concat_1p).] 0.028 secs (0.023u,0.004s)
Chars 4745 - 4805 [(rewrite~(ap_compose~(fun~y~=>...] 0.012 secs (0.012u,0.s)
Chars 4816 - 4820 [(cbn).] 0.01 secs (0.01u,0.s)
Chars 4831 - 4934 [(rewrite~~~(ap_compose~~~~~~(f...] 0.011 secs (0.011u,0.s)
Chars 4945 - 4968 [(rewrite~<-~!(ap_pp~f)).] 0.013 secs (0.013u,0.s)
Chars 4979 - 4997 [(apply~(ap~(ap~f))).] 0.006 secs (0.006u,0.s)
Chars 5008 - 5094 [(match~goal~with~~|~|-~_~=~(ap...] 0.006 secs (0.006u,0.s)
Chars 5105 - 5205 [(assert~~~(p1~=~~~~ap~(transpo...] 0.006 secs (0.006u,0.s)
Chars 5218 - 5234 [(subst~p1;~clear).] 0.005 secs (0.005u,0.s)
Chars 5247 - 5261 [etransitivity.] 0.002 secs (0.002u,0.s)
Chars 5274 - 5305 [1:~srapply~moveL_transport_V_1.] 0.001 secs (0.001u,0.s)
Chars 5318 - 5332 [etransitivity.] 0.002 secs (0.002u,0.s)
Chars 5347 - 5364 [srapply~inverse2.] 0.001 secs (0.001u,0.s)
Chars 5379 - 5404 [2:~srapply~transport_VpV.] 0.001 secs (0.001u,0.s)
Chars 5419 - 5440 [(symmetry;~apply~ap_V).] 0.004 secs (0.004u,0.s)
Chars 5453 - 5475 [(rewrite~X;~clear~X~p1).] 0.013 secs (0.013u,0.s)
Chars 5486 - 5513 [(rewrite~<-~ap_compose;~cbn).] 0.01 secs (0.01u,0.s)
Chars 5524 - 5608 [(rewrite~(ap_path_sigma~(fun~x...] 0.004 secs (0.004u,0.s)
Chars 5619 - 5662 [(cbn;~rewrite~!concat_p1,~conc...] 0.019 secs (0.019u,0.s)
Chars 5673 - 5688 [(apply~moveL_Vp).] 0.004 secs (0.003u,0.s)
Chars 5699 - 5800 [(match~goal~with~~|~|-~?pp1~@~...] 0.01 secs (0.01u,0.s)
Chars 5811 - 5863 [(assert~(p1~=~path_sigma'~E'~1...] 0.005 secs (0.005u,0.s)
Chars 5877 - 5886 [subst~p1.] 0.004 secs (0.004u,0.s)
Chars 5899 - 5919 [(rewrite~<-~ap_exist).] 0.004 secs (0.004u,0.s)
Chars 5932 - 6037 [(rewrite~~~(ap_compose~(transp...] 0.003 secs (0.003u,0.s)
Chars 6050 - 6077 [(f_ap;~set~(colimp~i~j~g~x)).] 0.006 secs (0.006u,0.s)
Chars 6090 - 6106 [(clear;~symmetry).] 0.004 secs (0.004u,0.s)
Chars 6119 - 6139 [(apply~transport_VpV).] 0.001 secs (0.001u,0.s)
Chars 6152 - 6174 [(rewrite~X;~clear~p1~X).] 0.012 secs (0.012u,0.s)
Chars 6185 - 6266 [(assert~(p2~=~path_sigma'~E'~1...] 0.005 secs (0.005u,0.s)
Chars 6277 - 6299 [(rewrite~X;~clear~p2~X).] 0.012 secs (0.012u,0.s)
Chars 6310 - 6346 [(rewrite~<-~!path_sigma_pp_pp'...] 0.008 secs (0.008u,0.s)
Chars 6357 - 6388 [(rewrite~concat_p1,~concat_pp_p).] 0.005 secs (0.005u,0.s)
Chars 6399 - 6415 [refine~(1~@@~_).] 0.004 secs (0.004u,0.s)
Chars 6426 - 6441 [(apply~moveL_Mp).] 0.003 secs (0.003u,0.s)
Chars 6452 - 6478 [(rewrite~<-~ap_V,~<-~ap_pp).] 0.004 secs (0.004u,0.s)
Chars 6489 - 6505 [srefine~(_~@~_).] 0.003 secs (0.003u,0.s)
Chars 6518 - 6564 [refine~(ap~(transport~E'~(coli...] 0.001 secs (0.001u,0.s)
Chars 6577 - 6614 [refine~((transport_E'_V~_~_~_)...] 0.001 secs (0.001u,0.s)
Chars 6627 - 6662 [refine~(ap~_~(transport_pV~_~_...] 0.001 secs (0.001u,0.s)
Chars 6675 - 6680 [f_ap.] 0.004 secs (0.004u,0.s)
Chars 6693 - 6709 [refine~(1~@@~_).] 0.003 secs (0.003u,0.s)
Chars 6722 - 6742 [(apply~transport_VpV).] 0.002 secs (0.002u,0.s)
Chars 6755 - 6840 [(set~(transport~E'~(colimp~i~j...] 0.003 secs (0.003u,0.s)
Chars 6853 - 6882 [(rewrite~ap_pp,~<-~ap_compose).] 0.002 secs (0.002u,0.s)
Chars 6895 - 6935 [refine~(_~@~(transport_E'_V_E'...] 0.002 secs (0.002u,0.s)
Chars 6948 - 6964 [refine~(1~@@~_).] 0.026 secs (0.02u,0.005s)
Chars 6977 - 6985 [subst~e.] 0.002 secs (0.002u,0.s)
Chars 6998 - 7034 [refine~(_~@~(transport_pVp~_~_...] 0.002 secs (0.002u,0.s)
Chars 7047 - 7066 [(rewrite~ap_compose).] 0.002 secs (0.002u,0.s)
Chars 7079 - 7094 [(f_ap;~symmetry).] 0.004 secs (0.004u,0.s)
Chars 7107 - 7127 [(apply~transport_VpV).] 0.001 secs (0.001u,0.s)
Chars 7138 - 7167 [(rewrite~X;~simpl;~hott_simpl).] 0.065 secs (0.065u,0.s)
Chars 7170 - 7178 [Defined.] 6.339 secs (6.169u,0.114s)
Chars 7241 - 7308 [Definition~flattening_lemma~:~...] 0.001 secs (0.001u,0.s)
Chars 7311 - 7317 [Proof.] 0. secs (0.u,0.s)
Chars 5187 - 5231 [simple~refine~(functor_pforall...] 40.122 secs (0.001u,0.022s)
Chars 5234 - 5235 [+] 0. secs (0.u,0.s)
Chars 5236 - 5244 [exact~g.] 0.001 secs (0.001u,0.s)
Chars 5247 - 5248 [+] 0. secs (0.u,0.s)
Chars 5249 - 5280 [exact~(point_eq~(g~(point~A))).] 0.04 secs (0.031u,0.008s)
Chars 5187 - 5231 [simple~refine~(functor_pforall...] 0. secs (0.u,0.s)
Chars 5236 - 5244 [exact~g.] 0. secs (0.u,0.s)
Chars 5249 - 5280 [exact~(point_eq~(g~(point~A))).] 0. secs (0.u,0.s)
Chars 5281 - 5289 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5291 - 5460 [Definition~pmap_compose_ppfora...] 0.002 secs (0.001u,0.s)
Chars 5461 - 5467 [Proof.] 0. secs (0.u,0.s)
Chars 3707 - 3729 [(apply~equiv_iff_hprop).] 40.072 secs (0.01u,0.027s)
Chars 3734 - 3735 [-] 0. secs (0.u,0.s)
Chars 3736 - 3745 [(intros~?).] 0. secs (0.u,0.s)
Chars 3746 - 3776 [(apply~F_corec;~try~assumption).] 0.001 secs (0.001u,0.s)
Chars 3783 - 3803 [exact~(fun~_~=>~tt).] 0. secs (0.u,0.s)
Chars 3808 - 3809 [-] 0. secs (0.u,0.s)
Chars 3810 - 3819 [(intros~f).] 0. secs (0.u,0.s)
Chars 3826 - 3863 [simple~refine~(inF_fromF_sect~...] 0.001 secs (0.001u,0.s)
Chars 3870 - 3871 [+] 0. secs (0.u,0.s)
Chars 3872 - 3881 [(intros~x).] 0. secs (0.u,0.s)
Chars 3890 - 3928 [exact~(F_functor~(unit_name~x)...] 0.001 secs (0.001u,0.s)
Chars 3935 - 3936 [+] 0. secs (0.u,0.s)
Chars 3937 - 3964 [(intros~x;~unfold~F_functor).] 0.001 secs (0.001u,0.s)
Chars 3973 - 4025 [exact~(F_corec_beta~(F_inF~F~U...] 0.002 secs (0.002u,0.s)
Chars 3707 - 3729 [(apply~equiv_iff_hprop).] 0. secs (0.u,0.s)
Chars 3736 - 3745 [(intros~?).] 0. secs (0.u,0.s)
Chars 3746 - 3776 [(apply~F_corec;~try~assumption).] 0. secs (0.u,0.s)
Chars 3783 - 3803 [exact~(fun~_~=>~tt).] 0. secs (0.u,0.s)
Chars 3810 - 3819 [(intros~f).] 0. secs (0.u,0.s)
Chars 3826 - 3863 [simple~refine~(inF_fromF_sect~...] 0. secs (0.u,0.s)
Chars 3872 - 3881 [(intros~x).] 0. secs (0.u,0.s)
Chars 3890 - 3928 [exact~(F_functor~(unit_name~x)...] 0. secs (0.u,0.s)
Chars 3937 - 3964 [(intros~x;~unfold~F_functor).] 0. secs (0.u,0.s)
Chars 3973 - 4025 [exact~(F_corec_beta~(F_inF~F~U...] 0. secs (0.u,0.s)
Chars 4028 - 4036 [Defined.] 0. secs (0.u,0.s)
Chars 4038 - 4066 [End~CoreflectiveSubuniverse.] 0.014 secs (0.011u,0.002s)
Chars 4257 - 4272 [Section~CoOpen.] 0. secs (0.u,0.s)
Chars 4275 - 4305 [Context~`{Funext}~(U~:~HProp).] 0. secs (0.u,0.s)
Chars 4309 - 4351 [Definition~coOp~:~Coreflective...] 0. secs (0.u,0.s)
Chars 4354 - 4360 [Proof.] 0. secs (0.u,0.s)
Chars 4779 - 4787 [intro~p.] 40.178 secs (0.001u,0.03s)
Chars 4792 - 4803 [(destruct~p).] 0.001 secs (0.u,0.s)
Chars 4808 - 4848 [(apply~path_path_isomorphism_h...] 0.017 secs (0.015u,0.001s)
Chars 4853 - 4861 [exact~_.] 0. secs (0.u,0.s)
Chars 4779 - 4787 [intro~p.] 0. secs (0.u,0.s)
Chars 4792 - 4803 [(destruct~p).] 0. secs (0.u,0.s)
Chars 4808 - 4848 [(apply~path_path_isomorphism_h...] 0. secs (0.u,0.s)
Chars 4853 - 4861 [exact~_.] 0. secs (0.u,0.s)
Chars 4864 - 4868 [Qed.] 0.001 secs (0.001u,0.s)
Chars 4872 - 5076 [#[global]~Instance~isequiv_iso...] 0.003 secs (0.003u,0.s)
Chars 5078 - 5104 [End~isequiv_isomorphic_id.] 0.009 secs (0.008u,0.s)
Chars 7253 - 7283 [(unfold~ComputeOpQuotient~in~G).] 40.162 secs (0.001u,0.031s)
Chars 7288 - 7310 [(induction~w;~cbn~in~*).] 0.014 secs (0.012u,0.001s)
Chars 7315 - 7316 [-] 0. secs (0.u,0.s)
Chars 7317 - 7337 [by~destruct~(G~tt)^.] 0.004 secs (0.003u,0.s)
Chars 7342 - 7343 [-] 0. secs (0.u,0.s)
Chars 7344 - 7352 [intro~x.] 0.002 secs (0.002u,0.s)
Chars 7353 - 7363 [(apply~IHw).] 0.003 secs (0.001u,0.001s)
Chars 7364 - 7372 [intro~a.] 0.003 secs (0.003u,0.s)
Chars 7373 - 7389 [(apply~(G~(x,~a))).] 0.004 secs (0.004u,0.s)
Chars 7253 - 7283 [(unfold~ComputeOpQuotient~in~G).] 0. secs (0.u,0.s)
Chars 7288 - 7310 [(induction~w;~cbn~in~*).] 0.005 secs (0.005u,0.s)
Chars 7317 - 7337 [by~destruct~(G~tt)^.] 0. secs (0.u,0.s)
Chars 7344 - 7352 [intro~x.] 0.002 secs (0.002u,0.s)
Chars 7353 - 7363 [(apply~IHw).] 0.002 secs (0.002u,0.s)
Chars 7364 - 7372 [intro~a.] 0.002 secs (0.002u,0.s)
Chars 7373 - 7389 [(apply~(G~(x,~a))).] 0.002 secs (0.002u,0.s)
Chars 7392 - 7400 [Defined.] 0.01 secs (0.006u,0.001s)
Chars 7404 - 7493 [#[global]~Instance~is_homomorp...] 0. secs (0.u,0.s)
Chars 7496 - 7502 [Proof.] 0. secs (0.u,0.s)
Chars 15901 - 15913 [(unfold~zero).] 40.15 secs (0.u,0.027s)
Chars 15918 - 15965 [one_line_proof~(sum_empty_r~_)...] 0.053 secs (0.046u,0.006s)
Chars 15901 - 15913 [(unfold~zero).] 0. secs (0.u,0.s)
Chars 15918 - 15965 [one_line_proof~(sum_empty_r~_)...] 0. secs (0.u,0.s)
Chars 15968 - 15976 [Defined.] 0.021 secs (0.015u,0.005s)
Chars 15980 - 16022 [Theorem~zero_plus~(x~:~No)~:~z...] 0.004 secs (0.003u,0.001s)
Chars 16025 - 16031 [Proof.] 0. secs (0.u,0.s)
Chars 6153 - 6176 [(apply~isequiv_surj_emb).] 40.152 secs (0.001u,0.032s)
Chars 6179 - 6180 [-] 0. secs (0.u,0.s)
Chars 6181 - 6189 [intro~f.] 0.001 secs (0.001u,0.s)
Chars 6194 - 6223 [rapply~contr_inhabited_hprop.] 0.038 secs (0.034u,0.003s)
Chars 6314 - 6377 [(assert~(e0~:~Tr~(-~1)~(hfiber...] 0.003 secs (0.003u,0.s)
Chars 6382 - 6415 [1:~(apply~issurjection_project...] 0.003 secs (0.003u,0.s)
Chars 6420 - 6438 [strip_truncations.] 0.079 secs (0.073u,0.005s)
Chars 6539 - 6602 [(assert~(a~:~Tr~(-~1)~(hfiber~...] 0.007 secs (0.007u,0.s)
Chars 6607 - 6611 [1:~{] 0. secs (0.u,0.s)
Chars 6612 - 6681 [refine~(isexact_preimage~(Tr~(...] 0.006 secs (0.006u,0.s)
Chars 6691 - 6722 [refine~(grp_homo_op~_~_~_~@~_).] 0.003 secs (0.002u,0.s)
Chars 6732 - 6769 [refine~(ap~_~(grp_homo_inv~_~_...] 0.003 secs (0.003u,0.s)
Chars 6779 - 6803 [(apply~grp_moveL_1M^-1).] 0.02 secs (0.018u,0.s)
Chars 6813 - 6837 [exact~((e0.2)^~@~p1~e0.1).] 0.002 secs (0.002u,0.s)
Chars 6838 - 6839 [}] 0. secs (0.u,0.s)
Chars 6844 - 6862 [strip_truncations.] 0.09 secs (0.08u,0.009s)
Chars 6867 - 6907 [refine~(tr~(inclusion~E~a.1~+~...] 0.005 secs (0.003u,0.001s)
Chars 6912 - 6943 [refine~(grp_homo_op~_~_~_~@~_).] 0.002 secs (0.002u,0.s)
Chars 6948 - 7003 [refine~(ap~(fun~x~=>~x~+~phi~e...] 0.006 secs (0.005u,0.s)
Chars 7008 - 7040 [refine~((grp_assoc~_~_~_)^~@~_).] 0.003 secs (0.003u,0.s)
Chars 7045 - 7089 [refine~(ap~_~(left_inverse~(ph...] 0.016 secs (0.014u,0.002s)
Chars 7094 - 7111 [(apply~grp_unit_r).] 0.002 secs (0.002u,0.s)
Chars 7114 - 7115 [-] 0. secs (0.u,0.s)
Chars 7116 - 7152 [(apply~isembedding_grouphomomo...] 0.002 secs (0.001u,0.s)
Chars 7157 - 7168 [(intros~e~p).] 0.001 secs (0.001u,0.s)
Chars 7173 - 7219 [(assert~(a~:~Tr~(-~1)~(hfiber~...] 0.003 secs (0.003u,0.s)
Chars 7224 - 7228 [1:~{] 0. secs (0.u,0.s)
Chars 7229 - 7290 [refine~(isexact_preimage~_~(in...] 0.005 secs (0.003u,0.001s)
Chars 7300 - 7353 [exact~((p1~e~@~ap~(projection~...] 0.004 secs (0.004u,0.s)
Chars 7354 - 7355 [}] 0. secs (0.u,0.s)
Chars 7360 - 7378 [strip_truncations.] 0.21 secs (0.203u,0.006s)
Chars 7383 - 7449 [refine~(((a.2)^~@~ap~(inclusio...] 0.004 secs (0.004u,0.s)
Chars 7454 - 7497 [rapply~(isinj_embedding~(inclu...] 0.01 secs (0.006u,0.s)
Chars 7502 - 7561 [refine~((((p0~a.1)^~@~ap~phi~a...] 0.006 secs (0.003u,0.s)
Chars 6153 - 6176 [(apply~isequiv_surj_emb).] 0. secs (0.u,0.s)
Chars 6181 - 6189 [intro~f.] 0. secs (0.u,0.s)
Chars 6194 - 6223 [rapply~contr_inhabited_hprop.] 0. secs (0.u,0.s)
Chars 6314 - 6377 [(assert~(e0~:~Tr~(-~1)~(hfiber...] 0. secs (0.u,0.s)
Chars 6382 - 6415 [1:~(apply~issurjection_project...] 0. secs (0.u,0.s)
Chars 6420 - 6438 [strip_truncations.] 0. secs (0.u,0.s)
Chars 6539 - 6602 [(assert~(a~:~Tr~(-~1)~(hfiber~...] 0. secs (0.u,0.s)
Chars 6612 - 6681 [refine~(isexact_preimage~(Tr~(...] 0. secs (0.u,0.s)
Chars 6691 - 6722 [refine~(grp_homo_op~_~_~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 6732 - 6769 [refine~(ap~_~(grp_homo_inv~_~_...] 0. secs (0.u,0.s)
Chars 6779 - 6803 [(apply~grp_moveL_1M^-1).] 0. secs (0.u,0.s)
Chars 6813 - 6837 [exact~((e0.2)^~@~p1~e0.1).] 0. secs (0.u,0.s)
Chars 6844 - 6862 [strip_truncations.] 0. secs (0.u,0.s)
Chars 6867 - 6907 [refine~(tr~(inclusion~E~a.1~+~...] 0. secs (0.u,0.s)
Chars 6912 - 6943 [refine~(grp_homo_op~_~_~_~@~_).] 0. secs (0.u,0.s)
Chars 6948 - 7003 [refine~(ap~(fun~x~=>~x~+~phi~e...] 0. secs (0.u,0.s)
Chars 7008 - 7040 [refine~((grp_assoc~_~_~_)^~@~_).] 0. secs (0.u,0.s)
Chars 7045 - 7089 [refine~(ap~_~(left_inverse~(ph...] 0. secs (0.u,0.s)
Chars 7094 - 7111 [(apply~grp_unit_r).] 0. secs (0.u,0.s)
Chars 7116 - 7152 [(apply~isembedding_grouphomomo...] 0. secs (0.u,0.s)
Chars 7157 - 7168 [(intros~e~p).] 0. secs (0.u,0.s)
Chars 7173 - 7219 [(assert~(a~:~Tr~(-~1)~(hfiber~...] 0. secs (0.u,0.s)
Chars 7229 - 7290 [refine~(isexact_preimage~_~(in...] 0. secs (0.u,0.s)
Chars 7300 - 7353 [exact~((p1~e~@~ap~(projection~...] 0. secs (0.u,0.s)
Chars 7360 - 7378 [strip_truncations.] 0. secs (0.u,0.s)
Chars 7383 - 7449 [refine~(((a.2)^~@~ap~(inclusio...] 0. secs (0.u,0.s)
Chars 7454 - 7497 [rapply~(isinj_embedding~(inclu...] 0. secs (0.u,0.s)
Chars 7502 - 7561 [refine~((((p0~a.1)^~@~ap~phi~a...] 0. secs (0.u,0.s)
Chars 7562 - 7570 [Defined.] 0.016 secs (0.015u,0.s)
Chars 7756 - 7956 [Definition~abses_path_data~{B~...] 0.006 secs (0.006u,0.s)
Chars 7958 - 8086 [Definition~abses_path_data_to_...] 0.001 secs (0.001u,0.s)
Chars 8087 - 8093 [Proof.] 0. secs (0.u,0.s)
Chars 8096 - 8097 [-] 0. secs (0.u,0.s)
Chars 3686 - 3698 [(induction~n).] 40.139 secs (0.001u,0.028s)
Chars 3701 - 3712 [1:~exact~_.] 0.002 secs (0.002u,0.s)
Chars 3715 - 3751 [(nrapply~is0functor_compose;~e...] 0.004 secs (0.004u,0.s)
Chars 3686 - 3698 [(induction~n).] 0. secs (0.u,0.s)
Chars 3701 - 3712 [1:~exact~_.] 0. secs (0.u,0.s)
Chars 3715 - 3751 [(nrapply~is0functor_compose;~e...] 0. secs (0.u,0.s)
Chars 3752 - 3760 [Defined.] 0.001 secs (0.001u,0.s)
Chars 3762 - 3838 [#[global]~Instance~is1functor_...] 0.002 secs (0.002u,0.s)
Chars 3839 - 3845 [Proof.] 0. secs (0.u,0.s)
Chars 2619 - 2678 [(rewrite~(distribute_r~x~y~(x~...] 40.201 secs (0.003u,0.031s)
Chars 2681 - 2718 [(rewrite~(distribute_r~_~_~(y~...] 0.004 secs (0.002u,0.002s)
Chars 2721 - 2750 [(rewrite~(distribute_l~x~y~z)).] 0.004 secs (0.003u,0.s)
Chars 2753 - 2819 [(rewrite~(commutativity~y~(x~⊓...] 0.017 secs (0.014u,0.002s)
Chars 2822 - 2851 [(rewrite~join_meet_absorption).] 0.003 secs (0.002u,0.s)
Chars 2854 - 2883 [(rewrite~(distribute_r~x~z~y)).] 0.003 secs (0.003u,0.s)
Chars 2886 - 2924 [(rewrite~(commutativity~(f:=jo...] 0.009 secs (0.006u,0.002s)
Chars 2927 - 2971 [(rewrite~(commutativity~(x~⊔~y...] 0.006 secs (0.004u,0.002s)
Chars 2974 - 3039 [(rewrite~simple_associativity,...] 0.014 secs (0.011u,0.002s)
Chars 3042 - 3068 [(rewrite~(idempotency~_~_)).] 0.006 secs (0.005u,0.s)
Chars 3071 - 3115 [(rewrite~(commutativity~(x~⊔~z...] 0.006 secs (0.005u,0.s)
Chars 3118 - 3130 [reflexivity.] 0. secs (0.u,0.s)
Chars 2619 - 2678 [(rewrite~(distribute_r~x~y~(x~...] 0. secs (0.u,0.s)
Chars 2681 - 2718 [(rewrite~(distribute_r~_~_~(y~...] 0. secs (0.u,0.s)
Chars 2721 - 2750 [(rewrite~(distribute_l~x~y~z)).] 0. secs (0.u,0.s)
Chars 2753 - 2819 [(rewrite~(commutativity~y~(x~⊓...] 0. secs (0.u,0.s)
Chars 2822 - 2851 [(rewrite~join_meet_absorption).] 0. secs (0.u,0.s)
Chars 2854 - 2883 [(rewrite~(distribute_r~x~z~y)).] 0. secs (0.u,0.s)
Chars 2886 - 2924 [(rewrite~(commutativity~(f:=jo...] 0. secs (0.u,0.s)
Chars 2927 - 2971 [(rewrite~(commutativity~(x~⊔~y...] 0. secs (0.u,0.s)
Chars 2974 - 3039 [(rewrite~simple_associativity,...] 0. secs (0.u,0.s)
Chars 3042 - 3068 [(rewrite~(idempotency~_~_)).] 0. secs (0.u,0.s)
Chars 3071 - 3115 [(rewrite~(commutativity~(x~⊔~z...] 0. secs (0.u,0.s)
Chars 3118 - 3130 [reflexivity.] 0. secs (0.u,0.s)
Chars 3133 - 3137 [Qed.] 0.006 secs (0.005u,0.s)
Chars 3138 - 3169 [End~distributive_lattice_props.] 0.014 secs (0.014u,0.s)
Chars 3171 - 3201 [Section~lower_bounded_lattice.] 0. secs (0.u,0.s)
Chars 3204 - 3270 [Context~`{IsLattice~L}~`{Botto...] 0.001 secs (0.001u,0.s)
Chars 3274 - 3326 [#[global]Instance~meet_bottom_...] 0. secs (0.u,0.s)
Chars 3329 - 3335 [Proof.] 0. secs (0.u,0.s)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣0⟩⟨0∣)
Crunching: (list2D_to_matrix [[0; 0]; [0; C1]] = bool_to_matrix' true)
Crunching: (list2D_to_matrix [[C1; 0]; [0; 0]] = bool_to_matrix' false)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 bool_to_ket contra × (bool_to_ket contra) †)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 bool_to_ket contra × (bool_to_ket contra) †)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 bool_to_ket contra × (bool_to_ket contra) †)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = bool_to_ket l × (bool_to_ket l) †)
Chars 3177 - 3223 [(pose~(g~:=~abses_pullback_mor...] 40.223 secs (0.001u,0.047s)
Chars 3226 - 3257 [nrapply~abses_path_data_to_iso.] 0.007 secs (0.007u,0.s)
Chars 3260 - 3289 [(exists~(component2~g);~split).] 0.007 secs (0.006u,0.s)
Chars 3292 - 3293 [-] 0. secs (0.u,0.s)
Chars 3294 - 3307 [(intro~a;~cbn).] 0.01 secs (0.01u,0.s)
Chars 3312 - 3355 [(apply~equiv_path_pullback_hse...] 0.052 secs (0.046u,0.005s)
Chars 3360 - 3361 [+] 0. secs (0.u,0.s)
Chars 3362 - 3402 [exact~((left_square~f~a)^~@~ap...] 0.004 secs (0.003u,0.001s)
Chars 3407 - 3408 [+] 0. secs (0.u,0.s)
Chars 3409 - 3431 [(apply~iscomplex_abses).] 0.006 secs (0.006u,0.s)
Chars 3434 - 3435 [-] 0. secs (0.u,0.s)
Chars 3436 - 3448 [reflexivity.] 0.006 secs (0.006u,0.s)
Chars 3177 - 3223 [(pose~(g~:=~abses_pullback_mor...] 0. secs (0.u,0.s)
Chars 3226 - 3257 [nrapply~abses_path_data_to_iso.] 0. secs (0.u,0.s)
Chars 3260 - 3289 [(exists~(component2~g);~split).] 0.001 secs (0.001u,0.s)
Chars 3294 - 3307 [(intro~a;~cbn).] 0.002 secs (0.001u,0.s)
Chars 3312 - 3355 [(apply~equiv_path_pullback_hse...] 0.008 secs (0.008u,0.s)
Chars 3362 - 3402 [exact~((left_square~f~a)^~@~ap...] 0. secs (0.u,0.s)
Chars 3409 - 3431 [(apply~iscomplex_abses).] 0. secs (0.u,0.s)
Chars 3436 - 3448 [reflexivity.] 0. secs (0.u,0.s)
Chars 3449 - 3457 [Defined.] 0.054 secs (0.044u,0.009s)
Chars 3589 - 3888 [Definition~abses_component1_tr...] 0.011 secs (0.009u,0.002s)
Chars 4137 - 4255 [#[global]~Instance~is0functor_...] 0.003 secs (0.003u,0.s)
Chars 4256 - 4262 [Proof.] 0. secs (0.u,0.s)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = bool_to_ket l × (bool_to_ket l) †)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 bool_to_ket contra × (bool_to_ket contra) †)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 bool_to_ket contra × (bool_to_ket contra) †)
Chars 5470 - 5494 [srapply~Build_pHomotopy.] 24.762 secs (0.001u,0.022s)
Chars 5497 - 5498 [+] 0. secs (0.u,0.s)
Chars 5499 - 5507 [intro~x.] 0. secs (0.u,0.s)
Chars 5508 - 5531 [exact~(point_eq~(g~x)).] 0.001 secs (0.001u,0.s)
Chars 5534 - 5535 [+] 0. secs (0.u,0.s)
Chars 5536 - 5571 [exact~(concat_p1~_~@~concat_1p...] 0.004 secs (0.004u,0.s)
Chars 5470 - 5494 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 5499 - 5507 [intro~x.] 0. secs (0.u,0.s)
Chars 5508 - 5531 [exact~(point_eq~(g~x)).] 0. secs (0.u,0.s)
Chars 5536 - 5571 [exact~(concat_p1~_~@~concat_1p...] 0.001 secs (0.001u,0.s)
Chars 5572 - 5580 [Defined.] 0.008 secs (0.007u,0.001s)
Chars 5582 - 5856 [Definition~pmap_compose_ppfora...] 0.004 secs (0.004u,0.s)
Chars 5857 - 5863 [Proof.] 0. secs (0.u,0.s)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = bool_to_ket l × (bool_to_ket l) †)
Crunching:
((abs >= 2)%nat \/ (x >= 2)%nat ->
 (bool_to_ket l × (bool_to_ket l) †) abs x = 0)
Chars 16036 - 16048 [(unfold~zero).] 31.377 secs (16.223u,-0.093s)
Chars 7322 - 7346 [srapply~colimit_unicity.] 40.175 secs (0.01u,0.036s)
Chars 7351 - 7378 [3:~(apply~iscolimit_colimit).] 0.003 secs (0.002u,0.001s)
Chars 7383 - 7406 [rapply~Build_IsColimit.] 0.008 secs (0.008u,0.s)
Chars 7411 - 7437 [(apply~unicocone_cocone_E').] 0.002 secs (0.002u,0.s)
Chars 7322 - 7346 [srapply~colimit_unicity.] 0.001 secs (0.001u,0.s)
Chars 7351 - 7378 [3:~(apply~iscolimit_colimit).] 0.001 secs (0.001u,0.s)
Chars 7383 - 7406 [rapply~Build_IsColimit.] 0.001 secs (0.001u,0.s)
Chars 7411 - 7437 [(apply~unicocone_cocone_E').] 0.001 secs (0.u,0.s)
Chars 7440 - 7448 [Defined.] 0. secs (0.u,0.s)
Chars 4365 - 4571 [(simple~refine~~~(Build_Corefl...] 40.73 secs (0.52u,0.083s)
Chars 4576 - 4602 [(intros~Y~X~YU;~simpl~in~*).] 0.001 secs (0.001u,0.s)
Chars 4607 - 4667 [refine~(isequiv_adjointify~_~(...] 0.002 secs (0.002u,0.s)
Chars 4672 - 4673 [-] 0. secs (0.u,0.s)
Chars 4674 - 4724 [(intros~g;~apply~path_arrow;~i...] 0.002 secs (0.002u,0.s)
Chars 4729 - 4730 [-] 0. secs (0.u,0.s)
Chars 4731 - 4768 [(intros~h;~apply~path_arrow;~i...] 0.002 secs (0.002u,0.s)
Chars 4775 - 4832 [(apply~path_prod;~[~reflexivit...] 0.004 secs (0.004u,0.s)
Chars 4365 - 4571 [(simple~refine~~~(Build_Corefl...] 0. secs (0.u,0.s)
Chars 4576 - 4602 [(intros~Y~X~YU;~simpl~in~*).] 0. secs (0.u,0.s)
Chars 4607 - 4667 [refine~(isequiv_adjointify~_~(...] 0. secs (0.u,0.s)
Chars 4674 - 4724 [(intros~g;~apply~path_arrow;~i...] 0. secs (0.u,0.s)
Chars 4731 - 4768 [(intros~h;~apply~path_arrow;~i...] 0.001 secs (0.001u,0.s)
Chars 4775 - 4832 [(apply~path_prod;~[~reflexivit...] 0.001 secs (0.001u,0.s)
Chars 4835 - 4843 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5408 - 5487 [Definition~coopen_isequiv_open...] 0.001 secs (0.001u,0.s)
Chars 5490 - 5496 [Proof.] 0. secs (0.u,0.s)
Chars 7450 - 7465 [End~Flattening.] 4.237 secs (3.992u,0.236s)
Chars 7507 - 7515 [intro~u.] 40.184 secs (0.u,0.032s)
Chars 7516 - 7565 [(apply~oppreserving_quotient,~...] 0.002 secs (0.001u,0.s)
Chars 7507 - 7515 [intro~u.] 0. secs (0.u,0.s)
Chars 7516 - 7565 [(apply~oppreserving_quotient,~...] 0. secs (0.u,0.s)
Chars 7568 - 7576 [Defined.] 0. secs (0.u,0.s)
Chars 7580 - 7670 [Definition~hom_quotient~:~Homo...] 0.002 secs (0.002u,0.s)
Chars 7674 - 7753 [#[global]Instance~surjection_q...] 0.001 secs (0.001u,0.s)
Chars 7756 - 7762 [Proof.] 0. secs (0.u,0.s)
Chars 16036 - 16048 [(unfold~zero).] 40.058 secs (0.001u,0.027s)
Chars 16053 - 16100 [one_line_proof~(sum_empty_l~_)...] 0.055 secs (0.041u,0.011s)
Chars 16036 - 16048 [(unfold~zero).] 0. secs (0.u,0.s)
Chars 16053 - 16100 [one_line_proof~(sum_empty_l~_)...] 0. secs (0.u,0.s)
Chars 16103 - 16111 [Defined.] 0.02 secs (0.014u,0.005s)
Chars 16230 - 16255 [Context~`{HasNegation~S}.] 0.001 secs (0.u,0.s)
Chars 16259 - 16313 [Definition~plus_negate~(x~:~No...] 0.004 secs (0.003u,0.s)
Chars 16316 - 16322 [Proof.] 0. secs (0.u,0.s)
Chars 8098 - 8117 [(intros~[phi~[p~q]]).] 40.119 secs (0.002u,0.034s)
Chars 8122 - 8211 [exact~~({|~grp_iso_homo~:=~phi...] 0.003 secs (0.003u,0.s)
Chars 8098 - 8117 [(intros~[phi~[p~q]]).] 0. secs (0.u,0.s)
Chars 8122 - 8211 [exact~~({|~grp_iso_homo~:=~phi...] 0. secs (0.u,0.s)
Chars 8212 - 8220 [Defined.] 0.003 secs (0.003u,0.s)
Chars 8222 - 8351 [Proposition~equiv_path_abses_d...] 0.001 secs (0.001u,0.s)
Chars 8352 - 8358 [Proof.] 0. secs (0.u,0.s)
Chars 3848 - 3860 [(induction~n).] 40.17 secs (0.001u,0.027s)
Chars 3863 - 3874 [1:~exact~_.] 0.002 secs (0.001u,0.s)
Chars 3877 - 3903 [rapply~is1functor_compose.] 0.155 secs (0.141u,0.013s)
Chars 3848 - 3860 [(induction~n).] 0. secs (0.u,0.s)
Chars 3863 - 3874 [1:~exact~_.] 0. secs (0.u,0.s)
Chars 3877 - 3903 [rapply~is1functor_compose.] 0. secs (0.u,0.s)
Chars 3904 - 3912 [Defined.] 0.002 secs (0.001u,0.s)
Chars 3914 - 4116 [Lemma~fmap_iterated_loops_pp~{...] 0.009 secs (0.006u,0.002s)
Chars 4117 - 4123 [Proof.] 0. secs (0.u,0.s)
Chars 3338 - 3347 [(intros~x).] 40.168 secs (0.u,0.029s)
Chars 3348 - 3388 [(rewrite~<-~(join_bottom_l~x),...] 0.004 secs (0.003u,0.001s)
Chars 3391 - 3399 [trivial.] 0. secs (0.u,0.s)
Chars 3338 - 3347 [(intros~x).] 0. secs (0.u,0.s)
Chars 3348 - 3388 [(rewrite~<-~(join_bottom_l~x),...] 0. secs (0.u,0.s)
Chars 3391 - 3399 [trivial.] 0. secs (0.u,0.s)
Chars 3402 - 3406 [Qed.] 0. secs (0.u,0.s)
Chars 3410 - 3463 [#[global]Instance~meet_bottom_...] 0.001 secs (0.u,0.s)
Chars 3466 - 3472 [Proof.] 0. secs (0.u,0.s)
Chars 4265 - 4308 [(srapply~Build_Is0Functor;~int...] 40.222 secs (0.004u,0.049s)
Chars 4311 - 4331 [snrefine~(_;~(_,~_)).] 0.003 secs (0.003u,0.s)
Chars 4334 - 4335 [-] 0. secs (0.u,0.s)
Chars 4336 - 4371 [srapply~equiv_functor_grp_pull...] 0.01 secs (0.009u,0.s)
Chars 4376 - 4398 [1,~3:~exact~grp_iso_id.] 0.001 secs (0.001u,0.s)
Chars 4403 - 4416 [1:~exact~p.1.] 0.001 secs (0.u,0.s)
Chars 4421 - 4436 [2:~reflexivity.] 0.003 secs (0.003u,0.s)
Chars 4441 - 4449 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 4454 - 4473 [exact~(snd~p.2~x)^.] 0.002 secs (0.002u,0.s)
Chars 4476 - 4477 [-] 0. secs (0.u,0.s)
Chars 4478 - 4486 [intro~x.] 0.001 secs (0.u,0.s)
Chars 4491 - 4536 [(srapply~equiv_path_pullback_h...] 0.184 secs (0.156u,0.027s)
Chars 4541 - 4556 [2:~reflexivity.] 0. secs (0.u,0.s)
Chars 4561 - 4579 [exact~(fst~p.2~x).] 0.001 secs (0.001u,0.s)
Chars 4582 - 4583 [-] 0. secs (0.u,0.s)
Chars 4584 - 4596 [reflexivity.] 0.014 secs (0.012u,0.001s)
Chars 4265 - 4308 [(srapply~Build_Is0Functor;~int...] 0. secs (0.u,0.s)
Chars 4311 - 4331 [snrefine~(_;~(_,~_)).] 0. secs (0.u,0.s)
Chars 4336 - 4371 [srapply~equiv_functor_grp_pull...] 0. secs (0.u,0.s)
Chars 4376 - 4398 [1,~3:~exact~grp_iso_id.] 0. secs (0.u,0.s)
Chars 4403 - 4416 [1:~exact~p.1.] 0. secs (0.u,0.s)
Chars 4421 - 4436 [2:~reflexivity.] 0. secs (0.u,0.s)
Chars 4441 - 4449 [intro~x.] 0. secs (0.u,0.s)
Chars 4454 - 4473 [exact~(snd~p.2~x)^.] 0. secs (0.u,0.s)
Chars 4478 - 4486 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 4491 - 4536 [(srapply~equiv_path_pullback_h...] 0.005 secs (0.004u,0.001s)
Chars 4541 - 4556 [2:~reflexivity.] 0. secs (0.u,0.s)
Chars 4561 - 4579 [exact~(fst~p.2~x).] 0. secs (0.u,0.s)
Chars 4584 - 4596 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 4597 - 4605 [Defined.] 0.062 secs (0.053u,0.007s)
Chars 4607 - 4725 [#[global]~Instance~is1functor_...] 0.009 secs (0.009u,0.s)
Chars 4726 - 4732 [Proof.] 0. secs (0.u,0.s)
Chars 5866 - 5890 [srapply~Build_pHomotopy.] 40.111 secs (0.001u,0.023s)
Chars 5893 - 5894 [+] 0. secs (0.u,0.s)
Chars 5895 - 5907 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 5910 - 5911 [+] 0. secs (0.u,0.s)
Chars 5912 - 5918 [(simpl).] 0.006 secs (0.005u,0.s)
Chars 5919 - 5969 [refine~(whiskerL~_~(inverse2~_...] 0.006 secs (0.006u,0.s)
Chars 5974 - 6016 [refine~(whiskerR~_~_~@~concat_...] 0.005 secs (0.004u,0.s)
Chars 6021 - 6075 [refine~(ap_pp~_~_~_~@~whiskerR...] 0.006 secs (0.006u,0.s)
Chars 5866 - 5890 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 5895 - 5907 [reflexivity.] 0. secs (0.u,0.s)
Chars 5912 - 5918 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 5919 - 5969 [refine~(whiskerL~_~(inverse2~_...] 0.002 secs (0.002u,0.s)
Chars 5974 - 6016 [refine~(whiskerR~_~_~@~concat_...] 0.001 secs (0.u,0.s)
Chars 6021 - 6075 [refine~(ap_pp~_~_~_~@~whiskerR...] 0.001 secs (0.001u,0.s)
Chars 6076 - 6084 [Defined.] 0.064 secs (0.052u,0.007s)
Chars 6086 - 6327 [Definition~pmap_compose_ppfora...] 0.004 secs (0.004u,0.s)
Chars 6328 - 6334 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutIf ffalse or nil then ;; else If ttrue then ;; else ;; end end
     : st
Chars 5501 - 5567 [refine~(isequiv_adjointify~_~(...] 40.163 secs (0.003u,0.027s)
Chars 5572 - 5573 [-] 0. secs (0.u,0.s)
Chars 5574 - 5596 [(intros~ux;~simpl~in~*).] 0.002 secs (0.001u,0.s)
Chars 5603 - 5630 [(apply~path_arrow;~intros~u).] 0.002 secs (0.002u,0.s)
Chars 5637 - 5706 [transitivity~(O_functor~(Op~U)...] 0.009 secs (0.009u,0.s)
Chars 5713 - 5714 [+] 0. secs (0.u,0.s)
Chars 5715 - 5765 [(apply~ap10,~ap,~path_arrow;~i...] 0.007 secs (0.007u,0.s)
Chars 5774 - 5833 [(apply~path_prod;~simpl;~[~app...] 0.008 secs (0.008u,0.s)
Chars 5840 - 5841 [+] 0. secs (0.u,0.s)
Chars 5842 - 5901 [exact~(ap10~(to_O_natural~(Op~...] 0.005 secs (0.005u,0.s)
Chars 5906 - 5907 [-] 0. secs (0.u,0.s)
Chars 5908 - 5931 [(intros~uux;~simpl~in~*).] 0.001 secs (0.001u,0.s)
Chars 5938 - 5965 [(apply~path_arrow;~intros~u).] 0.002 secs (0.002u,0.s)
Chars 5972 - 6020 [(apply~path_prod;~[~simpl~|~ap...] 0.005 secs (0.005u,0.s)
Chars 6027 - 6097 [transitivity~(O_functor~(Op~U)...] 0.009 secs (0.009u,0.s)
Chars 6104 - 6105 [+] 0. secs (0.u,0.s)
Chars 6106 - 6144 [(apply~ap10,~ap,~path_arrow;~i...] 0.006 secs (0.005u,0.s)
Chars 6153 - 6176 [(apply~path_prod;~simpl).] 0.004 secs (0.004u,0.s)
Chars 6185 - 6186 [*] 0. secs (0.u,0.s)
Chars 6187 - 6231 [exact~(ap~fst~(ap~uux~(path_is...] 0.004 secs (0.004u,0.s)
Chars 6240 - 6241 [*] 0. secs (0.u,0.s)
Chars 6242 - 6261 [(apply~path_ishprop).] 0.003 secs (0.003u,0.s)
Chars 6268 - 6269 [+] 0. secs (0.u,0.s)
Chars 6270 - 6336 [exact~(ap10~(to_O_natural~(Op~...] 0.005 secs (0.005u,0.s)
Chars 5501 - 5567 [refine~(isequiv_adjointify~_~(...] 0. secs (0.u,0.s)
Chars 5574 - 5596 [(intros~ux;~simpl~in~*).] 0. secs (0.u,0.s)
Chars 5603 - 5630 [(apply~path_arrow;~intros~u).] 0. secs (0.u,0.s)
Chars 5637 - 5706 [transitivity~(O_functor~(Op~U)...] 0. secs (0.u,0.s)
Chars 5715 - 5765 [(apply~ap10,~ap,~path_arrow;~i...] 0.001 secs (0.001u,0.s)
Chars 5774 - 5833 [(apply~path_prod;~simpl;~[~app...] 0.001 secs (0.001u,0.s)
Chars 5842 - 5901 [exact~(ap10~(to_O_natural~(Op~...] 0. secs (0.u,0.s)
Chars 5908 - 5931 [(intros~uux;~simpl~in~*).] 0.001 secs (0.001u,0.s)
Chars 5938 - 5965 [(apply~path_arrow;~intros~u).] 0.001 secs (0.001u,0.s)
Chars 5972 - 6020 [(apply~path_prod;~[~simpl~|~ap...] 0.001 secs (0.001u,0.s)
Chars 6027 - 6097 [transitivity~(O_functor~(Op~U)...] 0. secs (0.u,0.s)
Chars 6106 - 6144 [(apply~ap10,~ap,~path_arrow;~i...] 0.001 secs (0.001u,0.s)
Chars 6153 - 6176 [(apply~path_prod;~simpl).] 0.001 secs (0.001u,0.s)
Chars 6187 - 6231 [exact~(ap~fst~(ap~uux~(path_is...] 0. secs (0.u,0.s)
Chars 6242 - 6261 [(apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 6270 - 6336 [exact~(ap10~(to_O_natural~(Op~...] 0. secs (0.u,0.s)
Chars 6339 - 6347 [Defined.] 0.015 secs (0.013u,0.001s)
Chars 6351 - 6510 [Definition~coopen_equiv_open~X...] 0.003 secs (0.003u,0.s)
Chars 6512 - 6523 [End~CoOpen.] 0.027 secs (0.027u,0.s)
produces_a_value
     : M nat
the_value_tactic = 1
     : nat
empty_string = ""
     : string
world_string = "world"
     : string
other_string = "other"
     : string
the_sequence_6 = 
6 :: 3 :: 10 :: 5 :: 16 :: 8 :: 4 :: 2 :: 1 :: nil
     : list nat
inlist
     : forall (A : Type) (x : A) (x0 : list A), M (In x x0)
Chars 7767 - 7775 [intro~s.] 40.155 secs (0.u,0.03s)
Chars 7776 - 7802 [(apply~quotient_surjective).] 0.001 secs (0.001u,0.s)
Chars 7767 - 7775 [intro~s.] 0. secs (0.u,0.s)
Chars 7776 - 7802 [(apply~quotient_surjective).] 0. secs (0.u,0.s)
Chars 7805 - 7809 [Qed.] 0. secs (0.u,0.s)
Chars 7810 - 7827 [End~hom_quotient.] 0.027 secs (0.022u,0.004s)
Chars 7927 - 8142 [#[global]~Instance~is_isomorph...] 0.005 secs (0.004u,0.s)
Chars 8143 - 8149 [Proof.] 0. secs (0.u,0.s)
Chars 16327 - 16459 [(unfold~No~in~*;~repeat_No_ind...] 40.205 secs (0.039u,0.032s)
Chars 16464 - 16478 [(apply~path_No).] 0.003 secs (0.001u,0.001s)
Chars 16483 - 16484 [-] 0. secs (0.u,0.s)
Chars 16485 - 16542 [(apply~le_lr;~[~intros~[l|~r];...] 0.018 secs (0.016u,0.001s)
Chars 16549 - 16550 [+] 0. secs (0.u,0.s)
Chars 16551 - 16601 [(unfold~zero~in~IHL;~rewrite~<...] 0.008 secs (0.006u,0.001s)
Chars 16610 - 16626 [(apply~plus_lt_r).] 0.006 secs (0.005u,0.001s)
Chars 16635 - 16660 [refine~(lt_ropt~_~_~_~l).] 0.004 secs (0.004u,0.s)
Chars 16667 - 16668 [+] 0. secs (0.u,0.s)
Chars 16669 - 16719 [(unfold~zero~in~IHR;~rewrite~<...] 0.007 secs (0.006u,0.001s)
Chars 16728 - 16744 [(apply~plus_lt_l).] 0.006 secs (0.006u,0.s)
Chars 16753 - 16778 [refine~(lt_ropt~_~_~_~r).] 0.008 secs (0.006u,0.001s)
Chars 16783 - 16784 [-] 0. secs (0.u,0.s)
Chars 16785 - 16842 [(apply~le_lr;~[~intros~[]~|~in...] 0.018 secs (0.014u,0.002s)
Chars 16849 - 16850 [+] 0. secs (0.u,0.s)
Chars 16851 - 16901 [(unfold~zero~in~IHR;~rewrite~<...] 0.008 secs (0.007u,0.s)
Chars 16910 - 16926 [(apply~plus_lt_r).] 0.006 secs (0.005u,0.001s)
Chars 16935 - 16960 [refine~(lt_lopt~_~_~_~r).] 0.014 secs (0.011u,0.002s)
Chars 16967 - 16968 [+] 0. secs (0.u,0.s)
Chars 16969 - 17019 [(unfold~zero~in~IHL;~rewrite~<...] 0.007 secs (0.007u,0.s)
Chars 17028 - 17044 [(apply~plus_lt_l).] 0.006 secs (0.005u,0.s)
Chars 17053 - 17078 [refine~(lt_lopt~_~_~_~l).] 0.004 secs (0.004u,0.s)
Chars 16327 - 16459 [(unfold~No~in~*;~repeat_No_ind...] 0.005 secs (0.005u,0.s)
Chars 16464 - 16478 [(apply~path_No).] 0.002 secs (0.002u,0.s)
Chars 16485 - 16542 [(apply~le_lr;~[~intros~[l|~r];...] 0.03 secs (0.021u,0.008s)
Chars 16551 - 16601 [(unfold~zero~in~IHL;~rewrite~<...] 0.005 secs (0.004u,0.s)
Chars 16610 - 16626 [(apply~plus_lt_r).] 0.001 secs (0.001u,0.s)
Chars 16635 - 16660 [refine~(lt_ropt~_~_~_~l).] 0.001 secs (0.001u,0.s)
Chars 16669 - 16719 [(unfold~zero~in~IHR;~rewrite~<...] 0.005 secs (0.005u,0.s)
Chars 16728 - 16744 [(apply~plus_lt_l).] 0.001 secs (0.u,0.s)
Chars 16753 - 16778 [refine~(lt_ropt~_~_~_~r).] 0.001 secs (0.001u,0.s)
Chars 16785 - 16842 [(apply~le_lr;~[~intros~[]~|~in...] 0.01 secs (0.009u,0.s)
Chars 16851 - 16901 [(unfold~zero~in~IHR;~rewrite~<...] 0.005 secs (0.005u,0.s)
Chars 16910 - 16926 [(apply~plus_lt_r).] 0.001 secs (0.001u,0.s)
Chars 16935 - 16960 [refine~(lt_lopt~_~_~_~r).] 0.001 secs (0.001u,0.s)
find_witness Control.TimeoutChars 16969 - 17019 [(unfold~zero~in~IHL;~rewrite~<...] 0.005 secs (0.005u,0.s)
Chars 17028 - 17044 [(apply~plus_lt_l).] 0.001 secs (0.001u,0.s)
Chars 17053 - 17078 [refine~(lt_lopt~_~_~_~l).] 0.001 secs (0.001u,0.s)
Chars 17081 - 17089 [Defined.] 0.035 secs (0.03u,0.003s)
Chars 17093 - 17142 [Definition~sub~(x~y~:~No)~:~No...] 0.004 secs (0.003u,0.s)
Chars 17146 - 17179 [Infix~"-"~:=~sub~:~surreal_scope.] 0. secs (0.u,0.s)
Chars 17181 - 17194 [End~Addition.] 0.526 secs (0.483u,0.042s)
Chars 8361 - 8386 [srapply~equiv_adjointify.] 40.154 secs (0.003u,0.034s)
Chars 8389 - 8390 [-] 0. secs (0.u,0.s)
Chars 8391 - 8420 [(apply~abses_path_data_to_iso).] 0.001 secs (0.001u,0.s)
Chars 8423 - 8424 [-] 0. secs (0.u,0.s)
Chars 8425 - 8468 [srapply~(functor_sigma~(grp_is...] 0.002 secs (0.002u,0.s)
Chars 8473 - 8496 [exact~(fun~_~=>~idmap).] 0.001 secs (0.001u,0.s)
Chars 8499 - 8500 [-] 0. secs (0.u,0.s)
Chars 8501 - 8520 [(intros~[phi~[p~q]]).] 0.013 secs (0.01u,0.002s)
Chars 8525 - 8548 [(apply~path_sigma_hprop).] 0.205 secs (0.173u,0.031s)
Chars 8553 - 8590 [by~apply~equiv_path_groupisomo...] 0.015 secs (0.013u,0.001s)
Chars 8593 - 8594 [-] 0. secs (0.u,0.s)
Chars 8595 - 8607 [reflexivity.] 0.004 secs (0.004u,0.s)
Chars 8361 - 8386 [srapply~equiv_adjointify.] 0. secs (0.u,0.s)
Chars 8391 - 8420 [(apply~abses_path_data_to_iso).] 0. secs (0.u,0.s)
Chars 8425 - 8468 [srapply~(functor_sigma~(grp_is...] 0. secs (0.u,0.s)
Chars 8473 - 8496 [exact~(fun~_~=>~idmap).] 0. secs (0.u,0.s)
Chars 8501 - 8520 [(intros~[phi~[p~q]]).] 0.001 secs (0.001u,0.s)
Chars 8525 - 8548 [(apply~path_sigma_hprop).] 0.002 secs (0.002u,0.s)
Chars 8553 - 8590 [by~apply~equiv_path_groupisomo...] 0.002 secs (0.001u,0.s)
Chars 8595 - 8607 [reflexivity.] 0.001 secs (0.u,0.s)
Chars 8608 - 8616 [Defined.] 0.023 secs (0.019u,0.004s)
Chars 8618 - 8783 [Definition~equiv_path_abses~`{...] 0.004 secs (0.004u,0.s)
Chars 8785 - 9014 [Definition~path_abses~`{Unival...] 0.013 secs (0.012u,0.s)
Chars 9065 - 9222 [#[global]~Instance~isgraph_abs...] 0.026 secs (0.019u,0.006s)
Chars 9224 - 9382 [#[global]~Instance~is01cat_abs...] 0.011 secs (0.011u,0.s)
Chars 9384 - 9539 [#[global]~Instance~is0gpd_abse...] 0.014 secs (0.014u,0.s)
Chars 9541 - 9650 [#[global]~Instance~isgraph_abs...] 0.002 secs (0.001u,0.s)
Chars 9700 - 9825 [Definition~abses_path_data_1~{...] 0.006 secs (0.005u,0.s)
Chars 9875 - 10099 [Definition~abses_path_data_com...] 0.045 secs (0.037u,0.005s)
Chars 10101 - 10258 [#[global]~Instance~is01cat_abs...] 0.005 secs (0.004u,0.s)
Chars 10260 - 10356 [Definition~abses_path_data_inv...] 0.002 secs (0.002u,0.s)
Chars 10357 - 10363 [Proof.] 0. secs (0.u,0.s)
Chars 4126 - 4146 [(apply~fmap_loops_pp).] 40.157 secs (0.009u,0.027s)
Chars 4126 - 4146 [(apply~fmap_loops_pp).] 0.001 secs (0.001u,0.s)
Chars 4147 - 4155 [Defined.] 0.006 secs (0.004u,0.001s)
Chars 4228 - 4393 [Definition~hfiber_fmap_loops~{...] 0.006 secs (0.006u,0.s)
Chars 4394 - 4400 [Proof.] 0. secs (0.u,0.s)
Chars 3475 - 3484 [(intros~x).] 40.175 secs (0.u,0.028s)
Chars 3487 - 3534 [(rewrite~(commutativity~(f:=me...] 0.006 secs (0.003u,0.002s)
Chars 3537 - 3545 [trivial.] 0. secs (0.u,0.s)
Chars 3475 - 3484 [(intros~x).] 0. secs (0.u,0.s)
Chars 3487 - 3534 [(rewrite~(commutativity~(f:=me...] 0. secs (0.u,0.s)
Chars 3537 - 3545 [trivial.] 0. secs (0.u,0.s)
Chars 3548 - 3552 [Qed.] 0. secs (0.u,0.s)
Chars 3553 - 3579 [End~lower_bounded_lattice.] 0.003 secs (0.003u,0.s)
Chars 3581 - 3605 [Section~from_another_sl.] 0. secs (0.u,0.s)
Chars 3608 - 3638 [#[local]Open~Scope~mc_add_scope.] 0. secs (0.u,0.s)
Chars 3641 - 3782 [Context~`{IsSemiLattice~A}~`{I...] 0.002 secs (0.002u,0.s)
Chars 3786 - 3822 [Lemma~projected_sl~:~IsSemiLat...] 0. secs (0.u,0.s)
Chars 3825 - 3831 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 4735 - 4761 [snrapply~Build_Is1Functor.] 40.221 secs (0.01u,0.051s)
Chars 4764 - 4765 [-] 0. secs (0.u,0.s)
Chars 4766 - 4785 [(intros~E~F~p~q~h~x).] 0.002 secs (0.002u,0.s)
Chars 4790 - 4835 [(srapply~equiv_path_pullback_h...] 0.343 secs (0.295u,0.047s)
Chars 4840 - 4855 [2:~reflexivity.] 0.001 secs (0.001u,0.s)
Chars 4860 - 4872 [exact~(h~_).] 0.008 secs (0.002u,0.005s)
Chars 4875 - 4876 [-] 0. secs (0.u,0.s)
Chars 4877 - 4888 [(intros~E~x).] 0.001 secs (0.001u,0.s)
Chars 4893 - 4929 [by~srapply~equiv_path_pullback...] 0.328 secs (0.261u,0.065s)
Chars 4932 - 4933 [-] 0. secs (0.u,0.s)
Chars 4934 - 4953 [(intros~E~F~G~p~q~x).] 0.001 secs (0.001u,0.s)
Chars 4958 - 4994 [by~srapply~equiv_path_pullback...] 0.299 secs (0.282u,0.016s)
Chars 4735 - 4761 [snrapply~Build_Is1Functor.] 0. secs (0.u,0.s)
Chars 4766 - 4785 [(intros~E~F~p~q~h~x).] 0. secs (0.u,0.s)
Chars 4790 - 4835 [(srapply~equiv_path_pullback_h...] 0.007 secs (0.007u,0.s)
Chars 4840 - 4855 [2:~reflexivity.] 0. secs (0.u,0.s)
Chars 4860 - 4872 [exact~(h~_).] 0. secs (0.u,0.s)
Chars 4877 - 4888 [(intros~E~x).] 0. secs (0.u,0.s)
Chars 4893 - 4929 [by~srapply~equiv_path_pullback...] 0.001 secs (0.001u,0.s)
Chars 4934 - 4953 [(intros~E~F~G~p~q~x).] 0. secs (0.u,0.s)
Chars 4958 - 4994 [by~srapply~equiv_path_pullback...] 0.001 secs (0.001u,0.s)
Chars 4995 - 5003 [Defined.] 0.193 secs (0.193u,0.s)
Chars 5005 - 5224 [Lemma~ap_abses_pullback~`{Univ...] 0.043 secs (0.043u,0.s)
Chars 5225 - 5231 [Proof.] 0. secs (0.u,0.s)
Chars 6337 - 6368 [srapply~functor2_pforall_right.] 40.12 secs (0.004u,0.023s)
Chars 6371 - 6372 [+] 0. secs (0.u,0.s)
Chars 6373 - 6381 [exact~p.] 0.002 secs (0.002u,0.s)
Chars 6384 - 6385 [+] 0. secs (0.u,0.s)
Chars 6386 - 6394 [exact~q.] 0.001 secs (0.001u,0.s)
Chars 6397 - 6398 [+] 0. secs (0.u,0.s)
Chars 6399 - 6432 [exact~(point_htpy~(p~(point~A))).] 0.004 secs (0.004u,0.s)
Chars 6337 - 6368 [srapply~functor2_pforall_right.] 0. secs (0.u,0.s)
Chars 6373 - 6381 [exact~p.] 0. secs (0.u,0.s)
Chars 6386 - 6394 [exact~q.] 0. secs (0.u,0.s)
Chars 6399 - 6432 [exact~(point_htpy~(p~(point~A))).] 0.001 secs (0.001u,0.s)
Chars 6433 - 6441 [Defined.] 0.003 secs (0.003u,0.s)
Chars 6443 - 6724 [Definition~pmap_compose_ppfora...] 0.006 secs (0.005u,0.s)
Chars 6726 - 7007 [Definition~pmap_compose_ppfora...] 0.006 secs (0.006u,0.s)
Chars 7009 - 7271 [Definition~pmap_compose_ppfora...] 0.003 secs (0.003u,0.s)
Chars 7272 - 7278 [Proof.] 0. secs (0.u,0.s)
y_in_zyx = 
fun x y z : nat => eval (inlist y (z :: y :: x :: nil))
     : forall x y z : nat, In y (z :: y :: x :: nil)

Arguments y_in_zyx (x y z)%nat_scope
inlist' = 
fun (A : Type) (x : A) =>
mfix1 f s : list A : M In x s :=
    (mmatch s in list A as s' return M (In x s')
     [m: ([?l r : list A] l ++ r =>
                          [H : s =m= l ++ r] mtry'
                                               ('il <- f l; 
                                                ret
                                                 ((fun 
                                                 (A0 : Type) 
                                                 (x0 : A0)
                                                 (_ : 
                                                 forall x1 : list A0,
                                                 M (In x0 x1))
                                                 (s0 l0 r0 : list A0)
                                                 (_ : s0 =m= l0 ++ r0)
                                                 (il0 : In x0 l0) =>
                                                 inlist'_obligation_1 x0 l0
                                                 r0 il0) A x f s l r H il) )
                                               (fun e : Exception =>
                                                mmatch'' NotCaught e
                                                 (raise e)
                                                 (with 
                                                 _ => 
                                                 'ir <- f r; 
                                                 ret
                                                 ((fun 
                                                 (A0 : Type) 
                                                 (x0 : A0)
                                                 (_ : 
                                                 forall x1 : list A0,
                                                 M (In x0 x1))
                                                 (s0 l0 r0 : list A0)
                                                 (_ : s0 =m= l0 ++ r0)
                                                 (_ : Exception)
                                                 (ir0 : In x0 r0) =>
                                                 inlist'_obligation_2 x0 l0
                                                 r0 ir0) A x f s l r H e ir) 
                                                 end)))%branch
       | ([?s' : list A] x :: s' => [_ : s =m= x :: s'] ret (in_eq x s'))%branch
       | ([?(y : A)
          (s' : list A)] y :: s' => [_ : s =m= y :: s'] 
                         'r <- f s'; ret (in_cons y x s' r) )%branch
       | (_ => raise NotFound)%branch])
     : forall (A : Type) (x : A) (x0 : list A), M (In x x0)

Arguments inlist' [A]%type_scope x x%list_scope
inlist'_obligation_1 = 
fun (A : Type) (x : A) (l r : list A) (il : In x l) =>
in_or_app l r x (or_introl il)
     : forall (A : Type) (x : A) (l r : list A), In x l -> In x (l ++ r)

Arguments inlist'_obligation_1 [A]%type_scope x (l r)%list_scope il
inlist'_obligation_2 = 
fun (A : Type) (x : A) (l r : list A) (ir : In x r) =>
in_or_app l r x (or_intror ir)
     : forall (A : Type) (x : A) (l r : list A), In x r -> In x (l ++ r)

Arguments inlist'_obligation_2 [A]%type_scope x (l r)%list_scope ir
ex_inlist = 
fun x y z : nat =>
in_cons y x
  ((fix app (l m : list nat) {struct l} : list nat :=
      match l with
      | nil => m
      | a :: l1 => a :: app l1 m
      end) (z :: nil) (x :: z :: nil))
  (in_cons z x
     ((fix app (l m : list nat) {struct l} : list nat :=
         match l with
         | nil => m
         | a :: l1 => a :: app l1 m
         end) nil (x :: z :: nil)) (in_eq x (z :: nil)))
     : forall x y z : nat, In x ((y :: z :: nil) ++ x :: z :: nil)

Arguments ex_inlist (x y z)%nat_scope
ex_inlist' = 
fun x y z : nat =>
(fun (A : Type) (x0 : A) (_ : forall x1 : list A, M (In x0 x1))
   (s l r : list A) (_ : s =m= l ++ r) (_ : Exception) 
   (ir : In x0 r) => inlist'_obligation_2 x0 l r ir) nat x
  (mfix1 f s : list nat : M In x s :=
       (mmatch s in list nat as s' return M (In x s')
        [m: ([?l r : list nat] l ++ r =>
                               [H : s =m= l ++ r] 
                               mtry'
                                 ('il <- f l; 
                                  ret
                                    ((fun (A : Type) 
                                        (x0 : A)
                                        (_ : forall x1 : list A, M (In x0 x1))
                                        (s0 l0 r0 : list A)
                                        (_ : s0 =m= l0 ++ r0)
                                        (il0 : In x0 l0) =>
                                      inlist'_obligation_1 x0 l0 r0 il0) nat
                                       x f s l r H il) )
                                 (fun e : Exception =>
                                  mmatch'' NotCaught e 
                                    (raise e)
                                    (with _ => 'ir <- f r; 
                                          ret
                                            ((fun 
                                                (A : Type) 
                                                (x0 : A)
                                                (_ : 
                                                 forall x1 : list A,
                                                 M (In x0 x1))
                                                (s0 l0 r0 : list A)
                                                (_ : s0 =m= l0 ++ r0)
                                                (_ : Exception)
                                                (ir0 : In x0 r0) =>
                                              inlist'_obligation_2 x0 l0 r0
                                                ir0) nat x f s l r H e ir) 
                                     end)))%branch
          | ([?s' : list nat] x :: s' => [_ : s =m= x :: s'] ret (in_eq x s'))%branch
          | ([?(y0 : nat)
             (s' : list nat)] y0 :: s' => [_ : s =m= y0 :: s'] 
                              'r <- f s'; ret (in_cons y0 x s' r) )%branch
          | (_ => raise NotFound)%branch]))
  ((y :: z :: nil) ++ x :: z :: nil) (y :: z :: nil) 
  (x :: z :: nil)
  (reduce (RedWhd [rl:RedBeta; RedDelta; RedMatch])
     match
       meq_refl in (_ =m= a) return (a =m= (y :: z :: nil) ++ x :: z :: nil)
     with
     | meq_refl => meq_refl
     end) NotFound (in_eq x (z :: nil))
     : forall x y z : nat, In x ((y :: z :: nil) ++ x :: z :: nil)

Arguments ex_inlist' (x y z)%nat_scope
ex_inlist'' = 
fun x y z : nat =>
in_or_app (y :: z :: nil) (x :: z :: nil) x (or_intror (in_eq x (z :: nil)))
     : forall x y z : nat, In x ((y :: z :: nil) ++ x :: z :: nil)

Arguments ex_inlist'' (x y z)%nat_scope
ex1 = conj I (or_intror I)
     : True /\ (False \/ True)
nu@{u u0 u1} : forall {A B : Type}, name -> moption A -> (A -> M B) -> M B

nu is universe polymorphic
Arguments nu {A B}%type_scope _ _ _%function_scope
nu is opaque
Expands to: Constant Mtac2.intf.M.M.nu
ex_with_implication = 
fun (p q : Prop) (x : p) (x0 : q) => conj x x0
     : forall p q : Prop, p -> q -> p /\ q

Arguments ex_with_implication [p q]%type_scope _ _
find_witness Control.Timeout     = 1
     : nat
     = 2
     : nat
Chars 8152 - 8160 [intro~s.] 40.16 secs (0.u,0.031s)
Chars 8163 - 8199 [(apply~isequiv_surj_emb;~[~exa...] 0.04 secs (0.032u,0.007s)
Chars 8202 - 8231 [(apply~isembedding_isinj_hset).] 0.002 secs (0.002u,0.s)
Chars 8234 - 8247 [(intros~x~y~p).] 0. secs (0.u,0.s)
Chars 8250 - 8290 [by~apply~P,~(classes_eq_relate...] 0.018 secs (0.014u,0.003s)
Chars 8152 - 8160 [intro~s.] 0. secs (0.u,0.s)
Chars 8163 - 8199 [(apply~isequiv_surj_emb;~[~exa...] 0.001 secs (0.001u,0.s)
Chars 8202 - 8231 [(apply~isembedding_isinj_hset).] 0. secs (0.u,0.s)
Chars 8234 - 8247 [(intros~x~y~p).] 0. secs (0.u,0.s)
Chars 8250 - 8290 [by~apply~P,~(classes_eq_relate...] 0. secs (0.u,0.s)
Chars 8291 - 8295 [Qed.] 0.003 secs (0.002u,0.s)
Chars 8410 - 8439 [Section~ump_quotient_algebra.] 0. secs (0.u,0.s)
Chars 8442 - 8567 [Context~`{Univalence}~{σ}~{A~B...] 0.001 secs (0.001u,0.s)
Chars 8822 - 8854 [Section~quotient_algebra_mapout.] 0. secs (0.u,0.s)
Chars 8859 - 8954 [Context~(f~:~Homomorphism~A~B)...] 0.002 secs (0.002u,0.s)
Chars 8960 - 9117 [Definition~def_hom_quotient_al...] 0.034 secs (0.027u,0.007s)
Chars 9123 - 9384 [Lemma~oppreserving_quotient_al...] 0.005 secs (0.004u,0.001s)
Chars 9389 - 9395 [Proof.] 0. secs (0.u,0.s)
Chars 10366 - 10385 [(intros~[phi~[p~q]]).] 40.162 secs (0.001u,0.036s)
Chars 10388 - 10407 [srefine~(_;~(_,~_)).] 0.001 secs (0.001u,0.s)
Chars 10410 - 10411 [-] 0. secs (0.u,0.s)
Chars 10412 - 10440 [exact~(grp_iso_inverse~phi).] 0.001 secs (0.001u,0.s)
Chars 10443 - 10444 [-] 0. secs (0.u,0.s)
Chars 10445 - 10453 [intro~a.] 0.001 secs (0.001u,0.s)
Chars 10458 - 10506 [exact~(ap~_~(p~a)^~@~eissect~_...] 0.004 secs (0.003u,0.s)
Chars 10509 - 10510 [-] 0. secs (0.u,0.s)
Chars 10511 - 10526 [(intro~a;~simpl).] 0.002 secs (0.001u,0.s)
Chars 10531 - 10581 [exact~(ap~(projection~F)~(eisr...] 0.004 secs (0.004u,0.s)
Chars 10366 - 10385 [(intros~[phi~[p~q]]).] 0. secs (0.u,0.s)
Chars 10388 - 10407 [srefine~(_;~(_,~_)).] 0. secs (0.u,0.s)
Chars 10412 - 10440 [exact~(grp_iso_inverse~phi).] 0. secs (0.u,0.s)
Chars 10445 - 10453 [intro~a.] 0. secs (0.u,0.s)
Chars 10458 - 10506 [exact~(ap~_~(p~a)^~@~eissect~_...] 0. secs (0.u,0.s)
Chars 10511 - 10526 [(intro~a;~simpl).] 0.001 secs (0.u,0.s)
Chars 10531 - 10581 [exact~(ap~(projection~F)~(eisr...] 0. secs (0.u,0.s)
Chars 10582 - 10590 [Defined.] 0.007 secs (0.007u,0.s)
Chars 10592 - 10715 [#[global]~Instance~is0gpd_abse...] 0.004 secs (0.003u,0.s)
Chars 10717 - 10831 [#[global]~Instance~is2graph_ab...] 0.002 secs (0.001u,0.001s)
Chars 10865 - 10931 [#[global]Instance~is1cat_abses...] 0.002 secs (0.002u,0.s)
Chars 10932 - 10938 [Proof.] 0. secs (0.u,0.s)
Chars 4403 - 4442 [(apply~equiv_functor_sigma_id;...] 40.172 secs (0.002u,0.029s)
Chars 4445 - 4480 [refine~(equiv_moveR_Vp~_~_~_~o...] 0.003 secs (0.003u,0.s)
Chars 4483 - 4504 [(apply~equiv_moveR_pM).] 0.002 secs (0.002u,0.s)
Chars 4403 - 4442 [(apply~equiv_functor_sigma_id;...] 0.002 secs (0.002u,0.s)
Chars 4445 - 4480 [refine~(equiv_moveR_Vp~_~_~_~o...] 0. secs (0.u,0.s)
Chars 4483 - 4504 [(apply~equiv_moveR_pM).] 0.001 secs (0.001u,0.s)
Chars 4505 - 4513 [Defined.] 0.006 secs (0.006u,0.s)
Chars 4585 - 4709 [#[global]~Instance~istrunc_fma...] 0.003 secs (0.003u,0.s)
Chars 4710 - 4716 [Proof.] 0. secs (0.u,0.s)
     = {| unsigned := 1073745919; _unsigned_in_range := eq_refl |}
     : word64
find_witness Control.TimeoutChars 3834 - 3840 [split.] 40.169 secs (0.001u,0.028s)
Chars 3843 - 3844 [-] 0. secs (0.u,0.s)
Chars 3845 - 3872 [(apply~(projected_com_sg~f)).] 0.002 secs (0.002u,0.s)
Chars 3873 - 3884 [assumption.] 0. secs (0.u,0.s)
Chars 3887 - 3888 [-] 0. secs (0.u,0.s)
Chars 3889 - 3923 [(repeat~intro;~apply~(injectiv...] 0.002 secs (0.001u,0.s)
Chars 3924 - 3965 [(rewrite~!op_correct,~(idempot...] 0.004 secs (0.002u,0.001s)
Chars 3970 - 3982 [reflexivity.] 0. secs (0.u,0.s)
Chars 3834 - 3840 [split.] 0. secs (0.u,0.s)
Chars 3845 - 3872 [(apply~(projected_com_sg~f)).] 0. secs (0.u,0.s)
Chars 3873 - 3884 [assumption.] 0. secs (0.u,0.s)
Chars 3889 - 3923 [(repeat~intro;~apply~(injectiv...] 0. secs (0.u,0.s)
Chars 3924 - 3965 [(rewrite~!op_correct,~(idempot...] 0. secs (0.u,0.s)
Chars 3970 - 3982 [reflexivity.] 0. secs (0.u,0.s)
Chars 3985 - 3989 [Qed.] 0. secs (0.u,0.s)
Chars 3990 - 4010 [End~from_another_sl.] 0.004 secs (0.004u,0.s)
Chars 4012 - 4044 [Section~from_another_bounded_sl.] 0. secs (0.u,0.s)
Chars 4047 - 4077 [#[local]Open~Scope~mc_add_scope.] 0. secs (0.u,0.s)
Chars 4080 - 4291 [Context~`{IsBoundedSemiLattice...] 0.003 secs (0.002u,0.s)
Chars 4295 - 4346 [Lemma~projected_bounded_sl~:~I...] 0. secs (0.u,0.s)
Chars 4349 - 4355 [Proof.] 0. secs (0.u,0.s)
Chars 5234 - 5246 [(induction~p).] 40.242 secs (0.002u,0.048s)
Chars 5249 - 5289 [nrefine~(_~@~ap~equiv_path_abs...] 0.005 secs (0.005u,0.s)
Chars 5292 - 5354 [2:~refine~((fmap_id_strong~_~_...] 0.031 secs (0.025u,0.005s)
Chars 5357 - 5383 [exact~equiv_path_abses_1^.] 0.002 secs (0.002u,0.s)
Chars 5234 - 5246 [(induction~p).] 0. secs (0.u,0.s)
Chars 5249 - 5289 [nrefine~(_~@~ap~equiv_path_abs...] 0. secs (0.u,0.s)
Chars 5292 - 5354 [2:~refine~((fmap_id_strong~_~_...] 0. secs (0.u,0.s)
Chars 5357 - 5383 [exact~equiv_path_abses_1^.] 0. secs (0.u,0.s)
Chars 5384 - 5392 [Defined.] 0.009 secs (0.009u,0.s)
Chars 5394 - 5633 [Lemma~ap_abses_pullback_data~`...] 0.012 secs (0.01u,0.001s)
Chars 5634 - 5640 [Proof.] 0. secs (0.u,0.s)
Chars 7281 - 7311 [(unfold~pmap_compose_ppforall2).] 40.123 secs (0.002u,0.021s)
Chars 7314 - 7325 [revert~Q~g.] 0.001 secs (0.001u,0.s)
Chars 7326 - 7365 [refine~(fiberwise_pointed_map_...] 0.003 secs (0.003u,0.s)
Chars 7366 - 7377 [(intros~Q~g).] 0.002 secs (0.002u,0.s)
Chars 7380 - 7416 [srapply~functor2_pforall_right...] 0.008 secs (0.004u,0.002s)
Chars 7281 - 7311 [(unfold~pmap_compose_ppforall2).] 0. secs (0.u,0.s)
Chars 7314 - 7325 [revert~Q~g.] 0.001 secs (0.001u,0.s)
Chars 7326 - 7365 [refine~(fiberwise_pointed_map_...] 0.001 secs (0.u,0.s)
Chars 7366 - 7377 [(intros~Q~g).] 0.001 secs (0.001u,0.s)
Chars 7380 - 7416 [srapply~functor2_pforall_right...] 0.001 secs (0.001u,0.s)
Chars 7417 - 7425 [Defined.] 0.007 secs (0.005u,0.001s)
Chars 7427 - 7582 [Definition~pmap_compose_ppfora...] 0.001 secs (0.u,0.s)
Chars 7583 - 7589 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 7592 - 7616 [srapply~Build_pHomotopy.] 10.456 secs (0.002u,0.022s)
Chars 7619 - 7620 [+] 0. secs (0.u,0.s)
Chars 7621 - 7633 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 7636 - 7637 [+] 0. secs (0.u,0.s)
Chars 7638 - 7647 [symmetry.] 0.004 secs (0.003u,0.s)
Chars 7648 - 7709 [refine~(whiskerR~(concat_p1~_~...] 0.004 secs (0.003u,0.s)
Chars 7592 - 7616 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 7621 - 7633 [reflexivity.] 0. secs (0.u,0.s)
Chars 7638 - 7647 [symmetry.] 0. secs (0.u,0.s)
Chars 7648 - 7709 [refine~(whiskerR~(concat_p1~_~...] 0. secs (0.u,0.s)
Chars 7710 - 7718 [Defined.] 0.012 secs (0.009u,0.003s)
Chars 7720 - 7979 [Definition~pmap_compose_ppfora...] 0.006 secs (0.003u,0.002s)
Chars 7980 - 7986 [Proof.] 0. secs (0.u,0.s)
Crunching: (forall y : nat, H1 = y -> cnot H5 H1 = control σx H0 y)
Chars 9402 - 9432 [(unfold~ComputeOpQuotient~in~G).] 40.161 secs (0.002u,0.028s)
Chars 9439 - 9461 [(induction~w;~cbn~in~*).] 0.017 secs (0.015u,0.002s)
Chars 9468 - 9469 [-] 0. secs (0.u,0.s)
Chars 9470 - 9487 [(destruct~(G~tt)^).] 0.006 secs (0.005u,0.s)
Chars 9488 - 9496 [(apply~P).] 0.002 secs (0.002u,0.s)
Chars 9503 - 9504 [-] 0. secs (0.u,0.s)
Chars 9505 - 9543 [refine~(quotient_ind_prop~(Φ~t...] 0.039 secs (0.032u,0.004s)
Chars 9544 - 9552 [intro~x.] 0.004 secs (0.003u,0.001s)
Chars 9561 - 9617 [(apply~(IHw~(g~(class_of~(Φ~t)...] 0.006 secs (0.004u,0.001s)
Chars 9626 - 9627 [+] 0. secs (0.u,0.s)
Chars 9628 - 9636 [intro~a.] 0.004 secs (0.003u,0.s)
Chars 9637 - 9653 [(apply~(G~(x,~a))).] 0.005 secs (0.005u,0.s)
Chars 9662 - 9663 [+] 0. secs (0.u,0.s)
Chars 9664 - 9672 [(apply~P).] 0.003 secs (0.002u,0.s)
Chars 9402 - 9432 [(unfold~ComputeOpQuotient~in~G).] 0.001 secs (0.001u,0.s)
Chars 9439 - 9461 [(induction~w;~cbn~in~*).] 0.006 secs (0.006u,0.s)
Chars 9470 - 9487 [(destruct~(G~tt)^).] 0.001 secs (0.001u,0.s)
Chars 9488 - 9496 [(apply~P).] 0.001 secs (0.001u,0.s)
Chars 9505 - 9543 [refine~(quotient_ind_prop~(Φ~t...] 0.003 secs (0.003u,0.s)
Chars 9544 - 9552 [intro~x.] 0.003 secs (0.003u,0.s)
Chars 9561 - 9617 [(apply~(IHw~(g~(class_of~(Φ~t)...] 0.003 secs (0.002u,0.s)
Chars 9628 - 9636 [intro~a.] 0.003 secs (0.003u,0.s)
Chars 9637 - 9653 [(apply~(G~(x,~a))).] 0.003 secs (0.003u,0.s)
Chars 9664 - 9672 [(apply~P).] 0.002 secs (0.002u,0.s)
Chars 9677 - 9685 [Defined.] 0.012 secs (0.011u,0.001s)
Chars 9691 - 9802 [#[global]~Instance~is_homomorp...] 0.001 secs (0.u,0.s)
Chars 9807 - 9813 [Proof.] 0. secs (0.u,0.s)
Chars 10941 - 10963 [snrapply~Build_Is1Cat.] 40.187 secs (0.006u,0.036s)
Chars 10966 - 11011 [1:~(intros~?~?;~apply~is01cat_...] 0.002 secs (0.002u,0.s)
Chars 11014 - 11058 [1:~(intros~?~?;~apply~is0gpd_a...] 0.003 secs (0.003u,0.s)
Chars 11061 - 11083 [3-5:~(cbn;~reflexivity).] 0.018 secs (0.016u,0.001s)
Chars 11086 - 11157 [1,~2:~(intros~E~F~G~f;~srapply...] 0.021 secs (0.02u,0.s)
Chars 11160 - 11161 [-] 0. secs (0.u,0.s)
Chars 11162 - 11183 [exact~(ap~f.1~(h~e)).] 0.002 secs (0.002u,0.s)
Chars 11186 - 11187 [-] 0. secs (0.u,0.s)
Chars 11188 - 11206 [exact~(h~(f.1~e)).] 0.002 secs (0.002u,0.s)
Chars 10941 - 10963 [snrapply~Build_Is1Cat.] 0. secs (0.u,0.s)
Chars 10966 - 11011 [1:~(intros~?~?;~apply~is01cat_...] 0. secs (0.u,0.s)
Chars 11014 - 11058 [1:~(intros~?~?;~apply~is0gpd_a...] 0. secs (0.u,0.s)
Chars 11061 - 11083 [3-5:~(cbn;~reflexivity).] 0.003 secs (0.003u,0.s)
Chars 11086 - 11157 [1,~2:~(intros~E~F~G~f;~srapply...] 0.005 secs (0.004u,0.001s)
Chars 11162 - 11183 [exact~(ap~f.1~(h~e)).] 0. secs (0.u,0.s)
Chars 11188 - 11206 [exact~(h~(f.1~e)).] 0. secs (0.u,0.s)
Chars 11207 - 11215 [Defined.] 0.019 secs (0.016u,0.002s)
Chars 11217 - 11283 [#[global]Instance~is1gpd_abses...] 0.004 secs (0.002u,0.001s)
Chars 11284 - 11290 [Proof.] 0. secs (0.u,0.s)
Chars 4719 - 4727 [intro~p.] 40.162 secs (0.u,0.028s)
Chars 4728 - 4784 [(apply~(istrunc_equiv_istrunc~...] 0.01 secs (0.008u,0.001s)
Chars 4719 - 4727 [intro~p.] 0. secs (0.u,0.s)
Chars 4728 - 4784 [(apply~(istrunc_equiv_istrunc~...] 0. secs (0.u,0.s)
Chars 4785 - 4793 [Defined.] 0.004 secs (0.003u,0.001s)
Chars 4835 - 4991 [#[global]~Instance~isconnected...] 0.01 secs (0.01u,0.s)
Chars 4992 - 4998 [Proof.] 0. secs (0.u,0.s)
Chars 4358 - 4364 [split.] 40.152 secs (0.001u,0.028s)
Chars 4367 - 4368 [-] 0. secs (0.u,0.s)
Chars 4369 - 4408 [(apply~(projected_com_monoid~f...] 0.005 secs (0.005u,0.s)
Chars 4411 - 4412 [-] 0. secs (0.u,0.s)
Chars 4413 - 4447 [(repeat~intro;~apply~(injectiv...] 0.002 secs (0.002u,0.s)
Chars 4452 - 4492 [(rewrite~op_correct,~(idempote...] 0.032 secs (0.028u,0.003s)
Chars 4497 - 4505 [trivial.] 0.001 secs (0.001u,0.s)
Chars 4358 - 4364 [split.] 0. secs (0.u,0.s)
Chars 4369 - 4408 [(apply~(projected_com_monoid~f...] 0.001 secs (0.001u,0.s)
Chars 4413 - 4447 [(repeat~intro;~apply~(injectiv...] 0.001 secs (0.001u,0.s)
Chars 4452 - 4492 [(rewrite~op_correct,~(idempote...] 0. secs (0.u,0.s)
Chars 4497 - 4505 [trivial.] 0. secs (0.u,0.s)
Chars 4508 - 4512 [Qed.] 0. secs (0.u,0.s)
Chars 4513 - 4541 [End~from_another_bounded_sl.] 0.006 secs (0.005u,0.s)
Chars 4543 - 4637 [#[global]~Instance~id_join_sl_...] 0.002 secs (0.001u,0.s)
Chars 4639 - 4733 [#[global]~Instance~id_meet_sl_...] 0.002 secs (0.002u,0.s)
Chars 4735 - 4853 [#[global]~Instance~id_bounded_...] 0.002 secs (0.002u,0.s)
Chars 4855 - 4944 [#[global]~Instance~id_lattice_...] 0.005 secs (0.005u,0.s)
Chars 4946 - 4975 [Section~morphism_composition.] 0. secs (0.u,0.s)
Chars 4978 - 5120 [Context~`{Join~A}~`{Meet~A}~`{...] 0.002 secs (0.002u,0.s)
Chars 5124 - 5238 [Instance~compose_join_sl_morph...] 0.002 secs (0.001u,0.s)
Chars 5241 - 5247 [Proof.] 0. secs (0.u,0.s)
Chars 5250 - 5263 [(red;~apply~_).] 1.722 secs (0.02u,0.034s)
Chars 5250 - 5263 [(red;~apply~_).] 0. secs (0.u,0.s)
Chars 5266 - 5270 [Qed.] 0. secs (0.u,0.s)
Chars 5274 - 5388 [Instance~compose_meet_sl_morph...] 0.002 secs (0.002u,0.s)
Chars 5391 - 5397 [Proof.] 0. secs (0.u,0.s)
Chars 5400 - 5412 [(red;~apply~_).] 0.142 secs (0.021u,0.029s)
Chars 5400 - 5412 [(red;~apply~_).] 0. secs (0.u,0.s)
Chars 5415 - 5419 [Qed.] 0. secs (0.u,0.s)
Chars 5423 - 5566 [Instance~compose_bounded_join_...] 0.003 secs (0.002u,0.s)
Chars 5569 - 5575 [Proof.] 0. secs (0.u,0.s)
Chars 5578 - 5591 [(red;~apply~_).] 0.102 secs (0.007u,0.028s)
Chars 5578 - 5591 [(red;~apply~_).] 0.001 secs (0.001u,0.s)
Chars 5594 - 5598 [Qed.] 0. secs (0.u,0.s)
Chars 5602 - 5721 [Instance~compose_lattice_morph...] 0.003 secs (0.003u,0.s)
Chars 5724 - 5730 [Proof.] 0. secs (0.u,0.s)
dummy_len (foo_packet f)
     : Z
Chars 5643 - 5678 [refine~(ap_abses_pullback~_~_~...] 40.239 secs (0.015u,0.053s)
Chars 5681 - 5719 [(apply~(ap~(equiv_path_abses_i...] 0.005 secs (0.005u,0.s)
Chars 5722 - 5736 [(apply~eissect).] 0.133 secs (0.108u,0.024s)
Chars 5643 - 5678 [refine~(ap_abses_pullback~_~_~...] 0. secs (0.u,0.s)
Chars 5681 - 5719 [(apply~(ap~(equiv_path_abses_i...] 0. secs (0.u,0.s)
Chars 5722 - 5736 [(apply~eissect).] 0. secs (0.u,0.s)
Chars 5737 - 5745 [Defined.] 0.126 secs (0.102u,0.022s)
Chars 5747 - 5873 [Definition~abses_pullback_poin...] 0.005 secs (0.004u,0.001s)
Chars 5874 - 5880 [Proof.] 0. secs (0.u,0.s)
Chars 5733 - 5748 [(split;~apply~_).] 5.279 secs (0.007u,0.03s)
Chars 5733 - 5748 [(split;~apply~_).] 0.001 secs (0.001u,0.s)
Chars 5751 - 5755 [Qed.] 0. secs (0.u,0.s)
Chars 5759 - 5869 [Instance~invert_join_sl_morphi...] 0.003 secs (0.002u,0.s)
Chars 5872 - 5878 [Proof.] 0. secs (0.u,0.s)
Chars 5881 - 5894 [(red;~apply~_).] 0.139 secs (0.021u,0.029s)
Chars 5881 - 5894 [(red;~apply~_).] 0. secs (0.u,0.s)
Chars 5897 - 5901 [Qed.] 0. secs (0.u,0.s)
Chars 5905 - 6015 [Instance~invert_meet_sl_morphi...] 0.002 secs (0.002u,0.s)
Chars 6018 - 6024 [Proof.] 0. secs (0.u,0.s)
Chars 6027 - 6040 [(red;~apply~_).] 0.137 secs (0.019u,0.029s)
Chars 6027 - 6040 [(red;~apply~_).] 0. secs (0.u,0.s)
Chars 6043 - 6047 [Qed.] 0. secs (0.u,0.s)
Chars 6051 - 6183 [Instance~invert_bounded_join_s...] 0.003 secs (0.002u,0.s)
Chars 6186 - 6192 [Proof.] 0. secs (0.u,0.s)
Chars 6195 - 6208 [(red;~apply~_).] 0.1 secs (0.006u,0.028s)
Chars 6195 - 6208 [(red;~apply~_).] 0. secs (0.u,0.s)
Chars 6211 - 6215 [Qed.] 0.001 secs (0.001u,0.s)
Chars 6219 - 6331 [Instance~invert_lattice_morphi...] 0.003 secs (0.003u,0.s)
Chars 6334 - 6340 [Proof.] 0. secs (0.u,0.s)
Chars 6343 - 6358 [(split;~apply~_).] 0.169 secs (0.006u,0.028s)
Chars 6343 - 6358 [(split;~apply~_).] 0.001 secs (0.001u,0.s)
Chars 6361 - 6365 [Qed.] 0. secs (0.u,0.s)
Chars 6366 - 6391 [End~morphism_composition.] 0.038 secs (0.03u,0.008s)
Chars 6393 - 6511 [#[export]~Hint~Extern~4~(IsJoi...] 0. secs (0.u,0.s)
Chars 6512 - 6630 [#[export]~Hint~Extern~4~(IsMee...] 0. secs (0.u,0.s)
Chars 6631 - 6764 [#[export]~Hint~Extern~4~(IsBou...] 0. secs (0.u,0.s)
Chars 6765 - 6886 [#[export]~Hint~Extern~4~(IsLat...] 0. secs (0.u,0.s)
Chars 6887 - 7001 [#[export]~Hint~Extern~4~(IsJoi...] 0. secs (0.u,0.s)
Chars 7002 - 7116 [#[export]~Hint~Extern~4~(IsMee...] 0. secs (0.u,0.s)
Chars 7117 - 7246 [#[export]~Hint~Extern~4~(IsBou...] 0. secs (0.u,0.s)
Chars 7247 - 7364 [#[export]~Hint~Extern~4~(IsLat...] 0. secs (0.u,0.s)
Crunching:
((fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => C1
             | _ => 0
             end
  | 2%nat => match y with
             | 3%nat => C1
             | _ => 0
             end
  | 3%nat => match y with
             | 2%nat => C1
             | _ => 0
             end
  | S (S (S (S _))) => 0
  end) =
 (fun x y : nat =>
  if (x <? 2) && (y =? x)
  then C1
  else
   if (2 <=? x) && (2 <=? y)
   then
    match (x - 2)%nat with
    | 0%nat => match (y - 2)%nat with
               | 1%nat => C1
               | _ => 0
               end
    | 1%nat => match (y - 2)%nat with
               | 0%nat => C1
               | S _ => 0
               end
    | S (S _) => 0
    end
   else 0))
Chars 7989 - 8001 [revert~f'~p.] 40.14 secs (0.002u,0.022s)
Chars 8002 - 8029 [refine~(phomotopy_ind~_~_).] 0.002 secs (0.002u,0.s)
Chars 8032 - 8089 [refine~((ap~_~path_pforall_1~@...] 0.009 secs (0.005u,0.002s)
Chars 8092 - 8147 [exact~(path_pforall~(pmap_comp...] 0.005 secs (0.003u,0.001s)
Chars 7989 - 8001 [revert~f'~p.] 0.001 secs (0.001u,0.s)
Chars 8002 - 8029 [refine~(phomotopy_ind~_~_).] 0.001 secs (0.001u,0.s)
Chars 8032 - 8089 [refine~((ap~_~path_pforall_1~@...] 0.001 secs (0.001u,0.s)
Chars 8092 - 8147 [exact~(path_pforall~(pmap_comp...] 0. secs (0.u,0.s)
Chars 8148 - 8156 [Defined.] 0.014 secs (0.009u,0.004s)
Chars 9820 - 9828 [intro~u.] 40.182 secs (0.u,0.034s)
Chars 9835 - 9879 [(eapply~oppreserving_quotient_...] 0.002 secs (0.001u,0.s)
Chars 9886 - 9887 [-] 0. secs (0.u,0.s)
Chars 9888 - 9914 [(apply~compute_op_quotient).] 0.001 secs (0.001u,0.s)
Chars 9921 - 9922 [-] 0. secs (0.u,0.s)
Chars 9923 - 9931 [(apply~f).] 0.001 secs (0.001u,0.s)
Chars 9820 - 9828 [intro~u.] 0. secs (0.u,0.s)
Chars 9835 - 9879 [(eapply~oppreserving_quotient_...] 0. secs (0.u,0.s)
Chars 9888 - 9914 [(apply~compute_op_quotient).] 0. secs (0.u,0.s)
Chars 9923 - 9931 [(apply~f).] 0. secs (0.u,0.s)
Chars 9936 - 9944 [Defined.] 0. secs (0.u,0.s)
Chars 9950 - 10078 [Definition~hom_quotient_algebr...] 0.002 secs (0.002u,0.s)
Chars 10230 - 10371 [Lemma~compute_quotient_algebra...] 0.001 secs (0.001u,0.s)
Chars 10376 - 10382 [Proof.] 0. secs (0.u,0.s)
Chars 10389 - 10401 [reflexivity.] 0.593 secs (0.001u,0.031s)
Chars 10389 - 10401 [reflexivity.] 0. secs (0.u,0.s)
Chars 10406 - 10414 [Defined.] 0. secs (0.u,0.s)
Chars 10418 - 10446 [End~quotient_algebra_mapout.] 0.074 secs (0.058u,0.015s)
Chars 10450 - 10578 [Definition~hom_quotient_algebr...] 0.002 secs (0.001u,0.s)
Chars 10582 - 10719 [Lemma~ump_quotient_algebra_lr~...] 0.003 secs (0.002u,0.s)
Chars 10722 - 10728 [Proof.] 0. secs (0.u,0.s)
Chars 11293 - 11338 [(rapply~Build_Is1Gpd;~intros~E...] 40.205 secs (0.033u,0.037s)
Chars 11341 - 11342 [-] 0. secs (0.u,0.s)
Chars 11343 - 11357 [(apply~eissect).] 0.001 secs (0.001u,0.s)
Chars 11360 - 11361 [-] 0. secs (0.u,0.s)
Chars 11362 - 11376 [(apply~eisretr).] 0.001 secs (0.001u,0.s)
Chars 11293 - 11338 [(rapply~Build_Is1Gpd;~intros~E...] 0.003 secs (0.003u,0.s)
Chars 11343 - 11357 [(apply~eissect).] 0. secs (0.u,0.s)
Chars 11362 - 11376 [(apply~eisretr).] 0. secs (0.u,0.s)
Chars 11377 - 11385 [Defined.] 0.008 secs (0.006u,0.001s)
Chars 11387 - 11469 [#[global]~Instance~hasmorext_a...] 0.003 secs (0.002u,0.s)
Chars 11470 - 11476 [Proof.] 0. secs (0.u,0.s)
Chars 5001 - 5037 [(intros~p;~eapply~isconnected_...] 40.171 secs (0.001u,0.03s)
Chars 5040 - 5041 [-] 0. secs (0.u,0.s)
Chars 5042 - 5078 [refine~(hfiber_fmap_loops~f~p~...] 0.002 secs (0.002u,0.s)
Chars 5083 - 5109 [(symmetry;~apply~hfiber_ap).] 0.006 secs (0.006u,0.s)
Chars 5112 - 5113 [-] 0. secs (0.u,0.s)
Chars 5114 - 5122 [exact~_.] 0.194 secs (0.159u,0.034s)
Chars 5001 - 5037 [(intros~p;~eapply~isconnected_...] 0.001 secs (0.u,0.001s)
Chars 5042 - 5078 [refine~(hfiber_fmap_loops~f~p~...] 0. secs (0.u,0.s)
Chars 5083 - 5109 [(symmetry;~apply~hfiber_ap).] 0.002 secs (0.002u,0.s)
Chars 5114 - 5122 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 5123 - 5131 [Defined.] 0.024 secs (0.019u,0.004s)
Chars 5133 - 5359 [Definition~isconnected_iterate...] 0.003 secs (0.002u,0.s)
Chars 5360 - 5366 [Proof.] 0. secs (0.u,0.s)
Chars 5883 - 5904 [snrefine~(_;~(_,~_)).] 40.241 secs (0.004u,0.047s)
Chars 5907 - 5908 [-] 0. secs (0.u,0.s)
Chars 5909 - 5941 [snrapply~Build_GroupIsomorphism.] 0.003 secs (0.003u,0.s)
Chars 5946 - 5947 [+] 0. secs (0.u,0.s)
Chars 5948 - 5972 [srapply~ab_biprod_corec.] 0.003 secs (0.003u,0.s)
Chars 5979 - 5980 [*] 0. secs (0.u,0.s)
Chars 5981 - 6009 [refine~(ab_biprod_pr1~$o~_).] 0.002 secs (0.001u,0.s)
Chars 6018 - 6041 [(apply~grp_pullback_pr1).] 0.004 secs (0.003u,0.s)
Chars 6048 - 6049 [*] 0. secs (0.u,0.s)
Chars 6050 - 6067 [(apply~projection).] 0.001 secs (0.001u,0.s)
Chars 6072 - 6073 [+] 0. secs (0.u,0.s)
Chars 6074 - 6101 [srapply~isequiv_adjointify.] 0.007 secs (0.005u,0.001s)
Chars 6108 - 6109 [*] 0. secs (0.u,0.s)
Chars 6110 - 6138 [snrapply~grp_pullback_corec.] 0.038 secs (0.032u,0.005s)
Chars 6147 - 6149 [--] 0. secs (0.u,0.s)
Chars 6150 - 6190 [exact~(functor_ab_biprod~grp_h...] 0.003 secs (0.002u,0.s)
Chars 6199 - 6201 [--] 0. secs (0.u,0.s)
Chars 6202 - 6222 [exact~ab_biprod_pr2.] 0.002 secs (0.002u,0.s)
Chars 6231 - 6233 [--] 0. secs (0.u,0.s)
Chars 6234 - 6246 [reflexivity.] 0.006 secs (0.006u,0.s)
Chars 6253 - 6254 [*] 0. secs (0.u,0.s)
Chars 6255 - 6267 [reflexivity.] 0.01 secs (0.006u,0.004s)
Chars 6274 - 6275 [*] 0. secs (0.u,0.s)
Chars 6276 - 6298 [(intros~[[a~b]~[b'~c]]).] 0.077 secs (0.062u,0.014s)
Chars 6307 - 6352 [(srapply~equiv_path_pullback_h...] 0.181 secs (0.156u,0.024s)
Chars 6361 - 6376 [2:~reflexivity.] 0.001 secs (0.001u,0.s)
Chars 6385 - 6414 [exact~(path_prod'~idpath~c^).] 0.002 secs (0.002u,0.s)
Chars 6417 - 6418 [-] 0. secs (0.u,0.s)
Chars 6419 - 6431 [reflexivity.] 0.022 secs (0.02u,0.002s)
Chars 6434 - 6435 [-] 0. secs (0.u,0.s)
Chars 6436 - 6448 [reflexivity.] 0.034 secs (0.027u,0.006s)
Chars 5883 - 5904 [snrefine~(_;~(_,~_)).] 0. secs (0.u,0.s)
Chars 5909 - 5941 [snrapply~Build_GroupIsomorphism.] 0. secs (0.u,0.s)
Chars 5948 - 5972 [srapply~ab_biprod_corec.] 0. secs (0.u,0.s)
Chars 5981 - 6009 [refine~(ab_biprod_pr1~$o~_).] 0. secs (0.u,0.s)
Chars 6018 - 6041 [(apply~grp_pullback_pr1).] 0. secs (0.u,0.s)
Chars 6050 - 6067 [(apply~projection).] 0. secs (0.u,0.s)
Chars 6074 - 6101 [srapply~isequiv_adjointify.] 0.001 secs (0.001u,0.s)
Chars 6110 - 6138 [snrapply~grp_pullback_corec.] 0. secs (0.u,0.s)
Chars 6150 - 6190 [exact~(functor_ab_biprod~grp_h...] 0. secs (0.u,0.s)
Chars 6202 - 6222 [exact~ab_biprod_pr2.] 0. secs (0.u,0.s)
Chars 6234 - 6246 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 6255 - 6267 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 6276 - 6298 [(intros~[[a~b]~[b'~c]]).] 0.002 secs (0.002u,0.s)
Chars 6307 - 6352 [(srapply~equiv_path_pullback_h...] 0.013 secs (0.012u,0.s)
Chars 6361 - 6376 [2:~reflexivity.] 0. secs (0.u,0.s)
Chars 6385 - 6414 [exact~(path_prod'~idpath~c^).] 0. secs (0.u,0.s)
Chars 6419 - 6431 [reflexivity.] 0.012 secs (0.008u,0.003s)
Chars 6436 - 6448 [reflexivity.] 0.012 secs (0.012u,0.s)
Chars 6449 - 6457 [Defined.] 0.401 secs (0.395u,0.005s)
Chars 6459 - 6634 [Definition~abses_pullback'~{A~...] 0.01 secs (0.01u,0.s)
Chars 6695 - 6834 [Definition~abses_pullback~`{Un...] 0.005 secs (0.005u,0.s)
Chars 7053 - 7232 [Definition~abses_pullback_comp...] 0.007 secs (0.007u,0.s)
Chars 7233 - 7239 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 10733 - 10746 [(intros~[f~P]).] 40.162 secs (0.u,0.034s)
Chars 10747 - 10788 [exists~(hom_quotient_algebra_m...] 0.002 secs (0.002u,0.s)
Chars 10789 - 10797 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 10733 - 10746 [(intros~[f~P]).] 0. secs (0.u,0.s)
Chars 10747 - 10788 [exists~(hom_quotient_algebra_m...] 0. secs (0.u,0.s)
Chars 10789 - 10797 [exact~_.] 0. secs (0.u,0.s)
Chars 10800 - 10808 [Defined.] 0. secs (0.u,0.s)
Chars 10812 - 10949 [Lemma~ump_quotient_algebra_rl~...] 0.003 secs (0.003u,0.s)
Chars 10952 - 10958 [Proof.] 0. secs (0.u,0.s)
Chars 11479 - 11523 [(srapply~Build_HasMorExt;~intr...] 40.321 secs (0.122u,0.054s)
Chars 11526 - 11558 [(srapply~isequiv_homotopic';~c...] 0.005 secs (0.005u,0.s)
Chars 11561 - 11672 [1:~exact~~(((equiv_path_groupi...] 0.182 secs (0.142u,0.026s)
Chars 11675 - 11699 [(intro~p;~by~induction~p).] 0.018 secs (0.016u,0.001s)
Chars 11479 - 11523 [(srapply~Build_HasMorExt;~intr...] 0. secs (0.u,0.s)
Chars 11526 - 11558 [(srapply~isequiv_homotopic';~c...] 0.001 secs (0.001u,0.s)
Chars 11561 - 11672 [1:~exact~~(((equiv_path_groupi...] 0. secs (0.u,0.s)
Chars 11675 - 11699 [(intro~p;~by~induction~p).] 0.005 secs (0.005u,0.s)
Chars 11700 - 11708 [Defined.] 0.042 secs (0.035u,0.006s)
Chars 12025 - 12157 [Definition~equiv_path_abses_1~...] 0.004 secs (0.u,0.002s)
Chars 12158 - 12164 [Proof.] 0. secs (0.u,0.s)
Chars 5369 - 5393 [(induction~k;~intros~n~C).] 40.177 secs (0.004u,0.029s)
Chars 5396 - 5397 [-] 0. secs (0.u,0.s)
Chars 5398 - 5406 [exact~C.] 0.001 secs (0.001u,0.s)
Chars 5409 - 5410 [-] 0. secs (0.u,0.s)
Chars 5411 - 5440 [(apply~isconnected_fmap_loops).] 0.003 secs (0.003u,0.s)
Chars 5445 - 5455 [(apply~IHk).] 0.002 secs (0.001u,0.s)
Chars 5460 - 5468 [exact~C.] 0.001 secs (0.001u,0.s)
Chars 5369 - 5393 [(induction~k;~intros~n~C).] 0.001 secs (0.001u,0.s)
Chars 5398 - 5406 [exact~C.] 0. secs (0.u,0.s)
Chars 5411 - 5440 [(apply~isconnected_fmap_loops).] 0. secs (0.u,0.s)
Chars 5445 - 5455 [(apply~IHk).] 0.001 secs (0.001u,0.s)
Chars 5460 - 5468 [exact~C.] 0. secs (0.u,0.s)
Chars 5469 - 5477 [Defined.] 0.004 secs (0.002u,0.001s)
Chars 5537 - 5713 [Definition~equiv_loops_image~`...] 0.007 secs (0.006u,0.001s)
Chars 5714 - 5720 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 7242 - 7270 [(intro~E;~srefine~(_;~(_,~_))).] 40.179 secs (0.001u,0.05s)
Chars 7273 - 7274 [-] 0. secs (0.u,0.s)
Chars 7275 - 7310 [(apply~equiv_grp_pullback_comp...] 0.019 secs (0.014u,0.004s)
Chars 7313 - 7314 [-] 0. secs (0.u,0.s)
Chars 7315 - 7323 [intro~a.] 0.001 secs (0.u,0.s)
Chars 7328 - 7364 [by~srapply~equiv_path_pullback...] 0.133 secs (0.103u,0.029s)
Chars 7367 - 7368 [-] 0. secs (0.u,0.s)
Chars 7369 - 7381 [reflexivity.] 0.017 secs (0.013u,0.003s)
Chars 7242 - 7270 [(intro~E;~srefine~(_;~(_,~_))).] 0.001 secs (0.001u,0.s)
Chars 7275 - 7310 [(apply~equiv_grp_pullback_comp...] 0. secs (0.u,0.s)
Chars 7315 - 7323 [intro~a.] 0. secs (0.u,0.s)
Chars 7328 - 7364 [by~srapply~equiv_path_pullback...] 0. secs (0.u,0.s)
Chars 7369 - 7381 [reflexivity.] 0. secs (0.u,0.s)
Chars 7382 - 7390 [Defined.] 0.048 secs (0.043u,0.004s)
Chars 7463 - 7718 [Definition~abses_pullback_comp...] 0.03 secs (0.025u,0.005s)
Chars 8135 - 8318 [Definition~abses_pullback_pcom...] 0.016 secs (0.011u,0.005s)
Chars 8319 - 8325 [Proof.] 0. secs (0.u,0.s)
Chars 10963 - 10971 [intro~g.] 40.155 secs (0.u,0.032s)
Chars 10976 - 11014 [exists~(hom_quotient_algebra_m...] 0.002 secs (0.001u,0.s)
Chars 11019 - 11034 [(intros~s~x~y~E).] 0.001 secs (0.001u,0.s)
Chars 11039 - 11146 [exact~~(transport~(λ~z,~g~s~(c...] 0.005 secs (0.005u,0.s)
Chars 10963 - 10971 [intro~g.] 0. secs (0.u,0.s)
Chars 10976 - 11014 [exists~(hom_quotient_algebra_m...] 0. secs (0.u,0.s)
Chars 11019 - 11034 [(intros~s~x~y~E).] 0. secs (0.u,0.s)
Chars 11039 - 11146 [exact~~(transport~(λ~z,~g~s~(c...] 0. secs (0.u,0.s)
Chars 11149 - 11157 [Defined.] 0.001 secs (0.001u,0.s)
Chars 11463 - 11604 [Lemma~ump_quotient_algebra~:~~...] 0.003 secs (0.003u,0.s)
Chars 11607 - 11613 [Proof.] 0. secs (0.u,0.s)
Chars 12167 - 12210 [(apply~(equiv_ap_inv'~equiv_pa...] 40.173 secs (0.001u,0.035s)
Chars 12213 - 12238 [refine~(eissect~_~_~@~_).] 0.002 secs (0.002u,0.s)
Chars 12241 - 12273 [(srapply~path_sigma_hprop;~sim...] 0.235 secs (0.197u,0.023s)
Chars 12276 - 12312 [srapply~equiv_path_groupisomor...] 0.01 secs (0.009u,0.s)
Chars 12315 - 12327 [reflexivity.] 0.004 secs (0.002u,0.001s)
Chars 12167 - 12210 [(apply~(equiv_ap_inv'~equiv_pa...] 0. secs (0.u,0.s)
Chars 12213 - 12238 [refine~(eissect~_~_~@~_).] 0. secs (0.u,0.s)
Chars 12241 - 12273 [(srapply~path_sigma_hprop;~sim...] 0. secs (0.u,0.s)
Chars 12276 - 12312 [srapply~equiv_path_groupisomor...] 0. secs (0.u,0.s)
Chars 12315 - 12327 [reflexivity.] 0. secs (0.u,0.s)
Chars 12328 - 12336 [Defined.] 0.013 secs (0.009u,0.001s)
Chars 12338 - 12470 [Definition~equiv_path_absesV_1...] 0.028 secs (0.026u,0.001s)
Chars 12471 - 12477 [Proof.] 0. secs (0.u,0.s)
Chars 5723 - 5798 [(set~(C~:=~Build_pType~(image~...] 40.189 secs (0.007u,0.027s)
Chars 5801 - 5855 [(pose~(g~:=~Build_pMap~A~C~(fa...] 0.003 secs (0.003u,0.s)
Chars 5858 - 5923 [(pose~(h~:=~Build_pMap~C~B~(fa...] 0.003 secs (0.003u,0.s)
Chars 5926 - 6012 [transparent~assert~(~I~:~~(Fac...] 0.005 secs (0.004u,0.s)
Chars 6015 - 6016 [{] 0. secs (0.u,0.s)
Chars 6017 - 6166 [refine~~(@Build_Factorization~...] 0.159 secs (0.145u,0.014s)
Chars 6171 - 6190 [(intros~x;~symmetry).] 0.016 secs (0.013u,0.002s)
Chars 6195 - 6230 [refine~(_~@~fmap_comp~loops~g~...] 0.011 secs (0.008u,0.s)
Chars 6235 - 6241 [(simpl).] 0.007 secs (0.007u,0.s)
Chars 6246 - 6289 [(abstract~(rewrite~!concat_1p;...] 0.023 secs (0.017u,0.004s)
Chars 6290 - 6291 [}] 0. secs (0.u,0.s)
Chars 6294 - 6394 [exact~~(path_intermediate~~~~~...] 0.016 secs (0.012u,0.s)
Chars 5723 - 5798 [(set~(C~:=~Build_pType~(image~...] 0. secs (0.u,0.s)
Chars 5801 - 5855 [(pose~(g~:=~Build_pMap~A~C~(fa...] 0. secs (0.u,0.s)
Chars 5858 - 5923 [(pose~(h~:=~Build_pMap~C~B~(fa...] 0. secs (0.u,0.s)
Chars 5926 - 6012 [transparent~assert~(~I~:~~(Fac...] 0.001 secs (0.001u,0.s)
Chars 6017 - 6166 [refine~~(@Build_Factorization~...] 0.001 secs (0.001u,0.s)
Chars 6171 - 6190 [(intros~x;~symmetry).] 0.002 secs (0.001u,0.s)
Chars 6195 - 6230 [refine~(_~@~fmap_comp~loops~g~...] 0.001 secs (0.001u,0.s)
Chars 6235 - 6241 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 6246 - 6289 [(abstract~(rewrite~!concat_1p;...] 0.001 secs (0.001u,0.s)
Chars 6294 - 6394 [exact~~(path_intermediate~~~~~...] 0.001 secs (0.001u,0.s)
Chars 6395 - 6403 [Defined.] 0.01 secs (0.008u,0.001s)
Chars 6452 - 6508 [Definition~loops_inv~(A~:~pTyp...] 0. secs (0.u,0.s)
Chars 6509 - 6515 [Proof.] 0. secs (0.u,0.s)
Chars 6518 - 6539 [srapply~Build_pEquiv.] 0.127 secs (0.04u,0.037s)
Chars 6542 - 6594 [1:~exact~(Build_pMap~(loops~A)...] 0.001 secs (0.u,0.s)
Chars 6597 - 6624 [(apply~isequiv_path_inverse).] 0.001 secs (0.001u,0.s)
Chars 6518 - 6539 [srapply~Build_pEquiv.] 0. secs (0.u,0.s)
Chars 6542 - 6594 [1:~exact~(Build_pMap~(loops~A)...] 0. secs (0.u,0.s)
Chars 6597 - 6624 [(apply~isequiv_path_inverse).] 0. secs (0.u,0.s)
Chars 6625 - 6633 [Defined.] 0. secs (0.u,0.s)
Chars 6679 - 6775 [Definition~pequiv_fmap_loops~{...] 0.005 secs (0.003u,0.002s)
Chars 6990 - 7104 [Definition~unfold_iterated_loo...] 0. secs (0.u,0.s)
Chars 7105 - 7111 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 8328 - 8365 [exists~(abses_pullback_compose...] 40.162 secs (0.009u,0.042s)
Chars 8368 - 8415 [(intros~[[[a~b2]~[b1~c]]~[b0~c...] 0.266 secs (0.232u,0.033s)
Chars 8418 - 8463 [(srapply~equiv_path_pullback_h...] 0.261 secs (0.244u,0.016s)
Chars 8466 - 8481 [2:~reflexivity.] 0. secs (0.u,0.s)
Chars 8484 - 8524 [exact~(path_prod'~idpath~(c~@~...] 0.002 secs (0.002u,0.s)
Chars 8328 - 8365 [exists~(abses_pullback_compose...] 0. secs (0.u,0.s)
Chars 8368 - 8415 [(intros~[[[a~b2]~[b1~c]]~[b0~c...] 0.008 secs (0.008u,0.s)
Chars 8418 - 8463 [(srapply~equiv_path_pullback_h...] 0.029 secs (0.029u,0.s)
Chars 8466 - 8481 [2:~reflexivity.] 0. secs (0.u,0.s)
Chars 8484 - 8524 [exact~(path_prod'~idpath~(c~@~...] 0. secs (0.u,0.s)
Chars 8525 - 8533 [Defined.] 0.228 secs (0.227u,0.s)
Chars 8535 - 8726 [Definition~abses_pullback_pcom...] 0.007 secs (0.007u,0.s)
Chars 8727 - 8733 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutChars 11618 - 11704 [(apply~(equiv_adjointify~ump_q...] 40.148 secs (0.u,0.034s)
Chars 11709 - 11710 [-] 0. secs (0.u,0.s)
Chars 11711 - 11719 [intro~G.] 0.001 secs (0.u,0.001s)
Chars 11726 - 11755 [(apply~path_hset_homomorphism).] 0.003 secs (0.u,0.001s)
Chars 11762 - 11771 [funext~s.] 0.002 secs (0.002u,0.s)
Chars 11778 - 11824 [exact~(eissect~(quotient_ump~(...] 0.005 secs (0.005u,0.s)
Chars 11829 - 11830 [-] 0. secs (0.u,0.s)
Chars 11831 - 11839 [intro~F.] 0.001 secs (0.u,0.s)
Chars 11846 - 11869 [(apply~path_sigma_hprop).] 0.087 secs (0.07u,0.01s)
Chars 11876 - 11908 [by~apply~path_hset_homomorphism.] 0.003 secs (0.003u,0.s)
Chars 11618 - 11704 [(apply~(equiv_adjointify~ump_q...] 0. secs (0.u,0.s)
Chars 11711 - 11719 [intro~G.] 0. secs (0.u,0.s)
Chars 11726 - 11755 [(apply~path_hset_homomorphism).] 0. secs (0.u,0.s)
Chars 11762 - 11771 [funext~s.] 0. secs (0.u,0.s)
Chars 11778 - 11824 [exact~(eissect~(quotient_ump~(...] 0. secs (0.u,0.s)
Chars 11831 - 11839 [intro~F.] 0.001 secs (0.001u,0.s)
Chars 11846 - 11869 [(apply~path_sigma_hprop).] 0. secs (0.u,0.s)
Chars 11876 - 11908 [by~apply~path_hset_homomorphism.] 0. secs (0.u,0.s)
Chars 11911 - 11919 [Defined.] 0.005 secs (0.004u,0.001s)
Chars 11920 - 11945 [End~ump_quotient_algebra.] 0.063 secs (0.06u,0.002s)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 12480 - 12510 [(apply~moveR_equiv_M;~symmetry).] 40.172 secs (0.006u,0.034s)
Chars 12513 - 12538 [(apply~equiv_path_abses_1).] 0.007 secs (0.007u,0.s)
Chars 12480 - 12510 [(apply~moveR_equiv_M;~symmetry).] 0.001 secs (0.001u,0.s)
Chars 12513 - 12538 [(apply~equiv_path_abses_1).] 0. secs (0.u,0.s)
Chars 12539 - 12547 [Defined.] 0.071 secs (0.062u,0.007s)
Chars 12549 - 12748 [Definition~abses_path_data_V~`...] 0.005 secs (0.005u,0.s)
Chars 12749 - 12755 [Proof.] 0. secs (0.u,0.s)
Chars 7114 - 7126 [(induction~n).] 40.151 secs (0.u,0.03s)
Chars 7129 - 7144 [1:~reflexivity.] 0.001 secs (0.u,0.001s)
Chars 7147 - 7219 [(change~(iterated_loops~n.+2~X...] 0.001 secs (0.001u,0.s)
Chars 7222 - 7251 [(apply~pequiv_fmap_loops,~IHn).] 0.001 secs (0.001u,0.s)
Chars 7114 - 7126 [(induction~n).] 0. secs (0.u,0.s)
Chars 7129 - 7144 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 7147 - 7219 [(change~(iterated_loops~n.+2~X...] 0. secs (0.u,0.s)
Chars 7222 - 7251 [(apply~pequiv_fmap_loops,~IHn).] 0. secs (0.u,0.s)
Chars 7252 - 7260 [Defined.] 0.001 secs (0.001u,0.s)
Chars 7315 - 7539 [Definition~unfold_iterated_fma...] 0.007 secs (0.005u,0.001s)
Chars 7540 - 7546 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutChars 8736 - 8773 [refine~(to_pointed_compose~_~_...] 40.261 secs (0.009u,0.052s)
Chars 8776 - 8814 [(apply~equiv_ptransformation_p...] 0.012 secs (0.011u,0.s)
Chars 8817 - 8848 [(apply~abses_pullback_pcompose').] 0.007 secs (0.005u,0.001s)
Chars 8736 - 8773 [refine~(to_pointed_compose~_~_...] 0. secs (0.u,0.s)
Chars 8776 - 8814 [(apply~equiv_ptransformation_p...] 0. secs (0.u,0.s)
Chars 8817 - 8848 [(apply~abses_pullback_pcompose').] 0. secs (0.u,0.s)
Chars 8849 - 8857 [Defined.] 0.01 secs (0.009u,0.s)
Chars 8904 - 9026 [Lemma~abses_pullback_const'~`{...] 0.005 secs (0.005u,0.s)
Chars 9027 - 9033 [Proof.] 0. secs (0.u,0.s)
Chars 12758 - 12767 [revert~p.] 40.155 secs (0.u,0.033s)
Chars 12770 - 12837 [(equiv_intro~(equiv_path_abses...] 0.038 secs (0.038u,0.s)
Chars 12840 - 12882 [(refine~(ap~_~(eisretr~_~_)~@~...] 0.004 secs (0.004u,0.s)
Chars 12885 - 12971 [nrefine~~(ap~(equiv_path_abses...] 0.011 secs (0.011u,0.s)
Chars 12974 - 13028 [refine~(ap~equiv_path_abses_is...] 0.02 secs (0.015u,0.004s)
Chars 13031 - 13056 [exact~equiv_path_abses_1.] 0.002 secs (0.002u,0.s)
Chars 12758 - 12767 [revert~p.] 0. secs (0.u,0.s)
Chars 12770 - 12837 [(equiv_intro~(equiv_path_abses...] 0.001 secs (0.001u,0.s)
Chars 12840 - 12882 [(refine~(ap~_~(eisretr~_~_)~@~...] 0.001 secs (0.001u,0.s)
Chars 12885 - 12971 [nrefine~~(ap~(equiv_path_abses...] 0. secs (0.u,0.s)
Chars 12974 - 13028 [refine~(ap~equiv_path_abses_is...] 0. secs (0.u,0.s)
Chars 13031 - 13056 [exact~equiv_path_abses_1.] 0. secs (0.u,0.s)
Chars 13057 - 13065 [Defined.] 0.008 secs (0.005u,0.002s)
Chars 13136 - 13398 [Definition~abses_path_compose_...] 0.086 secs (0.078u,0.007s)
Chars 13399 - 13405 [Proof.] 0. secs (0.u,0.s)
Chars 7549 - 7561 [(induction~n).] 40.182 secs (0.002u,0.028s)
Chars 7564 - 7565 [-] 0. secs (0.u,0.s)
Chars 7566 - 7596 [srefine~(Build_pHomotopy~_~_).] 0.001 secs (0.001u,0.s)
Chars 7601 - 7602 [+] 0. secs (0.u,0.s)
Chars 7603 - 7615 [reflexivity.] 0.004 secs (0.004u,0.s)
Chars 7620 - 7621 [+] 0. secs (0.u,0.s)
Chars 7622 - 7626 [(cbn).] 0.033 secs (0.029u,0.003s)
Chars 7627 - 7642 [(apply~moveL_pV).] 0.009 secs (0.008u,0.s)
Chars 7649 - 7674 [refine~(concat_1p~_~@~_).] 0.005 secs (0.005u,0.s)
Chars 7681 - 7706 [refine~(concat_1p~_~@~_).] 0.005 secs (0.005u,0.s)
Chars 7713 - 7741 [refine~(_~@~(concat_p1~_)^).] 0.005 secs (0.005u,0.s)
Chars 7748 - 7770 [exact~(ap_idmap~_)^.] 0.003 secs (0.003u,0.s)
Chars 7773 - 7774 [-] 0. secs (0.u,0.s)
Chars 7775 - 7813 [refine~((fmap_comp~loops~_~_)^...] 0.054 secs (0.037u,0.014s)
Chars 7818 - 7854 [refine~(_~@*~fmap_comp~loops~_...] 0.016 secs (0.013u,0.001s)
Chars 7859 - 7880 [rapply~(fmap2~loops).] 0.013 secs (0.011u,0.001s)
Chars 7885 - 7895 [(apply~IHn).] 0.013 secs (0.011u,0.001s)
Chars 7549 - 7561 [(induction~n).] 0. secs (0.u,0.s)
Chars 7566 - 7596 [srefine~(Build_pHomotopy~_~_).] 0. secs (0.u,0.s)
Chars 7603 - 7615 [reflexivity.] 0. secs (0.u,0.s)
Chars 7622 - 7626 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 7627 - 7642 [(apply~moveL_pV).] 0.003 secs (0.003u,0.s)
Chars 7649 - 7674 [refine~(concat_1p~_~@~_).] 0.002 secs (0.002u,0.s)
Chars 7681 - 7706 [refine~(concat_1p~_~@~_).] 0.002 secs (0.u,0.001s)
Chars 7713 - 7741 [refine~(_~@~(concat_p1~_)^).] 0.002 secs (0.001u,0.001s)
Chars 7748 - 7770 [exact~(ap_idmap~_)^.] 0.002 secs (0.001u,0.s)
Chars 7775 - 7813 [refine~((fmap_comp~loops~_~_)^...] 0.001 secs (0.001u,0.s)
Chars 7818 - 7854 [refine~(_~@*~fmap_comp~loops~_...] 0.002 secs (0.001u,0.s)
Chars 7859 - 7880 [rapply~(fmap2~loops).] 0.002 secs (0.002u,0.s)
Chars 7885 - 7895 [(apply~IHn).] 0.002 secs (0.002u,0.s)
Chars 7896 - 7904 [Defined.] 0.175 secs (0.14u,0.024s)
Chars 7951 - 8085 [Definition~pequiv_fmap_iterate...] 0.005 secs (0.005u,0.s)
Chars 8118 - 8188 [Lemma~loops_prod~(X~Y~:~pType)...] 0.003 secs (0.u,0.002s)
Chars 8189 - 8195 [Proof.] 0. secs (0.u,0.s)
Chars 9036 - 9044 [intro~E.] 40.232 secs (0.001u,0.049s)
Chars 9047 - 9053 [(simpl).] 0.001 secs (0.u,0.001s)
Chars 9056 - 9087 [nrapply~abses_path_data_to_iso.] 0.005 secs (0.003u,0.002s)
Chars 9090 - 9113 [(srefine~(_;~(_,~_));~cbn).] 0.043 secs (0.037u,0.005s)
Chars 9116 - 9117 [-] 0. secs (0.u,0.s)
Chars 9118 - 9145 [srapply~grp_pullback_corec.] 0.003 secs (0.001u,0.001s)
Chars 9150 - 9151 [+] 0. secs (0.u,0.s)
Chars 9152 - 9189 [exact~(inclusion~_~$o~ab_bipro...] 0.004 secs (0.003u,0.s)
Chars 9194 - 9195 [+] 0. secs (0.u,0.s)
Chars 9196 - 9216 [exact~ab_biprod_pr2.] 0.002 secs (0.002u,0.s)
Chars 9221 - 9222 [+] 0. secs (0.u,0.s)
Chars 9223 - 9236 [(intro~x;~cbn).] 0.002 secs (0.002u,0.s)
Chars 9243 - 9265 [(apply~iscomplex_abses).] 0.006 secs (0.006u,0.s)
Chars 9268 - 9269 [-] 0. secs (0.u,0.s)
Chars 9270 - 9283 [(intro~a;~cbn).] 0.012 secs (0.009u,0.002s)
Chars 9288 - 9331 [by~srapply~equiv_path_pullback...] 0.134 secs (0.112u,0.021s)
Chars 9334 - 9335 [-] 0. secs (0.u,0.s)
Chars 9336 - 9348 [reflexivity.] 0.006 secs (0.006u,0.s)
Chars 9036 - 9044 [intro~E.] 0. secs (0.u,0.s)
Chars 9047 - 9053 [(simpl).] 0. secs (0.u,0.s)
Chars 9056 - 9087 [nrapply~abses_path_data_to_iso.] 0. secs (0.u,0.s)
Chars 9090 - 9113 [(srefine~(_;~(_,~_));~cbn).] 0.002 secs (0.002u,0.s)
Chars 9118 - 9145 [srapply~grp_pullback_corec.] 0. secs (0.u,0.s)
Chars 9152 - 9189 [exact~(inclusion~_~$o~ab_bipro...] 0. secs (0.u,0.s)
Chars 9196 - 9216 [exact~ab_biprod_pr2.] 0. secs (0.u,0.s)
Chars 9223 - 9236 [(intro~x;~cbn).] 0.001 secs (0.u,0.s)
Chars 9243 - 9265 [(apply~iscomplex_abses).] 0. secs (0.u,0.s)
Chars 9270 - 9283 [(intro~a;~cbn).] 0.007 secs (0.007u,0.s)
Chars 9288 - 9331 [by~srapply~equiv_path_pullback...] 0.002 secs (0.002u,0.s)
Chars 9336 - 9348 [reflexivity.] 0.002 secs (0.001u,0.s)
Chars 9349 - 9357 [Defined.] 0.122 secs (0.104u,0.017s)
Chars 9359 - 9549 [Definition~abses_pullback_cons...] 0.027 secs (0.026u,0.s)
Chars 9551 - 9676 [Lemma~abses_pullback_pconst'~`...] 0.007 secs (0.005u,0.001s)
Chars 9677 - 9683 [Proof.] 0. secs (0.u,0.s)
Chars 13408 - 13423 [(induction~p,~q).] 40.153 secs (0.003u,0.034s)
Chars 13426 - 13459 [refine~(equiv_path_abses_1^~@~_).] 0.003 secs (0.003u,0.s)
Chars 13462 - 13494 [(apply~(ap~equiv_path_abses_is...] 0.003 secs (0.002u,0.s)
Chars 13497 - 13520 [(apply~path_sigma_hprop).] 0.148 secs (0.129u,0.018s)
Chars 13523 - 13560 [by~apply~equiv_path_groupisomo...] 0.011 secs (0.009u,0.001s)
Chars 13408 - 13423 [(induction~p,~q).] 0. secs (0.u,0.s)
Chars 13426 - 13459 [refine~(equiv_path_abses_1^~@~_).] 0. secs (0.u,0.s)
Chars 13462 - 13494 [(apply~(ap~equiv_path_abses_is...] 0. secs (0.u,0.s)
Chars 13497 - 13520 [(apply~path_sigma_hprop).] 0. secs (0.u,0.s)
Chars 13523 - 13560 [by~apply~equiv_path_groupisomo...] 0. secs (0.u,0.s)
Chars 13561 - 13569 [Defined.] 0.013 secs (0.013u,0.s)
Chars 13658 - 13928 [Definition~abses_path_data_com...] 0.008 secs (0.007u,0.001s)
Chars 13929 - 13935 [Proof.] 0. secs (0.u,0.s)
Chars 8198 - 8262 [srefine~(Build_pEquiv~_~_~(Bui...] 40.167 secs (0.011u,0.031s)
Chars 8265 - 8329 [1:~(symmetry;~refine~(equiv_pa...] 0.007 secs (0.007u,0.s)
Chars 8332 - 8344 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 8198 - 8262 [srefine~(Build_pEquiv~_~_~(Bui...] 0. secs (0.u,0.s)
Chars 8265 - 8329 [1:~(symmetry;~refine~(equiv_pa...] 0. secs (0.u,0.s)
Chars 8332 - 8344 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 8345 - 8353 [Defined.] 0.004 secs (0.004u,0.s)
Chars 8419 - 8541 [Lemma~iterated_loops_prod~(X~Y...] 0.003 secs (0.002u,0.s)
Chars 8542 - 8548 [Proof.] 0. secs (0.u,0.s)
Chars 9686 - 9701 [srefine~(_;~_).] 40.224 secs (0.002u,0.048s)
Chars 9704 - 9736 [1:~rapply~abses_pullback_const'.] 0.003 secs (0.003u,0.s)
Chars 9739 - 9749 [(lazy~beta).] 0.002 secs (0.002u,0.s)
Chars 9752 - 9773 [(intro~x;~reflexivity).] 0.044 secs (0.038u,0.005s)
Chars 9686 - 9701 [srefine~(_;~_).] 0. secs (0.u,0.s)
Chars 9704 - 9736 [1:~rapply~abses_pullback_const'.] 0. secs (0.u,0.s)
Chars 9739 - 9749 [(lazy~beta).] 0.001 secs (0.001u,0.s)
Chars 9752 - 9773 [(intro~x;~reflexivity).] 0.031 secs (0.026u,0.004s)
Chars 9774 - 9782 [Defined.] 0.059 secs (0.048u,0.01s)
Chars 9784 - 9905 [Definition~abses_pullback_pcon...] 0.002 secs (0.002u,0.s)
Chars 9906 - 9912 [Proof.] 0. secs (0.u,0.s)
Crunching: (forall θ : R, rotation θ (3 * PI / 2) (PI / 2) = x_rotation θ)
Crunching: (forall θ : R, rotation θ (3 * PI / 2) (PI / 2) = x_rotation θ)
Crunching: (forall θ : R, rotation θ (3 * PI / 2) (PI / 2) = x_rotation θ)
Crunching: (forall θ : R, rotation θ (3 * PI / 2) (PI / 2) = x_rotation θ)
Crunching: (forall θ : R, rotation θ (3 * PI / 2) (PI / 2) = x_rotation θ)
Chars 13938 - 13954 [(generalize~p,~q).] 40.202 secs (0.001u,0.033s)
Chars 13957 - 14013 [(equiv_intro~(equiv_path_abses...] 0.043 secs (0.04u,0.002s)
Chars 14016 - 14072 [(equiv_intro~(equiv_path_abses...] 0.043 secs (0.039u,0.003s)
Chars 14075 - 14117 [refine~((eisretr~_~_~@@~eisret...] 0.004 secs (0.004u,0.s)
Chars 14120 - 14151 [rapply~abses_path_compose_beta.] 0.005 secs (0.004u,0.s)
Chars 13938 - 13954 [(generalize~p,~q).] 0. secs (0.u,0.s)
Chars 13957 - 14013 [(equiv_intro~(equiv_path_abses...] 0. secs (0.u,0.s)
Chars 14016 - 14072 [(equiv_intro~(equiv_path_abses...] 0. secs (0.u,0.s)
Chars 14075 - 14117 [refine~((eisretr~_~_~@@~eisret...] 0. secs (0.u,0.s)
Chars 14120 - 14151 [rapply~abses_path_compose_beta.] 0. secs (0.u,0.s)
Chars 14152 - 14160 [Defined.] 0.008 secs (0.004u,0.001s)
Chars 14198 - 14332 [Definition~equiv_path_data_hom...] 0.006 secs (0.004u,0.s)
Chars 14333 - 14339 [Proof.] 0. secs (0.u,0.s)
Chars 8551 - 8563 [(induction~n).] 40.135 secs (0.001u,0.028s)
Chars 8566 - 8581 [1:~reflexivity.] 0.001 secs (0.001u,0.s)
Chars 8584 - 8627 [refine~(pequiv_compose~_~(loop...] 0.002 secs (0.001u,0.s)
Chars 8630 - 8653 [by~rapply~(emap~loops).] 0.01 secs (0.007u,0.002s)
Chars 8551 - 8563 [(induction~n).] 0. secs (0.u,0.s)
Chars 8566 - 8581 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 8584 - 8627 [refine~(pequiv_compose~_~(loop...] 0. secs (0.u,0.s)
Chars 8630 - 8653 [by~rapply~(emap~loops).] 0. secs (0.u,0.s)
Chars 8654 - 8662 [Defined.] 0.006 secs (0.006u,0.s)
Chars 8696 - 8803 [Definition~loopsD~{A}~:~pFam~A...] 0.003 secs (0.003u,0.s)
Chars 8805 - 8924 [#[global]~Instance~istrunc_pfa...] 0.001 secs (0.u,0.s)
Chars 8925 - 8931 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutCrunching:
(match (2 * Nat.div2 x + Nat.b2n (Nat.odd x))%nat with
 | 0%nat =>
     match y with
     | 0%nat => cos (p / 2)
     | 1%nat => - Cexp (PI / 2) * sin (p / 2)
     | S (S _) => 0
     end
 | 1%nat =>
     match y with
     | 0%nat => Cexp (3 * PI / 2) * sin (p / 2)
     | 1%nat => Cexp (3 * PI / 2 + PI / 2) * cos (p / 2)
     | S (S _) => 0
     end
 | S (S _) => 0
 end = x_rotation p x y)
find_witness Control.TimeoutChars 9915 - 9957 [refine~(pmap_abses_const_to_po...] 40.259 secs (0.002u,0.049s)
Chars 9960 - 9999 [rapply~equiv_ptransformation_p...] 0.005 secs (0.004u,0.s)
Chars 10002 - 10031 [exact~abses_pullback_pconst'.] 0.004 secs (0.004u,0.s)
Chars 9915 - 9957 [refine~(pmap_abses_const_to_po...] 0. secs (0.u,0.s)
Chars 9960 - 9999 [rapply~equiv_ptransformation_p...] 0. secs (0.u,0.s)
Chars 10002 - 10031 [exact~abses_pullback_pconst'.] 0. secs (0.u,0.s)
Chars 10032 - 10040 [Defined.] 0.002 secs (0.001u,0.s)
Chars 10088 - 10229 [Lemma~abses_pullback_homotopic...] 0.007 secs (0.006u,0.001s)
Chars 10230 - 10236 [Proof.] 0. secs (0.u,0.s)
Chars 14342 - 14388 [(srapply~equiv_functor_forall_...] 40.174 secs (0.004u,0.032s)
Chars 14391 - 14420 [srapply~equiv_path_abses_iso.] 0.001 secs (0.001u,0.s)
Chars 14342 - 14388 [(srapply~equiv_functor_forall_...] 0.001 secs (0.001u,0.s)
Chars 14391 - 14420 [srapply~equiv_path_abses_iso.] 0. secs (0.u,0.s)
Chars 14421 - 14429 [Defined.] 0.001 secs (0.001u,0.s)
Chars 14431 - 14581 [Definition~pmap_abses_const~{B...] 0.019 secs (0.016u,0.002s)
Chars 14583 - 14774 [Definition~to_pointed~`{Unival...] 0.012 secs (0.012u,0.s)
Chars 14776 - 14902 [Lemma~pmap_abses_const_to_poin...] 0.003 secs (0.003u,0.s)
Chars 14903 - 14909 [Proof.] 0. secs (0.u,0.s)
Chars 8934 - 8943 [(intros~a).] 40.172 secs (0.u,0.027s)
Chars 8944 - 8963 [(pose~(H~(point~A))).] 0.001 secs (0.001u,0.s)
Chars 8964 - 8972 [exact~_.] 0.002 secs (0.002u,0.s)
Chars 8934 - 8943 [(intros~a).] 0. secs (0.u,0.s)
Chars 8944 - 8963 [(pose~(H~(point~A))).] 0. secs (0.u,0.s)
Chars 8964 - 8972 [exact~_.] 0. secs (0.u,0.s)
Chars 8973 - 8981 [Defined.] 0.001 secs (0.001u,0.s)
Chars 9016 - 9112 [Lemma~loops_psigma_commute~(A~...] 0.001 secs (0.001u,0.s)
Chars 9113 - 9119 [Proof.] 0. secs (0.u,0.s)
Chars 10239 - 10247 [intro~E.] 40.245 secs (0.u,0.048s)
Chars 10250 - 10270 [srefine~(_;~(_,~_)).] 0.001 secs (0.001u,0.s)
Chars 10273 - 10274 [-] 0. secs (0.u,0.s)
Chars 10275 - 10310 [srapply~equiv_functor_grp_pull...] 0.011 secs (0.007u,0.003s)
Chars 10315 - 10337 [1-3:~exact~grp_iso_id.] 0.002 secs (0.002u,0.s)
Chars 10342 - 10357 [1:~reflexivity.] 0.003 secs (0.002u,0.s)
Chars 10362 - 10370 [(apply~h).] 0.001 secs (0.001u,0.s)
Chars 10373 - 10374 [-] 0. secs (0.u,0.s)
Chars 10375 - 10388 [(intro~a;~cbn).] 0.075 secs (0.068u,0.006s)
Chars 10393 - 10436 [by~srapply~equiv_path_pullback...] 0.151 secs (0.125u,0.025s)
Chars 10439 - 10440 [-] 0. secs (0.u,0.s)
Chars 10441 - 10453 [reflexivity.] 0.013 secs (0.01u,0.002s)
Chars 10239 - 10247 [intro~E.] 0. secs (0.u,0.s)
Chars 10250 - 10270 [srefine~(_;~(_,~_)).] 0. secs (0.u,0.s)
Chars 10275 - 10310 [srapply~equiv_functor_grp_pull...] 0. secs (0.u,0.s)
Chars 10315 - 10337 [1-3:~exact~grp_iso_id.] 0.001 secs (0.001u,0.s)
Chars 10342 - 10357 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 10362 - 10370 [(apply~h).] 0. secs (0.u,0.s)
Chars 10375 - 10388 [(intro~a;~cbn).] 0.002 secs (0.002u,0.s)
Chars 10393 - 10436 [by~srapply~equiv_path_pullback...] 0.001 secs (0.001u,0.s)
Chars 10441 - 10453 [reflexivity.] 0. secs (0.u,0.s)
Chars 10454 - 10462 [Defined.] 0.039 secs (0.035u,0.003s)
Chars 10464 - 10607 [Lemma~abses_pullback_phomotopi...] 0.011 secs (0.008u,0.003s)
Chars 10608 - 10614 [Proof.] 0. secs (0.u,0.s)
Chars 9122 - 9186 [srefine~(Build_pEquiv~_~_~(Bui...] 34.775 secs (19.775u,-0.421s)
Chars 14912 - 14936 [srapply~Build_pHomotopy.] 40.173 secs (0.001u,0.034s)
Chars 14939 - 14954 [1:~reflexivity.] 0.005 secs (0.004u,0.s)
Chars 14957 - 14972 [(apply~moveL_pV).] 0.005 secs (0.005u,0.s)
Chars 14975 - 15000 [refine~(concat_1p~_~@~_).] 0.026 secs (0.009u,0.013s)
Chars 15003 - 15028 [(apply~equiv_path_abses_1).] 0.022 secs (0.02u,0.001s)
Chars 14912 - 14936 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 14939 - 14954 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 14957 - 14972 [(apply~moveL_pV).] 0.001 secs (0.001u,0.s)
Chars 14975 - 15000 [refine~(concat_1p~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 15003 - 15028 [(apply~equiv_path_abses_1).] 0. secs (0.u,0.s)
Chars 15029 - 15037 [Defined.] 0.027 secs (0.021u,0.005s)
Chars 15039 - 15276 [Lemma~abses_ap_fmap~`{Univalen...] 0.018 secs (0.018u,0.s)
Chars 15277 - 15283 [Proof.] 0. secs (0.u,0.s)
Chars 9122 - 9186 [srefine~(Build_pEquiv~_~_~(Bui...] 40.059 secs (0.01u,0.031s)
Chars 9189 - 9232 [1:~exact~((equiv_path_sigma~_~...] 0.001 secs (0.001u,0.s)
Chars 9235 - 9247 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 9122 - 9186 [srefine~(Build_pEquiv~_~_~(Bui...] 0. secs (0.u,0.s)
Chars 9189 - 9232 [1:~exact~((equiv_path_sigma~_~...] 0. secs (0.u,0.s)
Chars 9235 - 9247 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 9248 - 9256 [Defined.] 0.004 secs (0.002u,0.001s)
Chars 9292 - 9408 [Lemma~loops_pproduct_commute~`...] 0.001 secs (0.001u,0.s)
Chars 9409 - 9415 [Proof.] 0. secs (0.u,0.s)
find_witness Control.TimeoutCrunching: (rotation (- 0) (- 0) q = phase_shift a)
Crunching: (rotation (- 0) (- 0) q = phase_shift a)
find_witness Control.TimeoutChars 10617 - 10664 [(exists~(abses_pullback_homoto...] 40.335 secs (0.088u,0.056s)
Chars 10667 - 10699 [(intros~[[a~b']~[b~c]];~cbn~in...] 0.057 secs (0.049u,0.007s)
Chars 10702 - 10747 [(srapply~equiv_path_pullback_h...] 0.239 secs (0.199u,0.04s)
Chars 10750 - 10765 [2:~reflexivity.] 0.001 secs (0.001u,0.s)
Chars 10768 - 10804 [exact~(path_prod'~idpath~(c~@~...] 0.003 secs (0.003u,0.s)
Chars 10617 - 10664 [(exists~(abses_pullback_homoto...] 0.002 secs (0.002u,0.s)
Chars 10667 - 10699 [(intros~[[a~b']~[b~c]];~cbn~in...] 0.011 secs (0.008u,0.002s)
Chars 10702 - 10747 [(srapply~equiv_path_pullback_h...] 0.034 secs (0.032u,0.001s)
Chars 10750 - 10765 [2:~reflexivity.] 0. secs (0.u,0.s)
Chars 10768 - 10804 [exact~(path_prod'~idpath~(c~@~...] 0. secs (0.u,0.s)
Chars 10805 - 10813 [Defined.] 0.101 secs (0.099u,0.001s)
Chars 10815 - 11046 [Definition~abses_pullback_phom...] 0.023 secs (0.023u,0.s)
Chars 11089 - 11312 [Definition~iscomplex_abses_pul...] 0.014 secs (0.014u,0.s)
Chars 11313 - 11319 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutChars 15286 - 15295 [revert~p.] 40.2 secs (0.001u,0.035s)
Chars 9418 - 9482 [srefine~(Build_pEquiv~_~_~(Bui...] 40.18 secs (0.011u,0.029s)
Chars 9485 - 9506 [1:~(apply~equiv_apD10).] 0.001 secs (0.001u,0.s)
Chars 9509 - 9521 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 9418 - 9482 [srefine~(Build_pEquiv~_~_~(Bui...] 0. secs (0.u,0.s)
Chars 9485 - 9506 [1:~(apply~equiv_apD10).] 0. secs (0.u,0.s)
Chars 9509 - 9521 [reflexivity.] 0. secs (0.u,0.s)
Chars 9522 - 9530 [Defined.] 0.001 secs (0.u,0.001s)
Chars 9573 - 9730 [Lemma~iterated_loops_pproduct_...] 0.001 secs (0.001u,0.s)
Chars 9731 - 9737 [Proof.] 0. secs (0.u,0.s)
Chars 15298 - 15359 [(apply~(equiv_ind~(equiv_path_...] 0.179 secs (0.168u,0.007s)
Chars 15362 - 15374 [(induction~p).] 0.003 secs (0.003u,0.s)
Chars 15377 - 15414 [refine~(ap~(ap~f)~(eisretr~_~_...] 0.004 secs (0.004u,0.s)
Chars 15417 - 15457 [nrefine~(_~@~ap~equiv_path_abs...] 0.005 secs (0.005u,0.s)
Chars 15460 - 15464 [2:~{] 0. secs (0.u,0.s)
Chars 15465 - 15481 [rapply~path_hom.] 0.011 secs (0.01u,0.s)
Chars 15489 - 15514 [srefine~(_~$@~fmap2~_~_).] 0.007 secs (0.006u,0.s)
Chars 15522 - 15538 [2:~exact~(Id~E).] 0.002 secs (0.002u,0.s)
Chars 15546 - 15570 [2:~(intro~x;~reflexivity).] 0.008 secs (0.007u,0.s)
Chars 15578 - 15600 [exact~(fmap_id~f~_)^$.] 0.024 secs (0.023u,0.001s)
Chars 15601 - 15602 [}] 0. secs (0.u,0.s)
Chars 15605 - 15631 [exact~equiv_path_abses_1^.] 0.003 secs (0.003u,0.s)
Chars 15286 - 15295 [revert~p.] 0.001 secs (0.001u,0.s)
Chars 15298 - 15359 [(apply~(equiv_ind~(equiv_path_...] 0.002 secs (0.002u,0.s)
Chars 15362 - 15374 [(induction~p).] 0.001 secs (0.u,0.s)
Chars 15377 - 15414 [refine~(ap~(ap~f)~(eisretr~_~_...] 0.001 secs (0.001u,0.s)
Chars 15417 - 15457 [nrefine~(_~@~ap~equiv_path_abs...] 0.001 secs (0.001u,0.s)
Chars 15465 - 15481 [rapply~path_hom.] 0. secs (0.u,0.s)
Chars 15489 - 15514 [srefine~(_~$@~fmap2~_~_).] 0.001 secs (0.001u,0.s)
Chars 15522 - 15538 [2:~exact~(Id~E).] 0. secs (0.u,0.s)
Chars 15546 - 15570 [2:~(intro~x;~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 15578 - 15600 [exact~(fmap_id~f~_)^$.] 0.001 secs (0.001u,0.s)
Chars 15605 - 15631 [exact~equiv_path_abses_1^.] 0. secs (0.u,0.s)
Chars 15632 - 15640 [Defined.] 0.016 secs (0.012u,0.003s)
Chars 15642 - 15898 [Definition~to_pointed_compose~...] 0.043 secs (0.036u,0.007s)
Chars 15899 - 15905 [Proof.] 0. secs (0.u,0.s)
Chars 11322 - 11366 [refine~(abses_pullback_pcompos...] 40.262 secs (0.009u,0.051s)
Chars 11369 - 11417 [refine~(abses_pullback_phomoto...] 0.009 secs (0.008u,0.s)
Chars 11420 - 11452 [exact~abses_pullback_pconst'~^*$.] 0.009 secs (0.009u,0.s)
Chars 11322 - 11366 [refine~(abses_pullback_pcompos...] 0.001 secs (0.001u,0.s)
Chars 11369 - 11417 [refine~(abses_pullback_phomoto...] 0.001 secs (0.001u,0.s)
Chars 11420 - 11452 [exact~abses_pullback_pconst'~^*$.] 0. secs (0.u,0.s)
Chars 11453 - 11461 [Defined.] 0.007 secs (0.007u,0.s)
Chars 11463 - 11669 [Definition~iscomplex_abses_pul...] 0.008 secs (0.007u,0.s)
Chars 11670 - 11676 [Proof.] 0. secs (0.u,0.s)
find_witness Control.Timeoutfind_witness Control.TimeoutOrdersEx.Nat_as_OT.add_0_r: forall n : nat, n + 0 = n
OrdersEx.Nat_as_DT.add_0_r: forall n : nat, n + 0 = n
Nat.add_0_r: forall n : nat, n + 0 = n
NPeano.Nat.add_0_r: forall n : nat, n + 0 = n
Crunching:
(sqrtx x y =
 (hadamard × phase_shift (PI * / IZR (Z.succ (Z.succ 0))) × hadamard) x y)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Chars 9740 - 9752 [(induction~n).] 40.177 secs (0.001u,0.028s)
Chars 9755 - 9770 [1:~reflexivity.] 0.001 secs (0.001u,0.s)
Chars 9773 - 9815 [refine~(loops_pproduct_commute...] 0.002 secs (0.002u,0.s)
Chars 9818 - 9838 [rapply~(emap~loops).] 0.009 secs (0.008u,0.001s)
Chars 9841 - 9851 [exact~IHn.] 0.001 secs (0.001u,0.s)
Chars 9740 - 9752 [(induction~n).] 0. secs (0.u,0.s)
Chars 9755 - 9770 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 9773 - 9815 [refine~(loops_pproduct_commute...] 0. secs (0.u,0.s)
Chars 9818 - 9838 [rapply~(emap~loops).] 0. secs (0.u,0.s)
Chars 9841 - 9851 [exact~IHn.] 0. secs (0.u,0.s)
Chars 9852 - 9860 [Defined.] 0.002 secs (0.001u,0.s)
Chars 9907 - 10101 [Lemma~loops_psigma_trunc~(n~:~...] 0.001 secs (0.001u,0.s)
Chars 10102 - 10108 [Proof.] 0. secs (0.u,0.s)
Building eta_pattern_ident_cps_gen...
Chars 15908 - 15932 [srapply~Build_pHomotopy.] 40.18 secs (0.002u,0.035s)
Chars 15935 - 15950 [1:~reflexivity.] 0.006 secs (0.006u,0.s)
Chars 15953 - 15963 [(lazy~beta).] 0.003 secs (0.003u,0.s)
Chars 15966 - 15983 [nrapply~moveL_pV.] 0.012 secs (0.012u,0.s)
Chars 15986 - 16012 [nrefine~(concat_1p~_~@~_).] 0.01 secs (0.01u,0.s)
Chars 16015 - 16081 [(unfold~pmap_compose,~Build_pM...] 0.003 secs (0.002u,0.s)
Chars 16084 - 16120 [refine~(_~@~ap~(fun~x~=>~x~@~_...] 0.01 secs (0.01u,0.s)
Chars 16123 - 16150 [2:~(apply~(abses_ap_fmap~g)).] 0.016 secs (0.012u,0.003s)
Chars 16153 - 16203 [nrefine~(_~@~(abses_path_data_...] 0.021 secs (0.019u,0.002s)
Building eta_pattern_ident_cps_gen_expand_literal...
Chars 16206 - 16240 [nrapply~(ap~equiv_path_abses_i...] 0.016 secs (0.012u,0.003s)
Chars 16243 - 16259 [rapply~path_hom.] 0.017 secs (0.015u,0.001s)
Chars 16262 - 16274 [reflexivity.] 0.055 secs (0.042u,0.012s)
Chars 15908 - 15932 [srapply~Build_pHomotopy.] 0.001 secs (0.001u,0.s)
Chars 15935 - 15950 [1:~reflexivity.] 0.001 secs (0.001u,0.s)
Chars 15953 - 15963 [(lazy~beta).] 0.002 secs (0.002u,0.s)
Chars 15966 - 15983 [nrapply~moveL_pV.] 0.002 secs (0.002u,0.s)
Chars 15986 - 16012 [nrefine~(concat_1p~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 16015 - 16081 [(unfold~pmap_compose,~Build_pM...] 0.001 secs (0.001u,0.s)
Chars 16084 - 16120 [refine~(_~@~ap~(fun~x~=>~x~@~_...] 0.001 secs (0.001u,0.s)
Chars 16123 - 16150 [2:~(apply~(abses_ap_fmap~g)).] 0.001 secs (0.u,0.s)
Chars 16153 - 16203 [nrefine~(_~@~(abses_path_data_...] 0.001 secs (0.001u,0.s)
Chars 16206 - 16240 [nrapply~(ap~equiv_path_abses_i...] 0.002 secs (0.002u,0.s)
Chars 16243 - 16259 [rapply~path_hom.] 0.001 secs (0.001u,0.s)
Chars 16262 - 16274 [reflexivity.] 0.002 secs (0.002u,0.s)
Building split_types...
Chars 16275 - 16283 [Defined.] 0.122 secs (0.1u,0.021s)
Chars 16285 - 16457 [Definition~equiv_ptransformati...] 0.018 secs (0.017u,0.s)
Chars 16458 - 16464 [Proof.] 0. secs (0.u,0.s)
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Crunching:
(sqrtx x y =
 (hadamard × phase_shift (PI * / IZR (Z.succ (Z.succ 0))) × hadamard) x y)
Crunching:
((hadamard × phase_shift (PI * / IZR (Z.succ (Z.succ 0))) × hadamard) x y =
 sqrtx x y)
Crunching:
(sqrtx x y =
 (hadamard × phase_shift (PI * / IZR (Z.succ (Z.succ 0))) × hadamard) x y)
Crunching:
((hadamard × phase_shift (PI * / IZR (Z.succ (Z.succ 0))) × hadamard) x y =
 sqrtx x y)
Crunching:
(sqrtx x y =
 (hadamard × phase_shift (PI * / IZR (Z.succ (Z.succ 0))) × hadamard) x y)
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Crunching:
((hadamard × phase_shift (PI * / IZR (Z.succ (Z.succ 0))) × hadamard) x y =
 sqrtx x y)
Tactic call ran for 0.542 secs (0.533u,0.005s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.407 secs (0.401u,0.005s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.033 secs (0.033u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.036 secs (0.036u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 1.278 secs (1.229u,0.02s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 2.665 secs (2.598u,0.043s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.044 secs (0.044u,0.s) (success)
Tactic call ran for 0.008 secs (0.007u,0.s) (success)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × phase_shift (PI * / 2 + 0))
Tactic call ran for 0.037 secs (0.037u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.017 secs (0.017u,0.s) (success)
Tactic call ran for 0.15 secs (0.146u,0.004s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.178 secs (0.174u,0.003s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Chars 11679 - 11695 [refine~(_~@*~_).] 40.233 secs (0.002u,0.046s)
Chars 11698 - 11745 [2:~(symmetry;~exact~pmap_abses...] 0.004 secs (0.003u,0.s)
Chars 11748 - 11785 [refine~(to_pointed_compose~_~_...] 0.025 secs (0.018u,0.006s)
Chars 11788 - 11826 [(apply~equiv_ptransformation_p...] 0.004 secs (0.002u,0.001s)
Chars 11829 - 11865 [by~rapply~iscomplex_abses_pull...] 0.024 secs (0.017u,0.006s)
Chars 11679 - 11695 [refine~(_~@*~_).] 0. secs (0.u,0.s)
Chars 11698 - 11745 [2:~(symmetry;~exact~pmap_abses...] 0.001 secs (0.001u,0.s)
Chars 11748 - 11785 [refine~(to_pointed_compose~_~_...] 0. secs (0.u,0.s)
Chars 11788 - 11826 [(apply~equiv_ptransformation_p...] 0. secs (0.u,0.s)
Chars 11829 - 11865 [by~rapply~iscomplex_abses_pull...] 0. secs (0.u,0.s)
Chars 11866 - 11874 [Defined.] 0.009 secs (0.009u,0.s)
Chars 11965 - 12133 [Definition~iscomplex_pullback_...] 0.003 secs (0.003u,0.s)
Chars 12134 - 12140 [Proof.] 0. secs (0.u,0.s)
Assembling verified rewriter...
Refining with verified rewriter...
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × phase_shift (PI / 2))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 list2D_to_matrix
   [[C1 / √ 2; C1 / √ 2 * Cexp (PI / 2)];
    [C1 / √ 2; - (C1 / √ 2) * Cexp (PI / 2)]] × hadamard)
Crunching:
(sqrtx =
 list2D_to_matrix
   [[C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * Cexp (PI / 2) * (C1 / √ 2);
     C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * Cexp (PI / 2) * - (C1 / √ 2)];
    [C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * Cexp (PI / 2) * (C1 / √ 2);
     C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * Cexp (PI / 2) * - (C1 / √ 2)]])
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
find_witness Control.TimeoutBuilding eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
find_witness Control.TimeoutBuilding invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.571 secs (0.556u,0.014s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.332 secs (0.323u,0.008s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.038 secs (0.037u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.023 secs (0.023u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 1.193 secs (1.174u,0.017s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 2.458 secs (2.415u,0.04s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Chars 10111 - 10123 [(induction~n).] 40.152 secs (0.u,0.029s)
Chars 10126 - 10127 [{] 0. secs (0.u,0.s)
Chars 10128 - 10141 [(intros~A~P~p).] 0. secs (0.u,0.s)
Chars 10146 - 10210 [srefine~(Build_pEquiv~_~_~(Bui...] 0.011 secs (0.009u,0.001s)
Chars 10215 - 10252 [1:~refine~(@equiv_sigma_contr~...] 0.001 secs (0.001u,0.s)
Chars 10257 - 10269 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 10270 - 10271 [}] 0. secs (0.u,0.s)
Chars 10274 - 10287 [(intros~A~P~p).] 0. secs (0.u,0.s)
Chars 10290 - 10380 [refine~~(pequiv_inverse~(unfol...] 0.018 secs (0.014u,0.003s)
Chars 10383 - 10408 [refine~(IHn~_~_~_~o*E~_).] 0.002 secs (0.002u,0.s)
Chars 10411 - 10444 [rapply~(emap~(iterated_loops~_)).] 0.009 secs (0.009u,0.s)
Chars 10447 - 10474 [(apply~loops_psigma_commute).] 0.001 secs (0.001u,0.s)
Chars 10111 - 10123 [(induction~n).] 0. secs (0.u,0.s)
Chars 10128 - 10141 [(intros~A~P~p).] 0. secs (0.u,0.s)
Chars 10146 - 10210 [srefine~(Build_pEquiv~_~_~(Bui...] 0. secs (0.u,0.s)
Chars 10215 - 10252 [1:~refine~(@equiv_sigma_contr~...] 0. secs (0.u,0.s)
Chars 10257 - 10269 [reflexivity.] 0. secs (0.u,0.s)
Chars 10274 - 10287 [(intros~A~P~p).] 0. secs (0.u,0.s)
Chars 10290 - 10380 [refine~~(pequiv_inverse~(unfol...] 0. secs (0.u,0.s)
Chars 10383 - 10408 [refine~(IHn~_~_~_~o*E~_).] 0. secs (0.u,0.s)
Chars 10411 - 10444 [rapply~(emap~(iterated_loops~_)).] 0. secs (0.u,0.s)
Chars 10447 - 10474 [(apply~loops_psigma_commute).] 0. secs (0.u,0.s)
Chars 10475 - 10483 [Defined.] 0.002 secs (0.001u,0.s)
Chars 10563 - 10611 [#[local]Notation~"(~X~,~x~)"~:...] 0. secs (0.u,0.s)
Chars 11112 - 11264 [Definition~loops_type@{i~j~k}~...] 0. secs (0.u,0.s)
Chars 11265 - 11271 [Proof.] 0. secs (0.u,0.s)
Chars 16467 - 16499 [refine~(issig_pforall~_~_~oE~_).] 40.201 secs (0.024u,0.032s)
Chars 16502 - 16571 [(apply~(equiv_functor_sigma'~(...] 0.009 secs (0.008u,0.001s)
Chars 16574 - 16607 [refine~(equiv_concat_r~_~_~oE~_).] 0.003 secs (0.003u,0.s)
Chars 16610 - 16702 [1:~exact~~((abses_path_data_co...] 0.057 secs (0.053u,0.003s)
Chars 16705 - 16754 [refine~(equiv_ap'~equiv_path_a...] 0.047 secs (0.037u,0.008s)
Chars 16757 - 16798 [refine~(equiv_path_sigma_hprop...] 0.3 secs (0.252u,0.041s)
Chars 16801 - 16835 [(apply~equiv_path_groupisomorp...] 0.042 secs (0.036u,0.005s)
Chars 16467 - 16499 [refine~(issig_pforall~_~_~oE~_).] 0. secs (0.u,0.s)
Chars 16502 - 16571 [(apply~(equiv_functor_sigma'~(...] 0.003 secs (0.003u,0.s)
Chars 16574 - 16607 [refine~(equiv_concat_r~_~_~oE~_).] 0.001 secs (0.001u,0.s)
Chars 16610 - 16702 [1:~exact~~((abses_path_data_co...] 0. secs (0.u,0.s)
Chars 16705 - 16754 [refine~(equiv_ap'~equiv_path_a...] 0.002 secs (0.002u,0.s)
Chars 16757 - 16798 [refine~(equiv_path_sigma_hprop...] 0.001 secs (0.001u,0.s)
Chars 16801 - 16835 [(apply~equiv_path_groupisomorp...] 0.002 secs (0.002u,0.s)
Chars 16836 - 16844 [Defined.] 0.177 secs (0.176u,0.s)
Chars 17019 - 17270 [Lemma~abses_endomorphism_trivi...] 0.008 secs (0.008u,0.s)
Chars 17271 - 17277 [Proof.] 0. secs (0.u,0.s)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.114 secs (0.114u,0.s) (success)
Tactic call ran for 0.063 secs (0.057u,0.005s) (success)
Tactic call ran for 0.09 secs (0.084u,0.005s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.052 secs (0.05u,0.001s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.72 secs (0.707u,0.011s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.269 secs (0.265u,0.003s) (success)
Tactic call ran for 0.309 secs (0.305u,0.004s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 26.902 secs (26.496u,0.374s) (successful)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣0⟩)
Crunching:
(list2D_to_matrix [[C1]] =
 (fun x y : nat => if (x =? y) && (x <? 1) then R1 else R0))
Finished transaction in 2.214 secs (2.192u,0.02s) (successful)
Finished transaction in 2.142 secs (2.098u,0.042s) (successful)
Chars 12143 - 12175 [rapply~iscomplex_abses_pullback.] 40.277 secs (0.023u,0.05s)
Chars 12178 - 12201 [rapply~iscomplex_abses.] 0.002 secs (0.002u,0.s)
Chars 12143 - 12175 [rapply~iscomplex_abses_pullback.] 0. secs (0.u,0.s)
Chars 12178 - 12201 [rapply~iscomplex_abses.] 0. secs (0.u,0.s)
Chars 12202 - 12210 [Defined.] 0.004 secs (0.003u,0.s)
Chars 12378 - 12593 [Definition~equiv_hfiber_abses~...] 0.003 secs (0.003u,0.s)
Chars 12595 - 12800 [Definition~hfiber_abses_path~{...] 0.014 secs (0.013u,0.s)
Chars 12802 - 13146 [Definition~transport_path_data...] 0.059 secs (0.055u,0.003s)
Chars 13147 - 13153 [Proof.] 0. secs (0.u,0.s)
Crunching:
((forall x l1 l2 : R,
  derivable_pt_lim (id + fct_cte (PI / 2)) x l1 ->
  derivable_pt_lim sin ((id + fct_cte (PI / 2))%F x) l2 ->
  derivable_pt_lim (comp sin (id + fct_cte (PI / 2))) x (l2 * l1)%R) -> 
 1 < 0)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: ((⟨0∣ × ∣1⟩) x y = Zero x y)
Chars 13156 - 13168 [(induction~p).] 21.365 secs (-2.93u,-1.496s)
find_witness Control.TimeoutChars 11274 - 11294 [(apply~issig_pequiv').] 40.155 secs (0.u,0.031s)
Chars 11297 - 11327 [exists~(equiv_equiv_path~A~A).] 0.004 secs (0.002u,0.s)
Chars 11330 - 11342 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 11274 - 11294 [(apply~issig_pequiv').] 0. secs (0.u,0.s)
Chars 11297 - 11327 [exists~(equiv_equiv_path~A~A).] 0. secs (0.u,0.s)
Chars 11330 - 11342 [reflexivity.] 0. secs (0.u,0.s)
Chars 11343 - 11351 [Defined.] 0.002 secs (0.002u,0.s)
Chars 11353 - 11521 [Lemma~local_global_looping~`{U...] 0.001 secs (0.001u,0.s)
Chars 11522 - 11528 [Proof.] 0. secs (0.u,0.s)
Chars 17280 - 17305 [srapply~equiv_adjointify.] 40.186 secs (0.004u,0.034s)
Chars 17308 - 17309 [-] 0. secs (0.u,0.s)
Chars 17310 - 17325 [(intros~[phi~_]).] 0.006 secs (0.006u,0.s)
Chars 17330 - 17376 [exact~(ab_biprod_pr1~$o~phi~$o...] 0.006 secs (0.005u,0.001s)
Chars 17379 - 17380 [-] 0. secs (0.u,0.s)
Chars 17381 - 17389 [intro~f.] 0.001 secs (0.001u,0.s)
Chars 17394 - 17409 [snrefine~(_;~_).] 0.003 secs (0.003u,0.s)
Chars 17414 - 17415 [+] 0. secs (0.u,0.s)
Chars 17416 - 17455 [refine~(ab_biprod_rec~ab_bipro...] 0.004 secs (0.004u,0.s)
Chars 17462 - 17501 [refine~(ab_biprod_corec~f~grp_...] 0.001 secs (0.001u,0.s)
Chars 17506 - 17507 [+] 0. secs (0.u,0.s)
Chars 17508 - 17528 [(split;~intro~x;~cbn).] 0.012 secs (0.011u,0.001s)
Chars 17535 - 17536 [*] 0. secs (0.u,0.s)
Chars 17537 - 17558 [(apply~path_prod;~cbn).] 0.002 secs (0.002u,0.s)
Chars 17567 - 17569 [--] 0. secs (0.u,0.s)
Chars 17570 - 17620 [exact~(ap~_~(grp_homo_unit~f)~...] 0.011 secs (0.01u,0.s)
Chars 17629 - 17631 [--] 0. secs (0.u,0.s)
Chars 17632 - 17657 [exact~(right_identity~_).] 0.02 secs (0.019u,0.s)
Chars 17664 - 17665 [*] 0. secs (0.u,0.s)
Chars 17666 - 17691 [exact~(left_identity~_)^.] 0.012 secs (0.01u,0.001s)
Chars 17694 - 17695 [-] 0. secs (0.u,0.s)
Chars 17696 - 17704 [intro~f.] 0.009 secs (0.007u,0.001s)
Chars 17709 - 17759 [(rapply~equiv_path_grouphomomo...] 0.006 secs (0.005u,0.s)
Chars 17764 - 17788 [exact~(left_identity~_).] 0.009 secs (0.009u,0.s)
Chars 17791 - 17792 [-] 0. secs (0.u,0.s)
Chars 17793 - 17812 [(intros~[phi~[p~q]]).] 0.127 secs (0.105u,0.018s)
Chars 17817 - 17845 [(apply~path_sigma_hprop;~cbn).] 0.364 secs (0.331u,0.022s)
Chars 17850 - 17905 [(rapply~equiv_path_grouphomomo...] 0.019 secs (0.019u,0.s)
Chars 17910 - 17931 [(apply~path_prod;~cbn).] 0.004 secs (0.004u,0.s)
Chars 17936 - 17937 [+] 0. secs (0.u,0.s)
Chars 17938 - 17972 [(rewrite~(ab_biprod_decompose~...] 0.004 secs (0.004u,0.s)
Chars 17979 - 18034 [refine~(_~@~(grp_homo_op~(ab_b...] 0.008 secs (0.008u,0.s)
Chars 18041 - 18069 [(apply~grp_cancelR;~symmetry).] 0.007 secs (0.007u,0.s)
Chars 18076 - 18097 [exact~(ap~fst~(p~a)).] 0.004 secs (0.004u,0.s)
Chars 18102 - 18103 [+] 0. secs (0.u,0.s)
Chars 18104 - 18138 [(rewrite~(ab_biprod_decompose~...] 0.003 secs (0.003u,0.s)
Chars 18145 - 18215 [(refine~(_~@~(grp_homo_op~(ab_...] 0.017 secs (0.016u,0.s)
Chars 18222 - 18274 [exact~(ap011~_~(ap~snd~(p~a))~...] 0.007 secs (0.007u,0.s)
Chars 17280 - 17305 [srapply~equiv_adjointify.] 0.001 secs (0.001u,0.s)
Chars 17310 - 17325 [(intros~[phi~_]).] 0.001 secs (0.001u,0.s)
Chars 17330 - 17376 [exact~(ab_biprod_pr1~$o~phi~$o...] 0. secs (0.u,0.s)
Chars 17381 - 17389 [intro~f.] 0.001 secs (0.001u,0.s)
Chars 17394 - 17409 [snrefine~(_;~_).] 0.001 secs (0.001u,0.s)
Chars 17416 - 17455 [refine~(ab_biprod_rec~ab_bipro...] 0. secs (0.u,0.s)
Chars 17462 - 17501 [refine~(ab_biprod_corec~f~grp_...] 0. secs (0.u,0.s)
Chars 17508 - 17528 [(split;~intro~x;~cbn).] 0.003 secs (0.003u,0.s)
Chars 17537 - 17558 [(apply~path_prod;~cbn).] 0.001 secs (0.001u,0.s)
Chars 17570 - 17620 [exact~(ap~_~(grp_homo_unit~f)~...] 0. secs (0.u,0.s)
Chars 17632 - 17657 [exact~(right_identity~_).] 0. secs (0.u,0.s)
Chars 17666 - 17691 [exact~(left_identity~_)^.] 0. secs (0.u,0.s)
Chars 17696 - 17704 [intro~f.] 0.006 secs (0.006u,0.s)
Chars 17709 - 17759 [(rapply~equiv_path_grouphomomo...] 0.001 secs (0.001u,0.s)
Chars 17764 - 17788 [exact~(left_identity~_).] 0. secs (0.u,0.s)
Chars 17793 - 17812 [(intros~[phi~[p~q]]).] 0.007 secs (0.007u,0.s)
Chars 17817 - 17845 [(apply~path_sigma_hprop;~cbn).] 0.008 secs (0.008u,0.s)
Chars 17850 - 17905 [(rapply~equiv_path_grouphomomo...] 0.003 secs (0.003u,0.s)
Chars 17910 - 17931 [(apply~path_prod;~cbn).] 0.002 secs (0.002u,0.s)
Chars 17938 - 17972 [(rewrite~(ab_biprod_decompose~...] 0. secs (0.u,0.s)
Chars 17979 - 18034 [refine~(_~@~(grp_homo_op~(ab_b...] 0. secs (0.u,0.s)
Chars 18041 - 18069 [(apply~grp_cancelR;~symmetry).] 0.001 secs (0.001u,0.s)
Chars 18076 - 18097 [exact~(ap~fst~(p~a)).] 0. secs (0.u,0.s)
Chars 18104 - 18138 [(rewrite~(ab_biprod_decompose~...] 0. secs (0.u,0.s)
Chars 18145 - 18215 [(refine~(_~@~(grp_homo_op~(ab_...] 0.002 secs (0.002u,0.s)
Chars 18222 - 18274 [exact~(ap011~_~(ap~snd~(p~a))~...] 0. secs (0.u,0.s)
Chars 18275 - 18283 [Defined.] 0.287 secs (0.282u,0.002s)
Chars 18469 - 18613 [Definition~loops_abses~`{Univa...] 0.024 secs (0.024u,0.s)
Chars 18695 - 18810 [Definition~hom_loops_data_abse...] 0.001 secs (0.001u,0.s)
Chars 18811 - 18817 [Proof.] 0. secs (0.u,0.s)
0
6
12
14
5
13
[?e1; a; b; ?e1; c; d; ?e2]
Chars 13156 - 13168 [(induction~p).] 40.099 secs (0.003u,0.049s)
Chars 13171 - 13200 [refine~(transport_1~_~_~@~_).] 0.003 secs (0.003u,0.s)
Chars 13203 - 13242 [nrefine~(_~@~(ap~(fun~x~=>~x~$...] 0.005 secs (0.003u,0.001s)
Chars 13245 - 13249 [2:~{] 0. secs (0.u,0.s)
Chars 13250 - 13289 [refine~(_~@~ap~_~equiv_path_ab...] 0.005 secs (0.005u,0.s)
Chars 13297 - 13325 [exact~(fmap_id_strong~_~_)^.] 0.011 secs (0.008u,0.002s)
Chars 13326 - 13327 [}] 0. secs (0.u,0.s)
Chars 13330 - 13356 [exact~(cat_idr_strong~_)^.] 0.006 secs (0.005u,0.s)
Chars 13156 - 13168 [(induction~p).] 0.001 secs (0.001u,0.s)
Chars 13171 - 13200 [refine~(transport_1~_~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 13203 - 13242 [nrefine~(_~@~(ap~(fun~x~=>~x~$...] 0.001 secs (0.001u,0.s)
Chars 13250 - 13289 [refine~(_~@~ap~_~equiv_path_ab...] 0.001 secs (0.001u,0.s)
Chars 13297 - 13325 [exact~(fmap_id_strong~_~_)^.] 0. secs (0.u,0.s)
Chars 13330 - 13356 [exact~(cat_idr_strong~_)^.] 0. secs (0.u,0.s)
Chars 13357 - 13365 [Defined.] 0.012 secs (0.01u,0.001s)
Chars 13367 - 13561 [Definition~equiv_hfiber_abses_...] 0.008 secs (0.007u,0.s)
Chars 13562 - 13568 [Proof.] 0. secs (0.u,0.s)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[0]] = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[0]] = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[0]] = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[0]] = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: ((⟨1∣ × ∣1⟩) x y = (if true && true then C1 else 0))
Crunching: ((⟨1∣ × ∣1⟩) x y = (if true && true then C1 else 0))
Crunching: ((⟨1∣ × ∣1⟩) 0%nat y = (if true && true then C1 else 0))
Crunching: ((⟨1∣ × ∣1⟩) x y = (if true && true then C1 else 0))
Crunching: ((⟨1∣ × ∣1⟩) x 0%nat = (if (x =? 0) && (x <? 1) then C1 else 0))
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching:
(list2D_to_matrix [[C1]] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0))
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Chars 11531 - 11543 [(induction~n).] 40.167 secs (0.001u,0.03s)
Chars 11546 - 11547 [{] 0. secs (0.u,0.s)
Chars 11548 - 11589 [refine~(_~o*E~emap~loops~(loop...] 0.006 secs (0.005u,0.001s)
Chars 11594 - 11614 [(apply~issig_pequiv').] 0.001 secs (0.001u,0.s)
Chars 11619 - 11741 [exists~~~~(equiv_inverse~(equi...] 0.005 secs (0.005u,0.s)
Chars 11746 - 11758 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 11759 - 11760 [}] 0. secs (0.u,0.s)
Chars 11763 - 11817 [exact~(loops_pproduct_commute~...] 0.007 secs (0.007u,0.s)
Chars 11531 - 11543 [(induction~n).] 0. secs (0.u,0.s)
Chars 11548 - 11589 [refine~(_~o*E~emap~loops~(loop...] 0. secs (0.u,0.s)
Chars 11594 - 11614 [(apply~issig_pequiv').] 0. secs (0.u,0.s)
Chars 11619 - 11741 [exists~~~~(equiv_inverse~(equi...] 0. secs (0.u,0.s)
Chars 11746 - 11758 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 11763 - 11817 [exact~(loops_pproduct_commute~...] 0. secs (0.u,0.s)
Chars 11818 - 11826 [Defined.] 0.006 secs (0.005u,0.s)
Chars 11840 - 11955 [Theorem~equiv_istrunc_istrunc_...] 0. secs (0.u,0.s)
Chars 11956 - 11962 [Proof.] 0. secs (0.u,0.s)
Crunching: ((⟨1∣ × ∣1⟩) x y = (if true && true then C1 else 0))
Chars 18820 - 18830 [intro~phi.] 40.169 secs (0.u,0.035s)
Chars 18833 - 18853 [srefine~(_;~(_,~_)).] 0.001 secs (0.001u,0.s)
Chars 18856 - 18857 [-] 0. secs (0.u,0.s)
Chars 18858 - 18927 [exact~(ab_homo_add~grp_homo_id...] 0.005 secs (0.005u,0.s)
Chars 18930 - 18931 [-] 0. secs (0.u,0.s)
Chars 18932 - 18945 [(intro~a;~cbn).] 0.002 secs (0.001u,0.s)
Chars 18950 - 19003 [refine~(ap~(fun~x~=>~_~+~inclu...] 0.005 secs (0.004u,0.001s)
Chars 19008 - 19033 [1:~(apply~iscomplex_abses).] 0.004 secs (0.004u,0.s)
Chars 19038 - 19108 [refine~(ap~(fun~x~=>~_~+~x)~(g...] 0.007 secs (0.007u,0.s)
Chars 19113 - 19130 [(apply~grp_unit_r).] 0.001 secs (0.001u,0.s)
Chars 19133 - 19134 [-] 0. secs (0.u,0.s)
Chars 19135 - 19153 [(intro~e;~symmetry).] 0.004 secs (0.004u,0.s)
Chars 19158 - 19207 [(refine~(grp_homo_op~(projecti...] 0.005 secs (0.005u,0.s)
Chars 19212 - 19248 [refine~(ap~(fun~x~=>~_~+~x)~_~...] 0.003 secs (0.003u,0.s)
Chars 19253 - 19278 [1:~(apply~iscomplex_abses).] 0.004 secs (0.003u,0.s)
Chars 19283 - 19300 [(apply~grp_unit_r).] 0.002 secs (0.001u,0.s)
Chars 18820 - 18830 [intro~phi.] 0. secs (0.u,0.s)
Chars 18833 - 18853 [srefine~(_;~(_,~_)).] 0. secs (0.u,0.s)
Chars 18858 - 18927 [exact~(ab_homo_add~grp_homo_id...] 0. secs (0.u,0.s)
Chars 18932 - 18945 [(intro~a;~cbn).] 0.001 secs (0.001u,0.s)
Chars 18950 - 19003 [refine~(ap~(fun~x~=>~_~+~inclu...] 0. secs (0.u,0.s)
Chars 19008 - 19033 [1:~(apply~iscomplex_abses).] 0. secs (0.u,0.s)
Chars 19038 - 19108 [refine~(ap~(fun~x~=>~_~+~x)~(g...] 0. secs (0.u,0.s)
Chars 19113 - 19130 [(apply~grp_unit_r).] 0. secs (0.u,0.s)
Chars 19135 - 19153 [(intro~e;~symmetry).] 0.001 secs (0.001u,0.s)
Chars 19158 - 19207 [(refine~(grp_homo_op~(projecti...] 0.001 secs (0.001u,0.s)
Chars 19212 - 19248 [refine~(ap~(fun~x~=>~_~+~x)~_~...] 0. secs (0.u,0.s)
Chars 19253 - 19278 [1:~(apply~iscomplex_abses).] 0. secs (0.u,0.s)
Chars 19283 - 19300 [(apply~grp_unit_r).] 0. secs (0.u,0.s)
Chars 19301 - 19309 [Defined.] 0.015 secs (0.012u,0.002s)
Chars 19466 - 19799 [Record~AbSESMorphism~{A~X~B~Y~...] 0.027 secs (0.023u,0.003s)
Chars 19801 - 19839 [Arguments~AbSESMorphism~{A~X~B...] 0. secs (0.u,0.s)
Chars 19840 - 19894 [Arguments~Build_AbSESMorphism~...] 0. secs (0.u,0.s)
Chars 19896 - 20255 [Definition~issig_AbSESMorphism...] 0.759 secs (0.707u,0.039s)
Chars 20257 - 20466 [Definition~absesmorphism_compo...] 0.002 secs (0.002u,0.s)
Chars 20467 - 20473 [Proof.] 0. secs (0.u,0.s)
Crunching: ((⟨1∣ × ∣1⟩) x y = (if true && true then C1 else 0))
Crunching: ((⟨1∣ × ∣1⟩) x x = (if true && true then C1 else 0))
Crunching: ((if true && true then C1 else 0) = (⟨1∣ × ∣1⟩) x y)
Crunching: ((if true && true then C1 else 0) = (⟨1∣ × ∣1⟩) x y)
Crunching: ((if true && true then C1 else 0) = (⟨1∣ × ∣1⟩) 0%nat y)
Crunching: ((⟨1∣ × ∣1⟩) 0%nat y = (if true && true then C1 else 0))
Crunching: ((⟨1∣ × ∣1⟩) x y = (if true && true then C1 else 0))
Crunching: ((⟨1∣ × ∣1⟩) 0%nat 0%nat = C1)
find_witness Control.TimeoutCrunching: ((⟨1∣ × ∣1⟩) x y = (if true && true then C1 else 0))
Crunching: ((⟨1∣ × ∣1⟩) 0%nat y = (if true && true then C1 else 0))
Crunching:
((⟨1∣ × ∣1⟩) x y = (if true && (x <? 1) then IZR (Z.succ 0) else 0))
Crunching: ((⟨1∣ × ∣1⟩) x 0%nat = (if (x =? 0) && (x <? 1) then C1 else 0))
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching:
(list2D_to_matrix [[C1]] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0))
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
find_witness Control.TimeoutChars 13571 - 13608 [refine~(equiv_path_sigma~_~_~_...] 40.227 secs (0.001u,0.047s)
Chars 13611 - 13687 [(srapply~(equiv_functor_sigma'...] 0.008 secs (0.008u,0.s)
Chars 13690 - 13723 [refine~(equiv_concat_l~_~_~oE~_).] 0.003 secs (0.003u,0.s)
Chars 13726 - 13727 [{] 0. secs (0.u,0.s)
Chars 13728 - 13787 [refine~(transport_path_data_hf...] 0.011 secs (0.009u,0.001s)
Chars 13792 - 13855 [refine~(ap~(fun~x~=>~fmap~(abs...] 0.022 secs (0.02u,0.002s)
Chars 13860 - 13861 [{] 0. secs (0.u,0.s)
Chars 13862 - 13902 [refine~(ap~_~(abses_path_data_...] 0.004 secs (0.004u,0.s)
Chars 13909 - 13923 [(apply~eissect).] 0.129 secs (0.106u,0.022s)
Chars 13924 - 13925 [}] 0. secs (0.u,0.s)
Chars 13930 - 13962 [refine~(ap~(fun~x~=>~x~$@~_)~_).] 0.004 secs (0.004u,0.s)
Chars 13967 - 13996 [rapply~gpd_strong_1functor_V.] 0.123 secs (0.107u,0.015s)
Chars 13997 - 13998 [}] 0. secs (0.u,0.s)
Chars 14001 - 14042 [refine~(equiv_path_sigma_hprop...] 0.197 secs (0.192u,0.004s)
Chars 14045 - 14079 [(apply~equiv_path_groupisomorp...] 0.022 secs (0.021u,0.s)
Chars 13571 - 13608 [refine~(equiv_path_sigma~_~_~_...] 0. secs (0.u,0.s)
Chars 13611 - 13687 [(srapply~(equiv_functor_sigma'...] 0.003 secs (0.003u,0.s)
Chars 13690 - 13723 [refine~(equiv_concat_l~_~_~oE~_).] 0.001 secs (0.001u,0.s)
Chars 13728 - 13787 [refine~(transport_path_data_hf...] 0. secs (0.u,0.s)
Chars 13792 - 13855 [refine~(ap~(fun~x~=>~fmap~(abs...] 0. secs (0.u,0.s)
Chars 13862 - 13902 [refine~(ap~_~(abses_path_data_...] 0. secs (0.u,0.s)
Chars 13909 - 13923 [(apply~eissect).] 0. secs (0.u,0.s)
Chars 13930 - 13962 [refine~(ap~(fun~x~=>~x~$@~_)~_).] 0. secs (0.u,0.s)
Chars 13967 - 13996 [rapply~gpd_strong_1functor_V.] 0. secs (0.u,0.s)
Chars 14001 - 14042 [refine~(equiv_path_sigma_hprop...] 0.001 secs (0.001u,0.s)
Chars 14045 - 14079 [(apply~equiv_path_groupisomorp...] 0.001 secs (0.001u,0.s)
Chars 14080 - 14088 [Defined.] 0.113 secs (0.108u,0.004s)
(repeat m ('n) = PreCommon.Pre.ident.eagerly nat_rect (fun _ : nat => list H') [] (fun (_ : nat) (repeat_k : list H') => m :: repeat_k) ('n))
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = ∣0⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = ∣0⟩)
Chars 20476 - 20658 [rapply~~(Build_AbSESMorphism~(...] 30.301 secs (6.212u,-1.035s)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = ∣0⟩)
Chars 11965 - 11989 [srapply~equiv_iff_hprop.] 40.287 secs (0.087u,0.049s)
Chars 11992 - 12007 [intro~tr_loops.] 0. secs (0.u,0.s)
Chars 12010 - 12023 [(intros~x~y~p).] 0. secs (0.u,0.s)
Chars 12026 - 12037 [(destruct~p).] 0.001 secs (0.001u,0.s)
Chars 12040 - 12055 [(apply~tr_loops).] 0. secs (0.u,0.s)
Chars 11965 - 11989 [srapply~equiv_iff_hprop.] 0. secs (0.u,0.s)
Chars 11992 - 12007 [intro~tr_loops.] 0. secs (0.u,0.s)
Chars 12010 - 12023 [(intros~x~y~p).] 0. secs (0.u,0.s)
Chars 12026 - 12037 [(destruct~p).] 0. secs (0.u,0.s)
Chars 12040 - 12055 [(apply~tr_loops).] 0. secs (0.u,0.s)
Chars 12056 - 12064 [Defined.] 0.001 secs (0.001u,0.s)
Chars 12284 - 12430 [Theorem~equiv_istrunc_contr_it...] 0. secs (0.u,0.s)
Chars 12431 - 12437 [Proof.] 0. secs (0.u,0.s)
Chars 20476 - 20658 [rapply~~(Build_AbSESMorphism~(...] 40.086 secs (0.03u,0.036s)
Chars 20661 - 20662 [-] 0. secs (0.u,0.s)
Chars 20663 - 20676 [(intro~x;~cbn).] 0.002 secs (0.002u,0.s)
Chars 20681 - 20730 [exact~(left_square~g~_~@~ap~_~...] 0.005 secs (0.004u,0.s)
Chars 20733 - 20734 [-] 0. secs (0.u,0.s)
Chars 20735 - 20748 [(intro~x;~cbn).] 0.002 secs (0.002u,0.s)
Chars 20753 - 20804 [exact~(right_square~g~_~@~ap~_...] 0.005 secs (0.005u,0.s)
Chars 20476 - 20658 [rapply~~(Build_AbSESMorphism~(...] 0. secs (0.u,0.s)
Chars 20663 - 20676 [(intro~x;~cbn).] 0.001 secs (0.001u,0.s)
Chars 20681 - 20730 [exact~(left_square~g~_~@~ap~_~...] 0. secs (0.u,0.s)
Chars 20735 - 20748 [(intro~x;~cbn).] 0.001 secs (0.001u,0.s)
Chars 20753 - 20804 [exact~(right_square~g~_~@~ap~_...] 0. secs (0.u,0.s)
Chars 20805 - 20813 [Defined.] 0.006 secs (0.006u,0.s)
Chars 21107 - 21286 [Definition~projection_split_to...] 0.005 secs (0.005u,0.s)
Chars 21287 - 21293 [Proof.] 0. secs (0.u,0.s)
(repeat m ('n) = PreCommon.Pre.ident.eagerly nat_rect (fun _ : nat => list H') [] (fun (_ : nat) (repeat_k : list H') => m :: repeat_k) ('n))
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
find_witness Control.TimeoutBuilding invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = ∣0⟩)
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Crunching: False
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.629 secs (0.616u,0.012s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.418 secs (0.376u,0.04s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.048 secs (0.036u,0.011s) (success)
Proving split_ident_to_ident...
Crunching: False
Tactic call ran for 0.043 secs (0.039u,0.003s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 1.356 secs (1.319u,0.035s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 2.793 secs (2.766u,0.022s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Crunching: (Morphisms.respectful ?R2 eq (Mmult ⟨1∣) adjoint)
Reifying...
Crunching: False
Chars 12440 - 12461 [(induction~n;~intro~A).] 40.199 secs (0.002u,0.03s)
Chars 12464 - 12465 [{] 0. secs (0.u,0.s)
Chars 12466 - 12470 [(cbn).] 0. secs (0.u,0.s)
Chars 12471 - 12505 [exact~equiv_hprop_inhabited_co...] 0.001 secs (0.001u,0.s)
Chars 12506 - 12507 [}] 0. secs (0.u,0.s)
Chars 12510 - 12559 [refine~(_~oE~equiv_istrunc_ist...] 0.002 secs (0.002u,0.s)
Chars 12562 - 12594 [srapply~equiv_functor_forall_id.] 0.002 secs (0.002u,0.s)
Chars 12597 - 12605 [intro~a.] 0.001 secs (0.u,0.s)
Chars 12608 - 12617 [(cbn~beta).] 0. secs (0.u,0.s)
Chars 12620 - 12653 [refine~(_~oE~IHn~(loops~(A,~a))).] 0.002 secs (0.002u,0.s)
Chars 12656 - 12727 [refine~(equiv_inO_equiv~(-~2)~...] 0.004 secs (0.003u,0.s)
Chars 12730 - 12753 [rapply~equiv_iff_hprop.] 0.159 secs (0.131u,0.026s)
Chars 12756 - 12767 [(intros~X~p).] 0.001 secs (0.001u,0.s)
Chars 12770 - 12801 [refine~(@contr_equiv'~_~_~_~X).] 0.001 secs (0.u,0.s)
Chars 12804 - 12837 [rapply~(emap~(iterated_loops~_)).] 0.011 secs (0.011u,0.s)
Chars 12840 - 12862 [srapply~Build_pEquiv'.] 0.003 secs (0.002u,0.s)
Chars 12865 - 12896 [1:~exact~(equiv_concat_lr~p~1).] 0.004 secs (0.002u,0.s)
Chars 12899 - 12927 [(cbn;~unfold~ispointed_loops).] 0.002 secs (0.002u,0.s)
Chars 12930 - 12964 [exact~(concat_p1~_~@~concat_p1...] 0.002 secs (0.002u,0.s)
Chars 12440 - 12461 [(induction~n;~intro~A).] 0.001 secs (0.001u,0.s)
Chars 12466 - 12470 [(cbn).] 0. secs (0.u,0.s)
Chars 12471 - 12505 [exact~equiv_hprop_inhabited_co...] 0. secs (0.u,0.s)
Chars 12510 - 12559 [refine~(_~oE~equiv_istrunc_ist...] 0. secs (0.u,0.s)
Chars 12562 - 12594 [srapply~equiv_functor_forall_id.] 0. secs (0.u,0.s)
Chars 12597 - 12605 [intro~a.] 0. secs (0.u,0.s)
Chars 12608 - 12617 [(cbn~beta).] 0. secs (0.u,0.s)
Chars 12620 - 12653 [refine~(_~oE~IHn~(loops~(A,~a))).] 0. secs (0.u,0.s)
Chars 12656 - 12727 [refine~(equiv_inO_equiv~(-~2)~...] 0. secs (0.u,0.s)
Chars 12730 - 12753 [rapply~equiv_iff_hprop.] 0. secs (0.u,0.s)
Chars 12756 - 12767 [(intros~X~p).] 0. secs (0.u,0.s)
Chars 12770 - 12801 [refine~(@contr_equiv'~_~_~_~X).] 0. secs (0.u,0.s)
Chars 12804 - 12837 [rapply~(emap~(iterated_loops~_)).] 0. secs (0.u,0.s)
Chars 12840 - 12862 [srapply~Build_pEquiv'.] 0. secs (0.u,0.s)
Chars 12865 - 12896 [1:~exact~(equiv_concat_lr~p~1).] 0. secs (0.u,0.s)
Chars 12899 - 12927 [(cbn;~unfold~ispointed_loops).] 0.001 secs (0.001u,0.s)
Chars 12930 - 12964 [exact~(concat_p1~_~@~concat_p1...] 0. secs (0.u,0.s)
Chars 12965 - 12973 [Defined.] 0.007 secs (0.006u,0.001s)
Chars 13023 - 13095 [#[global]Instance~is1natural_l...] 0.003 secs (0.003u,0.s)
Chars 13096 - 13102 [Proof.] 0. secs (0.u,0.s)
Chars 21296 - 21338 [snrapply~(grp_kernel_corec~(G:...] 40.196 secs (0.006u,0.034s)
Chars 21341 - 21342 [-] 0. secs (0.u,0.s)
Chars 21343 - 21434 [refine~~(ab_homo_add~grp_homo_...] 0.004 secs (0.003u,0.s)
Chars 21437 - 21438 [-] 0. secs (0.u,0.s)
Chars 21439 - 21454 [(intro~x;~simpl).] 0.003 secs (0.003u,0.s)
Chars 21459 - 21503 [refine~(grp_homo_op~(projectio...] 0.002 secs (0.002u,0.s)
Chars 21508 - 21589 [refine~~(ap~(fun~y~=>~(project...] 0.007 secs (0.006u,0.s)
Chars 21594 - 21632 [refine~(grp_homo_inv~_~_~@~ap~...] 0.003 secs (0.003u,0.s)
Chars 21637 - 21645 [(apply~h).] 0.001 secs (0.001u,0.s)
Chars 21296 - 21338 [snrapply~(grp_kernel_corec~(G:...] 0. secs (0.u,0.s)
Chars 21343 - 21434 [refine~~(ab_homo_add~grp_homo_...] 0. secs (0.u,0.s)
Chars 21439 - 21454 [(intro~x;~simpl).] 0.001 secs (0.001u,0.s)
Chars 21459 - 21503 [refine~(grp_homo_op~(projectio...] 0. secs (0.u,0.s)
Chars 21508 - 21589 [refine~~(ap~(fun~y~=>~(project...] 0. secs (0.u,0.s)
Chars 21594 - 21632 [refine~(grp_homo_inv~_~_~@~ap~...] 0. secs (0.u,0.s)
Chars 21637 - 21645 [(apply~h).] 0. secs (0.u,0.s)
Chars 21646 - 21654 [Defined.] 0.006 secs (0.005u,0.s)
Chars 21730 - 21933 [Lemma~projection_split_to_kern...] 0.009 secs (0.009u,0.s)
Chars 21934 - 21940 [Proof.] 0. secs (0.u,0.s)
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.274 secs (0.268u,0.005s) (success)
Tactic call ran for 0.252 secs (0.248u,0.003s) (success)
Tactic call ran for 0.195 secs (0.194u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.134 secs (0.132u,0.002s) (success)
Tactic call ran for 1.728 secs (1.696u,0.03s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.458 secs (0.453u,0.004s) (success)
Tactic call ran for 0.98 secs (0.969u,0.01s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 39.519 secs (38.922u,0.499s) (successful)
Crunching:
(?R2 x Hxnonpos ->
 match Rcase_abs x with
 | in_left => 0
 | right a => Rsqrt {| nonneg := x; cond_nonneg := Rge_le x 0 a |}
 end <= √ a + Hxnonpos)
Crunching: ((√ l2)² < (√ a + UIP_refl)²)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨1∣ × σx)
Crunching: (list2D_to_matrix [[C1; 0]] = ⟨0∣)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣0⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣0⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣0⟩)
Crunching: (list2D_to_matrix [[0]; [C1]] = ∣1⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣0⟩)
Crunching: nat
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣0⟩)
Crunching: (Morphisms.respectful eq eq ((σx × ∣0⟩) θ) (∣1⟩ a))
Crunching: (forall y : nat, x0 = y -> (σx × ∣0⟩) θ x0 = ∣1⟩ n y)
Crunching: ((σx × ∣0⟩) θ Dec = ∣1⟩ θ y0)
Crunching: (Dec = H0 -> (σx × ∣0⟩) θ Dec = ∣1⟩ θ H0)
Crunching: (x0 = p0 -> (σx × ∣0⟩) h x0 = ∣1⟩ H p0)
Crunching: (Morphisms.respectful eq eq ((σx × ∣0⟩) r3) (∣1⟩ z))
Crunching: nat
Crunching: nat
Crunching: nat
Crunching: ((σx × ∣0⟩) a 0%nat = ∣1⟩ b Hb)
Crunching: ((σx × ∣0⟩) a 0%nat = ∣1⟩ b Hb)
Crunching: (Ha = 0%nat -> (σx × ∣0⟩) a Ha = ∣1⟩ b 0%nat)
Chars 13105 - 13118 [(intros~A~B~f).] 40.172 secs (0.u,0.03s)
Chars 13121 - 13145 [srapply~Build_pHomotopy.] 0.002 secs (0.002u,0.s)
Chars 13148 - 13149 [+] 0. secs (0.u,0.s)
Chars 13150 - 13159 [(intros~p).] 0. secs (0.u,0.s)
Chars 13160 - 13226 [refine~((inv_Vp~_~_~@~whiskerR...] 0.005 secs (0.004u,0.001s)
Chars 13231 - 13288 [refine~(inv_pp~_~_~@~whiskerL~...] 0.005 secs (0.005u,0.s)
Chars 13291 - 13292 [+] 0. secs (0.u,0.s)
Chars 13293 - 13308 [pointed_reduce.] 0.18 secs (0.152u,0.026s)
Chars 13309 - 13321 [reflexivity.] 0. secs (0.u,0.s)
Chars 13105 - 13118 [(intros~A~B~f).] 0. secs (0.u,0.s)
Chars 13121 - 13145 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 13150 - 13159 [(intros~p).] 0. secs (0.u,0.s)
Chars 13160 - 13226 [refine~((inv_Vp~_~_~@~whiskerR...] 0. secs (0.u,0.s)
Chars 13231 - 13288 [refine~(inv_pp~_~_~@~whiskerL~...] 0. secs (0.u,0.s)
Chars 13293 - 13308 [pointed_reduce.] 0.004 secs (0.003u,0.s)
Chars 13309 - 13321 [reflexivity.] 0. secs (0.u,0.s)
Chars 13322 - 13330 [Defined.] 0.143 secs (0.125u,0.016s)
Chars 13547 - 13685 [Definition~equiv_loops_ppforal...] 0.001 secs (0.u,0.001s)
Chars 13686 - 13692 [Proof.] 0. secs (0.u,0.s)
Chars 21943 - 21951 [intro~a.] 40.185 secs (0.001u,0.034s)
Chars 21954 - 21982 [(apply~path_sigma_hprop;~cbn).] 0.019 secs (0.016u,0.002s)
Chars 21985 - 22004 [(apply~grp_cancelL1).] 0.001 secs (0.001u,0.s)
Chars 22007 - 22042 [refine~(ap~(fun~x~=>~-~s~x)~_~...] 0.003 secs (0.003u,0.s)
Chars 22045 - 22066 [1:~rapply~cx_isexact.] 0.005 secs (0.004u,0.s)
Chars 22069 - 22118 [exact~(ap~_~(grp_homo_unit~_)~...] 0.005 secs (0.005u,0.s)
Chars 21943 - 21951 [intro~a.] 0. secs (0.u,0.s)
Chars 21954 - 21982 [(apply~path_sigma_hprop;~cbn).] 0.001 secs (0.001u,0.s)
Chars 21985 - 22004 [(apply~grp_cancelL1).] 0. secs (0.u,0.s)
Chars 22007 - 22042 [refine~(ap~(fun~x~=>~-~s~x)~_~...] 0. secs (0.u,0.s)
Chars 22045 - 22066 [1:~rapply~cx_isexact.] 0. secs (0.u,0.s)
Chars 22069 - 22118 [exact~(ap~_~(grp_homo_unit~_)~...] 0. secs (0.u,0.s)
Chars 22119 - 22127 [Defined.] 0.008 secs (0.007u,0.s)
Chars 22300 - 22508 [Definition~projection_split_is...] 0.004 secs (0.003u,0.001s)
Chars 22509 - 22515 [Proof.] 0. secs (0.u,0.s)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣0⟩)
Crunching: (Morphisms.respectful eq eq ((σx × ∣0⟩) θ) (∣1⟩ a))
Crunching: ((σx × ∣0⟩) θ x0 = ∣1⟩ n y0)
Crunching: ((σx × ∣0⟩) θ x0 = ∣1⟩ n y0)
Crunching: ((σx × ∣0⟩) θ x0 = ∣1⟩ n y0)
Crunching: (forall y : nat, x0 = y -> (σx × ∣0⟩) θ x0 = ∣1⟩ n y)
Crunching: ((σx × ∣0⟩) θ x0 = ∣1⟩ n x0)
Crunching: (x0 = p -> (σx × ∣0⟩) θ x0 = ∣1⟩ n p)
Crunching: (forall y : nat, x0 = y -> (σx × ∣0⟩) θ x0 = ∣1⟩ θ y)
Crunching: ((σx × ∣0⟩) θ a = ∣1⟩ θ H)
Crunching: (∣1⟩ θ H = (σx × ∣0⟩) θ a)
Crunching: ((σx × ∣0⟩) θ a = ∣1⟩ θ H)
Crunching: (∣1⟩ θ H = (σx × ∣0⟩) θ a)
Crunching: ((σx × ∣0⟩) θ Dec = ∣1⟩ θ y0)
Crunching: (Dec = le_mn2 -> (σx × ∣0⟩) θ Dec = ∣1⟩ θ le_mn2)
Crunching: (Dec = H0 -> (σx × ∣0⟩) θ Dec = ∣1⟩ θ H0)
Crunching: (Morphisms.respectful eq eq ((σx × ∣0⟩) h) (∣1⟩ a))
Crunching: (Morphisms.respectful eq eq ((σx × ∣0⟩) h) (∣1⟩ a))
Crunching: (x0 < y)
Crunching: (x0 < y)
Crunching: (x0 = p0 -> (σx × ∣0⟩) h x0 = ∣1⟩ H p0)
Crunching: (x0 = p0 -> (σx × ∣0⟩) h x0 = ∣1⟩ H p0)
Crunching: (x0 = p0 -> (σx × ∣0⟩) H x0 = ∣1⟩ H p0)
Crunching: ((σx × ∣0⟩) h t0 = ∣1⟩ H y0)
Crunching: ((σx × ∣0⟩) h t0 = ∣1⟩ H y0)
Crunching: (get_vec t0 (σx × ∣0⟩) h 0%nat = ∣1⟩ h y0)
Crunching: (∣1⟩ h y0 = get_vec t0 (σx × ∣0⟩) h 0%nat)
Crunching: (t0 = m -> (σx × ∣0⟩) h t0 = ∣1⟩ H m)
Crunching: ((σx × ∣0⟩) h t0 = ∣1⟩ H y0)
Crunching: ((σx × ∣0⟩) h t0 = ∣1⟩ H y0)
Crunching: (get_vec t0 (σx × ∣0⟩) h 0%nat = ∣1⟩ h y0)
Crunching: (∣1⟩ h y0 = get_vec t0 (σx × ∣0⟩) h 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣0⟩)
Crunching: (list2D_to_matrix [[0]; [C1]] = ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[e; e0]] = ⟨0∣ × σx)
Crunching: (list2D_to_matrix [[0; C1]] = ⟨1∣)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (n ^ n0 * n = n ^ n0 * n ^ 1)
Chars 13695 - 13717 [srapply~Build_pEquiv'.] 40.166 secs (0.u,0.03s)
Chars 13720 - 13796 [1:~(symmetry;~exact~(equiv_pat...] 0.003 secs (0.001u,0.001s)
Chars 13799 - 13811 [reflexivity.] 0.002 secs (0.u,0.001s)
Chars 13695 - 13717 [srapply~Build_pEquiv'.] 0. secs (0.u,0.s)
Chars 13720 - 13796 [1:~(symmetry;~exact~(equiv_pat...] 0. secs (0.u,0.s)
Chars 13799 - 13811 [reflexivity.] 0. secs (0.u,0.s)
Chars 13812 - 13820 [Defined.] 0.002 secs (0.001u,0.s)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Chars 22518 - 22549 [srapply~Build_GroupIsomorphism.] 40.211 secs (0.024u,0.042s)
Chars 22552 - 22553 [-] 0. secs (0.u,0.s)
Chars 22554 - 22596 [refine~(ab_biprod_corec~_~(pro...] 0.014 secs (0.01u,0.003s)
Chars 22601 - 22640 [exact~(projection_split_to_ker...] 0.001 secs (0.001u,0.s)
Chars 22643 - 22644 [-] 0. secs (0.u,0.s)
Chars 22645 - 22672 [srapply~isequiv_adjointify.] 0.003 secs (0.003u,0.s)
Chars 22677 - 22678 [+] 0. secs (0.u,0.s)
Chars 22679 - 22706 [refine~(ab_biprod_rec~_~s).] 0.001 secs (0.u,0.s)
Chars 22713 - 22734 [rapply~subgroup_incl.] 0.001 secs (0.001u,0.s)
Chars 22739 - 22740 [+] 0. secs (0.u,0.s)
Chars 22741 - 22761 [(intros~[a~b];~simpl).] 0.024 secs (0.021u,0.002s)
Chars 22768 - 22785 [(apply~path_prod').] 0.006 secs (0.005u,0.s)
Chars 22792 - 22793 [*] 0. secs (0.u,0.s)
Chars 22794 - 22824 [(srapply~path_sigma_hprop;~cbn).] 0.103 secs (0.079u,0.015s)
Chars 22833 - 22869 [refine~((associativity~_~_~_)^...] 0.024 secs (0.021u,0.001s)
Chars 22878 - 22897 [(apply~grp_cancelL1).] 0.002 secs (0.002u,0.s)
Chars 22906 - 22940 [refine~(ap~_~_~@~right_inverse...] 0.005 secs (0.004u,0.s)
Chars 22949 - 22964 [(apply~(ap~(-))).] 0.002 secs (0.002u,0.s)
Chars 22973 - 22986 [(apply~(ap~s)).] 0.002 secs (0.002u,0.s)
Chars 22995 - 23045 [refine~(grp_homo_op~(projectio...] 0.003 secs (0.003u,0.s)
Chars 23054 - 23110 [exact~((ap~(fun~y~=>~y~+~_)~a....] 0.019 secs (0.018u,0.s)
Chars 23117 - 23118 [*] 0. secs (0.u,0.s)
Chars 23119 - 23169 [refine~(grp_homo_op~(projectio...] 0.003 secs (0.003u,0.s)
Chars 23178 - 23234 [exact~((ap~(fun~y~=>~y~+~_)~a....] 0.019 secs (0.013u,0.005s)
Chars 23239 - 23240 [+] 0. secs (0.u,0.s)
Chars 23241 - 23256 [(intro~e;~simpl).] 0.004 secs (0.003u,0.s)
Chars 23263 - 23285 [by~apply~grp_moveR_gM.] 0.002 secs (0.001u,0.s)
Chars 22518 - 22549 [srapply~Build_GroupIsomorphism.] 0. secs (0.u,0.s)
Chars 22554 - 22596 [refine~(ab_biprod_corec~_~(pro...] 0. secs (0.u,0.s)
Chars 22601 - 22640 [exact~(projection_split_to_ker...] 0. secs (0.u,0.s)
Chars 22645 - 22672 [srapply~isequiv_adjointify.] 0. secs (0.u,0.s)
Chars 22679 - 22706 [refine~(ab_biprod_rec~_~s).] 0. secs (0.u,0.s)
Chars 22713 - 22734 [rapply~subgroup_incl.] 0. secs (0.u,0.s)
Chars 22741 - 22761 [(intros~[a~b];~simpl).] 0.002 secs (0.002u,0.s)
Chars 22768 - 22785 [(apply~path_prod').] 0.003 secs (0.003u,0.s)
Chars 22794 - 22824 [(srapply~path_sigma_hprop;~cbn).] 0.005 secs (0.005u,0.s)
Chars 22833 - 22869 [refine~((associativity~_~_~_)^...] 0. secs (0.u,0.s)
Chars 22878 - 22897 [(apply~grp_cancelL1).] 0. secs (0.u,0.s)
Chars 22906 - 22940 [refine~(ap~_~_~@~right_inverse...] 0. secs (0.u,0.s)
Chars 22949 - 22964 [(apply~(ap~(-))).] 0. secs (0.u,0.s)
Chars 22973 - 22986 [(apply~(ap~s)).] 0. secs (0.u,0.s)
Chars 22995 - 23045 [refine~(grp_homo_op~(projectio...] 0. secs (0.u,0.s)
Chars 23054 - 23110 [exact~((ap~(fun~y~=>~y~+~_)~a....] 0. secs (0.u,0.s)
Chars 23119 - 23169 [refine~(grp_homo_op~(projectio...] 0. secs (0.u,0.s)
Chars 23178 - 23234 [exact~((ap~(fun~y~=>~y~+~_)~a....] 0. secs (0.u,0.s)
Chars 23241 - 23256 [(intro~e;~simpl).] 0.001 secs (0.001u,0.s)
Chars 23263 - 23285 [by~apply~grp_moveR_gM.] 0. secs (0.u,0.s)
Chars 23286 - 23294 [Defined.] 0.055 secs (0.049u,0.004s)
Chars 23338 - 23515 [Definition~projection_split_is...] 0.003 secs (0.003u,0.s)
Chars 23516 - 23522 [Proof.] 0. secs (0.u,0.s)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (x ^ l * x = x ^ (l + 1))
Crunching:
(forall x : R,
 7 / 8 <= x <= 7 / 4 /\ (- cos x)%R = 0 -> n ^ n0 * n = n ^ S n0)
Crunching: (n ^ n0 * n = n ^ n0 * n ^ 1)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Crunching: ((if (x =? y) && (x <? 2) then C1 else 0) = 0)
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (0 = (if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σy × σy)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σy × σy)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σy × σy)
Crunching: (WF_Matrix (σy × σy))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σy × σy)
Finished transaction in 90.007 secs (89.661u,0.267s) (successful)
Chars 23525 - 23567 [etransitivity~(ab_biprod~(ab_k...] 40.2 secs (0.003u,0.035s)
Chars 23570 - 23571 [-] 0. secs (0.u,0.s)
Chars 23572 - 23606 [exact~(projection_split_iso1~E...] 0.001 secs (0.001u,0.s)
Chars 23609 - 23610 [-] 0. secs (0.u,0.s)
Chars 23611 - 23676 [srapply~(equiv_functor_ab_bipr...] 0.006 secs (0.005u,0.001s)
Chars 23681 - 23702 [rapply~grp_iso_cxfib.] 0.004 secs (0.003u,0.s)
Chars 23525 - 23567 [etransitivity~(ab_biprod~(ab_k...] 0. secs (0.u,0.s)
Chars 23572 - 23606 [exact~(projection_split_iso1~E...] 0. secs (0.u,0.s)
Chars 23611 - 23676 [srapply~(equiv_functor_ab_bipr...] 0. secs (0.u,0.s)
Chars 23681 - 23702 [rapply~grp_iso_cxfib.] 0. secs (0.u,0.s)
Chars 23703 - 23711 [Defined.] 0.004 secs (0.001u,0.001s)
Chars 23713 - 23902 [Proposition~projection_split_b...] 0.007 secs (0.007u,0.s)
Chars 23903 - 23909 [Proof.] 0. secs (0.u,0.s)
Crunching: (WF_Matrix (σy × σy))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σy × σy)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σy × σy)
Finished transaction in 18.899 secs (18.612u,0.27s) (successful)
Crunching: (fst (σy H5 0%nat) = fst C1)
Crunching: (fst (σy H5 0%nat) = fst C1)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σy × σy)
Crunching: (list2D_to_matrix [[- Ci * Ci; 0]; [0; Ci * - Ci]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σz × σz)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σz × σz)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σz × σz)
Chars 23912 - 23920 [intro~a.] 40.166 secs (0.u,0.035s)
Chars 23923 - 23965 [refine~(ap~_~(ab_corec_beta~_~...] 0.013 secs (0.01u,0.002s)
Chars 23968 - 24014 [refine~(ab_biprod_functor_beta...] 0.015 secs (0.013u,0.001s)
Chars 24017 - 24036 [nrapply~path_prod'.] 0.006 secs (0.006u,0.s)
Chars 24039 - 24060 [2:~rapply~cx_isexact.] 0.005 secs (0.003u,0.001s)
Chars 24063 - 24121 [refine~(ap~_~(projection_split...] 0.004 secs (0.003u,0.001s)
Chars 24124 - 24138 [(apply~eissect).] 0.002 secs (0.002u,0.s)
Chars 23912 - 23920 [intro~a.] 0. secs (0.u,0.s)
Chars 23923 - 23965 [refine~(ap~_~(ab_corec_beta~_~...] 0. secs (0.u,0.s)
Chars 23968 - 24014 [refine~(ab_biprod_functor_beta...] 0. secs (0.u,0.s)
Chars 24017 - 24036 [nrapply~path_prod'.] 0.001 secs (0.001u,0.s)
Chars 24039 - 24060 [2:~rapply~cx_isexact.] 0. secs (0.u,0.s)
Chars 24063 - 24121 [refine~(ap~_~(projection_split...] 0. secs (0.u,0.s)
Chars 24124 - 24138 [(apply~eissect).] 0. secs (0.u,0.s)
Chars 24139 - 24147 [Defined.] 0.019 secs (0.016u,0.002s)
Chars 24247 - 24410 [Proposition~iff_abses_trivial_...] 0.004 secs (0.004u,0.s)
Chars 24411 - 24417 [Proof.] 0. secs (0.u,0.s)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σz × σz)
     = ("incr",
        (["c"], [], bedrock_func_body:(
           $"v" = load($"c");
           $"one" = $1;
           $"v" = $"v" + $1;
           store($"c", $"v"))))
     : bedrock_func

(** val length : 'a1 list -> int **)

let rec length = function
| [] -> 0
| _ :: l' -> Stdlib.Int.succ (length l')

(** val app : 'a1 list -> 'a1 list -> 'a1 list **)

let rec app l m =
  match l with
  | [] -> m
  | a :: l1 -> a :: (app l1 m)

module Nat =
 struct
  (** val ltb : int -> int -> bool **)

  let ltb n0 m =
    (<=) (Stdlib.Int.succ n0) m
 end

module Pos =
 struct
  (** val succ : int -> int **)

  let rec succ = Pervasives.succ

  (** val add : int -> int -> int **)

  let rec add = (+)

  (** val add_carry : int -> int -> int **)

  and add_carry x y =
    (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
      (fun p ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q -> (fun p->1+2*p) (add_carry p q))
        (fun q -> (fun p->2*p) (add_carry p q))
        (fun _ -> (fun p->1+2*p) (succ p))
        y)
      (fun p ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q -> (fun p->2*p) (add_carry p q))
        (fun q -> (fun p->1+2*p) (add p q))
        (fun _ -> (fun p->2*p) (succ p))
        y)
      (fun _ ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q -> (fun p->1+2*p) (succ q))
        (fun q -> (fun p->2*p) (succ q))
        (fun _ -> (fun p->1+2*p) 1)
        y)
      x

  (** val pred_double : int -> int **)

  let rec pred_double x =
    (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
      (fun p -> (fun p->1+2*p) ((fun p->2*p) p))
      (fun p -> (fun p->1+2*p) (pred_double p))
      (fun _ -> 1)
      x

  (** val pred_N : int -> int **)

  let pred_N x =
    (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
      (fun p -> ((fun p->2*p) p))
      (fun p -> (pred_double p))
      (fun _ -> 0)
      x

  (** val mul : int -> int -> int **)

  let rec mul = ( * )

  (** val iter : ('a1 -> 'a1) -> 'a1 -> int -> 'a1 **)

  let rec iter f x n0 =
    (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
      (fun n' -> f (iter f (iter f x n') n'))
      (fun n' -> iter f (iter f x n') n')
      (fun _ -> f x)
      n0

  (** val div2 : int -> int **)

  let div2 p =
    (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
      (fun p0 -> p0)
      (fun p0 -> p0)
      (fun _ -> 1)
      p

  (** val div2_up : int -> int **)

  let div2_up p =
    (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
      (fun p0 -> succ p0)
      (fun p0 -> p0)
      (fun _ -> 1)
      p

  (** val coq_Nsucc_double : int -> int **)

  let coq_Nsucc_double x =
    (fun f0 fp n -> if n=0 then f0 () else fp n)
      (fun _ -> 1)
      (fun p -> ((fun p->1+2*p) p))
      x

  (** val coq_Ndouble : int -> int **)

  let coq_Ndouble n0 =
    (fun f0 fp n -> if n=0 then f0 () else fp n)
      (fun _ -> 0)
      (fun p -> ((fun p->2*p) p))
      n0

  (** val coq_lor : int -> int -> int **)

  let rec coq_lor p q =
    (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
      (fun p0 ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q0 -> (fun p->1+2*p) (coq_lor p0 q0))
        (fun q0 -> (fun p->1+2*p) (coq_lor p0 q0))
        (fun _ -> p)
        q)
      (fun p0 ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q0 -> (fun p->1+2*p) (coq_lor p0 q0))
        (fun q0 -> (fun p->2*p) (coq_lor p0 q0))
        (fun _ -> (fun p->1+2*p) p0)
        q)
      (fun _ ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun _ -> q)
        (fun q0 -> (fun p->1+2*p) q0)
        (fun _ -> q)
        q)
      p

  (** val coq_land : int -> int -> int **)

  let rec coq_land p q =
    (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
      (fun p0 ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q0 -> coq_Nsucc_double (coq_land p0 q0))
        (fun q0 -> coq_Ndouble (coq_land p0 q0))
        (fun _ -> 1)
        q)
      (fun p0 ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q0 -> coq_Ndouble (coq_land p0 q0))
        (fun q0 -> coq_Ndouble (coq_land p0 q0))
        (fun _ -> 0)
        q)
      (fun _ ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun _ -> 1)
        (fun _ -> 0)
        (fun _ -> 1)
        q)
      p

  (** val ldiff : int -> int -> int **)

  let rec ldiff p q =
    (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
      (fun p0 ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q0 -> coq_Ndouble (ldiff p0 q0))
        (fun q0 -> coq_Nsucc_double (ldiff p0 q0))
        (fun _ -> ((fun p->2*p) p0))
        q)
      (fun p0 ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q0 -> coq_Ndouble (ldiff p0 q0))
        (fun q0 -> coq_Ndouble (ldiff p0 q0))
        (fun _ -> p)
        q)
      (fun _ ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun _ -> 0)
        (fun _ -> 1)
        (fun _ -> 0)
        q)
      p
 end

module N =
 struct
  (** val succ_pos : int -> int **)

  let succ_pos n0 =
    (fun f0 fp n -> if n=0 then f0 () else fp n)
      (fun _ -> 1)
      (fun p -> Pos.succ p)
      n0

  (** val coq_lor : int -> int -> int **)

  let coq_lor n0 m =
    (fun f0 fp n -> if n=0 then f0 () else fp n)
      (fun _ -> m)
      (fun p ->
      (fun f0 fp n -> if n=0 then f0 () else fp n)
        (fun _ -> n0)
        (fun q -> (Pos.coq_lor p q))
        m)
      n0

  (** val coq_land : int -> int -> int **)

  let coq_land n0 m =
    (fun f0 fp n -> if n=0 then f0 () else fp n)
      (fun _ -> 0)
      (fun p ->
      (fun f0 fp n -> if n=0 then f0 () else fp n)
        (fun _ -> 0)
        (fun q -> Pos.coq_land p q)
        m)
      n0

  (** val ldiff : int -> int -> int **)

  let ldiff n0 m =
    (fun f0 fp n -> if n=0 then f0 () else fp n)
      (fun _ -> 0)
      (fun p ->
      (fun f0 fp n -> if n=0 then f0 () else fp n)
        (fun _ -> n0)
        (fun q -> Pos.ldiff p q)
        m)
      n0
 end

(** val map : ('a1 -> 'a2) -> 'a1 list -> 'a2 list **)

let rec map f = function
| [] -> []
| a :: t -> (f a) :: (map f t)

(** val fold_left : ('a1 -> 'a2 -> 'a1) -> 'a2 list -> 'a1 -> 'a1 **)

let rec fold_left f l a0 =
  match l with
  | [] -> a0
  | b :: t -> fold_left f t (f a0 b)

module Z =
 struct
  (** val double : int -> int **)

  let double x =
    (fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
      (fun _ -> 0)
      (fun p -> ((fun p->2*p) p))
      (fun p -> (~-) ((fun p->2*p) p))
      x

  (** val succ_double : int -> int **)

  let succ_double x =
    (fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
      (fun _ -> 1)
      (fun p -> ((fun p->1+2*p) p))
      (fun p -> (~-) (Pos.pred_double p))
      x

  (** val pred_double : int -> int **)

  let pred_double x =
    (fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
      (fun _ -> (~-) 1)
      (fun p -> (Pos.pred_double p))
      (fun p -> (~-) ((fun p->1+2*p) p))
      x

  (** val pos_sub : int -> int -> int **)

  let rec pos_sub x y =
    (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
      (fun p ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q -> double (pos_sub p q))
        (fun q -> succ_double (pos_sub p q))
        (fun _ -> ((fun p->2*p) p))
        y)
      (fun p ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q -> pred_double (pos_sub p q))
        (fun q -> double (pos_sub p q))
        (fun _ -> (Pos.pred_double p))
        y)
      (fun _ ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun q -> (~-) ((fun p->2*p) q))
        (fun q -> (~-) (Pos.pred_double q))
        (fun _ -> 0)
        y)
      x

  (** val add : int -> int -> int **)

  let add = (+)

  (** val opp : int -> int **)

  let opp = (~-)

  (** val pred : int -> int **)

  let pred = Pervasives.pred

  (** val mul : int -> int -> int **)

  let mul = ( * )

  (** val of_N : int -> int **)

  let of_N = fun p -> p

  (** val div2 : int -> int **)

  let div2 z0 =
    (fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
      (fun _ -> 0)
      (fun p ->
      (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
        (fun _ -> (Pos.div2 p))
        (fun _ -> (Pos.div2 p))
        (fun _ -> 0)
        p)
      (fun p -> (~-) (Pos.div2_up p))
      z0

  (** val lnot : int -> int **)

  let lnot a =
    pred (opp a)
 end

(** val chunk' : int -> 'a1 list -> 'a1 list -> 'a1 list list **)

let rec chunk' k bs ck =
  match bs with
  | [] -> (match ck with
           | [] -> []
           | _ :: _ -> ck :: [])
  | b :: bs0 ->
    let ck0 = app ck (b :: []) in
    if Nat.ltb (length ck0) k
    then chunk' k bs0 ck0
    else ck0 :: (chunk' k bs0 [])

(** val chunk : int -> 'a1 list -> 'a1 list list **)

let chunk k bs =
  chunk' k bs []

module Coq_byte =
 struct
  (** val unsigned : char -> int **)

  let unsigned b =
    Z.of_N (Char.code b)
 end

(** val le_combine : char list -> int **)

let rec le_combine = function
| [] -> 0
| h :: t ->
  (lor) (Coq_byte.unsigned h)
    (Int.shift_left (le_combine t) ((fun p->2*p) ((fun p->2*p) ((fun p->2*p)
      1))))

(** val onec_add16 : int -> int -> int **)

let onec_add16 z1 z2 =
  let sum = Z.add z1 z2 in
  Z.add
    ((land) sum ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p)
      ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p)
      ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p)
      ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p)
      1))))))))))))))))
    (Int.shift_right sum ((fun p->2*p) ((fun p->2*p) ((fun p->2*p)
      ((fun p->2*p) 1)))))

(** val ip_checksum : char list -> int **)

let ip_checksum bs =
  let chk =
    fold_left onec_add16
      (map le_combine (chunk (Stdlib.Int.succ (Stdlib.Int.succ 0)) bs))
      ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p)
      ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p)
      ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p)
      ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p) 1)))))))))))))))
  in
  (land) (Z.lnot chk) ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p)
    ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p)
    ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p)
    ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p) ((fun p->1+2*p)
    1)))))))))))))))

find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σz × σz)
Crunching: (list2D_to_matrix [[C1; 0]; [0; - C1 * - C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × hadamard)
Crunching: (WF_Matrix (hadamard × hadamard))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × hadamard)
Crunching:
((fun x z : nat => Σ (fun y : nat => hadamard x y * hadamard y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (WF_Matrix (hadamard × hadamard))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × hadamard)
Crunching:
((fun x z : nat => Σ (fun y : nat => hadamard x y * hadamard y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
((fun x z : nat => Σ (fun y : nat => hadamard x y * hadamard y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else (- 0)%R))
Crunching: (WF_Matrix (hadamard × hadamard))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × hadamard)
Crunching:
((fun x z : nat => Σ (fun y : nat => hadamard x y * hadamard y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.TimeoutCrunching:
((fun x z : nat => Σ (fun y : nat => hadamard x y * hadamard y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else (- 0)%R))
Crunching: (WF_Matrix (hadamard × hadamard))
Chars 24420 - 24483 [(refine~(iff_compose~_~(iff_eq...] 40.191 secs (0.005u,0.035s)
Chars 24486 - 24487 [-] 0. secs (0.u,0.s)
Chars 24488 - 24501 [(intros~[s~h]).] 0.002 secs (0.002u,0.s)
Chars 24506 - 24540 [exists~(projection_split_iso~E...] 0.003 secs (0.003u,0.s)
Chars 24545 - 24551 [split.] 0.002 secs (0.001u,0.s)
Chars 24556 - 24557 [+] 0. secs (0.u,0.s)
Chars 24558 - 24588 [nrapply~projection_split_beta.] 0.008 secs (0.005u,0.002s)
Chars 24593 - 24594 [+] 0. secs (0.u,0.s)
Chars 24595 - 24607 [reflexivity.] 0.004 secs (0.004u,0.s)
Chars 24610 - 24611 [-] 0. secs (0.u,0.s)
Chars 24612 - 24631 [(intros~[phi~[g~h]]).] 0.006 secs (0.005u,0.s)
Chars 24636 - 24698 [exists~(grp_homo_compose~(grp_...] 0.004 secs (0.004u,0.s)
Chars 24703 - 24716 [(intro~x;~cbn).] 0.003 secs (0.003u,0.s)
Chars 24721 - 24756 [exact~(h~_~@~ap~snd~(eisretr~_...] 0.023 secs (0.015u,0.007s)
Chars 24420 - 24483 [(refine~(iff_compose~_~(iff_eq...] 0.001 secs (0.001u,0.s)
Chars 24488 - 24501 [(intros~[s~h]).] 0. secs (0.u,0.s)
Chars 24506 - 24540 [exists~(projection_split_iso~E...] 0. secs (0.u,0.s)
Chars 24545 - 24551 [split.] 0.001 secs (0.001u,0.s)
Chars 24558 - 24588 [nrapply~projection_split_beta.] 0. secs (0.u,0.s)
Chars 24595 - 24607 [reflexivity.] 0. secs (0.u,0.s)
Chars 24612 - 24631 [(intros~[phi~[g~h]]).] 0. secs (0.u,0.s)
Chars 24636 - 24698 [exists~(grp_homo_compose~(grp_...] 0. secs (0.u,0.s)
Chars 24703 - 24716 [(intro~x;~cbn).] 0.002 secs (0.001u,0.s)
Chars 24721 - 24756 [exact~(h~_~@~ap~snd~(eisretr~_...] 0.001 secs (0.001u,0.s)
Chars 24757 - 24765 [Defined.] 0.023 secs (0.021u,0.001s)
Chars 24902 - 25051 [Definition~abses_from_inclusio...] 0.002 secs (0.002u,0.s)
Chars 25052 - 25058 [Proof.] 0. secs (0.u,0.s)
Crunching: ((hadamard × hadamard) q SF = 0)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × hadamard)
Crunching:
((fun x z : nat => Σ (fun y : nat => hadamard x y * hadamard y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.Timeoutlet list_char_of_string s = List.init (String.length s) (String.get s)
let () =
  Callback.register "ip_checksum" ip_checksum;
  Callback.register "list_char_of_string" list_char_of_string
Crunching:
((fun x z : nat => Σ (fun y : nat => hadamard x y * hadamard y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else (- 0)%R))
Crunching: (WF_Matrix (hadamard × hadamard))
Crunching: (0 = (hadamard × hadamard) Pdec l)
Crunching: ((hadamard × hadamard) q SF = 0)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × hadamard)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * (C1 / √ 2);
     C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * - (C1 / √ 2)];
    [C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * (C1 / √ 2);
     C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * - (C1 / √ 2)]] = 
 I 2)
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
find_witness Control.TimeoutChars 25061 - 25087 [srapply~(Build_AbSES~E~i).] 40.219 secs (0.058u,0.041s)
Chars 25090 - 25116 [1:~exact~grp_quotient_map.] 0.001 secs (0.001u,0.s)
Chars 25119 - 25130 [1:~exact~_.] 0.002 secs (0.002u,0.s)
Chars 25133 - 25155 [srapply~Build_IsExact.] 0.053 secs (0.044u,0.008s)
Chars 25158 - 25159 [-] 0. secs (0.u,0.s)
Chars 25160 - 25184 [srapply~Build_pHomotopy.] 0.002 secs (0.002u,0.s)
Chars 25189 - 25190 [+] 0. secs (0.u,0.s)
Chars 25191 - 25199 [intro~x.] 0.001 secs (0.u,0.001s)
Chars 25206 - 25223 [(apply~qglue;~cbn).] 0.009 secs (0.008u,0.001s)
Chars 25230 - 25242 [exists~(-~x).] 0.004 secs (0.003u,0.s)
Chars 25249 - 25292 [exact~(grp_homo_inv~_~_~@~(grp...] 0.009 secs (0.003u,0.s)
Chars 25297 - 25298 [+] 0. secs (0.u,0.s)
Chars 25299 - 25318 [(apply~path_ishprop).] 0.022 secs (0.018u,0.002s)
Chars 25321 - 25322 [-] 0. secs (0.u,0.s)
Chars 25323 - 25403 [snrapply~~(conn_map_homotopic~...] 0.051 secs (0.044u,0.003s)
Chars 25408 - 25409 [+] 0. secs (0.u,0.s)
Chars 25410 - 25470 [exact~(grp_kernel_quotient_iso...] 0.004 secs (0.002u,0.001s)
Chars 25475 - 25476 [+] 0. secs (0.u,0.s)
Chars 25477 - 25485 [intro~a.] 0.009 secs (0.008u,0.s)
Chars 25492 - 25538 [by~rapply~(isinj_embedding~(su...] 0.043 secs (0.036u,0.006s)
Chars 25543 - 25544 [+] 0. secs (0.u,0.s)
Chars 25545 - 25553 [exact~_.] 0.056 secs (0.046u,0.009s)
Chars 25061 - 25087 [srapply~(Build_AbSES~E~i).] 0. secs (0.u,0.s)
Chars 25090 - 25116 [1:~exact~grp_quotient_map.] 0. secs (0.u,0.s)
Chars 25119 - 25130 [1:~exact~_.] 0. secs (0.u,0.s)
Chars 25133 - 25155 [srapply~Build_IsExact.] 0. secs (0.u,0.s)
Chars 25160 - 25184 [srapply~Build_pHomotopy.] 0. secs (0.u,0.s)
Chars 25191 - 25199 [intro~x.] 0. secs (0.u,0.s)
Chars 25206 - 25223 [(apply~qglue;~cbn).] 0.001 secs (0.001u,0.s)
Chars 25230 - 25242 [exists~(-~x).] 0. secs (0.u,0.s)
Chars 25249 - 25292 [exact~(grp_homo_inv~_~_~@~(grp...] 0. secs (0.u,0.s)
Chars 25299 - 25318 [(apply~path_ishprop).] 0.003 secs (0.003u,0.s)
Chars 25323 - 25403 [snrapply~~(conn_map_homotopic~...] 0.006 secs (0.006u,0.s)
Chars 25410 - 25470 [exact~(grp_kernel_quotient_iso...] 0. secs (0.u,0.s)
Chars 25477 - 25485 [intro~a.] 0.006 secs (0.006u,0.s)
Chars 25492 - 25538 [by~rapply~(isinj_embedding~(su...] 0.005 secs (0.005u,0.s)
Chars 25545 - 25553 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 25554 - 25562 [Defined.] 0.098 secs (0.08u,0.017s)
Crunching:
((forall N : nat, INR N <= 2 ^ N) ->
 (fun x z : nat => Σ (fun y : nat => ∣0⟩ x y * ⟨0∣ y z) 1)
 .+ (fun x z : nat => Σ (fun y : nat => ∣1⟩ x y * ⟨1∣ y z) 1) = 
 I 2)
Crunching: (WF_Matrix (∣0⟩⟨0∣ .+ ∣1⟩⟨1∣))
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣0⟩⟨0∣)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 list2D_to_matrix [[C1; 0]; [0; 0]] .+ list2D_to_matrix [[0; 0]; [0; C1]])
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (WF_Matrix (∣1⟩⟨1∣ .+ ∣0⟩⟨0∣))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (WF_Matrix (∣1⟩⟨1∣ .+ ∣0⟩⟨0∣))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (WF_Matrix (∣1⟩⟨1∣ .+ ∣0⟩⟨0∣))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 (fun x z : nat => Σ (fun y : nat => ∣1⟩ x y * ⟨1∣ y z) 1)
 .+ (fun x z : nat => Σ (fun y : nat => ∣0⟩ x y * ⟨0∣ y z) 1))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (WF_Matrix (∣1⟩⟨1∣ .+ ∣0⟩⟨0∣))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 (fun x z : nat => Σ (fun y : nat => ∣1⟩ x y * ⟨1∣ y z) 1)
 .+ (fun x z : nat => Σ (fun y : nat => ∣0⟩ x y * ⟨0∣ y z) 1))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (WF_Matrix (∣1⟩⟨1∣ .+ ∣0⟩⟨0∣))
Crunching: (0 = ∣1⟩⟨1∣ x0 Hx0 + ∣0⟩⟨0∣ x0 Hx0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) Hyp_F_NE y = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) B y = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) H1 y = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) a b = 0)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 (fun x z : nat => Σ (fun y : nat => ∣1⟩ x y * ⟨1∣ y z) 1)
 .+ (fun x z : nat => Σ (fun y : nat => ∣0⟩ x y * ⟨0∣ y z) 1))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (WF_Matrix (∣1⟩⟨1∣ .+ ∣0⟩⟨0∣))
Crunching: (0 = ∣1⟩⟨1∣ x0 Hx0 + ∣0⟩⟨0∣ x0 Hx0)
Crunching: (∣1⟩⟨1∣ w r + ∣0⟩⟨0∣ w r = 0)
Crunching: (∣1⟩⟨1∣ w eps + ∣0⟩⟨0∣ w eps = 0)
Crunching: (∣1⟩⟨1∣ w x + ∣0⟩⟨0∣ w x = 0)
Crunching: (∣1⟩⟨1∣ H7 r + ∣0⟩⟨0∣ H7 r = 0)
Crunching: (∣1⟩⟨1∣ H7 An + ∣0⟩⟨0∣ H7 An = 0)
Finished transaction in 68.94 secs (28.201u,0.326s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (fst (∣1⟩⟨1∣ a b + ∣0⟩⟨0∣ a b) = fst 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) Hyp_F_NE y = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) start y = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) B y = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) H1 y = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) H1 y = (0, 0))
Finished transaction in 3.668 secs (3.644u,0.009s) (successful)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) a b = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) n IH = 0)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 (fun x z : nat => Σ (fun y : nat => ∣1⟩ x y * ⟨1∣ y z) 1)
 .+ (fun x z : nat => Σ (fun y : nat => ∣0⟩ x y * ⟨0∣ y z) 1))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (WF_Matrix (∣1⟩⟨1∣ .+ ∣0⟩⟨0∣))
Finished transaction in 98.267 secs (57.453u,0.503s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (∣1⟩⟨1∣ x0 Hx0 + ∣0⟩⟨0∣ x0 Hx0 = 0)
Finished transaction in 4.269 secs (4.235u,0.03s) (successful)
Crunching: (0 = ∣1⟩ x0 0%nat * ⟨1∣ 0%nat Hx0 + ∣0⟩ x0 0%nat * ⟨0∣ 0%nat Hx0)
Crunching: (0 = ∣1⟩⟨1∣ x0 Hx0 + ∣0⟩⟨0∣ x0 Hx0)
find_witness Control.TimeoutCrunching: (∣1⟩⟨1∣ w r + ∣0⟩⟨0∣ w r = 0)
Crunching: (∣1⟩⟨1∣ w eps + ∣0⟩⟨0∣ w eps = 0)
Crunching: (∣1⟩⟨1∣ w x + ∣0⟩⟨0∣ w x = 0)
find_witness Control.TimeoutCrunching: (∣1⟩⟨1∣ H7 r + ∣0⟩⟨0∣ H7 r = 0)
Crunching: (∣1⟩⟨1∣ H7 An + ∣0⟩⟨0∣ H7 An = 0)
Crunching: (fst (∣1⟩⟨1∣ a b + ∣0⟩⟨0∣ a b) = fst 0)
Crunching: (fst (∣1⟩⟨1∣ a b + ∣0⟩⟨0∣ a b) = fst 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) Hyp_F_NE y = 0)
Crunching:
(forall y : nat,
 (Hyp_F_NE >= 2)%nat \/ (y >= 2)%nat -> (∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) Hyp_F_NE y = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) start y = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) start y = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) B y = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) B m = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) B m = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) B m = 0)
Crunching: ((∣1⟩⟨1∣ .+ ∣0⟩⟨0∣) B H1 = 0)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣1⟩⟨1∣)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣0⟩⟨0∣)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 list2D_to_matrix [[0; 0]; [0; C1]] .+ list2D_to_matrix [[C1; 0]; [0; 0]])
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
find_witness Control.TimeoutCrunching:
(WF_Matrix
   (cnot
    × (fun x y : nat =>
       hadamard (x / 2)%nat (y / 2)%nat * I 2 (x mod 2) (y mod 2))))
Crunching:
(WF_Matrix
   (cnot
    × (fun x y : nat =>
       hadamard (x / 2)%nat (y / 2)%nat * I 2 (x mod 2) (y mod 2))))
Crunching:
(WF_Matrix
   (cnot
    × (fun x y : nat =>
       hadamard (x / 2)%nat (y / 2)%nat * I 2 (x mod 2) (y mod 2))))
Crunching:
(forall y d1 d2 : R,
 d1 > 0 ->
 d2 > 0 -> Rabs (y - Hneq) < Rmin d1 d2 -> Hneq - d1 <= y <= Hneq + d2)
Crunching:
(WF_Matrix
   (cnot
    × (fun x y : nat =>
       hadamard (x / 2)%nat (y / 2)%nat * I 2 (x mod 2) (y mod 2))))
     = ("io_sum",
        ([], [], bedrock_func_body:(
           ($"w1") = $"readw"();
           ($"w2") = $"readw"();
           $"sum" = $"w1" + $"w2";
           $"writew"($"sum"))))
     : bedrock_func
     = "void io_echo(void) {
  uintptr_t w;
  w = readw();
  writew(w);
  return;
}
"
     : string
     = "void io_sum(void) {
  uintptr_t w1, w2, sum;
  w1 = readw();
  w2 = readw();
  sum = (w1)+(w2);
  writew(sum);
  return;
}
"
     : string
     = "uintptr_t io_check(uintptr_t expected) {
  uintptr_t read, err;
  read = readw();
  if ((uintptr_t)((read)==(expected))) {
    writew((uintptr_t)0ULL);
    err = (uintptr_t)0ULL;
  } else {
    writew((uintptr_t)42ULL);
    err = (uintptr_t)42ULL;
  }
  err = (err)+((uintptr_t)1ULL);
  return err;
}
"
     : string
Crunching:
(forall y d1 d2 : R,
 d1 > 0 ->
 d2 > 0 -> Rabs (y - Hneq) < Rmin d1 d2 -> Hneq - d1 <= y <= Hneq + d2)
Crunching:
(WF_Matrix
   (cnot
    × (fun x y : nat =>
       hadamard (x / 2)%nat (y / 2)%nat * I 2 (x mod 2) (y mod 2))))
Crunching:
(list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = hadamard ⊗ I 2 × ∣ 0, 0 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]; [e1]; [e2]] =
 cnot × list2D_to_matrix [[C1 / √ 2]; [0]; [C1 / √ 2]; [0]])
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [0]; [0]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0, 0 ⟩ .+ ∣ 1, 1 ⟩))
Crunching:
(Σ (fun y0 : nat => Σ (fun y : nat => H x y * (∣0⟩ y0 y) ^*) 1 * σx y0 y) 2 =
 Σ (fun y0 : nat => H x y0 * (∣1⟩ y y0) ^*) 1)
Crunching:
(forall x : nat,
 (H × ((fun x0 y : nat => (∣0⟩ y x0) ^*) × σx)) x =
 (H × (fun x0 y : nat => (∣1⟩ y x0) ^*)) x)
Crunching:
(Σ (fun y0 : nat => Σ (fun y : nat => H x y * (∣0⟩ y0 y) ^*) 1 * σx y0 y) 2 =
 Σ (fun y0 : nat => H x y0 * (∣1⟩ y y0) ^*) 1)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
(forall x : nat,
 (H × ((fun x0 y : nat => (∣0⟩ y x0) ^*) × σx)) x =
 (H × (fun x0 y : nat => (∣1⟩ y x0) ^*)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) q =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) q)
Crunching:
((H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) A =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) A)
Crunching: ((l × (⟨0∣ × σx)) r1 r2 = 0)
Crunching:
(Σ (fun y0 : nat => Σ (fun y : nat => H x y * (∣0⟩ y0 y) ^*) 1 * σx y0 y) 2 =
 Σ (fun y0 : nat => H x y0 * (∣1⟩ y y0) ^*) 1)
Crunching: (H x 0%nat * 0 = H x 0%nat * 0 ^*)
Crunching:
(Σ (fun y0 : nat => Σ (fun y : nat => H x y * (∣0⟩ y0 y) ^*) 1 * σx y0 y) 2 =
 Σ (fun y0 : nat => H x y0 * (∣1⟩ y y0) ^*) 1)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
(forall x : nat,
 (H × ((fun x0 y : nat => (∣0⟩ y x0) ^*) × σx)) x =
 (H × (fun x0 y : nat => (∣1⟩ y x0) ^*)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) q =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) q)
Crunching:
((H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) A =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) A)
Crunching:
(Σ (fun y0 : nat => Σ (fun y : nat => H x y * (∣0⟩ y0 y) ^*) 1 * σx y0 y) 2 =
 Σ (fun y0 : nat => H x y0 * (∣1⟩ y y0) ^*) 1)
Crunching:
(forall x : nat,
 (H × ((fun x0 y : nat => (∣0⟩ y x0) ^*) × σx)) x =
 (H × (fun x0 y : nat => (∣1⟩ y x0) ^*)) x)
Crunching:
(WF_Matrix
   (fun x z : nat =>
    Σ (fun y : nat => Σ (fun y0 : nat => l x y0 * ⟨0∣ y0 y) 1 * σx y z) 2))
Crunching: ((l × (⟨0∣ × σx)) r1 r2 = 0)
Crunching:
(Σ (fun y0 : nat => Σ (fun y : nat => H x y * (∣0⟩ y0 y) ^*) 1 * σx y0 y) 2 =
 Σ (fun y0 : nat => H x y0 * (∣1⟩ y y0) ^*) 1)
Crunching:
(Σ (fun y0 : nat => Σ (fun y : nat => H x y * (∣0⟩ y0 y) ^*) 1 * σx y0 y) 2 =
 Σ (fun y0 : nat => H x y0 * (∣1⟩ y y0) ^*) 1)
find_witness Control.TimeoutCrunching:
((H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) Hn =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) Hn)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching: (WF_Matrix n -> WF_Matrix (pad Hb a n))
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
(forall x : nat,
 (H × ((fun x0 y : nat => (∣0⟩ y x0) ^*) × σx)) x =
 (H × (fun x0 y : nat => (∣1⟩ y x0) ^*)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) q =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) q)
Crunching:
((H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) 0%nat =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) 0%nat)
Crunching:
((H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) A =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) A)
Crunching:
(Σ (fun y0 : nat => Σ (fun y : nat => H x y * (∣0⟩ y0 y) ^*) 1 * σx y0 y) 2 =
 Σ (fun y0 : nat => H x y0 * (∣1⟩ y y0) ^*) 1)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
((H × (fun x y : nat => (∣0⟩ y x) ^*) × σx) n =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) n)
Crunching:
(forall x : nat,
 (H × ((fun x0 y : nat => (∣0⟩ y x0) ^*) × σx)) x =
 (H × (fun x0 y : nat => (∣1⟩ y x0) ^*)) x)
Crunching:
((H × (fun x y : nat => (∣1⟩ y x) ^*)) x =
 (H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) x)
Crunching:
((H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) q =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) q)
Crunching:
((H × ((fun x y : nat => (∣0⟩ y x) ^*) × σx)) A =
 (H × (fun x y : nat => (∣1⟩ y x) ^*)) A)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching:
(WF_Matrix
   (fun x z : nat =>
    Σ (fun y : nat => Σ (fun y0 : nat => l x y0 * ⟨0∣ y0 y) 1 * σx y z) 2))
Crunching: (I 1 = list2D_to_matrix [[C1]])
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching:
((fun x z : nat => Σ (fun y : nat => ⟨ 0 ∣ x y * ∣ 0 ⟩ y z) 2) = I 1)
Crunching:
(probability_of_outcome Hug Heub = probability_of_outcome Heub Hug)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(forall y : nat,
 (x >= 2 ^ dim)%nat \/ (y >= 2 ^ dim)%nat -> pad Hb dim A x y = 0)
Crunching:
(probability_of_outcome Hug Heub = probability_of_outcome Heub Hug)
Crunching:
(probability_of_outcome Hug Heub = probability_of_outcome Heub Hug)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall z : R * R,
 (((let (x, _) := a in x) + - (let (x, _) := z in x))%R,
  ((let (_, y) := a in y) + - (let (_, y) := z in y))%R) = b ->
 (((let (x, _) := a in x) + - (let (x, _) := b in x) +
   - (let (x, _) := z in x))%R,
  ((let (_, y) := a in y) + - (let (_, y) := b in y) +
   - (let (_, y) := z in y))%R) = (R0, R0))
Crunching:
(probability_of_outcome Hug Heub = probability_of_outcome Heub Hug)
Crunching:
(probability_of_outcome Hug Heub = probability_of_outcome Heub Hug)
Crunching:
(probability_of_outcome Hug Heub = probability_of_outcome Heub Hug)
Crunching:
(0 + C1 / √ 2 * (/ √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩) 0%nat 0%nat +
 C1 / √ 2 * (/ √ 2 .* ∣0⟩ .+ / √ 2 .* ∣1⟩) 1%nat 0%nat = C1)
Crunching: (forall z : C, a - z = Hocc -> a - Hocc - z = 0)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(cos_in 0 (cos 0) ->
 N = x_lt_y ->
 (hadamard × (fun x y : nat => / √ 2 * ∣ 0 ⟩ x y + / √ 2 * ∣ 1 ⟩ x y)) x N =
 ∣ 0 ⟩ y x_lt_y)
Crunching:
(cos_in 0 (cos 0) ->
 N = x_lt_y ->
 (hadamard × (fun x y : nat => / √ 2 * ∣ 0 ⟩ x y + / √ 2 * ∣ 1 ⟩ x y)) x N =
 ∣ 0 ⟩ y x_lt_y)
Crunching: Z
Finished transaction in 44.892 secs (4.512u,0.133s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.TimeoutCrunching:
(forall x : R,
 sin_in 0² x ->
 forall (dim start : nat) (A B : Square (2 ^ y0)),
 pad start dim A × pad start dim B = pad start dim (A × B))
Crunching: (0 <= Cmod2 c)
Crunching: (Cmod2 Hx >= 0)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
find_witness Control.TimeoutCrunching:
(forall x : R,
 sin_in 0² x ->
 forall (dim start : nat) (A B : Square (2 ^ y0)),
 pad start dim A × pad start dim B = pad start dim (A × B))
Crunching: (0 <= Cmod2 c)
Crunching: (0 <= Cmod2 c)
Crunching: (Cmod2 Hx >= 0)
Crunching: (p < m -> Hm Hxrange = Hm p -> Hxrange = p)
Crunching: (S a0 + S b <= S a0 * S b)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 <= 3 -> σx × ∣0⟩ × q = ∣1⟩ × q)
Crunching: (0 <= 3 -> σx × ∣0⟩ × q = ∣1⟩ × q)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching: (0 = Cmod2 Hx)
Crunching:
(forall x : R,
 sin_in 0² x ->
 forall (dim start : nat) (A B : Square (2 ^ y0)),
 pad start dim A × pad start dim B = pad start dim (A × B))
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching: (permutation a (b ∘ c)%prg)
Crunching:
(forall x : R,
 sin_in 0² x ->
 forall (dim start : nat) (A B : Square (2 ^ y0)),
 pad start dim A × pad start dim B = pad start dim (A × B))
Crunching: (0 <= 3 -> σx × ∣0⟩ × q = ∣1⟩ × q)
Crunching:
(forall n : nat, (2 ^ n + (2 ^ n + 0)) * 2 = 2 ^ (n + 1) + (2 ^ (n + 1) + 0))
Crunching: (0 <= 3 -> σx × ∣0⟩ × q = ∣1⟩ × q)
Crunching: (0 <> √ 2)
Crunching: (0 <> √ 2)
Crunching: (0 <= 3 -> σx × ∣0⟩ × q = ∣1⟩ × q)
Crunching:
(0² <= IZR (Z.succ (Z.succ 0)) * ((Cmod2 c)² / IZR (Z.succ (Z.succ 0))))
Crunching: (y² <= (Cmod2 c)² / 2 + y)
Crunching: (0%nat <> 0%nat)
Crunching: (b² <= (Cmod2 c)² / 2 + y)
Crunching: (0 <= 3 -> σx × ∣0⟩ × q = ∣1⟩ × q)
Crunching: (y² <= (Cmod2 c)² / 2 + y)
Crunching: (b² <= (Cmod2 c)² / 2 + y)
Crunching:
(forall x : R,
 sin_in 0² x ->
 forall (dim start : nat) (A B : Square (2 ^ y0)),
 pad start dim A × pad start dim B = pad start dim (A × B))
Crunching: (0 <= Cmod2 c)
Crunching:
(forall x : R,
 sin_in 0² x ->
 forall (dim start : nat) (A B : Square (2 ^ y0)),
 pad start dim A × pad start dim B = pad start dim (A × B))
Crunching: (0 <= Cmod2 c)
Crunching: (Cmod2 Hx >= 0)
Crunching: (Cmod2 Hx = 0)
Crunching: (permutation a (b ∘ c)%prg)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (Cmod2 Hx = 0)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (0 = Cmod2 Hx)
Crunching: (Cmod2 Hx = 0)
Crunching: (0 = Cmod2 Hx)
Crunching: (Cmod2 Hx = 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (0 = Cmod2 Hx)
Crunching: (n - c - z = 0)
Crunching: (Cmod2 Hx = 0)
Crunching: (n + - c + - z = 0)
Crunching: (0 = Cmod2 Hx)
Crunching: (n - c - a = (/ 2 * 0)%R)
Crunching: (Cmod2 Hx = 0)
Crunching: ((σx × ∣0⟩ × q) x x = (∣1⟩ × q) x x)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (permutation a (b ∘ c)%prg)
Crunching: (0 = Cmod2 Hx)
Crunching: (permutation k (kM ∘ g)%prg)
Crunching: ((σx × ∣0⟩ × q) 0%nat y = (∣1⟩ × q) 0%nat y)
Crunching: (Cmod2 Hx = 0)
Crunching: (pad 0 x (I 2) = I (2 ^ x))
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching: (0 = Cmod2 Hx)
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching: (n - c - z = 0)
Crunching: (n + - c + - z = 0)
Crunching:
(probability_of_outcome H2 H9 =
 (norm (fun x z : nat => Σ (fun y : nat => ((H2) † x y * H9 y z)%C) delta1)
  ^ 2)%R)
Crunching: (0 <> √ 2)
Crunching:
(probability_of_outcome H2 H9 =
 (norm (fun x z : nat => Σ (fun y : nat => ((H2) † x y * H9 y z)%C) delta1)
  ^ 2)%R)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 = Cmod2 Hx)
Crunching: (0 <> √ 2)
Crunching: (0 <= 3 -> σx × ∣0⟩ × q = ∣1⟩ × q)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: False
Crunching: (0 = Cmod2 Hx)
Crunching: (pad 0 x (I 2) = I (2 ^ x))
Crunching: (Cmod2 Hx = 0)
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching: (0 = Cmod2 Hx)
Crunching: (0 <= 3 -> σx × ∣0⟩ × q = ∣1⟩ × q)
Crunching: (Cmod2 Hx = 0)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣0⟩)
Crunching: (0 = Cmod2 Hx)
Crunching: (Cmod2 Hx = 0)
Crunching: (0 = Cmod2 Hx)
Crunching: (Cmod2 Hx = 0)
Crunching: (0 = Cmod2 Hx)
Crunching:
(Σ (fun y0 : nat => Σ (fun y : nat => σx x y * ∣0⟩ y y0) 2 * q y0 y) 1 =
 Σ (fun y0 : nat => ∣1⟩ x y0 * q y0 y) 1)
Crunching: (Cmod2 Hx = 0)
Crunching: ((σx × ∣0⟩ × q) x y = (∣1⟩ × q) x y)
Crunching: (0 = Cmod2 Hx)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: ((σx × ∣0⟩ × q) x 0%nat = (1 * 1)%R)
Crunching: ((σx × ∣0⟩ × q) x 0%nat = (1 * 1)%R)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (0 = Cmod2 Hx)
find_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
Crunching:
((forall N : nat, INR N <= 2 ^ N) ->
 (fun n : nat => 0 < 3 -> (σx × ∣0⟩ × q) n y = (∣1⟩ × q) x y) x)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Finished transaction in 43.957 secs (3.587u,0.132s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (permutation a (b ∘ c)%prg)
Crunching: (permutation k (kM ∘ g)%prg)
type_is_by_reference: type -> bool
is_numeric_type: type -> bool
type_is_by_value: type -> bool
is_long_type: type -> bool
is_pointer_type: type -> bool
is_anyfloat_type: type -> bool
is_ptrofs_type: type -> bool
bool_type: type -> bool
is_int32_type: type -> bool
is_int_type: type -> bool
is_scalar_type: type -> bool
is_float_type: type -> bool
is_single_type: type -> bool
type_is_volatile: type -> bool
same_base_type: type -> type -> bool
is_neutral_cast: type -> type -> bool
eqb_type: type -> type -> bool
composite_compute.complete_legal_cosu_type: composite_env -> type -> bool
complete_type: composite_env -> type -> bool
complete_or_function_type: composite_env -> type -> bool
align_mem.LegalAlignasStrong.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrict.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrongFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrictFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching: (pad 0 x (I 2) = I (2 ^ x))
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching: (I (2 ^ 1) = pad 0 1 (I 2))
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching: (pad 0 1 (I 2) = I 2)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => ((X ⨂ hadamard) x y * Hnin y z)%C) (2 ^ X)) = 
 X ⨂ a)
Crunching: (Ind < S H -> Ext Ind = H -> permutation H (fswap Ext Ind H))
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => ((X ⨂ hadamard) x y * Hnin y z)%C) (2 ^ X)) = 
 X ⨂ a)
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching: ((fun x y : nat => if (x =? y) && (x <? Hb) then C1 else 0) = ?y)
Crunching:
((fun x y : nat => if (x =? y) && (x <? Hb) then C1 else 0) =
 big_sum
   (fun i x z : nat =>
    Σ (fun y : nat => basis_vector n i x y * (basis_vector n i z y) ^*) 1) Hb)
Crunching: (pad 0 b (I 2) = I (2 ^ b))
Crunching: ((fun x y : nat => if (x =? y) && (x <? Hb) then C1 else 0) = ?y)
Crunching: (pad 0 n (I 2) = I (2 ^ n))
Crunching:
((fun x y : nat => if (x =? y) && (x <? Hb) then C1 else 0) =
 big_sum
   (fun i x z : nat =>
    Σ (fun y : nat => basis_vector n i x y * (basis_vector n i z y) ^*) 1) Hb)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (0 < 3)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => ((X ⨂ hadamard) x y * Hnin y z)%C) (2 ^ X)) = 
 X ⨂ a)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= H ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x e2
      then l1 H
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x H
       then l1 e2
       else l1 x) <= H /\
   S (g x) <= H /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x e2
      then l1 H
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x H
       then l1 e2
       else l1 x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) e2
    then l1 H
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) H
     then l1 e2
     else l1 (g x)) = x)
Crunching:
((exists g : nat -> nat,
    forall x : nat,
    S x <= S H ->
    S (l1 x) <= S H /\ S (g x) <= S H /\ g (l1 x) = x /\ l1 (g x) = x) ->
 S e2 <= S H ->
 l1 e2 = H ->
 exists g : nat -> nat,
   forall x : nat,
   S x <= H ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x e2
      then l1 H
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x H
       then l1 e2
       else l1 x) <= H /\
   S (g x) <= H /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x e2
      then l1 H
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x H
       then l1 e2
       else l1 x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) e2
    then l1 H
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) H
     then l1 e2
     else l1 (g x)) = x)
Crunching: False
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (permutation (S H) x -> permutation H (fswap x p H))
Crunching: (permutation (S H) x -> permutation H (fswap x p H))
Crunching: (list2D_to_matrix [[e]] = I 1 × Hnin)
Crunching: (list2D_to_matrix [[Hnin 0 0]] = I 1)
Crunching: (X ⨂ hadamard × Hnin = X ⨂ H)
find_witness Control.TimeoutCrunching: (X ⨂ hadamard × Hnin = X ⨂ H)
Crunching: ((fun n : nat -> nat => x p = H -> permutation H (fswap n p H)) x)
Crunching: (X ⨂ H8 = X ⨂ hadamard × Hnin)
Crunching: (X ⨂ H8 = X ⨂ hadamard × Hnin)
Crunching: (X ⨂ hadamard × Hnin = X ⨂ H8)
Crunching: (list2D_to_matrix [[e]] = I 1 × Hnin)
Crunching: (list2D_to_matrix [[Hnin 0 0]] = I 1)
Crunching: (X ⨂ hadamard × Hnin = X ⨂ H)
Crunching: (X ⨂ hadamard × Hnin = X ⨂ H)
Crunching: (list2D_to_matrix [[e]] = I 1 × Hnin)
Crunching: (list2D_to_matrix [[Hnin 0 0]] = I 1)
Crunching: (X ⨂ hadamard × Hnin = X ⨂ H)
Crunching: (X ⨂ hadamard × Hnin = X ⨂ H)
Crunching: (Ind < S H -> Ext Ind = H -> permutation H (fswap Ext Ind H))
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣1⟩)
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
find_witness Control.TimeoutCrunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
Crunching: (Z.abs_N (Z.rem (Z.pos x) (Z.pos l)) = (N.pos x mod N.pos l)%N)
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
Crunching: (?R2 N3 H3 -> Z.abs_N N3 = Z.to_N H3)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(exists g : nat -> nat,
   forall x : nat,
   S x <= 0 ->
   S
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) <= 0 /\
   S (g x) <= 0 /\
   g
     (if
       (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) x f
      then HIn 0
      else
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => match m with
                  | 0 => true
                  | S _ => false
                  end
           | S n' => match m with
                     | 0 => false
                     | S m' => eqb n' m'
                     end
           end) x 0
       then HIn f
       else HIn x) = x /\
   (if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) (g x) f
    then HIn 0
    else
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) (g x) 0
     then HIn f
     else HIn (g x)) = x)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(I (S m) =
 I m
 .+ (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0)
    × (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0) †)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣0⟩)
Finished transaction in 44.642 secs (4.253u,0.142s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣0⟩)
Crunching: (0 < t / 2)
Crunching:
(forall (ϕ : Vector (2 ^ x)) (ψ : Vector (2 ^ (x + x'))),
 prob_partial_meas ϕ ψ =
 (√ fst ((((ϕ ⊗ I (2 ^ x')) † × ψ) † × ((ϕ ⊗ I (2 ^ x')) † × ψ)) 0%nat 0%nat)
  ^ 2)%R)
Crunching: (0 < t / 2)
Crunching: (0 < t)
Crunching:
(forall q2 : Matrix 1 2, WF_Matrix q2 -> z × ⟨0∣ × (∣0⟩ × q2) = z × q2)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[C1]] × q2)
Crunching: (0 < t)
Crunching: ((h × (⟨0∣ × ∣0⟩ × h_neq)) x y = (h × h_neq) x y)
Crunching: (0 < t / 2)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨0∣ × (∣1⟩ × q2) = Zero)
Crunching: (forall x : nat, v x0 x = v (f x0) x)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨0∣ × (∣1⟩ × q2) = Zero)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨0∣ × (∣1⟩ × q2) = Zero)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨0∣ × (∣1⟩ × q2) = Zero)
Crunching: ((sin PI)² = 0 -> q1 × (⟨0∣ × ∣1⟩ × q2) = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × Ha)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨0∣ × (∣1⟩ × q2) = Zero)
Crunching: (0 < t / 2)
out of reach
Tactic call ran for 0.009 secs (0.002u,0.005s) (failure)
Crunching: ((sin PI)² = 0 -> q1 × (⟨0∣ × ∣1⟩ × q2) = Zero)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × Ha)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (0 < t)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.001s) (failure)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × Ha)
Crunching: (0 < t)
Crunching: (0 < t / 2)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨0∣ × (∣1⟩ × q2) = Zero)
find_witness Control.TimeoutCrunching: ((sin PI)² = 0 -> q1 × (⟨0∣ × ∣1⟩ × q2) = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × Ha)
Crunching:
(prob_partial_meas ϕ ψ =
 (norm
    (fun x z : nat =>
     Σ
       (fun y : nat =>
        (((ϕ
           ⊗ (fun x0 y0 : nat =>
              if (x0 =? y0) && (x0 <? 2 ^ n) then C1 else 0)) y x) ^* * 
         ψ y z)%C) (2 ^ m * 2 ^ n)) ^ 2)%R)
Crunching: (pad_u dim 0 u m Heq = 0)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
Crunching: (1 < 0 * 1)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × Ha)
Crunching:
(nat ->
 forall (n : nat) (v : nat -> nat -> nat -> R * R) (f : nat -> nat),
 (exists g : nat -> nat,
    forall x : nat,
    S x <= n -> S (f x) <= n /\ S (g x) <= n /\ g (f x) = x /\ f (g x) = x) ->
 (fix big_sum
    (G : Type) (H : Monoid G) (f0 : nat -> G) (n0 : nat) {struct n0} : G :=
    match n0 with
    | 0 => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) 
          (big_sum G H f0 n') (f0 n')
    end) (nat -> nat -> R * R)
   {|
     Gzero := fun _ _ : nat => (R0, R0);
     Gplus :=
       fun (A B : nat -> nat -> R * R) (x y : nat) =>
       (((let (x0, _) := A x y in x0) + (let (x0, _) := B x y in x0))%R,
        ((let (_, y0) := A x y in y0) + (let (_, y0) := B x y in y0))%R);
     Gplus_0_l :=
       fun g : nat -> nat -> R * R =>
       functional_extensionality
         (fun x y : nat =>
          ((R0 + (let (x0, _) := g x y in x0))%R,
           (R0 + (let (_, y0) := g x y in y0))%R)) g
         (fun x : nat =>
          functional_extensionality
            (fun y : nat =>
             ((R0 + (let (x0, _) := g x y in x0))%R,
              (R0 + (let (_, y0) := g x y in y0))%R)) 
            (g x)
            (fun y : nat =>
             c_proj_eq
               ((R0 + (let (x0, _) := g x y in x0))%R,
                (R0 + (let (_, y0) := g x y in y0))%R) 
               (g x y)
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                           (EnvRing.PEX 1);
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs := EnvRing.PEX 1
                     |} ()) [] eq_refl
                  (fun _ : positive => let (x0, _) := g x y in x0))
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                           (EnvRing.PEX 1);
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs := EnvRing.PEX 1
                     |} ()) [] eq_refl
                  (fun _ : positive => let (_, y0) := g x y in y0))));
     Gplus_0_r :=
       fun g : nat -> nat -> R * R =>
       functional_extensionality
         (fun x y : nat =>
          (((let (x0, _) := g x y in x0) + R0)%R,
           ((let (_, y0) := g x y in y0) + R0)%R)) g
         (fun x : nat =>
          functional_extensionality
            (fun y : nat =>
             (((let (x0, _) := g x y in x0) + R0)%R,
              ((let (_, y0) := g x y in y0) + R0)%R)) 
            (g x)
            (fun y : nat =>
             c_proj_eq
               (((let (x0, _) := g x y in x0) + R0)%R,
                ((let (_, y0) := g x y in y0) + R0)%R) 
               (g x y)
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEX 1)
                           (EnvRing.PEc (RMicromega.CZ 0));
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs := EnvRing.PEX 1
                     |} ()) [] eq_refl
                  (fun _ : positive => let (x0, _) := g x y in x0))
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEX 1)
                           (EnvRing.PEc (RMicromega.CZ 0));
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs := EnvRing.PEX 1
                     |} ()) [] eq_refl
                  (fun _ : positive => let (_, y0) := g x y in y0))));
     Gplus_assoc :=
       fun g h i : nat -> nat -> R * R =>
       functional_extensionality
         (fun x y : nat =>
          (((let (x0, _) := g x y in x0) +
            ((let (x0, _) := h x y in x0) + (let (x0, _) := i x y in x0)))%R,
           ((let (_, y0) := g x y in y0) +
            ((let (_, y0) := h x y in y0) + (let (_, y0) := i x y in y0)))%R))
         (fun x y : nat =>
          (((let (x0, _) := g x y in x0) + (let (x0, _) := h x y in x0) +
            (let (x0, _) := i x y in x0))%R,
           ((let (_, y0) := g x y in y0) + (let (_, y0) := h x y in y0) +
            (let (_, y0) := i x y in y0))%R))
         (fun x : nat =>
          functional_extensionality
            (fun y : nat =>
             (((let (x0, _) := g x y in x0) +
               ((let (x0, _) := h x y in x0) + (let (x0, _) := i x y in x0)))%R,
              ((let (_, y0) := g x y in y0) +
               ((let (_, y0) := h x y in y0) + (let (_, y0) := i x y in y0)))%R))
            (fun y : nat =>
             (((let (x0, _) := g x y in x0) + (let (x0, _) := h x y in x0) +
               (let (x0, _) := i x y in x0))%R,
              ((let (_, y0) := g x y in y0) + (let (_, y0) := h x y in y0) +
               (let (_, y0) := i x y in y0))%R))
            (fun y : nat =>
             c_proj_eq
               (((let (x0, _) := g x y in x0) +
                 ((let (x0, _) := h x y in x0) + (let (x0, _) := i x y in x0)))%R,
                ((let (_, y0) := g x y in y0) +
                 ((let (_, y0) := h x y in y0) + (let (_, y0) := i x y in y0)))%R)
               (((let (x0, _) := g x y in x0) + (let (x0, _) := h x y in x0) +
                 (let (x0, _) := i x y in x0))%R,
                ((let (_, y0) := g x y in y0) + (let (_, y0) := h x y in y0) +
                 (let (_, y0) := i x y in y0))%R)
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEX 1)
                           (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs :=
                         EnvRing.PEadd
                           (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                           (EnvRing.PEX 3)
                     |} ()) [] eq_refl
                  (fun p : positive =>
                   match p with
                   | (_~1)%positive => let (x0, _) := i x y in x0
                   | (_~0)%positive => let (x0, _) := h x y in x0
                   | 1%positive => let (x0, _) := g x y in x0
                   end))
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEX 1)
                           (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs :=
                         EnvRing.PEadd
                           (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                           (EnvRing.PEX 3)
                     |} ()) [] eq_refl
                  (fun p : positive =>
                   match p with
                   | (_~1)%positive => let (_, y0) := i x y in y0
                   | (_~0)%positive => let (_, y0) := h x y in y0
                   | 1%positive => let (_, y0) := g x y in y0
                   end))))
   |} v n =
 (fix big_sum
    (G : Type) (H : Monoid G) (f0 : nat -> G) (n0 : nat) {struct n0} : G :=
    match n0 with
    | 0 => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) 
          (big_sum G H f0 n') (f0 n')
    end) (nat -> nat -> R * R)
   {|
     Gzero := fun _ _ : nat => (R0, R0);
     Gplus :=
       fun (A B : nat -> nat -> R * R) (x y : nat) =>
       (((let (x0, _) := A x y in x0) + (let (x0, _) := B x y in x0))%R,
        ((let (_, y0) := A x y in y0) + (let (_, y0) := B x y in y0))%R);
     Gplus_0_l :=
       fun g : nat -> nat -> R * R =>
       functional_extensionality
         (fun x y : nat =>
          ((R0 + (let (x0, _) := g x y in x0))%R,
           (R0 + (let (_, y0) := g x y in y0))%R)) g
         (fun x : nat =>
          functional_extensionality
            (fun y : nat =>
             ((R0 + (let (x0, _) := g x y in x0))%R,
              (R0 + (let (_, y0) := g x y in y0))%R)) 
            (g x)
            (fun y : nat =>
             c_proj_eq
               ((R0 + (let (x0, _) := g x y in x0))%R,
                (R0 + (let (_, y0) := g x y in y0))%R) 
               (g x y)
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                           (EnvRing.PEX 1);
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs := EnvRing.PEX 1
                     |} ()) [] eq_refl
                  (fun _ : positive => let (x0, _) := g x y in x0))
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                           (EnvRing.PEX 1);
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs := EnvRing.PEX 1
                     |} ()) [] eq_refl
                  (fun _ : positive => let (_, y0) := g x y in y0))));
     Gplus_0_r :=
       fun g : nat -> nat -> R * R =>
       functional_extensionality
         (fun x y : nat =>
          (((let (x0, _) := g x y in x0) + R0)%R,
           ((let (_, y0) := g x y in y0) + R0)%R)) g
         (fun x : nat =>
          functional_extensionality
            (fun y : nat =>
             (((let (x0, _) := g x y in x0) + R0)%R,
              ((let (_, y0) := g x y in y0) + R0)%R)) 
            (g x)
            (fun y : nat =>
             c_proj_eq
               (((let (x0, _) := g x y in x0) + R0)%R,
                ((let (_, y0) := g x y in y0) + R0)%R) 
               (g x y)
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEX 1)
                           (EnvRing.PEc (RMicromega.CZ 0));
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs := EnvRing.PEX 1
                     |} ()) [] eq_refl
                  (fun _ : positive => let (x0, _) := g x y in x0))
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEX 1)
                           (EnvRing.PEc (RMicromega.CZ 0));
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs := EnvRing.PEX 1
                     |} ()) [] eq_refl
                  (fun _ : positive => let (_, y0) := g x y in y0))));
     Gplus_assoc :=
       fun g h i : nat -> nat -> R * R =>
       functional_extensionality
         (fun x y : nat =>
          (((let (x0, _) := g x y in x0) +
            ((let (x0, _) := h x y in x0) + (let (x0, _) := i x y in x0)))%R,
           ((let (_, y0) := g x y in y0) +
            ((let (_, y0) := h x y in y0) + (let (_, y0) := i x y in y0)))%R))
         (fun x y : nat =>
          (((let (x0, _) := g x y in x0) + (let (x0, _) := h x y in x0) +
            (let (x0, _) := i x y in x0))%R,
           ((let (_, y0) := g x y in y0) + (let (_, y0) := h x y in y0) +
            (let (_, y0) := i x y in y0))%R))
         (fun x : nat =>
          functional_extensionality
            (fun y : nat =>
             (((let (x0, _) := g x y in x0) +
               ((let (x0, _) := h x y in x0) + (let (x0, _) := i x y in x0)))%R,
              ((let (_, y0) := g x y in y0) +
               ((let (_, y0) := h x y in y0) + (let (_, y0) := i x y in y0)))%R))
            (fun y : nat =>
             (((let (x0, _) := g x y in x0) + (let (x0, _) := h x y in x0) +
               (let (x0, _) := i x y in x0))%R,
              ((let (_, y0) := g x y in y0) + (let (_, y0) := h x y in y0) +
               (let (_, y0) := i x y in y0))%R))
            (fun y : nat =>
             c_proj_eq
               (((let (x0, _) := g x y in x0) +
                 ((let (x0, _) := h x y in x0) + (let (x0, _) := i x y in x0)))%R,
                ((let (_, y0) := g x y in y0) +
                 ((let (_, y0) := h x y in y0) + (let (_, y0) := i x y in y0)))%R)
               (((let (x0, _) := g x y in x0) + (let (x0, _) := h x y in x0) +
                 (let (x0, _) := i x y in x0))%R,
                ((let (_, y0) := g x y in y0) + (let (_, y0) := h x y in y0) +
                 (let (_, y0) := i x y in y0))%R)
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEX 1)
                           (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs :=
                         EnvRing.PEadd
                           (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                           (EnvRing.PEX 3)
                     |} ()) [] eq_refl
                  (fun p : positive =>
                   match p with
                   | (_~1)%positive => let (x0, _) := i x y in x0
                   | (_~0)%positive => let (x0, _) := h x y in x0
                   | 1%positive => let (x0, _) := g x y in x0
                   end))
               (RMicromega.RTautoChecker_sound
                  (Tauto.A Tauto.isProp
                     {|
                       RingMicromega.Flhs :=
                         EnvRing.PEadd (EnvRing.PEX 1)
                           (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
                       RingMicromega.Fop := RingMicromega.OpEq;
                       RingMicromega.Frhs :=
                         EnvRing.PEadd
                           (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                           (EnvRing.PEX 3)
                     |} ()) [] eq_refl
                  (fun p : positive =>
                   match p with
                   | (_~1)%positive => let (_, y0) := i x y in y0
                   | (_~0)%positive => let (_, y0) := h x y in y0
                   | 1%positive => let (_, y0) := g x y in y0
                   end))))
   |} (fun i : nat => v (f i)) n)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × H1)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × contra)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × Hc)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × n)
Crunching:
(forall (ϕ : Vector (2 ^ x)) (ψ : Vector (2 ^ (x + x'))),
 prob_partial_meas ϕ ψ =
 (√ fst ((((ϕ ⊗ I (2 ^ x')) † × ψ) † × ((ϕ ⊗ I (2 ^ x')) † × ψ)) 0%nat 0%nat)
  ^ 2)%R)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨0∣ × (∣1⟩ × q2) = Zero)
Crunching: (WF_Matrix (big_sum x n))
Crunching: (big_sum x n = big_sum (fun i : nat => x (y i)) n)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: ((sin PI)² = 0 -> q1 × (⟨0∣ × ∣1⟩ × q2) = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × Ha)
Crunching: (0 < t / 2)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching:
((Hfalse < 2)%nat -> (H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
Tactic call ran for 0.009 secs (0.008u,0.001s) (success)
Crunching: (0 < t)
find_witness Control.TimeoutCrunching: (0 < t)
Crunching: (0 < t)
Crunching: (forall x y : R, x <> y <-> y <> x)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Crunching:
(match
   (let (x, _) :=
      let (q, r) :=
        (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
           match a with
           | (a'~1)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 1%N
                         | N.pos p => N.pos p~1
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end)
           | (a'~0)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 0%N
                         | N.pos p => N.pos p~0
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end)
           | 1%positive =>
               match b with
               | 1%N => (1%N, 0%N)
               | _ => (0%N, 1%N)
               end
           end) l' (N.pos H) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    x)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (x, _) :=
    (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
       match a with
       | (a'~1)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 1%N
                  | N.pos p => N.pos p~1
                  end)
       | (a'~0)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 0%N
                  | N.pos p => N.pos p~0
                  end)
       | 1%positive => match b with
                       | 1%N => (1%N, 0%N)
                       | _ => (0%N, 1%N)
                       end
       end) l' (N.pos H) in
  x))
Crunching: (0 < t)
Crunching: (0 < t)
Crunching:
(forall l1 l2 : list R,
 sum_over_list (l1 ++ l2) = (sum_over_list l1 + sum_over_list l2)%R)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (0 < t)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
specialized IHeP using (eq_refl e )
Crunching: (forall x : nat, v x0 x = v (f x0) x)
Crunching: (forall x : nat, v x0 x = v (f x0) x)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (0 < t)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(match
   (let (x, _) :=
      let (q, r) :=
        (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
           match a with
           | (a'~1)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 1%N
                         | N.pos p => N.pos p~1
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end)
           | (a'~0)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 0%N
                         | N.pos p => N.pos p~0
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end)
           | 1%positive =>
               match b with
               | 1%N => (1%N, 0%N)
               | _ => (0%N, 1%N)
               end
           end) n (N.pos m) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    x)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (x, _) :=
    (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
       match a with
       | (a'~1)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 1%N
                  | N.pos p => N.pos p~1
                  end)
       | (a'~0)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 0%N
                  | N.pos p => N.pos p~0
                  end)
       | 1%positive => match b with
                       | 1%N => (1%N, 0%N)
                       | _ => (0%N, 1%N)
                       end
       end) n (N.pos m) in
  x))
Crunching: (0 < t)
Crunching: (0 < t / 2)
Crunching:
(forall (ϕ : Vector (2 ^ x)) (ψ : Vector (2 ^ (x + x'))),
 prob_partial_meas ϕ ψ =
 (√ fst ((((ϕ ⊗ I (2 ^ x')) † × ψ) † × ((ϕ ⊗ I (2 ^ x')) † × ψ)) 0%nat 0%nat)
  ^ 2)%R)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching:
(forall l1 l2 : list R,
 sum_over_list (l1 ++ l2) = (sum_over_list l1 + sum_over_list l2)%R)
Crunching:
(match
   (let (x, _) :=
      let (q, r) :=
        (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
           match a with
           | (a'~1)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 1%N
                         | N.pos p => N.pos p~1
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end)
           | (a'~0)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 0%N
                         | N.pos p => N.pos p~0
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end)
           | 1%positive =>
               match b with
               | 1%N => (1%N, 0%N)
               | _ => (0%N, 1%N)
               end
           end) n (N.pos m) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    x)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (x, _) :=
    (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
       match a with
       | (a'~1)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 1%N
                  | N.pos p => N.pos p~1
                  end)
       | (a'~0)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 0%N
                  | N.pos p => N.pos p~0
                  end)
       | 1%positive => match b with
                       | 1%N => (1%N, 0%N)
                       | _ => (0%N, 1%N)
                       end
       end) n (N.pos m) in
  x))
specialized IHeP2 using (eq_refl e0 )
specialized IHeP1 using (eq_refl e )
Crunching:
(match
   (let (x, _) :=
      let (q, r) :=
        (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
           match a with
           | (a'~1)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 1%N
                         | N.pos p => N.pos p~1
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end)
           | (a'~0)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 0%N
                         | N.pos p => N.pos p~0
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end)
           | 1%positive =>
               match b with
               | 1%N => (1%N, 0%N)
               | _ => (0%N, 1%N)
               end
           end) n (N.pos m) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    x)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (x, _) :=
    (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
       match a with
       | (a'~1)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 1%N
                  | N.pos p => N.pos p~1
                  end)
       | (a'~0)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 0%N
                  | N.pos p => N.pos p~0
                  end)
       | 1%positive => match b with
                       | 1%N => (1%N, 0%N)
                       | _ => (0%N, 1%N)
                       end
       end) n (N.pos m) in
  x))
Crunching:
(match
   (let (x, _) :=
      let (q, r) :=
        (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
           match a with
           | (a'~1)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 1%N
                         | N.pos p => N.pos p~1
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end)
           | (a'~0)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 0%N
                         | N.pos p => N.pos p~0
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end)
           | 1%positive =>
               match b with
               | 1%N => (1%N, 0%N)
               | _ => (0%N, 1%N)
               end
           end) n (N.pos m) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    x)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (x, _) :=
    (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
       match a with
       | (a'~1)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 1%N
                  | N.pos p => N.pos p~1
                  end)
       | (a'~0)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 0%N
                  | N.pos p => N.pos p~0
                  end)
       | 1%positive => match b with
                       | 1%N => (1%N, 0%N)
                       | _ => (0%N, 1%N)
                       end
       end) n (N.pos m) in
  x))
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣ 0 ⟩)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Crunching: (list2D_to_matrix [[0]; [C1]] = ∣ 1 ⟩)
Crunching: ((j < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse j = ∣ 1 ⟩ Hfalse j)
Crunching:
(match
   (let (x, _) :=
      let (q, r) :=
        (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
           match a with
           | (a'~1)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 1%N
                         | N.pos p => N.pos p~1
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end)
           | (a'~0)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 0%N
                         | N.pos p => N.pos p~0
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end)
           | 1%positive =>
               match b with
               | 1%N => (1%N, 0%N)
               | _ => (0%N, 1%N)
               end
           end) n (N.pos m) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    x)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (x, _) :=
    (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
       match a with
       | (a'~1)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 1%N
                  | N.pos p => N.pos p~1
                  end)
       | (a'~0)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 0%N
                  | N.pos p => N.pos p~0
                  end)
       | 1%positive => match b with
                       | 1%N => (1%N, 0%N)
                       | _ => (0%N, 1%N)
                       end
       end) n (N.pos m) in
  x))
Crunching: ((m < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse m = ∣ 1 ⟩ Hfalse m)
Crunching:
(match
   (let (x, _) :=
      let (q, r) :=
        (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
           match a with
           | (a'~1)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 1%N
                        | N.pos p => N.pos p~1
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 1%N
                         | N.pos p => N.pos p~1
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 1%N
                      | N.pos p => N.pos p~1
                      end)
           | (a'~0)%positive =>
               let (q, r) := pos_div_eucl a' b in
               if
                match
                  match b with
                  | 0%N =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Eq
                      | N.pos _ => Lt
                      end
                  | N.pos n' =>
                      match
                        match r with
                        | 0%N => 0%N
                        | N.pos p => N.pos p~0
                        end
                      with
                      | 0%N => Gt
                      | N.pos m' =>
                          (fix compare_cont
                             (r0 : comparison) (x y : positive) {struct y} :
                               comparison :=
                             match x with
                             | (p~1)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont r0 p q0
                                 | (q0~0)%positive => compare_cont Gt p q0
                                 | 1%positive => Gt
                                 end
                             | (p~0)%positive =>
                                 match y with
                                 | (q0~1)%positive => compare_cont Lt p q0
                                 | (q0~0)%positive => compare_cont r0 p q0
                                 | 1%positive => Gt
                                 end
                             | 1%positive =>
                                 match y with
                                 | 1%positive => r0
                                 | _ => Lt
                                 end
                             end) Eq n' m'
                      end
                  end
                with
                | Gt => false
                | _ => true
                end
               then
                (match q with
                 | 0%N => 1%N
                 | N.pos p => N.pos p~1
                 end,
                 match
                   match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end
                 with
                 | 0%N => 0%N
                 | N.pos n' =>
                     match b with
                     | 0%N =>
                         match r with
                         | 0%N => 0%N
                         | N.pos p => N.pos p~0
                         end
                     | N.pos m' =>
                         match
                           (fix sub_mask (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive => Pos.IsPos p~0
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | 1%positive =>
                                  match y with
                                  | 1%positive => Pos.IsNul
                                  | _ => Pos.IsNeg
                                  end
                              end
                            with sub_mask_carry (x y : positive) {struct y} :
                                Pos.mask :=
                              match x with
                              | (p~1)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p0~1)%positive =>
                                                (p0~0~1)%positive
                                            | (p0~0)%positive =>
                                                ((pred_double p0)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p)
                                  end
                              | (p~0)%positive =>
                                  match y with
                                  | (q0~1)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsNul
                                      | Pos.IsPos p0 => Pos.IsPos p0~0
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | (q0~0)%positive =>
                                      match sub_mask_carry p q0 with
                                      | Pos.IsNul => Pos.IsPos 1
                                      | Pos.IsPos p0 => Pos.IsPos p0~1
                                      | Pos.IsNeg => Pos.IsNeg
                                      end
                                  | 1%positive =>
                                      match p with
                                      | (p0~1)%positive => Pos.IsPos p0~0~0
                                      | (p0~0)%positive =>
                                          Pos.IsPos
                                            ((fix pred_double
                                                (x0 : positive) : positive :=
                                                match x0 with
                                                | ...%positive =>
                                                 (p1~0~1)%positive
                                                | ...%positive =>
                                                 ((...)~1)%positive
                                                | 1%positive => 1%positive
                                                end) p0)~0
                                      | 1%positive => Pos.IsNul
                                      end
                                  end
                              | 1%positive => Pos.IsNeg
                              end
                            for
                            sub_mask) n' m'
                         with
                         | Pos.IsPos p => N.pos p
                         | _ => 0%N
                         end
                     end
                 end)
               else
                (match q with
                 | 0%N => 0%N
                 | N.pos p => N.pos p~0
                 end, match r with
                      | 0%N => 0%N
                      | N.pos p => N.pos p~0
                      end)
           | 1%positive =>
               match b with
               | 1%N => (1%N, 0%N)
               | _ => (0%N, 1%N)
               end
           end) n (N.pos m) in
      (match q with
       | 0%N => 0%Z
       | N.pos p => Z.pos p
       end, match r with
            | 0%N => 0%Z
            | N.pos p => Z.pos p
            end) in
    x)
 with
 | 0%Z => 0%N
 | Z.pos p | Z.neg p => N.pos p
 end =
 (let (x, _) :=
    (fix pos_div_eucl (a : positive) (b : N) {struct a} : N * N :=
       match a with
       | (a'~1)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 1%N
                    | N.pos p => N.pos p~1
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 1%N
                   | N.pos p => N.pos p~1
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 1%N
                     | N.pos p => N.pos p~1
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 1%N
                  | N.pos p => N.pos p~1
                  end)
       | (a'~0)%positive =>
           let (q, r) := pos_div_eucl a' b in
           if
            match
              match b with
              | 0%N =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Eq
                  | N.pos _ => Lt
                  end
              | N.pos n' =>
                  match
                    match r with
                    | 0%N => 0%N
                    | N.pos p => N.pos p~0
                    end
                  with
                  | 0%N => Gt
                  | N.pos m' =>
                      (fix compare_cont
                         (r0 : comparison) (x y : positive) {struct y} :
                           comparison :=
                         match x with
                         | (p~1)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont r0 p q0
                             | (q0~0)%positive => compare_cont Gt p q0
                             | 1%positive => Gt
                             end
                         | (p~0)%positive =>
                             match y with
                             | (q0~1)%positive => compare_cont Lt p q0
                             | (q0~0)%positive => compare_cont r0 p q0
                             | 1%positive => Gt
                             end
                         | 1%positive =>
                             match y with
                             | 1%positive => r0
                             | _ => Lt
                             end
                         end) Eq n' m'
                  end
              end
            with
            | Gt => false
            | _ => true
            end
           then
            (match q with
             | 0%N => 1%N
             | N.pos p => N.pos p~1
             end,
             match match r with
                   | 0%N => 0%N
                   | N.pos p => N.pos p~0
                   end with
             | 0%N => 0%N
             | N.pos n' =>
                 match b with
                 | 0%N =>
                     match r with
                     | 0%N => 0%N
                     | N.pos p => N.pos p~0
                     end
                 | N.pos m' =>
                     match
                       (fix sub_mask (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive => Pos.IsPos p~0
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | 1%positive =>
                              match y with
                              | 1%positive => Pos.IsNul
                              | _ => Pos.IsNeg
                              end
                          end
                        with sub_mask_carry (x y : positive) {struct y} :
                            Pos.mask :=
                          match x with
                          | (p~1)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  Pos.IsPos
                                    ((fix pred_double 
                                      (x0 : positive) : positive :=
                                        match x0 with
                                        | (p0~1)%positive =>
                                            (p0~0~1)%positive
                                        | (p0~0)%positive =>
                                            ((pred_double p0)~1)%positive
                                        | 1%positive => 1%positive
                                        end) p)
                              end
                          | (p~0)%positive =>
                              match y with
                              | (q0~1)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsNul
                                  | Pos.IsPos p0 => Pos.IsPos p0~0
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | (q0~0)%positive =>
                                  match sub_mask_carry p q0 with
                                  | Pos.IsNul => Pos.IsPos 1
                                  | Pos.IsPos p0 => Pos.IsPos p0~1
                                  | Pos.IsNeg => Pos.IsNeg
                                  end
                              | 1%positive =>
                                  match p with
                                  | (p0~1)%positive => Pos.IsPos p0~0~0
                                  | (p0~0)%positive =>
                                      Pos.IsPos
                                        ((fix pred_double 
                                          (x0 : positive) : positive :=
                                            match x0 with
                                            | (p1~1)%positive =>
                                                (p1~0~1)%positive
                                            | (p1~0)%positive =>
                                                ((pred_double p1)~1)%positive
                                            | 1%positive => 1%positive
                                            end) p0)~0
                                  | 1%positive => Pos.IsNul
                                  end
                              end
                          | 1%positive => Pos.IsNeg
                          end
                        for
                        sub_mask) n' m'
                     with
                     | Pos.IsPos p => N.pos p
                     | _ => 0%N
                     end
                 end
             end)
           else
            (match q with
             | 0%N => 0%N
             | N.pos p => N.pos p~0
             end, match r with
                  | 0%N => 0%N
                  | N.pos p => N.pos p~0
                  end)
       | 1%positive => match b with
                       | 1%N => (1%N, 0%N)
                       | _ => (0%N, 1%N)
                       end
       end) n (N.pos m) in
  x))
Crunching:
((Hfalse < 2)%nat -> (H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
Crunching: ((H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
Crunching: ((H' < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse H' = ∣ 1 ⟩ Hfalse H')
Crunching: (WF_Matrix (perm_mat 0 p))
Crunching: (Z.abs_N (Z.pos p ÷ Z.pos q0) = (N.pos p / N.pos q0)%N)
Crunching: (sum_over_list (LE ++ h) = (sum_over_list LE + sum_over_list h)%R)
Crunching: ((k < 1)%nat -> (σx × ∣ 0 ⟩) Hfalse k = ∣ 1 ⟩ Hfalse k)
Crunching: (Z.abs_N (Z.pos p ÷ Z.pos q0) = (N.pos p / N.pos q0)%N)
Crunching:
(big_sum (fun i : nat => nth i (a0 ++ a) 0) (length (a0 ++ a)) =
 (big_sum (fun i : nat => nth i a0 0) (length a0) +
  big_sum (fun i : nat => nth i a 0) (length a))%R)
Crunching: (WF_Matrix (perm_mat 0 p))
Crunching:
(forall y : nat,
 (H4 >= 2 ^ v)%nat \/ (y >= 2 ^ v)%nat -> pad_ctrl v b_y n u H4 y = R0)
Crunching: ((σy × ∣ 0 ⟩) a y = 0)
Crunching: (pad_ctrl 0 b_y y0 u x y = 0)
Finished transaction in 44.264 secs (3.899u,0.137s) (successful)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (prob_partial_meas HF (H0 ⊗ z1) = probability_of_outcome HF H0)
Crunching:
(forall l1 l2 : list R,
 sum_over_list (l1 ++ l2) = (sum_over_list l1 + sum_over_list l2)%R)
Crunching:
(forall (n : nat) (H : Vector (2 ^ m)),
 prob_partial_meas H (H0 ⊗ z1) = probability_of_outcome H H0)
Crunching: (WF_Matrix (perm_mat 0 p))
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × H7)
Crunching:
(Set ->
 forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × H7)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching:
(Set ->
 forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching: (perm_mat H8 p Hxz y = 0%R)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching: ((σy × ∣ 0 ⟩) a y = 0)
Crunching: (a >= H8 \/ n >= H8 -> perm_mat H8 p a n = 0%R)
     = "RUPICOLA"
     : string
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × H7)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × H7)
Crunching: ((σy × ∣ 0 ⟩) a 0%nat = 0)
clear  H0  :  (False -> cB (map (rec a1)) a1 = Lt)
Crunching: (WF_Matrix (l' × (⟨1∣ × ∣0⟩ × n)))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(Set ->
 forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching:
(Set ->
 forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching:
(forall (ψ1 : Vector (2 ^ n)) (ψ2 : Vector (2 ^ R)),
 Pure_State_Vector ψ2 ->
 prob_partial_meas l'
   (fun x y : nat =>
    ψ1 (x / 2 ^ R)%nat (y / 1)%nat * ψ2 (x mod 2 ^ R) (y mod 1)) =
 probability_of_outcome l' ψ1)
Crunching:
((sin PI)² = 0 ->
 Hx > 0 ->
 exists alp : R,
   alp > 0 /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\
    (let (Base, dist, _, _, _, _) as m return (Base m -> Base m -> R) :=
       R_met in
     dist) x 1 < alp ->
    (let (Base, dist, _, _, _, _) as m return (Base m -> Base m -> R) :=
       R_met in
     dist) (atan x) (atan 1) < Hx))
Crunching: (WF_Matrix (perm_mat 0 p))
Crunching:
(H4 > 0 ->
 exists alp : R,
   alp > 0 /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\ dist R_met x 1 < alp ->
    dist R_met (atan x) (atan 1) < H4))
     = "YAPIGOLT"
     : string
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × H7)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[e; e0]] = list2D_to_matrix [[0]] × H7)
Crunching: (0 + σy a 0%nat * ∣ 0 ⟩ 0%nat m + σy a 1%nat * ∣ 0 ⟩ 1%nat m = 0)
Crunching: ((0 < n)%nat -> (r * q + q * r)%R = (q * q + r * r)%R)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣0⟩)
Crunching: (0 + σy a 0%nat * ∣ 0 ⟩ 0%nat m + σy a 1%nat * ∣ 0 ⟩ 1%nat m = 0)
Tactic call ran for 0.005 secs (0.004u,0.001s) (success)
Crunching: (perm_mat l n EQ y = 0%R)
Tactic call ran for 0.007 secs (0.002u,0.004s) (success)
Crunching: (WF_Matrix (l' × (⟨1∣ × ∣0⟩ × n)))
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (forall a b : R, 0 <= a <= b -> b * a + a * b <= a * a + b * b)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (sum_over_list (LE ++ h) = (sum_over_list LE + sum_over_list h)%R)
Crunching:
(Set ->
 forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching:
(big_sum (fun i : nat => nth i (a0 ++ a) 0) (length (a0 ++ a)) =
 (big_sum (fun i : nat => nth i a0 0) (length a0) +
  big_sum (fun i : nat => nth i a 0) (length a))%R)
Crunching:
(Set ->
 forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Tactic call ran for 0.008 secs (0.007u,0.001s) (success)
Crunching:
(forall (q1 : Vector 2) (q2 : Matrix 1 2), q1 × ⟨1∣ × (∣0⟩ × q2) = Zero)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (WF_Matrix f -> env × (⟨1∣ × ∣1⟩ × f) = env × f)
Crunching: (WF_Matrix f -> env × (⟨1∣ × ∣1⟩ × f) = env × f)
Crunching: (WF_Matrix f -> env × (⟨1∣ × ∣1⟩ × f) = env × f)
Tactic call ran for 0.004 secs (0.003u,0.001s) (success)
Tactic call ran for 0.005 secs (0.004u,0.s) (success)
Crunching: (In (env × f) [])
Crunching: (In (env × f) [])
Crunching: (In (env × f) [])
Tactic call ran for 0.013 secs (0.006u,0.006s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching:
(Pure_State_Vector ϕ ->
 prob_partial_meas d (ψ ⊗ ϕ) = probability_of_outcome d ψ)
Crunching: (perm_mat 0 p x a = 0%R)
Crunching:
(forall (ϕ ψ1 : Vector (2 ^ y0)) (ψ2 : Vector (2 ^ Hl)),
 Pure_State_Vector ψ2 ->
 prob_partial_meas ϕ (ψ1 ⊗ ψ2) = probability_of_outcome ϕ ψ1)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (swap × swap = I (2 * 2))
Crunching: (swap × swap = I (2 * 2))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (swap × swap = I (2 * 2))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (I (2 * 2) = swap × swap)
Crunching: (swap × swap = I (2 * 2))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (I (2 * 2) = swap × swap)
Crunching:
(forall H : Vector (2 ^ m),
 prob_partial_meas H (H0 ⊗ z1) = (Cmod ⟨ H, H0 ⟩ * (Cmod ⟨ H, H0 ⟩ * 1))%R)
Crunching: (swap × swap = I (2 * 2))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (I (2 * 2) = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (swap × swap = I (2 * 2))
Crunching:
(prob_partial_meas Hlen (H0 ⊗ z1) =
 (Cmod ⟨ Hlen, H0 ⟩ * (Cmod ⟨ Hlen, H0 ⟩ * 1))%R)
Crunching:
((Cmod ⟨ Hlen, H0 ⟩ * (Cmod ⟨ Hlen, H0 ⟩ * 1))%R =
 prob_partial_meas Hlen (H0 ⊗ z1))
Crunching:
(prob_partial_meas Hlen (H0 ⊗ z1) =
 (Cmod ⟨ Hlen, H0 ⟩ * (Cmod ⟨ Hlen, H0 ⟩ * 1))%R)
Crunching:
((Cmod ⟨ Hlen, H0 ⟩ * (Cmod ⟨ Hlen, H0 ⟩ * 1))%R =
 prob_partial_meas Hlen (H0 ⊗ z1))
Crunching: (swap × swap = I (2 * 2))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(prob_partial_meas Hlen (H0 ⊗ z1) =
 (Cmod ⟨ Hlen, H0 ⟩ * (Cmod ⟨ Hlen, H0 ⟩ * 1))%R)
Crunching: (perm_mat a n H10 k = 0%R)
Crunching: (perm_mat a n H10 k = 0%R)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
((Cmod ⟨ Hlen, H0 ⟩ * (Cmod ⟨ Hlen, H0 ⟩ * 1))%R =
 prob_partial_meas Hlen (H0 ⊗ z1))
Crunching: (WF_Matrix (perm_mat 0 p))
Crunching: (I (2 * 2) = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (swap × swap = I (2 * 2))
Crunching:
(prob_partial_meas Hlen (H0 ⊗ z1) =
 (Cmod ⟨ Hlen, H0 ⟩ * (Cmod ⟨ Hlen, H0 ⟩ * 1))%R)
Crunching: (swap × swap = I (2 * 2))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (n > 0 -> x < n)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (perm_mat (0 - 0) p n s = 0%R)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (I (2 * 2) = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
out of reach
Tactic call ran for 0.008 secs (0.003u,0.005s) (failure)
Crunching: (swap × swap = I (2 * 2))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (I (2 * 2) = swap × swap)
Crunching: (swap × swap = I (2 * 2))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(forall j : nat, (p < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) p j = ∣ 0 ⟩ p j)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: ((H < 2)%nat -> (p < 1)%nat -> (σz × ∣ 0 ⟩) H p = ∣ 0 ⟩ H p)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (Σ (fun y : nat => σz i y * ∣ 0 ⟩ y j) 2 = ∣ 0 ⟩ i j)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (- (PI / 2) < 0 -> swap × swap = I 4)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(forall j : nat,
 (H17 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H17 j = ∣ 0 ⟩ H17 j)
Crunching:
((H17 < 2)%nat -> (H3 < 1)%nat -> (σz × ∣ 0 ⟩) H17 H3 = ∣ 0 ⟩ H17 H3)
Crunching: ((y < 2)%nat -> (h < 1)%nat -> (σz × ∣ 0 ⟩) y h = ∣ 0 ⟩ y h)
Crunching: ((H < 2)%nat -> (H0 < 1)%nat -> (σz × ∣ 0 ⟩) H H0 = ∣ 0 ⟩ H H0)
Crunching:
(forall j : nat, (p < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) p j = ∣ 0 ⟩ p j)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Crunching: ((σz × ∣0⟩) i j = ∣0⟩ i j)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: ((H < 2)%nat -> (p < 1)%nat -> (σz × ∣ 0 ⟩) H p = ∣ 0 ⟩ H p)
Crunching:
(forall j : nat, (H < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H j = ∣ 0 ⟩ H j)
out of reach
Tactic call ran for 0.007 secs (0.004u,0.002s) (failure)
Tactic call ran for 0.005 secs (0.004u,0.001s) (success)
Crunching: (Σ (fun y : nat => σz i y * ∣ 0 ⟩ y j) 2 = ∣ 0 ⟩ i j)
Crunching: (Σ (fun y : nat => σz i y * ∣ 0 ⟩ y j) 2 = ∣ 0 ⟩ i j)
Finished transaction in 558.542 secs (553.942u,3.552s) (successful)
Crunching: ((σz × ∣ 0 ⟩) i j = ∣ 0 ⟩ i j)
Crunching: ((σz × ∣ 0 ⟩) i j = ∣ 0 ⟩ i j)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
find_witness Control.TimeoutCrunching: (I (2 * 2) = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(forall n : nat, (0 < n)%nat -> (if Nat.eq_dec n 0 then 1 else INR n) = INR n)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (forall x y : R, ~ x <= y -> x > y)
Crunching: (swap × swap = I (2 * 2))
Crunching: (0 <= big_sum (fun i : nat => nth i f 0) (length f))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (I (2 * 2) = swap × swap)
Crunching: (swap × swap = I (2 * 2))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(forall j : nat,
 (H17 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H17 j = ∣ 0 ⟩ H17 j)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
((H17 < 2)%nat -> (H3 < 1)%nat -> (σz × ∣ 0 ⟩) H17 H3 = ∣ 0 ⟩ H17 H3)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = swap × swap)
Crunching: (swap × swap = I (2 * 2))
Crunching: ((y < 2)%nat -> (h < 1)%nat -> (σz × ∣ 0 ⟩) y h = ∣ 0 ⟩ y h)
Crunching: ((σz × ∣ 0 ⟩) y h = ∣ 0 ⟩ y h)
Crunching: ((H < 2)%nat -> (H0 < 1)%nat -> (σz × ∣ 0 ⟩) H H0 = ∣ 0 ⟩ H H0)
Crunching:
(forall j : nat, (p < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) p j = ∣ 0 ⟩ p j)
Crunching: (forall x y : R, ~ x <= y -> x > y)
Crunching:
((forall y : nat, (0 >= 2 * 2)%nat \/ (y >= 2 * 2)%nat -> Hab 0%nat y = 0) ->
 Hab × swap × swap = Hab)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = l × swap)
Crunching:
((0 + 1)%R = 1%R ->
 perm_mat z Hab × perm_mat z Hnin = perm_mat z (Hab ∘ Hnin)%prg)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = l × swap)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hn × ∣ LT ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching:
(forall b : bool, phase_shift Hyp × ∣ b ⟩ = Cexp (b * Hyp) .* ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ H ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ f ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ m ⟩)
Crunching:
((forall y : nat, (0 >= 2 * 2)%nat \/ (y >= 2 * 2)%nat -> Hab 0%nat y = 0) ->
 Hab × swap × swap = Hab)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching:
((phase_shift n × ∣ 1 ⟩) 1%nat 0%nat = (Cexp (1 * n) .* ∣ 1 ⟩) 1%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[0]; [Cexp n]] = Cexp (1 * n) .* ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hn × ∣ LT ⟩)
Crunching:
(forall g : nat -> nat,
 permutation z g -> perm_mat z Hab × perm_mat z g = perm_mat z (Hab ∘ g)%prg)
Crunching:
(R0 < R0 ->
 (forall N : nat, INR N <= IPR 2 ^ N) ->
 (forall y : nat, (0 >= 2 * 2)%nat \/ (y >= 2 * 2)%nat -> Hab 0%nat y = R0) ->
 Hab × swap × swap = Hab)
find_witness Control.TimeoutCrunching:
((0 + 1)%R = 1%R ->
 perm_mat z Hab × perm_mat z Hnin = perm_mat z (Hab ∘ Hnin)%prg)
Crunching:
(Morphisms.respectful eq eq ((phase_shift Hyp × N2) p)
   ((Cexp (b * Hyp) .* H6) o))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching:
((IZR (Z.of_nat 1) + 0)%R = IZR (Z.of_nat 1) ->
 perm_mat z Hab × perm_mat z Hnin = perm_mat z (Hab ∘ Hnin)%prg)
Crunching:
((IZR (Z.of_nat 1) + 0)%R = IZR (Z.of_nat 1) ->
 perm_mat z Hab × perm_mat z Hnin = perm_mat z (Hab ∘ Hnin)%prg)
Crunching:
((IZR (Z.of_nat 1) + 0)%R = IZR (Z.of_nat 1) ->
 perm_mat z Hab × perm_mat z Hnin = perm_mat z (Hab ∘ Hnin)%prg)
Crunching:
((IZR (Z.of_nat 1) + 0)%R = IZR (Z.of_nat 1) ->
 perm_mat z Hab × perm_mat z Hnin = perm_mat z (Hab ∘ Hnin)%prg)
Finished transaction in 46.152 secs (5.756u,0.148s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching:
(Morphisms.respectful eq eq ((phase_shift Hyp × N2) p)
   ((Cexp (b * Hyp) .* H6) o))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
out of reach
Tactic call ran for 0.006 secs (0.004u,0.002s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (n < p / 2 + p / 2)
Crunching:
((0 + 1)%R = 1%R ->
 perm_mat z Hab × perm_mat z Hnin = perm_mat z (Hab ∘ Hnin)%prg)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hyp × ∣ b ⟩)
Crunching:
((0 + 1)%R = 1%R ->
 perm_mat z Hab × perm_mat z Hnin = perm_mat z (Hab ∘ Hnin)%prg)
Crunching: (WF_Unitary (pad_u n H5 H1))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.TimeoutCrunching:
((0 + 1)%R = 1%R ->
 perm_mat z Hab × perm_mat z Hnin = perm_mat z (Hab ∘ Hnin)%prg)
find_witness Control.TimeoutTactic call ran for 0.009 secs (0.008u,0.001s) (success)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(forall b : bool, phase_shift Hyp × ∣ b ⟩ = Cexp (b * Hyp) .* ∣ b ⟩)
Crunching: (length [] = 0%nat -> False)
Crunching: (?x < y)
Crunching: (?x < y)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (WF_Matrix (fun x y : nat => Cexp (H * Hyp) * ∣ H ⟩ x y))
find_witness Control.TimeoutTactic call ran for 0.008 secs (0.008u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (sample [] r < length [])%nat
Crunching: (perm_mat n f = I n)
find_witness Control.TimeoutCrunching:
(?R4 m H ->
 Morphisms.respectful eq (Morphisms.respectful eq eq) 
   (hadamard × m) (/ √ 2 .* H))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(((R1, R0) = (R0, R0) -> False) ->
 forall (n : nat) (f : nat -> nat),
 (forall x : nat, S x <= n -> f x = x) ->
 (fun x y : nat =>
  if
   if
    if
     (fix eqb (n0 m : nat) {struct n0} : bool :=
        match n0 with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) x (f y)
    then
     match n with
     | 0 => false
     | S m' =>
         (fix leb (n0 m : nat) {struct n0} : bool :=
            match n0 with
            | 0 => true
            | S n' => match m with
                      | 0 => false
                      | S m'0 => leb n' m'0
                      end
            end) x m'
     end
    else false
   then
    match n with
    | 0 => false
    | S m' =>
        (fix leb (n0 m : nat) {struct n0} : bool :=
           match n0 with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
           end) y m'
    end
   else false
  then (R1, R0)
  else (R0, R0)) =
 (fun x y : nat =>
  if
   if
    (fix eqb (n0 m : nat) {struct n0} : bool :=
       match n0 with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) x y
   then
    match n with
    | 0 => false
    | S m' =>
        (fix leb (n0 m : nat) {struct n0} : bool :=
           match n0 with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
           end) x m'
    end
   else false
  then (R1, R0)
  else (R0, R0)))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (perm_mat 0 f = I 0)
     = ("fnv1a",
        (["data"; "len"], ["hash"], bedrock_func_body:(
           $"p" = $16777619;
           $"hash" = $2166136261;
           $"from" = $0;
           $"_gs_from0" = $0;
           $"_gs_to0" = $"len";
           while $"_gs_from0" < $"_gs_to0" {
             {$"b" = load1($"data" + $1 * $"_gs_from0");
              $"hash" = ($"hash" ^ $"b") * $16777619;
              $(cmd.unset "b")};
             $"_gs_from0" = $"_gs_from0" + $1
           })))
     : bedrock_func
     = ("fnv1a",
        (["data"; "len"], ["hash"], bedrock_func_body:(
           $"p" = $1099511628211;
           $"hash" = $14695981039346656037;
           $"from" = $0;
           $"_gs_from0" = $0;
           $"_gs_to0" = $"len";
           while $"_gs_from0" < $"_gs_to0" {
             {$"b" = load1($"data" + $1 * $"_gs_from0");
              $"hash" = ($"hash" ^ $"b") * $1099511628211;
              $(cmd.unset "b")};
             $"_gs_from0" = $"_gs_from0" + $1
           })))
     : bedrock_func
Crunching: (perm_mat n f = I n)
Crunching: (sample [] n < length [])%nat
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (0 <= q <= H -> H * q + q * H <= q * q + H * H)
find_witness Control.TimeoutFinished transaction in 75.708 secs (73.618u,1.544s) (successful)
Crunching: (length [] = 0%nat -> False)
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
Crunching: (0 <= E1 < sum_over_list [] -> (0 < 0)%nat)
Crunching: (length [] = 0%nat -> False)
Crunching: (perm_mat n f = I n)
Crunching: (perm_mat n f = I n)
Crunching:
(((R1, R0) = (R0, R0) -> False) ->
 forall (n : nat) (f : nat -> nat),
 (forall x : nat, S x <= n -> f x = x) ->
 (fun x y : nat =>
  if
   if
    if
     (fix eqb (n0 m : nat) {struct n0} : bool :=
        match n0 with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) x (f y)
    then
     match n with
     | 0 => false
     | S m' =>
         (fix leb (n0 m : nat) {struct n0} : bool :=
            match n0 with
            | 0 => true
            | S n' => match m with
                      | 0 => false
                      | S m'0 => leb n' m'0
                      end
            end) x m'
     end
    else false
   then
    match n with
    | 0 => false
    | S m' =>
        (fix leb (n0 m : nat) {struct n0} : bool :=
           match n0 with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
           end) y m'
    end
   else false
  then (R1, R0)
  else (R0, R0)) =
 (fun x y : nat =>
  if
   if
    (fix eqb (n0 m : nat) {struct n0} : bool :=
       match n0 with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) x y
   then
    match n with
    | 0 => false
    | S m' =>
        (fix leb (n0 m : nat) {struct n0} : bool :=
           match n0 with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
           end) x m'
    end
   else false
  then (R1, R0)
  else (R0, R0)))
find_witness Control.TimeoutCrunching: (l1 - k <= l2)
Crunching: (sample [] H10 < length [])%nat
Crunching:
(WF_Unitary
   (pad m dim
      (∣1⟩⟨1∣ ⊗ I (2 ^ (n - m - 1)) ⊗ u .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (n - m - 1)) ⊗ I 2)))
Crunching: ((x * H1 + H1 * x)%R = (H1 * H1 + x * x)%R)
Crunching:
(forall (dim m n : nat) (u : Square 2),
 m <> n ->
 (m < dim)%nat ->
 (n < dim)%nat -> WF_Unitary u -> WF_Unitary (pad_ctrl dim m n u))
Crunching: ((x * H1 + H1 * x)%R = (H1 * H1 + x * x)%R)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ n ⟩)
find_witness Control.TimeoutCrunching: ((hadamard × ∣ p ⟩) 0%nat 0%nat = ?y)
Crunching: ((hadamard × ∣ p ⟩) 0%nat 0%nat = ?y)
Crunching:
(Σ (fun y : nat => hadamard 0%nat y * ∣ Hb ⟩ y 0%nat) 2 =
 (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ Hb .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching:
(Morphisms.respectful eq eq
   (fun z : nat => Σ (fun y0 : nat => hadamard y y0 * n y0 z) 2)
   ((/ √ 2 .* m) y))
Crunching:
(?R4 m H ->
 Morphisms.respectful eq (Morphisms.respectful eq eq) 
   (hadamard × m) (/ √ 2 .* H))
Crunching: (sample l r < length l)%nat
find_witness Control.TimeoutCrunching:
(forall y : nat,
 Ha = y -> Morphisms.respectful eq eq ((hadamard × m) Ha) ((/ √ 2 .* H) y))
Crunching:
(forall y : nat, l1 = y -> (hadamard × m) Ha l1 = (/ √ 2 .* H) Ha y)
Crunching:
(forall y : nat,
 Maj = y -> Morphisms.respectful eq eq ((hadamard × m) Maj) ((/ √ 2 .* H) y))
Crunching: (perm_mat 0 f = I 0)
Crunching: (perm_mat n f = I n)
find_witness Control.TimeoutCrunching:
(perm_mat n f x 0 =
 (if (x =? 0) && match n with
                 | 0 => false
                 | S m' => x <=? m'
                 end
  then C1
  else 0%R))
Crunching: (perm_mat n f = I n)
Crunching: (perm_mat HA H3 = I HA)
Crunching: (perm_mat HA H3 = I HA)
Finished transaction in 15.093 secs (14.759u,0.249s) (successful)
Crunching:
(forall y0 : nat,
 H' = y0 ->
 Morphisms.respectful eq eq ((hadamard × Heqb) H') ((/ √ 2 .* y) y0))
Crunching: (perm_mat 0 f = I 0)
Crunching:
(?R4 Heqb a' ->
 Morphisms.respectful eq (Morphisms.respectful eq eq) 
   (hadamard × Heqb) (/ √ 2 .* a'))
find_witness Control.TimeoutCrunching: (1 <= S (sample l r))%nat
Crunching: (1 <= S (sample l r))%nat
Crunching:
(?R4 Heqb l ->
 Morphisms.respectful eq (Morphisms.respectful eq eq) 
   (hadamard × Heqb) (/ √ 2 .* l))
Crunching:
((Rmax x y < z -> x < z /\ y < z) /\ (x < z /\ y < z -> Rmax x y < z))
Crunching: (1 <= S (sample l r))%nat
Crunching: (1 <= S (sample l r))%nat
Crunching:
(forall y0 : nat,
 z = y0 -> Morphisms.respectful eq eq ((hadamard × E0) z) ((/ √ 2 .* y) y0))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(cos_approx (7 / 8) (2 * 0 + 1) <= cos (7 / 8) ->
 cos (7 / 8) <= cos_approx (7 / 8) (2 * (0 + 1)) -> ∣0⟩ H2 y = (- 0)%R)
Crunching: ((hadamard × E0) q LE = (/ √ 2 .* y) q LE)
Crunching: (pad_ctrl dim m n u x y = 0)
Crunching:
(forall y0 : nat,
 z = y0 -> Morphisms.respectful eq eq ((hadamard × E0) z) ((/ √ 2 .* y) y0))
Crunching: ((hadamard × E0) q LE = (/ √ 2 .* y) q LE)
Crunching: (∣0⟩ H2 y = (R0, R0))
Crunching:
(?R3 a b ->
 Morphisms.respectful ?R2 (Morphisms.respectful eq eq) 
   (hadamard × a) (/ √ 2 .* b))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching:
(WF_Unitary
   (pad m dim
      (∣1⟩⟨1∣ ⊗ I (2 ^ (n - m - 1)) ⊗ u .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (n - m - 1)) ⊗ I 2)))
Crunching: False
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ a, n ⟩)
Crunching:
(WF_Unitary
   (pad m dim
      (∣1⟩⟨1∣ ⊗ I (2 ^ (0 - m - 1)) ⊗ u .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (0 - m - 1)) ⊗ I 2)))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ a, n ⟩)
Crunching: False
Crunching:
((Rmax x y < z -> x < z /\ y < z) /\ (x < z /\ y < z -> Rmax x y < z))
find_witness Control.TimeoutCrunching:
(forall (dim m n : nat) (u : Square 2),
 m <> n ->
 (m < dim)%nat ->
 (n < dim)%nat -> WF_Unitary u -> WF_Unitary (pad_ctrl dim m n u))
Tactic call ran for 0.013 secs (0.013u,0.s) (success)
Crunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
Crunching: (1 <= S (sample l r))%nat
Crunching: (WF_Unitary (pad_ctrl n Hn n0 u))
Crunching: False
Crunching: False
Crunching:
(forall x y z : R,
 x + - y < z \/ (x + - y)%R = z -> x < y + z \/ x = (y + z)%R)
Crunching:
(cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat))
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.017 secs (0.015u,0.002s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ a, n ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ a, n ⟩)
find_witness Control.TimeoutCrunching: False
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: False
Crunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
Crunching: False
Crunching: False
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]; [e0]; [e1]; [e2]] =
 cnot
 × (fun x y : nat =>
    ∣ l2' ⟩ (fst (Nat.divmod x 1 0 1)) (fst (Nat.divmod y 0 0 0)) *
    ∣ l ⟩
      match snd (Nat.divmod x 1 0 1) with
      | 0%nat => 1%nat
      | S _ => 0%nat
      end 0%nat))
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching: False
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
Crunching: False
Crunching: False
Crunching: False
find_witness Control.TimeoutCrunching:
(cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat))
Crunching:
((fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat) =
 cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat))
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
Crunching: False
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ a, n ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ a, n ⟩)
find_witness Control.TimeoutCrunching: False
Finished transaction in 25.057 secs (24.687u,0.361s) (successful)
Crunching: False
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: False
Crunching:
(list2D_to_matrix [[e]; [e0]; [e1]; [e2]] =
 cnot
 × (fun x y : nat =>
    ∣ l2' ⟩ (fst (Nat.divmod x 1 0 1)) (fst (Nat.divmod y 0 0 0)) *
    ∣ l ⟩
      match snd (Nat.divmod x 1 0 1) with
      | 0%nat => 1%nat
      | S _ => 0%nat
      end 0%nat))
find_witness Control.TimeoutCrunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
Crunching:
(cos_approx (7 / 8) (2 * 0 + 1) <= cos (7 / 8) ->
 cos (7 / 8) <= cos_approx (7 / 8) (2 * (0 + 1)) -> ∣0⟩ H2 y = 0)
find_witness Control.TimeoutCrunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod S l2' ⟩)
Crunching: (∣0⟩ LT y = 0 -> ∣0⟩ (S LT) y = 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: False
Crunching:
(cos_approx (7 / 8) (2 * 0 + 1) <= cos (7 / 8) ->
 cos (7 / 8) <= cos_approx (7 / 8) (2 * (0 + 1)) -> ∣0⟩ H2 y = (- 0)%R)
Crunching:
(list2D_to_matrix [[e]; [e0]; [e1]; [e2]] =
 cnot
 × (fun x y : nat =>
    ∣ l2' ⟩ (fst (Nat.divmod x 1 0 1)) (fst (Nat.divmod y 0 0 0)) *
    ∣ l ⟩
      match snd (Nat.divmod x 1 0 1) with
      | 0%nat => 1%nat
      | S _ => 0%nat
      end 0%nat))
Crunching:
(list2D_to_matrix [[e]; [e0]; [e1]; [e2]] =
 cnot
 × (fun x y : nat =>
    ∣ l2' ⟩ (fst (Nat.divmod x 1 0 1)) (fst (Nat.divmod y 0 0 0)) *
    ∣ l ⟩
      match snd (Nat.divmod x 1 0 1) with
      | 0%nat => 1%nat
      | S _ => 0%nat
      end 0%nat))
find_witness Control.TimeoutCrunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
Crunching: False
rewrite if_dtt
if (pA a)
then (fun E : pA a = true => p (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: False
Crunching: False
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
Crunching:
((forall (x : R) (n : nat), cos_approx x n = cos_approx (- x) n) ->
 ∣0⟩ H2 y = (- 0)%R)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ q, q' ⟩)
Crunching: False
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Finished transaction in 9.617 secs (9.5u,0.11s) (successful)
Crunching: False
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ x, y ⟩)
find_witness Control.TimeoutCrunching: False
Crunching: False
Crunching:
(cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat))
Crunching:
((fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat) =
 cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat))
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
Crunching:
(cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat))
Crunching: False
Crunching: (∣0⟩⟨0∣ n H = 0)
Crunching: (∣0⟩⟨0∣ Na H4 = 0)
Crunching: (∣0⟩⟨0∣ Na H4 = 0)
     = [11; 10; 9; 8; 7; 6; 5; 4; 3; 2; 1; 0]
     : list Z
Finished transaction in 0.002 secs (0.002u,0.s) (successful)
     = [{| Naive.unsigned := 11; Naive._unsigned_in_range := eq_refl |};
        {| Naive.unsigned := 10; Naive._unsigned_in_range := eq_refl |};
        {| Naive.unsigned := 9; Naive._unsigned_in_range := eq_refl |};
        {| Naive.unsigned := 8; Naive._unsigned_in_range := eq_refl |};
        {| Naive.unsigned := 7; Naive._unsigned_in_range := eq_refl |};
        {| Naive.unsigned := 6; Naive._unsigned_in_range := eq_refl |};
        {| Naive.unsigned := 5; Naive._unsigned_in_range := eq_refl |};
        {| Naive.unsigned := 4; Naive._unsigned_in_range := eq_refl |};
        {| Naive.unsigned := 3; Naive._unsigned_in_range := eq_refl |};
        {| Naive.unsigned := 2; Naive._unsigned_in_range := eq_refl |};
        {| Naive.unsigned := 1; Naive._unsigned_in_range := eq_refl |};
        {| Naive.unsigned := 0; Naive._unsigned_in_range := eq_refl |}]
     : list word
Finished transaction in 0.007 secs (0.007u,0.s) (successful)
     = ("sizedlist_memcpy",
        (["len"; "a1"; "a2"], [], bedrock_func_body:(
           $"_gs_from0" = $0;
           $"_gs_to0" = $"len";
           while $"_gs_from0" < $"_gs_to0" {
             {$"v" = load($"a1" + $8 * $"_gs_from0");
              store($"a2" + $8 * $"_gs_from0", $"v");
              $(cmd.unset "v")};
             $"_gs_from0" = $"_gs_from0" + $1
           })))
     : bedrock_func
     = ("unsizedlist_memcpy",
        (["len"; "a1"; "a2"], [], bedrock_func_body:(
           $"_gs_from0" = $0;
           $"_gs_to0" = $"len";
           while $"_gs_from0" < $"_gs_to0" {
             {$"v" = load($"a1" + $8 * $"_gs_from0");
              store($"a2" + $8 * $"_gs_from0", $"v");
              $(cmd.unset "v")};
             $"_gs_from0" = $"_gs_from0" + $1
           })))
     : bedrock_func
     = ("vect_memcpy_s",
        (["len"; "a1"; "a2"], [], bedrock_func_body:(
           $"_gs_from0" = $0;
           $"_gs_to0" = $"len";
           while $"_gs_from0" .< $"_gs_to0" {
             {$"v" = load($"a1" + $8 * $"_gs_from0");
              store($"a2" + $8 * $"_gs_from0", $"v");
              $(cmd.unset "v")};
             $"_gs_from0" = $"_gs_from0" + $1
           })))
     : bedrock_func
Crunching: (∣0⟩⟨0∣ Na H4 = 0)
Crunching: False
Crunching: (∣0⟩⟨0∣ Na H4 = 0)
Crunching: (∣0⟩⟨0∣ Na H4 = 0)
Crunching: (∣0⟩⟨0∣ Na H4 = 0)
Crunching: (WF_Unitary (pad_swap dim m n))
Crunching: (WF_Matrix ∣0⟩⟨0∣)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ a, n ⟩)
Crunching: False
Crunching: False
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: False
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ a, n ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ a, n ⟩)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching:
((if Rlt_le_dec r l' then 0%nat else S (sample l (r - l'))) = S (length l))
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: (cnot × ∣ 0, n ⟩ = ∣ 0, (0 + n) mod 1 ⟩)
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: (list2D_to_matrix [[e]] = cnot × (∣0⟩ ⊗ ∣ n ⟩))
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: (cnot × ∣ 0, n ⟩ = ∣ 0, (0 + n) mod 1 ⟩)
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: (list2D_to_matrix [[e]] = cnot × ∣ 0, n ⟩)
Crunching: False
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ a, b ⟩)
Crunching: False
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: False
Crunching: False
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ n, m ⟩)
Crunching: False
Crunching:
(list2D_to_matrix [[e]; [e0]; [e1]; [e2]] =
 cnot
 × (fun x y : nat =>
    ∣ l2' ⟩ (fst (Nat.divmod x 1 0 1)) (fst (Nat.divmod y 0 0 0)) *
    ∣ l ⟩
      match snd (Nat.divmod x 1 0 1) with
      | 0%nat => 1%nat
      | S _ => 0%nat
      end 0%nat))
Crunching:
(list2D_to_matrix [[e]; [e0]; [e1]; [e2]] =
 cnot
 × (fun x y : nat =>
    ∣ l2' ⟩ (fst (Nat.divmod x 1 0 1)) (fst (Nat.divmod y 0 0 0)) *
    ∣ l ⟩
      match snd (Nat.divmod x 1 0 1) with
      | 0%nat => 1%nat
      | S _ => 0%nat
      end 0%nat))
Crunching: (cnot × ∣ l2', l ⟩ = ∣ l2', (l2' + l) mod 2 ⟩)
Crunching:
((if Rlt_le_dec r l' then 0%nat else S (sample l (r - l'))) = S (length l))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Finished transaction in 46.857 secs (6.307u,0.223s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
find_witness Control.TimeoutFinished transaction in 0.811 secs (0.799u,0.005s) (successful)
Crunching: (WF_Unitary (pad_swap dim m n))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: ((b < 0)%nat -> WF_Unitary (pad_swap 0 a b))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 22.801 secs (22.458u,0.163s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (WF_Unitary (pad_swap H4 n m))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeout     = ("decr",
        (["p"], [], bedrock_func_body:(
           $"ttl" = load($"p" + $8 * $1);
           $"ttl" = $"ttl" + $18446744073709551615;
           store($"p" + $8 * $1, $"ttl"))))
     : bedrock_func
     = ("mask_bytes",
        (["bs"; "len"; "mask"], [], bedrock_func_body:(
           $"_gs_from0" = $0;
           $"_gs_to0" = $"len";
           while $"_gs_from0" < $"_gs_to0" {
             {$"_gs_tmp0" = load1($"bs" + $1 * $"_gs_from0");
              $"_gs_tmp0" = $"mask" & $"_gs_tmp0";
              store1($"bs" + $1 * $"_gs_from0", $"_gs_tmp0");
              $(cmd.unset "_gs_tmp0")};
             $"_gs_from0" = $"_gs_from0" + $1
           })))
     : bedrock_func
     = ("xor_bytes",
        (["bs"; "len"], ["r"], bedrock_func_body:(
           $"r" = $0;
           $"_gs_from0" = $0;
           $"_gs_to0" = $"len";
           while $"_gs_from0" < $"_gs_to0" {
             {$"_gs_tmp0" = load1($"bs" + $1 * $"_gs_from0");
              $"r" = $"r" ^ $"_gs_tmp0";
              $(cmd.unset "_gs_tmp0")};
             $"_gs_from0" = $"_gs_from0" + $1
           })))
     : bedrock_func
     = ("incr_words",
        (["ws"; "len"], [], bedrock_func_body:(
           $"_gs_from0" = $0;
           $"_gs_to0" = $"len";
           while $"_gs_from0" < $"_gs_to0" {
             {$"_gs_tmp0" = load($"ws" + $8 * $"_gs_from0");
              $"_gs_tmp0" = $1 + $"_gs_tmp0";
              store($"ws" + $8 * $"_gs_from0", $"_gs_tmp0");
              $(cmd.unset "_gs_tmp0")};
             $"_gs_from0" = $"_gs_from0" + $1
           })))
     : bedrock_func
     = ("sum_words",
        (["ws"; "len"], ["r"], bedrock_func_body:(
           $"r" = $0;
           $"_gs_from0" = $0;
           $"_gs_to0" = $"len";
           while $"_gs_from0" < $"_gs_to0" {
             {$"_gs_tmp0" = load($"ws" + $8 * $"_gs_from0");
              $"r" = $"r" + $"_gs_tmp0";
              $(cmd.unset "_gs_tmp0")};
             $"_gs_from0" = $"_gs_from0" + $1
           })))
     : bedrock_func
     = ("count_ws",
        (["data"; "len"; "needle"], ["r"], bedrock_func_body:(
           $"r" = $0;
           $"_gs_from0" = $0;
           $"_gs_to0" = $(expr.op bopname.divu "len" 8);
           while $"_gs_from0" < $"_gs_to0" {
             {$"_gs_tmp0" = load($"data" + $8 * $"_gs_from0");
              $"hit" = $"_gs_tmp0" == $"needle";
              $"r" = $"r" + $"hit";
              /*skip*/;
              $(cmd.unset "_gs_tmp0");
              $(cmd.unset "hit")};
             $"_gs_from0" = $"_gs_from0" + $1
           })))
     : bedrock_func
Crunching: Type
find_witness Control.TimeoutCrunching: (perm_to_matrix 0 p = I 1)
find_witness Control.TimeoutCrunching:
((fun x z : nat =>
  Σ
    (fun y : nat =>
     (perm_to_matrix 0 l x y * (if (y =? z) && (y <? 1) then C1 else 0%R))%C)
    1) = (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching: ((-1) ^ (2 * n + 1) = -1)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (sample (H5 ++ m) p1 = sample H5 p1)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutsimplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
simplified dependent [if false]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f : nat -> bool,
 permutation 0 l ->
 perm_to_matrix 0 l × f_to_vec 0 f = f_to_vec 0 (fun x : nat => f (l x)))
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: (permutation 0 len -> perm_to_matrix 0 len × I 1 = I 1)
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching: (WF_Unitary (pad_swap H4 n m))
Crunching:
(forall r : R,
 0 <= r ->
 r < sum_over_list (a :: l1) ->
 sample ((a :: l1) ++ []) r = sample (a :: l1) r)
find_witness Control.TimeoutCrunching: (permutation 0 len -> perm_to_matrix 0 len × I 1 = I 1)
Crunching: (sample ((a :: l1) ++ []) l = sample (a :: l1) l)
find_witness Control.TimeoutCrunching: (permutation 0 len -> perm_to_matrix 0 len × I 1 = I 1)
find_witness Control.TimeoutCrunching: (pad_u dim m A × pad_u dim 0 B = pad_u dim 0 B × pad_u dim m A)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.008 secs (0.007u,0.s) (failure)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × (∣0⟩ ⊗ ∣0⟩))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
out of reach
Tactic call ran for 0.008 secs (0.007u,0.001s) (failure)
find_witness Control.TimeoutCrunching: (pad_u dim m A × pad_u dim 0 B = pad_u dim 0 B × pad_u dim m A)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.006u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutclear  H1  :  (False -> Hocc = false)
find_witness Control.Timeoutfind_witness Control.Timeoutclear  H1  :  (False -> b1 = false)
find_witness Control.Timeoutfind_witness Control.Timeoutclear  H1  :  (False -> Hocc = false)
clear  H1  :  (False -> Hocc = false)
out of reach
Tactic call ran for 0.013 secs (0.008u,0.005s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutclear  H1  :  (False -> b1 = false)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutclear  H1  :  (False -> Hocc = false)
clear  H1  :  (False -> Hocc = false)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutclear  H1  :  (False -> b1 = false)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.014 secs (0.01u,0.002s) (failure)
find_witness Control.TimeoutCrunching:
(forall y : nat, l' >= 2 ^ a \/ y >= 2 ^ a -> perm_to_matrix a n l' y = 0%R)
Crunching: (bool_to_ket LE m H4 = (R0, R0))
find_witness Control.TimeoutCrunching: (perm_to_matrix i H5 H' M = 0%R)
find_witness Control.TimeoutCrunching: (bool_to_ket LE m H4 = (R0, R0))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
Crunching: (perm_to_matrix i H5 H' M = 0%R)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.009 secs (0.009u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(forall y : nat, l' >= 2 ^ a \/ y >= 2 ^ a -> perm_to_matrix a n l' y = 0%R)
Crunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
find_witness Control.TimeoutCrunching:
(forall y : nat, l' >= 2 ^ a \/ y >= 2 ^ a -> perm_to_matrix a n l' y = 0%R)
find_witness Control.TimeoutCrunching:
(forall y : nat, l' >= 2 ^ a \/ y >= 2 ^ a -> perm_to_matrix a n l' y = 0%R)
Crunching: (forall r : R, r <= 0 -> 0 <= r -> r = 0)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (perm_to_matrix i H5 H' M = 0%R)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(H > 0 ->
 exists N : nat, forall n : nat, (n >= N)%nat -> R_dist (PI_2_3_7_tg n) 0 < H)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(pad_u H11 0 a' × pad_u H11 a Ha = pad_u H11 a Ha × pad_u H11 0 a')
Crunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
find_witness Control.TimeoutCrunching: (continuity_pt id HH1)
Crunching: (0 < 2)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.016 secs (0.011u,0.004s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: (cnot × ∣ 0, 1 ⟩ = ∣ 0, 1 ⟩)
Crunching:
(pad_u H11 0 a' × pad_u H11 a Ha = pad_u H11 a Ha × pad_u H11 0 a')
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: (perm_to_matrix i H5 H' M = 0%R)
Crunching:
(pad_u H11 Hn Hq × pad_u H11 Hp a = pad_u H11 Hp a × pad_u H11 Hn Hq)
Crunching:
(pad_u H11 Hn Hq × pad_u H11 Hp a = pad_u H11 Hp a × pad_u H11 Hn Hq)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: (M * H4 < M)
Crunching: (perm_to_matrix i H5 H' M = 0%R)
find_witness Control.TimeoutCrunching: (M * H4 < M)
Crunching: (M * H4 < M)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.009 secs (0.009u,0.s) (failure)
Crunching: (0 < 2)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall (l2 : list R) (r : R),
 Forall (fun x : R => 0 <= x) [] ->
 Forall (fun x : R => 0 <= x) l2 -> 0 <= r -> sample l2 r = sample l2 (r - 0))
Crunching:
(forall y0 : nat,
 eq_dep_eq >= 2 ^ x \/ y0 >= 2 ^ x -> perm_to_matrix x y eq_dep_eq y0 = 0%R)
Crunching:
((fun n : nat =>
  forall y0 : nat,
  eq_dep_eq >= S (S n) ^ x \/ y0 >= S (S n) ^ x ->
  perm_to_matrix x y eq_dep_eq y0 = 0%R) 0)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall y : nat, l' >= 2 ^ a \/ y >= 2 ^ a -> perm_to_matrix a n l' y = 0%R)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutrewrite if_dtt
if (pA (proj1_sig sa))
then
(fun E : pA (proj1_sig sa) = true =>
 eq (F (exist (fun a0 : A => pA a0 = true) (proj1_sig sa) E)))
else (fun _ : pA (proj1_sig sa) = false => eq false)
Crunching:
((nat -> nat) ->
 forall y : nat, l' >= 2 ^ a \/ y >= 2 ^ a -> perm_to_matrix a n l' y = 0%R)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: nat
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(forall y : nat, l' >= 2 ^ a \/ y >= 2 ^ a -> perm_to_matrix a n l' y = 0%R)
Crunching:
(forall y : nat, l' >= 2 ^ a \/ y >= 2 ^ a -> perm_to_matrix a n l' y = 0%R)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(forall y : nat, l' >= 2 ^ a \/ y >= 2 ^ a -> perm_to_matrix a n l' y = 0%R)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.008 secs (0.007u,0.s) (failure)
find_witness Control.TimeoutCrunching: (pad_u x m A' × pad_u x n B' = pad_u x n B' × pad_u x m A')
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(forall y : nat, l' >= 2 ^ a \/ y >= 2 ^ a -> perm_to_matrix a n l' y = 0%R)
Crunching:
(forall y : nat, l' >= 2 ^ a \/ y >= 2 ^ a -> perm_to_matrix a n l' y = 0%R)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (continuity_pt sqrt 1 -> WF_Matrix ∣ H' ⟩)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutFinished transaction in 42.106 secs (1.649u,0.156s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (pad_u dim m A × pad_u dim 0 B = pad_u dim 0 B × pad_u dim m A)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
simplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => F (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
Crunching: (perm_to_matrix i H5 H2 EQ = 0%R)
Crunching: (perm_to_matrix i H5 H2 EQ = 0%R)
find_witness Control.TimeoutFinished transaction in 1.526 secs (1.517u,0.007s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching:
((if m + 1 <=? dim then I (2 ^ m) ⊗ A ⊗ I (2 ^ (dim - (m + 1))) else Zero)
 × pad_ctrl dim n o B =
 pad_ctrl dim n o B
 × (if m + 1 <=? dim then I (2 ^ m) ⊗ A ⊗ I (2 ^ (dim - (m + 1))) else Zero))
Crunching: (perm_to_matrix i H5 H' M = 0%R)
find_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 4.143 secs (4.135u,0.003s) (successful)
Crunching:
((if
   if
    if
     (fix eqb (n m : nat) {struct n} : bool :=
        match n with
        | 0 => match m with
               | 0 => true
               | S _ => false
               end
        | S n' => match m with
                  | 0 => false
                  | S m' => eqb n' m'
                  end
        end) H'
       ((fix binlist_to_nat (l : list bool) : nat :=
           match l with
           | [] => 0
           | b :: l' =>
               (fix add (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => m
                  | S p => S (add p m)
                  end) (if b then 1 else 0)
                 ((fix add (n m : nat) {struct n} : nat :=
                     match n with
                     | 0 => m
                     | S p => S (add p m)
                     end) (binlist_to_nat l')
                    ((fix add (n m : nat) {struct n} : nat :=
                        match n with
                        | 0 => m
                        | S p => S (add p m)
                        end) (binlist_to_nat l') 0))
           end)
          ((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
                list bool :=
              match len with
              | 0 => []
              | S len' => f len' :: funbool_to_list len' f
              end) i
             (fun x : nat =>
              (fix list_to_funbool (len : nat) (l : list bool) {struct l} :
                   nat -> bool :=
                 match l with
                 | [] => fun _ : nat => false
                 | h :: t =>
                     fun j : nat =>
                     if
                      (fix eqb (n m : nat) {struct n} : bool :=
                         match n with
                         | 0 => match m with
                                | 0 => true
                                | S _ => false
                                end
                         | S n' =>
                             match m with
                             | 0 => false
                             | S m' => eqb n' m'
                             end
                         end) j
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0 => n
                            | S k =>
                                match m with
                                | 0 => n
                                | S l0 => sub k l0
                                end
                            end) len 1)
                     then h
                     else
                      list_to_funbool
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0 => n
                            | S k =>
                                match m with
                                | 0 => n
                                | S l0 => sub k l0
                                end
                            end) len 1) t j
                 end) i
                ((fix app (l m : list bool) {struct l} : list bool :=
                    match l with
                    | [] => m
                    | a :: l1 => a :: app l1 m
                    end)
                   ((fix nat_to_binlist' (n : nat) : list bool :=
                       match n with
                       | 0 => []
                       | S n' =>
                           (fix incr_bin (l : list bool) : list bool :=
                              match l with
                              | [] => [true]
                              | true :: t => false :: incr_bin t
                              | false :: t => true :: t
                              end) (nat_to_binlist' n')
                       end) A)
                   ((fix repeat (x0 : bool) (n : nat) {struct n} :
                         list bool :=
                       match n with
                       | 0 => []
                       | S k => x0 :: repeat x0 k
                       end) false
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0 => n
                          | S k => match m with
                                   | 0 => n
                                   | S l => sub k l
                                   end
                          end) i
                         ((fix length (l : list bool) : nat :=
                             match l with
                             | [] => 0
                             | _ :: l' => S (length l')
                             end)
                            ((fix nat_to_binlist' (n : nat) : list bool :=
                                match n with
                                | 0 => []
                                | S n' =>
                                    (fix incr_bin 
                                     (l : list bool) : 
                                     list bool :=
                                       match l with
                                       | [] => [true]
                                       | true :: t => false :: incr_bin t
                                       | false :: t => true :: t
                                       end) (nat_to_binlist' n')
                                end) A))))) (H5 x))))
    then
     match
       (fix pow (n m : nat) {struct m} : nat :=
          match m with
          | 0 => 1
          | S m0 =>
              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                 match n0 with
                 | 0 => 0
                 | S p =>
                     (fix add (n1 m2 : nat) {struct n1} : nat :=
                        match n1 with
                        | 0 => m2
                        | S p0 => S (add p0 m2)
                        end) m1 (mul p m1)
                 end) n (pow n m0)
          end) 2 i
     with
     | 0 => false
     | S m' =>
         (fix leb (n m : nat) {struct n} : bool :=
            match n with
            | 0 => true
            | S n' => match m with
                      | 0 => false
                      | S m'0 => leb n' m'0
                      end
            end) H' m'
     end
    else false
   then
    match
      (fix pow (n m : nat) {struct m} : nat :=
         match m with
         | 0 => 1
         | S m0 =>
             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                match n0 with
                | 0 => 0
                | S p =>
                    (fix add (n1 m2 : nat) {struct n1} : nat :=
                       match n1 with
                       | 0 => m2
                       | S p0 => S (add p0 m2)
                       end) m1 (mul p m1)
                end) n (pow n m0)
         end) 2 i
    with
    | 0 => false
    | S m' =>
        (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
           end) A m'
    end
   else false
  then (R1, R0)
  else (R0, R0)) = (R0, R0))
rewrite if_dtt
if (pA a1)
then (fun E : pA a1 = true => F (exist (fun a0 : A => pA a0 = true) a1 E))
else (fun _ : pA a1 = false => false)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutFinished transaction in 1.564 secs (1.558u,0.003s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (0 < 2)
Crunching:
(q <> f ->
 WF_Matrix x ->
 WF_Matrix H ->
 pad_u n q x × pad_ctrl n H1 f H = pad_ctrl n H1 f H × pad_u n q x)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (0 < eps / 5 * 1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutsimplified dependent [if true] in H0
Ha' : (pA a')  = true
if (pA a')
then (fun E : pA a' = true => F (exist (fun a0 : A => pA a0 = true) a' E))
else (fun _ : pA a' = false => false)
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
Crunching:
((qubit_perm_to_nat_perm H l ∘ qubit_perm_to_nat_perm H a)%prg =
 qubit_perm_to_nat_perm H (a ∘ l)%prg)
out of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
find_witness Control.TimeoutFinished transaction in 2.981 secs (2.966u,0.013s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
out of reach
Tactic call ran for 0.009 secs (0.008u,0.s) (failure)
Crunching:
(permutation x m ->
 (qubit_perm_to_nat_perm x m ∘ qubit_perm_to_nat_perm x Hn)%prg =
 qubit_perm_to_nat_perm x (Hn ∘ m)%prg)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (exp_in 0 1 -> 0%nat <> 2%nat -> cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.009 secs (0.009u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (exp_in 0 1 -> 0%nat <> 2%nat -> cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
find_witness Control.TimeoutCrunching:
((qubit_perm_to_nat_perm H l ∘ qubit_perm_to_nat_perm H a)%prg =
 qubit_perm_to_nat_perm H (a ∘ l)%prg)
find_witness Control.TimeoutFinished transaction in 130.901 secs (125.721u,3.769s) (successful)
Finished transaction in 45.045 secs (4.575u,0.166s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.TimeoutFinished transaction in 0.489 secs (0.456u,0.023s) (successful)
find_witness Control.TimeoutCrunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
find_witness Control.Timeoutrewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
Crunching: (cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
Crunching: (Hf <= sample (repeat 0%R Hf ++ l) r)%nat
Crunching:
((qubit_perm_to_nat_perm H l ∘ qubit_perm_to_nat_perm H a)%prg =
 qubit_perm_to_nat_perm H (a ∘ l)%prg)
Crunching:
((qubit_perm_to_nat_perm H l ∘ qubit_perm_to_nat_perm H a)%prg =
 qubit_perm_to_nat_perm H (a ∘ l)%prg)
out of reach
Tactic call ran for 0.009 secs (0.008u,0.s) (failure)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
find_witness Control.TimeoutCrunching: (exp_in 0 1 -> 0%nat <> 2%nat -> cnot × ∣ 1, 0 ⟩ = ∣ 1, 1 ⟩)
find_witness Control.TimeoutCrunching: (continuity_pt sqrt 1 -> WF_Matrix ∣ H' ⟩)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutrewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
find_witness Control.Timeoutrewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (0%nat <> 2%nat -> cnot × (∣1⟩ ⊗ ∣0⟩) = ∣1⟩ ⊗ ∣1⟩)
Crunching:
(permutation x m ->
 (qubit_perm_to_nat_perm x m ∘ qubit_perm_to_nat_perm x Hn)%prg =
 qubit_perm_to_nat_perm x (Hn ∘ m)%prg)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
Crunching: (bools_to_matrix n n0 H2 = 0)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
find_witness Control.Timeoutrewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
out of reach
Tactic call ran for 0.02 secs (0.007u,0.012s) (failure)
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
Finished transaction in 4.246 secs (4.225u,0.017s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
find_witness Control.Timeoutfind_witness Control.Timeoutrewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching: (Hf <= sample (repeat 0%R Hf ++ l) r)%nat
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
Crunching: (cnot × ∣ 1, 1 ⟩ = ∣ 1, 0 ⟩)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutrewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
Finished transaction in 4.245 secs (4.232u,0.008s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (bools_to_matrix n n0 H2 = 0)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall (m n o : nat) (A B : Square 2),
 m <> n ->
 m <> o ->
 WF_Matrix A ->
 WF_Matrix B ->
 pad_u HN m A × pad_ctrl HN n o B = pad_ctrl HN n o B × pad_u HN m A)
find_witness Control.TimeoutCrunching:
((forall a b : R, Rabs b <= Rabs a -> Rabs (Rabs a - Rabs b) <= Rabs (a - b)) ->
 swap × ∣ 0, 0 ⟩ = ∣ 0, 0 ⟩)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 4.31 secs (4.285u,0.021s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
Crunching:
(H2 <> b ->
 WF_Matrix n ->
 WF_Matrix Ha ->
 pad_u l1N H2 n × pad_ctrl l1N a b Ha = pad_ctrl l1N a b Ha × pad_u l1N H2 n)
find_witness Control.TimeoutCrunching:
((qubit_perm_to_nat_perm H l ∘ qubit_perm_to_nat_perm H a)%prg =
 qubit_perm_to_nat_perm H (a ∘ l)%prg)
Crunching:
((if m + 1 <=? dim then I (2 ^ m) ⊗ A ⊗ I (2 ^ (dim - (m + 1))) else Zero)
 × pad_ctrl dim n o B =
 pad_ctrl dim n o B
 × (if m + 1 <=? dim then I (2 ^ m) ⊗ A ⊗ I (2 ^ (dim - (m + 1))) else Zero))
Crunching:
((qubit_perm_to_nat_perm H l ∘ qubit_perm_to_nat_perm H a)%prg =
 qubit_perm_to_nat_perm H (a ∘ l)%prg)
find_witness Control.TimeoutCrunching:
(pad_u dim 0 A × pad_ctrl dim 0 o B = pad_ctrl dim 0 o B × pad_u dim 0 A)
Crunching: (Hb <= sample (repeat 0%R Hb ++ l) H6)%nat
Crunching: (Hb <= sample (repeat 0%R Hb ++ l) H6)%nat
find_witness Control.TimeoutCrunching: (x = 0 -> x + - z <= y)
find_witness Control.Timeoutrewrite match_option_dtt
match (List.nth_error (proj1_sig l) (proj1_sig contra)) with
| None =>
(fun E : List.nth_error (proj1_sig l) (proj1_sig contra) = None =>
 match slist_nth_lemma1 l contra E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error (proj1_sig l) (proj1_sig contra) = Some a)
 => a)
Crunching: (x = 0 -> x + - z <= y)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (bools_to_matrix M_nat H4 y = 0)
find_witness Control.TimeoutFinished transaction in 5.585 secs (5.529u,0.048s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.001s) (failure)
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutrewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((qubit_perm_to_nat_perm H l ∘ qubit_perm_to_nat_perm H a)%prg =
 qubit_perm_to_nat_perm H (a ∘ l)%prg)
Crunching:
((qubit_perm_to_nat_perm H l ∘ qubit_perm_to_nat_perm H a)%prg =
 qubit_perm_to_nat_perm H (a ∘ l)%prg)
Crunching: (bools_to_matrix abs He a = 0)
find_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.TimeoutCrunching:
((Hx0 > 0)%R ->
 exists alp : R,
   (alp > 0)%R /\
   (forall x : Base R_met,
    D_x no_cond x0 x /\ (dist R_met x x0 < alp)%R ->
    (dist R_met (id x) (id x0) < Hx0)%R))
rewrite match_option_dtt
match (List.nth_error (proj1_sig l) (proj1_sig contra)) with
| None =>
(fun E : List.nth_error (proj1_sig l) (proj1_sig contra) = None =>
 match slist_nth_lemma1 l contra E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error (proj1_sig l) (proj1_sig contra) = Some a)
 => a)
rewrite match_option_dtt
match (List.nth_error (proj1_sig l) (proj1_sig contra)) with
| None =>
(fun E : List.nth_error (proj1_sig l) (proj1_sig contra) = None =>
 match slist_nth_lemma1 l contra E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error (proj1_sig l) (proj1_sig contra) = Some a)
 => a)
find_witness Control.TimeoutCrunching:
((Hx0 > 0)%R ->
 exists alp : R,
   (alp > 0)%R /\
   (forall x : Base R_met,
    D_x no_cond x0 x /\ (dist R_met x x0 < alp)%R ->
    (dist R_met (id x) (id x0) < Hx0)%R))
Finished transaction in 5.408 secs (5.379u,0.022s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.TimeoutCrunching: (bools_to_matrix n n0 H2 = 0)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error nil (proj1_sig x)) with
| None =>
(fun E : List.nth_error nil (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a : A) (_ : List.nth_error nil (proj1_sig x) = Some a) => a)
find_witness Control.TimeoutCrunching: (H4 <= sample (repeat 0%R H4 ++ a) b)%nat
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutFinished transaction in 2.921 secs (2.913u,0.003s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(0 < / 2 ->
 √ (x0 + p0) <=
 √ x0 +
 match Rcase_abs p0 with
 | in_left => 0
 | right a => Rsqrt {| nonneg := p0; cond_nonneg := Rge_le p0 0 a |}
 end)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(0 < / 2 ->
 √ (x0 + p0) <=
 √ x0 +
 match Rcase_abs p0 with
 | in_left => 0
 | right a => Rsqrt {| nonneg := p0; cond_nonneg := Rge_le p0 0 a |}
 end)
Crunching: (bools_to_matrix n n0 H2 = 0)
Crunching:
(0 < / 2 ->
 √ (x0 + p0) <=
 √ x0 +
 match Rcase_abs p0 with
 | in_left => 0
 | right a => Rsqrt {| nonneg := p0; cond_nonneg := Rge_le p0 0 a |}
 end)
Building all_base...
Building all_idents...
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding ident_index...
Building eta_ident_cps_gen...
out of reach
Tactic call ran for 0.011 secs (0.007u,0.004s) (failure)
Building eta_ident_cps_gen_expand_literal...
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutBuilding eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
find_witness Control.TimeoutTactic call ran for 0.008 secs (0.008u,0.s) (success)
Building raw_ident_index...
Crunching:
(forall x y : nat,
 swap
 × (fun x0 y0 : nat =>
    ∣ x ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ y ⟩ (x0 mod 2)%nat (y0 mod 1)%nat) =
 (fun x0 y0 : nat =>
  ∣ y ⟩ (x0 / 2)%nat (y0 / 1)%nat * ∣ x ⟩ (x0 mod 2)%nat (y0 mod 1)%nat))
Crunching:
(swap
 × (fun x y : nat =>
    ∣ eps ⟩ (x / 2)%nat (y / 1)%nat * ∣ l' ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ l' ⟩ (x / 2)%nat (y / 1)%nat * ∣ eps ⟩ (x mod 2)%nat (y mod 1)%nat))
find_witness Control.TimeoutBuilding raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
find_witness Control.TimeoutBuilding raw_ident_to_ident...
Building raw_ident_infos_of...
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall g : nat -> nat,
 permutation 0 Hlen' ->
 permutation 0 g ->
 perm_to_matrix 0 Hlen' × perm_to_matrix 0 g =
 perm_to_matrix 0 (g ∘ Hlen')%prg)
find_witness Control.TimeoutBuilding split_raw_ident_gen...
Crunching:
(permutation a a' ->
 perm_to_matrix a b × perm_to_matrix a a' = perm_to_matrix a (a' ∘ b)%prg)
Crunching:
(permutation a a' ->
 perm_to_matrix a b × perm_to_matrix a a' = perm_to_matrix a (a' ∘ b)%prg)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]] = perm_to_matrix 0 Hlen' × perm_to_matrix 0 g)
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 g 0 0]] =
 perm_to_matrix 0 (g ∘ Hlen')%prg)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]] = perm_to_matrix 0 Hlen' × perm_to_matrix 0 cond)
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 cond 0 0]] =
 perm_to_matrix 0 (cond ∘ Hlen')%prg)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Building invert_bind_args...
(signed (Z.to_nat (Z.log2 (bitwidth_of (signed m)))) = signed m)
Crunching:
((forall a b : R, Rabs b <= Rabs a -> Rabs (Rabs a - Rabs b) <= Rabs (a - b)) ->
 swap × ∣ 0, 0 ⟩ = ∣ 0, 0 ⟩)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.001s) (failure)
Crunching:
(permutation l H9 ->
 permutation l X ->
 perm_to_matrix l H9 × perm_to_matrix l X = perm_to_matrix l (X ∘ H9)%prg)
Crunching:
((fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ P)%prg) && (x <? 2 ^ n0) &&
   (y <? 2 ^ n0)
  then C1
  else 0%R)
 × (fun x y : nat =>
    if
     (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ n)%prg) && (x <? 2 ^ n0) &&
     (y <? 2 ^ n0)
    then C1
    else 0%R) =
 (fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ (n ∘ P))%prg) &&
   (x <? 2 ^ n0) && (y <? 2 ^ n0)
  then C1
  else 0%R))
Crunching:
((fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ P)%prg) && (x <? 2 ^ n0) &&
   (y <? 2 ^ n0)
  then C1
  else 0%R)
 × (fun x y : nat =>
    if
     (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ n)%prg) && (x <? 2 ^ n0) &&
     (y <? 2 ^ n0)
    then C1
    else 0%R) =
 (fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ (n ∘ P))%prg) &&
   (x <? 2 ^ n0) && (y <? 2 ^ n0)
  then C1
  else 0%R))
find_witness Control.TimeoutCrunching:
((fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ P)%prg) && (x <? 2 ^ n0) &&
   (y <? 2 ^ n0)
  then C1
  else 0%R)
 × (fun x y : nat =>
    if
     (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ n)%prg) && (x <? 2 ^ n0) &&
     (y <? 2 ^ n0)
    then C1
    else 0%R) =
 (fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ (n ∘ P))%prg) &&
   (x <? 2 ^ n0) && (y <? 2 ^ n0)
  then C1
  else 0%R))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(permutation a a' ->
 perm_to_matrix a b × perm_to_matrix a a' = perm_to_matrix a (a' ∘ b)%prg)
Crunching:
(permutation a a' ->
 perm_to_matrix a b × perm_to_matrix a a' = perm_to_matrix a (a' ∘ b)%prg)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(perm_to_matrix H f × perm_to_matrix H g = perm_to_matrix H (g ∘ f)%prg)
find_witness Control.TimeoutCrunching:
((forall a b : R, Rabs b <= Rabs a -> Rabs (Rabs a - Rabs b) <= Rabs (a - b)) ->
 swap × ∣ 0, 0 ⟩ = ∣ 0, 0 ⟩)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.001s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.003u,0.002s) (failure)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.143 secs (0.139u,0.003s) (success)
Finished transaction in 0.461 secs (0.453u,0.007s) (successful)
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (WF_Matrix ∣-⟩)
Building eta_pattern_ident_cps_gen_expand_literal...
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Building split_types...
find_witness Control.TimeoutCrunching: (cos 1 = (1 - 1 / 2 + 1 / 24)%R)
(reflect_rel eq interp_beq)
Crunching: (cos 1 <= 1 - 1 / 2 + 1 / 24)
Crunching: (cos 1 <= 1 - 1 / 2 + 1 / 24)
(signed (Z.to_nat (Z.log2 (bitwidth_of (signed m)))) = signed m)
Building add_types_from_raw_sig...
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeout(reflect_rel eq interp_beq)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
((big_sum
    (fun i : nat =>
     if n i then match i with
                 | 0%nat => m
                 | S m => nth m q 0
                 end else 0) (length q) +
  (if n (length q)
   then match length q with
        | 0%nat => m
        | S m => nth m q 0
        end
   else 0))%R =
 (if n 0%nat
  then (m + pr_outcome_sum q (fun y : nat => n (S y)))%R
  else pr_outcome_sum q (fun y : nat => n (S y))))
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching:
(list2D_to_matrix [[e]] = perm_to_matrix 0 Hlen' × perm_to_matrix 0 g)
Building to_type_split_types_subst_default_eq...
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 g 0 0]] =
 perm_to_matrix 0 (g ∘ Hlen')%prg)
Crunching: (∣L⟩ x y = (R0, R0))
(reflect_rel eq interp_beq)
Crunching: (3 = 0)
(invert_Z_cast2 e = Some r ->
 existT expr t e =
 existT expr (type.base (tZ * tZ) -> type.base (tZ * tZ))%etype
   (#Compilers.ident_Z_cast2 @ GallinaReify.base.reify r)%expr)
Building projT1_add_types_from_raw_sig_eq...
Crunching: ((∣ Ha ⟩) † = ⟨ Ha ∣)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(permutation 0 Hlen' ->
 permutation 0 X ->
 perm_to_matrix 0 Hlen' × perm_to_matrix 0 X =
 perm_to_matrix 0 (X ∘ Hlen')%prg)
Crunching:
(permutation 0 Hlen' ->
 permutation 0 X ->
 perm_to_matrix 0 Hlen' × perm_to_matrix 0 X =
 perm_to_matrix 0 (X ∘ Hlen')%prg)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeout(reflect_rel eq interp_beq)
Crunching: (forall y : nat, (X >= 4)%nat \/ (y >= 1)%nat -> ∣Φ+⟩ X y = 0)
(invert_Z_cast2 e = Some r ->
 existT expr t e =
 existT expr (type.base (tZ * tZ) -> type.base (tZ * tZ))%etype
   (#Compilers.ident_Z_cast2 @ GallinaReify.base.reify r)%expr)
find_witness Control.TimeoutBuilding arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Crunching:
(list2D_to_matrix [[e]] = perm_to_matrix 0 Hlen' × perm_to_matrix 0 cond)
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 cond 0 0]] =
 perm_to_matrix 0 (cond ∘ Hlen')%prg)
Building to_typed_unfolded...
Crunching: (R -> False)
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(list2D_to_matrix [[e]] = perm_to_matrix 0 Hlen' × perm_to_matrix 0 cond)
(reflect_rel eq interp_beq)
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 cond 0 0]] =
 perm_to_matrix 0 (cond ∘ Hlen')%prg)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching:
(perm_to_matrix (S p) Hlen' × perm_to_matrix (S p) cond =
 perm_to_matrix (S p) (cond ∘ Hlen')%prg)
(invert_Z_cast2 e = Some r ->
 existT expr t e =
 existT expr (type.base (tZ * tZ) -> type.base (tZ * tZ))%etype
   (#Compilers.ident_Z_cast2 @ GallinaReify.base.reify r)%expr)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (R -> False)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.038 secs (0.037u,0.s) (failure)
find_witness Control.TimeoutBuilding unify...
Crunching: (3 = 0)
Crunching: ((∣ Ha ⟩) † = ⟨ Ha ∣)
find_witness Control.TimeoutCrunching:
(forall x0 : nat -> nat,
 (forall x : nat,
  x < l -> p x < l /\ x0 x < l /\ x0 (p x) = x /\ p (x0 x) = x) ->
 (fun x z : nat =>
  Σ
    (fun y : nat =>
     ((if
        (x =? funbool_to_nat l (nat_to_funbool l y ∘ p)%prg) && (x <? 2 ^ l) &&
        (y <? 2 ^ l)
       then C1
       else 0%R) *
      (if
        (y =? funbool_to_nat l (nat_to_funbool l z ∘ g)%prg) && (y <? 2 ^ l) &&
        (z <? 2 ^ l)
       then C1
       else 0%R))%C) (2 ^ l)) = ?y)
Crunching:
(forall f0 : nat -> bool,
 pr_outcome_sum [f] f0 =
 (if f0 0%nat
  then (f + pr_outcome_sum [] (fun y : nat => f0 (S y)))%R
  else pr_outcome_sum [] (fun y : nat => f0 (S y))))
Crunching: (list2D_to_matrix [[e]] = perm_to_matrix 0 p × perm_to_matrix 0 g)
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 g 0 0]] = perm_to_matrix 0 (g ∘ p)%prg)
find_witness Control.Timeout(reflect_rel eq interp_beq)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.Timeout(invert_Z_cast2 e = Some r ->
 existT expr t e =
 existT expr (type.base (tZ * tZ) -> type.base (tZ * tZ))%etype
   (#Compilers.ident_Z_cast2 @ GallinaReify.base.reify r)%expr)
out of reach
Tactic call ran for 0.042 secs (0.042u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall f : nat -> bool,
 pr_outcome_sum (alp_f2c :: H13) f =
 (if f 0%nat
  then (alp_f2c + pr_outcome_sum H13 (fun y : nat => f (S y)))%R
  else pr_outcome_sum H13 (fun y : nat => f (S y))))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching: ((Maj1 >= 4)%nat \/ (x >= 1)%nat -> ∣Φ+⟩ Maj1 x = 0)
Crunching:
(forall g : nat -> nat,
 permutation 0 p ->
 permutation 0 g ->
 perm_to_matrix 0 p × perm_to_matrix 0 g = perm_to_matrix 0 (g ∘ p)%prg)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]] = perm_to_matrix 0 p × perm_to_matrix 0 n)
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 n 0 0]] = perm_to_matrix 0 (n ∘ p)%prg)
find_witness Control.TimeoutBuilding unify_unknown...
Building final ident package...
Finished transaction in 72.821 secs (31.5u,1.019s) (successful)
find_witness Control.TimeoutFinished transaction in 0. secs (0.u,0.s) (successful)
Crunching: (forall y : nat, (X >= 4)%nat \/ (y >= 1)%nat -> ∣Φ+⟩ X y = 0)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Building index_of_base...
Building base_type_list...
(reflect_rel eq interp_beq)
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(perm_to_matrix l p × perm_to_matrix l q = perm_to_matrix l (q ∘ p)%prg)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Finished transaction in 14.46 secs (14.131u,0.225s) (successful)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(perm_to_matrix l (q ∘ p)%prg = perm_to_matrix l p × perm_to_matrix l q)
Crunching:
(perm_to_matrix l p × perm_to_matrix l q = perm_to_matrix l (q ∘ p)%prg)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching:
(perm_to_matrix l (q ∘ p)%prg = perm_to_matrix l p × perm_to_matrix l q)
Crunching:
(perm_to_matrix l p × perm_to_matrix l q = perm_to_matrix l (q ∘ p)%prg)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
(invert_Z_cast2 e = Some r ->
 existT expr t e =
 existT expr (type.base (tZ * tZ) -> type.base (tZ * tZ))%etype
   (#Compilers.ident_Z_cast2 @ GallinaReify.base.reify r)%expr)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutCrunching:
(pad_ctrl H a x A × pad_ctrl H y p B = pad_ctrl H y p B × pad_ctrl H a x A)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
(signed (Z.to_nat (Z.log2 (bitwidth_of (signed m)))) = signed m)
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
(signed (Z.to_nat (Z.log2 (bitwidth_of (signed m)))) = signed m)
Crunching:
(pad_ctrl H y p B × pad_ctrl H a x A = pad_ctrl H a x A × pad_ctrl H y p B)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(permutation l H9 ->
 permutation l X ->
 perm_to_matrix l H9 × perm_to_matrix l X = perm_to_matrix l (X ∘ H9)%prg)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
(reflect_rel eq interp_beq)
Crunching:
(list2D_to_matrix [[e]] = perm_to_matrix 0 H9 × perm_to_matrix 0 X)
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 X 0 0]] = perm_to_matrix 0 (X ∘ H9)%prg)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(list2D_to_matrix [[e]] = perm_to_matrix 0 H9 × perm_to_matrix 0 X)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 X 0 0]] = perm_to_matrix 0 (X ∘ H9)%prg)
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((big_sum
    (fun i : nat =>
     if n i then match i with
                 | 0%nat => m
                 | S m => nth m q 0
                 end else 0) (length q) +
  (if n (length q)
   then match length q with
        | 0%nat => m
        | S m => nth m q 0
        end
   else 0))%R =
 (if n 0%nat
  then (m + pr_outcome_sum q (fun y : nat => n (S y)))%R
  else pr_outcome_sum q (fun y : nat => n (S y))))
find_witness Control.TimeoutCrunching:
((forall (l1 lf1 : list R) (a b c : R) (f : R -> R),
  adapted_couple f a b l1 lf1 ->
  a <= c <= b -> {l : list R & {l0 : list R & adapted_couple f c b l l0}}) ->
 a + b < Ha)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutCrunching:
((fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ P)%prg) && (x <? 2 ^ n0) &&
   (y <? 2 ^ n0)
  then C1
  else 0%R)
 × (fun x y : nat =>
    if
     (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ n)%prg) && (x <? 2 ^ n0) &&
     (y <? 2 ^ n0)
    then C1
    else 0%R) =
 (fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ (n ∘ P))%prg) &&
   (x <? 2 ^ n0) && (y <? 2 ^ n0)
  then C1
  else 0%R))
find_witness Control.TimeoutCrunching: (cnot H5 y = 0)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ P)%prg) && (x <? 2 ^ n0) &&
   (y <? 2 ^ n0)
  then C1
  else 0%R)
 × (fun x y : nat =>
    if
     (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ n)%prg) && (x <? 2 ^ n0) &&
     (y <? 2 ^ n0)
    then C1
    else 0%R) =
 (fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ (n ∘ P))%prg) &&
   (x <? 2 ^ n0) && (y <? 2 ^ n0)
  then C1
  else 0%R))
out of reach
Tactic call ran for 0.003 secs (0.002u,0.001s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ P)%prg) && (x <? 2 ^ n0) &&
   (y <? 2 ^ n0)
  then C1
  else 0%R)
 × (fun x y : nat =>
    if
     (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ n)%prg) && (x <? 2 ^ n0) &&
     (y <? 2 ^ n0)
    then C1
    else 0%R) =
 (fun x y : nat =>
  if
   (x =? funbool_to_nat n0 (nat_to_funbool n0 y ∘ (n ∘ P))%prg) &&
   (x <? 2 ^ n0) && (y <? 2 ^ n0)
  then C1
  else 0%R))
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
find_witness Control.TimeoutBuilding index_of_ident...
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutout of reach
Tactic call ran for 0.058 secs (0.048u,0.009s) (failure)
find_witness Control.Timeout(invert_Z_cast2 e = Some r ->
 existT expr t e =
 existT expr (type.base (tZ * tZ) -> type.base (tZ * tZ))%etype
   (#Compilers.ident_Z_cast2 @ GallinaReify.base.reify r)%expr)
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (∣0⟩ = basis_vector 2 0)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall x y z : R, y <= z - x -> x + y <= z)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
Crunching: (R -> False)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (∣0⟩ = basis_vector 2 0)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.044 secs (0.044u,0.s) (failure)
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutCrunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
Crunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
find_witness Control.TimeoutBuilding eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((forall (l1 lf1 : list R) (a b c : R) (f : R -> R),
  adapted_couple f a b l1 lf1 ->
  a <= c <= b -> {l : list R & {l0 : list R & adapted_couple f c b l l0}}) ->
 a + b < Ha)
find_witness Control.TimeoutCrunching:
(pr_outcome_sum ([] ++ l2) f =
 (pr_outcome_sum [] f +
  pr_outcome_sum l2 (fun x : nat => f (length [] + x)%nat))%R)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutCrunching: (cnot H5 y = 0)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(pad_ctrl H a n A × pad_ctrl H o p B = pad_ctrl H o p B × pad_ctrl H a n A)
Crunching: (perm_to_matrix x v = I (2 ^ x))
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
Crunching: (Pure_State (perm_to_matrix 0 f))
Crunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
Crunching:
(pad_ctrl H a n A × pad_ctrl H o p B = pad_ctrl H o p B × pad_ctrl H a n A)
(false = true)
Crunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
Crunching: (Pure_State (perm_to_matrix 0 f))
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(ConstructiveCauchyReals.CRealEq (Rrepr (pr_outcome_sum ([] ++ l2) f))
   (Rrepr
      (pr_outcome_sum [] f +
       pr_outcome_sum l2 (fun x : nat => f (length [] + x)%nat))))
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching:
(pad_ctrl H a n A × pad_ctrl H o p B = pad_ctrl H o p B × pad_ctrl H a n A)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
find_witness Control.TimeoutCrunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
(invert_Z_cast2 e = Some r ->
 existT expr t e =
 existT expr (type.base (tZ * tZ) -> type.base (tZ * tZ))%etype
   (#Compilers.ident_Z_cast2 @ GallinaReify.base.reify r)%expr)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Crunching: (WF_Matrix cnot)
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: (WF_Matrix (perm_to_matrix 0 f))
Building index_of_base...
Building base_type_list...
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
find_witness Control.TimeoutBuilding eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: (WF_Matrix cnot)
Crunching:
(pad_ctrl H a n A × pad_ctrl H o p B = pad_ctrl H o p B × pad_ctrl H a n A)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: (WF_Matrix cnot)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching:
(pr_outcome_sum ([] ++ l2) f =
 (pr_outcome_sum [] f +
  pr_outcome_sum l2 (fun x : nat => f (length [] + x)%nat))%R)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Crunching:
(pr_outcome_sum ([] ++ l2) f =
 (pr_outcome_sum [] f +
  pr_outcome_sum l2 (fun x : nat => f (length [] + x)%nat))%R)
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(pad_ctrl H a n A × pad_ctrl H o p B = pad_ctrl H o p B × pad_ctrl H a n A)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutCrunching:
(pr_outcome_sum ([] ++ l2) l =
 (pr_outcome_sum [] l +
  pr_outcome_sum l2 (fun x : nat => l (length [] + x)%nat))%R)
find_witness Control.TimeoutCrunching: (WF_Matrix cnot)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
Crunching:
(pad_ctrl H a n A × pad_ctrl H o p B = pad_ctrl H o p B × pad_ctrl H a n A)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
(pad_ctrl H a n A × pad_ctrl H o p B = pad_ctrl H o p B × pad_ctrl H a n A)
Crunching: (∣1⟩ = basis_vector 2 1)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
Building index_of_base...
find_witness Control.TimeoutBuilding base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
find_witness Control.TimeoutBuilding base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
find_witness Control.Timeoutfind_witness Control.TimeoutBuilding index_of_base...
find_witness Control.TimeoutBuilding base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
find_witness Control.TimeoutBuilding all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(pr_outcome_sum (r :: r0 ++ l2) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum l2 (fun x : nat => f (S (length r0 + x))))%R)
find_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
Building index_of_base...
Crunching: (∣0⟩ = basis_vector 2 0)
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Tactic call ran for 0.015 secs (0.012u,0.002s) (success)
Crunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (WF_Matrix (- Ci .* σx × σy × σz))
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
find_witness Control.TimeoutBuilding index_of_ident...
Crunching: (Pure_State (perm_to_matrix 0 f))
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Crunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
Crunching: (Pure_State (perm_to_matrix 0 f))
Tactic call ran for 0.01 secs (0.009u,0.s) (success)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
find_witness Control.TimeoutBuilding all_base...
Building all_base_and_interp...
Building index_of_ident...
Crunching: (WF_Matrix (perm_to_matrix 0 f))
find_witness Control.TimeoutBuilding ident_interp...
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.017 secs (0.012u,0.005s) (success)
find_witness Control.TimeoutTactic call ran for 0.012 secs (0.009u,0.002s) (success)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Crunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.TimeoutCrunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
find_witness Control.TimeoutCrunching:
((forall x : nat, x < 0 -> f x = x) -> Pure_State (perm_to_matrix 0 f))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
find_witness Control.TimeoutBuilding reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
find_witness Control.TimeoutBuilding all_ident_and_interp...
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Crunching: (perm_to_matrix 0 A = I 1)
find_witness Control.TimeoutBuilding buildEagerIdentAndInterpCorrect...
Crunching: (perm_to_matrix 0 A = I 1)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Crunching: (I 1 = perm_to_matrix 0 A)
Crunching: (perm_to_matrix 0 A = I 1)
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
find_witness Control.TimeoutCrunching: (perm_to_matrix 0 A = I 1)
Building ident_is_var_like...
Tactic call ran for 0.015 secs (0.013u,0.001s) (success)
find_witness Control.TimeoutCrunching: (perm_to_matrix 0 A = I 1)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (I 1 = perm_to_matrix 0 A)
Crunching: (perm_to_matrix 0 A = I 1)
Building eqv_Reflexive_Proper...
Crunching: (WF_Matrix H0 -> WF_Matrix (control H0))
find_witness Control.TimeoutTactic call ran for 0.01 secs (0.008u,0.002s) (success)
Crunching: False
Crunching: False
Building ident_interp_Proper...
Crunching: (perm_to_matrix f g 0 v = √ 0)
Building invertIdent...
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutBuilding buildInvertIdentCorrect...
Building base_default...
Building package...
Tactic call ran for 0.015 secs (0.009u,0.005s) (success)
Crunching: (control U a0 y = (R0, R0))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(0 < IZR (Z.succ (Z.succ 0)) ->
 (r = 0 -> False) ->
 forall (l2 : list R) (f : nat -> bool),
 pr_outcome_sum (r :: r0 ++ l2) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum l2 (fun x : nat => f (S (length r0 + x))))%R)
find_witness Control.TimeoutTactic call ran for 0.009 secs (0.008u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (perm_to_matrix 0 x f y = 0%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (1 * 0)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
Crunching: (perm_to_matrix f g 0 v = √ 0)
find_witness Control.TimeoutCrunching:
(forall (p0 : nat -> nat) (x y : nat),
 x >= 2 ^ p \/ y >= 2 ^ p -> perm_to_matrix p p0 x y = 0%R)
Tactic call ran for 0.009 secs (0.008u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (control Hx HP y = 0)
Crunching: False
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Crunching:
(forall c : nat,
 0 <= x <= Hx ->
 0 < c -> (x + Hx) * (x ^ c + Hx ^ c) <= 2 * (x * x ^ c + Hx * Hx ^ c))
Crunching: False
Crunching: (pr_outcome_sum (repeat 0 l) x = (1 * 0)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (1 * 0)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (1 * 0)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (WF_Matrix (∣ 0 ⟩ × (- Ci .* σx × σy × σz)))
find_witness Control.TimeoutTactic call ran for 0.008 secs (0.008u,0.s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
Crunching: ((- Ci .* σx × (σy × (σz × ∣ 0 ⟩))) x = ∣ 0 ⟩ x)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 0 ⟩)
find_witness Control.TimeoutCrunching: (WF_Matrix H0 -> WF_Matrix (control H0))
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
Crunching:
(0 <= cv <= x ->
 0 < y -> (cv + x) * (cv ^ y + x ^ y) <= 2 * (cv * cv ^ y + x * x ^ y))
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
find_witness Control.TimeoutCrunching: False
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]] = σz × ∣ 1 ⟩)
find_witness Control.TimeoutCrunching:
((- Ci .* σx × (σy × (σz × ∣ 1 ⟩))) 1%nat 0%nat = ∣ 1 ⟩ 1%nat 0%nat)
Tactic call ran for 0.009 secs (0.008u,0.s) (success)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.003u,0.003s) (failure)
Tactic call ran for 0.008 secs (0.007u,0.001s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (perm_to_matrix delta H6 a b = 0%R)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update n Ha Hn Ha = Hn)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall b : p1, update eps ep b ep = b)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.001s) (failure)
find_witness Control.TimeoutCrunching: (pr_outcome_sum (repeat 0 l) x = (1 * 0)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (1 * 0)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (1 * 0)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (1 * 0)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (1 * 0)%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (pr_outcome_sum (repeat 0 l) x = (1 * 0)%R)
Crunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
out of reach
Tactic call ran for 0.007 secs (0.005u,0.001s) (failure)
Crunching: (pr_outcome_sum (repeat 0 l) x = (1 * 0)%R)
find_witness Control.TimeoutCrunching: (pr_outcome_sum (repeat 0 l) x = (0 * 1)%R)
Crunching: (pr_outcome_sum (repeat 0 a0) f = (0 * 1)%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
     = (exist (fun k : nat => (k <? 6) = true) 0 eq_refl,
        (exist (fun k : nat => (k <? 5) = true) 0 eq_refl,
         (exist (fun k : nat => (k <? 4) = true) 0 eq_refl,
          (exist (fun k : nat => (k <? 3) = true) 0 eq_refl,
           (exist (fun k : nat => (k <? 2) = true) 0 eq_refl,
            (exist (fun k : nat => (k <? 1) = true) 0 eq_refl, tt))))))
     : decr_list (fun n : nat => ltN (S n)) 6
Crunching: (Hn = update n Ha Hn Ha)
Crunching: (perm_to_matrix 0 x f y = 0%R)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (update n Ha Hn Ha = Hn)
out of reach
Tactic call ran for 0.005 secs (0.002u,0.002s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(nat ->
 forall A B : Matrix x H,
 WF_Matrix A -> WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(WF_Matrix y1 -> WF_Matrix H2 -> y1 .⊕ H2 = ∣0⟩⟨0∣ ⊗ y1 .+ ∣1⟩⟨1∣ ⊗ H2)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall A B : Matrix z' a,
 WF_Matrix A -> WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
find_witness Control.TimeoutCrunching: (c .⊕ Ha = ∣0⟩⟨0∣ ⊗ c .+ ∣1⟩⟨1∣ ⊗ Ha)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update f i b i = b)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(forall (f : nat -> start) (i : nat) (b : start), update f i b i = b)
Crunching: (WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (forall b : p1, update eps ep b ep = b)
Crunching:
(nat ->
 forall A B : Matrix x H,
 WF_Matrix A -> WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching: (WF_Matrix ZC1 -> GCP2 .⊕ ZC1 = ∣0⟩⟨0∣ ⊗ GCP2 .+ ∣1⟩⟨1∣ ⊗ ZC1)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(WF_Matrix y1 -> WF_Matrix H2 -> y1 .⊕ H2 = ∣0⟩⟨0∣ ⊗ y1 .+ ∣1⟩⟨1∣ ⊗ H2)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.TimeoutCrunching:
(forall A B : Matrix z' a,
 WF_Matrix A -> WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (c .⊕ Ha = ∣0⟩⟨0∣ ⊗ c .+ ∣1⟩⟨1∣ ⊗ Ha)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (WF_Matrix A -> WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching: (WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(nat ->
 forall A B : Matrix x H,
 WF_Matrix A -> WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
find_witness Control.TimeoutCrunching:
(nat ->
 forall A B : Matrix x H,
 WF_Matrix A -> WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (WF_Matrix ZC1 -> GCP2 .⊕ ZC1 = ∣0⟩⟨0∣ ⊗ GCP2 .+ ∣1⟩⟨1∣ ⊗ ZC1)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(WF_Matrix y1 -> WF_Matrix H2 -> y1 .⊕ H2 = ∣0⟩⟨0∣ ⊗ y1 .+ ∣1⟩⟨1∣ ⊗ H2)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (WF_Matrix B -> Hlen' .⊕ B = ∣0⟩⟨0∣ ⊗ Hlen' .+ ∣1⟩⟨1∣ ⊗ B)
Crunching: (WF_Matrix B -> Hlen' .⊕ B = ∣0⟩⟨0∣ ⊗ Hlen' .+ ∣1⟩⟨1∣ ⊗ B)
find_witness Control.TimeoutCrunching:
(forall A B : Matrix z' a,
 WF_Matrix A -> WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (c .⊕ Ha = ∣0⟩⟨0∣ ⊗ c .+ ∣1⟩⟨1∣ ⊗ Ha)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Finished transaction in 33.897 secs (32.953u,0.604s) (successful)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (WF_Matrix A -> WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
Crunching:
(A .⊕ B =
 (fun x0 y : nat => ∣0⟩⟨0∣ (x0 / x)%nat (y / a)%nat * A (x0 mod x) (y mod a))
 .+ (fun x0 y : nat =>
     ∣1⟩⟨1∣ (x0 / x)%nat (y / a)%nat * B (x0 mod x) (y mod a)))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(A .⊕ B =
 (fun x0 y : nat => ∣0⟩⟨0∣ (x0 / x)%nat (y / a)%nat * A (x0 mod x) (y mod a))
 .+ (fun x0 y : nat =>
     ∣1⟩⟨1∣ (x0 / x)%nat (y / a)%nat * B (x0 mod x) (y mod a)))
find_witness Control.TimeoutCrunching:
(A .⊕ B =
 (fun x0 y : nat => ∣0⟩⟨0∣ (x0 / x)%nat (y / a)%nat * A (x0 mod x) (y mod a))
 .+ (fun x0 y : nat =>
     ∣1⟩⟨1∣ (x0 / x)%nat (y / a)%nat * B (x0 mod x) (y mod a)))
find_witness Control.TimeoutCrunching:
(A .⊕ B =
 (fun x0 y : nat => ∣0⟩⟨0∣ (x0 / x)%nat (y / a)%nat * A (x0 mod x) (y mod a))
 .+ (fun x0 y : nat =>
     ∣1⟩⟨1∣ (x0 / x)%nat (y / a)%nat * B (x0 mod x) (y mod a)))
Tactic call ran for 0.008 secs (0.007u,0.001s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(A .⊕ B =
 (fun x0 y : nat => ∣0⟩⟨0∣ (x0 / x)%nat (y / a)%nat * A (x0 mod x) (y mod a))
 .+ (fun x0 y : nat =>
     ∣1⟩⟨1∣ (x0 / x)%nat (y / a)%nat * B (x0 mod x) (y mod a)))
find_witness Control.TimeoutCrunching:
(A .⊕ B =
 (fun x0 y : nat => ∣0⟩⟨0∣ (x0 / x)%nat (y / a)%nat * A (x0 mod x) (y mod a))
 .+ (fun x0 y : nat =>
     ∣1⟩⟨1∣ (x0 / x)%nat (y / a)%nat * B (x0 mod x) (y mod a)))
find_witness Control.TimeoutTactic call ran for 0.007 secs (0.007u,0.s) (success)
Crunching:
(WF_Matrix H ->
 WF_Matrix y_encad4 -> H .⊕ y_encad4 = ∣0⟩⟨0∣ ⊗ H .+ ∣1⟩⟨1∣ ⊗ y_encad4)
Crunching:
(WF_Matrix H -> WF_Matrix Hl -> H .⊕ Hl = ∣0⟩⟨0∣ ⊗ H .+ ∣1⟩⟨1∣ ⊗ Hl)
Crunching:
(nat ->
 forall A B : Matrix x H,
 WF_Matrix A -> WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
Crunching:
(nat ->
 forall A B : Matrix x H,
 WF_Matrix A -> WF_Matrix B -> A .⊕ B = ∣0⟩⟨0∣ ⊗ A .+ ∣1⟩⟨1∣ ⊗ B)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.006 secs (0.006u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.012 secs (0.011u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (WF_Matrix ZC1 -> GCP2 .⊕ ZC1 = ∣0⟩⟨0∣ ⊗ GCP2 .+ ∣1⟩⟨1∣ ⊗ ZC1)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.012 secs (0.01u,0.002s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.02 secs (0.015u,0.005s) (success)
Crunching: (forall y : nat, HF = y -> update Hn H0 b HF = Hn y)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) Ev' H0
  then Hxy
  else Hn Ev') = Hn Ev')
Crunching:
((H0 = Ev' -> False) ->
 (if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) Ev' H0
  then Hxy
  else Hn Ev') = Hn Ev')
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update Hn H0 Hxz Ev' = Hn Ev')
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall (i j : nat) (b : psi_vn), i <> j -> update H5 i b j = H5 j)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.007 secs (0.007u,0.s) (success)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (pr_outcome_sum feqt y = pr_outcome_sum feqt x1)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.007 secs (0.007u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
Crunching:
((forall x : nat, (x < length feqt)%nat -> m x = H6 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H6)
find_witness Control.TimeoutCrunching:
((forall x : nat, (x < length feqt)%nat -> m x = H0 x) ->
 pr_outcome_sum feqt m = pr_outcome_sum feqt H0)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (pr_outcome_sum feqt n = pr_outcome_sum feqt ρ)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (pr_outcome_sum feqt Heq = pr_outcome_sum feqt eps)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (pr_outcome_sum feqt y = pr_outcome_sum feqt x1)
Crunching: (m = E1 q -> update E1 q m = E1)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (WF_Matrix hadamard /\ (hadamard) † × hadamard = I 2)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.013 secs (0.01u,0.002s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.002u,0.001s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(cos_in (√ 0) (cos (√ 0)) -> forall b : l, b = H1 He -> update H1 He b = H1)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (σx) † × σx)
Crunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.TimeoutCrunching: (WF_Matrix σx /\ (σx) † × σx = I 2)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(fst (Σ (fun y0 : nat => (σx) † x y0 * σx y0 y) 2) =
 fst (if (x =? y) && (x <? 2) then C1 else 0))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (m = E1 q -> update E1 q m = E1)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (σx) † × σx)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.003u,0.001s) (failure)
find_witness Control.TimeoutCrunching: (WF_Matrix σx /\ (σx) † × σx = I 2)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (m = E1 q -> update E1 q m = E1)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(fst (Σ (fun y0 : nat => (σx) † x y0 * σx y0 y) 2) =
 fst (if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.TimeoutCrunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.TimeoutCrunching: (m = E1 q -> update E1 q m = E1)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (σx) † × σx)
Crunching: (0 < 0)%nat
find_witness Control.TimeoutCrunching: (WF_Matrix σx /\ (σx) † × σx = I 2)
Crunching: (update HA 0 (HA H) = HA)
find_witness Control.TimeoutCrunching: (update HA 0 (HA H) = HA)
Crunching: (update HA 0 (HA H) = HA)
find_witness Control.TimeoutCrunching: (update HA 0 (HA H) = HA)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (update HA 0 (HA H) = HA)
find_witness Control.TimeoutCrunching: (update HA 0 (HA H) = HA)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching: (update HA 0 (HA H) = HA)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (update HA 0 (HA H) = HA)
find_witness Control.TimeoutCrunching: (update HA 0 (HA H) = HA)
Crunching: (update HA 0 (HA H) = HA)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: (update HA 0 (HA H) = HA)
find_witness Control.TimeoutCrunching: (update HA 0 (HA H) = HA)
Crunching: (update HA 0 (HA H) = HA)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (update HA 0 (HA H) = HA)
Crunching: (update HA 0 (HA H) = HA)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: (update HA 0 (HA H) = HA)
Crunching: (update HA 0 (HA H) = HA)
Crunching: (update HA 0 (HA H) = HA)
Crunching: (update HA 0 (HA H) = HA)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (update HA 0 (HA H) = HA)
Crunching: (update HA 0 (HA H) = HA)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: (abs = HA w -> (fun j : nat => if j =? w then abs else HA j) = HA)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCase compile_stmt_correct/SInteract
find_witness Control.Timeoutfind_witness Control.TimeoutCase compile_stmt_correct/SCall
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (0 < 0)%nat
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: ((if m x then nth x n 0 else 0) = 0)
Crunching: ((if m x then nth x n 0 else 0) = 0)
Crunching: ((if m x then nth x n 0 else 0) = 0)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update (update m n H) n HF = update m n HF)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutrewrite if_dtt
if (n =? S r)
find_witness Control.Timeoutthen
(fun E : (n =? S r) = true =>
 ltN_of_nat 0 n
   (ltN_S_mod_lemma1 (exist (fun k : nat => (k <? n) = true) r Hr) E))
else
(fun E : (n =? S r) = false =>
 ltN_of_nat (S r) n
   (ltN_S_mod_lemma2 (exist (fun k : nat => (k <? n) = true) r Hr) E))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((fun n : nat =>
  forall n0 : nat,
  (forall m : nat,
   (m < n0)%nat ->
   0 + (σx) † n 0%nat * match y with
                        | 1%nat => C1
                        | _ => 0
                        end +
   (σx) † x 1%nat * match y with
                    | 0%nat => C1
                    | S _ => 0
                    end = (if (x =? y) && (x <=? 1) then C1 else 0)) ->
  0 + (σx) † x 0%nat * match y with
                       | 1%nat => C1
                       | _ => 0
                       end +
  (σx) † x 1%nat * match y with
                   | 0%nat => C1
                   | S _ => 0
                   end = (if (x =? y) && (x <=? 1) then C1 else 0)) x)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update (update m s1 ρ) s1 mixed = update m s1 mixed)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(fst (Σ (fun y0 : nat => (σx) † x y0 * σx y0 y) 2) =
 fst (if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall x : nat, update op n a x = op x)
Crunching: (forall b b' : H3, update (update x y b) y b' = update x y b')
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCase compile_stmt_correct/SLoad
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((fun x z : nat => Σ (fun y : nat => (σy) † x y * σy y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (σy) † × σy)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x : nat =>
    if H5 x
    then
     (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
        match x0 with
        | 0%nat => match x1 with
                   | [] => x2
                   | x3 :: _ => x3
                   end
        | S x3 => match x1 with
                  | [] => x2
                  | _ :: x5 => Ffix x3 x5 x2
                  end
        end) x N1 R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end) N1) = R0)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCase compile_stmt_correct/SStore
find_witness Control.TimeoutCrunching:
((fun x z : nat => Σ (fun y : nat => (σy) † x y * σy y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (σy) † × σy)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (σy) † × σy)
Crunching: (update (update hn X b) X b' = update hn X b')
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((fun x z : nat => Σ (fun y : nat => (σz) † x y * σz y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (σz) † × σz)
Case compile_stmt_correct/SInlinetable
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.01 secs (0.01u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update (update m n H) n HF = update m n HF)
Crunching:
((fun x z : nat => Σ (fun y : nat => (σz) † x y * σz y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (σz) † × σz)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update (update a n H2) n m = update a n m)
find_witness Control.TimeoutTactic call ran for 0.012 secs (0.012u,0.s) (success)
find_witness Control.TimeoutFlattenExpr: Entering slow lemmas section
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update (update l H a) H Hnotz = update l H Hnotz)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.004u,0.001s) (failure)
Crunching: (update (update f 0 a) 0 Hn = update f 0 Hn)
Crunching:
(0 < Ha ->
 exists alp : R,
   0 < alp /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\
    (let (Base, dist, _, _, _, _) as m return (Base m -> Base m -> R) :=
       R_met in
     dist) x 1 < alp ->
    (let (Base, dist, _, _, _, _) as m return (Base m -> Base m -> R) :=
       R_met in
     dist) (atan x) (atan 1) < Ha))
Crunching:
(h > 0 ->
 exists alp : R,
   alp > 0 /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\ dist R_met x 1 < alp ->
    dist R_met (atan x) (atan 1) < h))
Crunching:
(h > 0 ->
 exists alp : R,
   alp > 0 /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\ dist R_met x 1 < alp ->
    dist R_met (atan x) (atan 1) < h))
find_witness Control.TimeoutTactic call ran for 0.011 secs (0.011u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (update (update m s1 ρ) s1 mixed = update m s1 mixed)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall x : Base R_met,
 D_x no_cond 1 x /\ dist R_met x 1 < 1 -> dist R_met (atan x) (atan 1) < eps)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(exists alp : R,
   alp > 0 /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\ dist R_met x 1 < alp ->
    dist R_met (atan x) (atan 1) < p))
find_witness Control.TimeoutTactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.006 secs (0.004u,0.002s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall f : nat -> bool,
 (forall i : nat, (i < length (LS' :: n))%nat -> f i = true) ->
 pr_outcome_sum (LS' :: n) f = sum_over_list (LS' :: n))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (σz) † × σz)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
find_witness Control.TimeoutFinished transaction in 182.409 secs (181.894u,0.32s) (successful)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall l : list R,
 (forall f : nat -> bool,
  (forall i : nat, (i < length l)%nat -> f i = true) ->
  pr_outcome_sum l f = sum_over_list l) ->
 forall f : nat -> bool,
 (forall i : nat, (i < length (Hbeq :: l))%nat -> f i = true) ->
 pr_outcome_sum (Hbeq :: l) f = sum_over_list (Hbeq :: l))
find_witness Control.TimeoutCrunching:
((fun x z : nat => Σ (fun y : nat => (σz) † x y * σz y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (σz) † × σz)
find_witness Control.TimeoutCase compile_stmt_correct/SStackalloc
find_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 0.006 secs (0.004u,0.001s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.022 secs (0.003u,0.016s) (failure)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
find_witness Control.TimeoutCrunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
Crunching:
(WF_Matrix (phase_shift x) /\ (phase_shift x) † × phase_shift x = I 2)
find_witness Control.TimeoutCrunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.004 secs (0.004u,0.s) (success)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift ϕ) † × phase_shift ϕ)
out of reach
Tactic call ran for 0.005 secs (0.003u,0.002s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.003u,0.002s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift ϕ) † × phase_shift ϕ)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift ϕ) † × phase_shift ϕ)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift ϕ) † × phase_shift ϕ)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall f : nat -> bool,
 pr_outcome_sum [] f =
 (sum_over_list [] - pr_outcome_sum [] (fun x : nat => ¬ f x))%R)
find_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching:
(forall f : nat -> bool,
 pr_outcome_sum [] f =
 (sum_over_list [] - pr_outcome_sum [] (fun x : nat => ¬ f x))%R)
find_witness Control.TimeoutCrunching:
(forall f : nat -> bool,
 pr_outcome_sum [] f =
 (sum_over_list [] - pr_outcome_sum [] (fun x : nat => ¬ f x))%R)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (?r1 < ?r2)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (forall z : C, Hn - z = Hapart -> Hn - Hapart - z = 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(nat ->
 forall b b' : Hnin,
 0 <> j -> update (update x 0 b) j b' = update (update x j b') 0 b)
Case compile_stmt_correct/SLit
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching:
((1 + 0)%R = 1%R ->
 (0 + 1)%R = 1%R ->
 (fun x : nat =>
  if
   (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
      match x0 with
      | 0 => match x1 with
             | 0 => true
             | S _ => false
             end
      | S x2 => match x1 with
                | 0 => false
                | S x3 => Ffix x2 x3
                end
      end) x j
  then b'
  else
   if
    (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
       match x0 with
       | 0 => match x1 with
              | 0 => true
              | S _ => false
              end
       | S x2 => match x1 with
                 | 0 => false
                 | S x3 => Ffix x2 x3
                 end
       end) x i
   then b
   else r x) =
 (fun x : nat =>
  if
   (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
      match x0 with
      | 0 => match x1 with
             | 0 => true
             | S _ => false
             end
      | S x2 => match x1 with
                | 0 => false
                | S x3 => Ffix x2 x3
                end
      end) x i
  then b
  else
   if
    (fix Ffix (x0 x1 : nat) {struct x0} : bool :=
       match x0 with
       | 0 => match x1 with
              | 0 => true
              | S _ => false
              end
       | S x2 => match x1 with
                 | 0 => false
                 | S x3 => Ffix x2 x3
                 end
       end) x j
   then b'
   else r x))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
find_witness Control.TimeoutCrunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
find_witness Control.TimeoutCase compile_stmt_correct/SOp
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(WF_Matrix (phase_shift x) /\ (phase_shift x) † × phase_shift x = I 2)
find_witness Control.TimeoutCrunching:
(WF_Matrix (phase_shift x) /\ (phase_shift x) † × phase_shift x = I 2)
find_witness Control.TimeoutCrunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (shift x 0 = x)
find_witness Control.TimeoutCrunching:
(WF_Matrix (phase_shift x) /\ (phase_shift x) † × phase_shift x = I 2)
find_witness Control.TimeoutCrunching:
(WF_Matrix (phase_shift x) /\ (phase_shift x) † × phase_shift x = I 2)
Crunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(WF_Matrix (phase_shift x) /\ (phase_shift x) † × phase_shift x = I 2)
Crunching: (shift x 0 = x)
find_witness Control.TimeoutCrunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
find_witness Control.TimeoutCrunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
Crunching:
(WF_Matrix (phase_shift x) /\ (phase_shift x) † × phase_shift x = I 2)
find_witness Control.TimeoutCrunching: (shift x 0 = x)
find_witness Control.TimeoutCrunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
Crunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(WF_Matrix (phase_shift x) /\ (phase_shift x) † × phase_shift x = I 2)
find_witness Control.TimeoutCrunching:
(WF_Matrix (phase_shift x) /\ (phase_shift x) † × phase_shift x = I 2)
find_witness Control.TimeoutCrunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
Crunching:
(WF_Matrix
   (fun x0 y : nat =>
    match x0 with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | 1%nat => match y with
               | 1%nat => Cexp x
               | _ => 0
               end
    | S (S _) => 0
    end))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (shift x 0 = x)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(WF_Matrix (phase_shift x) /\ (phase_shift x) † × phase_shift x = I 2)
Crunching:
(WF_Matrix (phase_shift x) /\ (phase_shift x) † × phase_shift x = I 2)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift x) † × phase_shift x)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.011 secs (0.011u,0.s) (success)
Crunching: (shift (shift n b) a = shift n (a + b))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.018 secs (0.013u,0.005s) (failure)
find_witness Control.TimeoutCrunching:
(forall i j : nat, shift (shift eps0_pos j) i = shift eps0_pos (i + j))
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.011 secs (0.011u,0.s) (success)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (phase_shift ϕ) † × phase_shift ϕ)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.014 secs (0.013u,0.001s) (failure)
find_witness Control.TimeoutCrunching: (shift (shift start n) q = shift start (q + n))
find_witness Control.Timeoutfind_witness Control.Timeoutrewrite if_dtt
if (n =? proj1_sig r)
then
(fun E : (n =? proj1_sig r) = true =>
 ltN_of_nat 0 (S n) (ltN_S_mod_lemma1 r E))
else
(fun E : (n =? proj1_sig r) = false =>
 ltN_of_nat (S (proj1_sig r)) (S n) (ltN_S_mod_lemma2 r E))
Crunching: (shift (shift n b) a = shift n (a + b))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.009 secs (0.009u,0.s) (success)
Crunching:
((fun x z : nat => Σ (fun y : nat => (Sgate y x) ^* * Sgate y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
out of reach
Tactic call ran for 0.015 secs (0.01u,0.004s) (failure)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (Sgate) † × Sgate)
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall i j : nat, shift (shift eps0_pos j) i = shift eps0_pos (i + j))
Crunching:
(forall i j : nat, shift (shift eps0_pos j) i = shift eps0_pos (i + j))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(pr_outcome_sum q n <= pr_outcome_sum q (fun rnd : nat => n rnd || Hq rnd))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
find_witness Control.TimeoutCrunching:
((fun x z : nat => Σ (fun y : nat => (Sgate y x) ^* * Sgate y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.TimeoutCrunching: (shift (shift l m) 0 = shift l m)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (Sgate) † × Sgate)
find_witness Control.TimeoutCrunching:
(pr_outcome_sum q n <= pr_outcome_sum q (fun rnd : nat => n rnd || Hq rnd))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(pr_outcome_sum q n <= pr_outcome_sum q (fun rnd : nat => n rnd || Hq rnd))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (shift (shift start n) q = shift start (q + n))
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
find_witness Control.TimeoutCrunching: (shift (shift a B) H1 i = shift a (H1 + B) i)
out of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
Crunching:
((fun i : nat =>
  a
    ((fix add (n m : nat) {struct n} : nat :=
        match n with
        | 0 => m
        | S p => S (add p m)
        end)
       ((fix add (n m : nat) {struct n} : nat :=
           match n with
           | 0 => m
           | S p => S (add p m)
           end) i IHP') P)) =
 (fun i : nat =>
  a
    ((fix add (n m : nat) {struct n} : nat :=
        match n with
        | 0 => m
        | S p => S (add p m)
        end) i
       ((fix add (n m : nat) {struct n} : nat :=
           match n with
           | 0 => m
           | S p => S (add p m)
           end) IHP' P))))
Crunching:
((forall r1 r2 r3 : R, r1 < r2 -> r2 < r3 -> r1 < r3) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 pr_outcome_sum a m <= pr_outcome_sum a (fun rnd : nat => m rnd || Hx rnd))
Crunching: (shift (shift n b) a = shift n (a + b))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutrewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) =?
 proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e))
then
(fun
   _ : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) =?
        proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = true =>
 AA tt)
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) =?
         proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = false =>
 BB
   ((if
      proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
      proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e) as b1
      return
        ((proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
          proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = b1 ->
         ltN 0)
     then
      fun
        E1 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
              proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = true
      =>
      ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp)) 0
        (ltN_pop_lemma1 0 (exist (fun k : nat => (k <? 1) = true) x0 e)
           (exist (fun k : nat => (k <? 1) = true) cc pp) E1)
     else
      fun
        E1 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
              proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) =
             false =>
      ltN_of_nat
        (Init.Nat.pred
           (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp))) 0
        (ltN_pop_lemma2 0 (exist (fun k : nat => (k <? 1) = true) x0 e)
           (exist (fun k : nat => (k <? 1) = true) cc pp) E1 E0)) eq_refl))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.009 secs (0.008u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.012 secs (0.012u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.012 secs (0.012u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCase compile_stmt_correct/SSet
find_witness Control.Timeoutrewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) =?
 proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e))
then
(fun
   _ : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) =?
        proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = true =>
 AA tt)
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) =?
         proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = false =>
 BB
   ((if
      proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
      proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e) as b1
      return
        ((proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
          proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = b1 ->
         ltN 0)
     then
      fun
        E1 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
              proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = true
      =>
      ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp)) 0
        (ltN_pop_lemma1 0 (exist (fun k : nat => (k <? 1) = true) x0 e)
           (exist (fun k : nat => (k <? 1) = true) cc pp) E1)
     else
      fun
        E1 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
              proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) =
             false =>
      ltN_of_nat
        (Init.Nat.pred
           (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp))) 0
        (ltN_pop_lemma2 0 (exist (fun k : nat => (k <? 1) = true) x0 e)
           (exist (fun k : nat => (k <? 1) = true) cc pp) E1 E0)) eq_refl))
Crunching:
(pr_outcome_sum q n <= pr_outcome_sum q (fun rnd : nat => n rnd || Hq rnd))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.009 secs (0.009u,0.s) (failure)
Crunching: (∣1⟩ = basis_vector 2 1)
Case compile_stmt_correct/SIf/Then
Crunching:
(pr_outcome_sum q n <= pr_outcome_sum q (fun rnd : nat => n rnd || Hq rnd))
Crunching: (∣1⟩ = basis_vector 2 1)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (fswap a n y n = a y)
find_witness Control.TimeoutCrunching: (Z.abs_N (Z.rem (Z.pos p) (Z.pos q)) = (N.pos p mod N.pos q)%N)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(pr_outcome_sum q n <= pr_outcome_sum q (fun rnd : nat => n rnd || Hq rnd))
out of reach
Tactic call ran for 0.01 secs (0.009u,0.s) (failure)
find_witness Control.TimeoutCrunching: (Z.abs_N (Z.rem (Z.pos p) (Z.pos q)) = (N.pos p mod N.pos q)%N)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall x y : nat, fswap l x y x = l y)
find_witness Control.TimeoutCrunching: (Z.abs_N (Z.rem (Z.pos p) (Z.pos q)) = (N.pos p mod N.pos q)%N)
Crunching: (fswap a n y n = a y)
Crunching: (a y = fswap a n y n)
Crunching: (fswap a n y n = a y)
Crunching: (a y = fswap a n y n)
Crunching: (fswap a n y n = a y)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: False
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (Z.abs_N (Z.rem (Z.pos p) (Z.pos q)) = (N.pos p mod N.pos q)%N)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCase compile_stmt_correct/SIf/Else
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: False
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = (Tgate) † × Tgate)
Crunching: False
Crunching: False
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H4 r ϕ y x) ^* * rotation H4 r ϕ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) =?
 proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e))
then
(fun
   _ : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) =?
        proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = true =>
 AA tt)
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) =?
         proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = false =>
 BB
   ((if
      proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
      proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e) as b1
      return
        ((proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
          proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = b1 ->
         ltN 0)
     then
      fun
        E1 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
              proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = true
      =>
      ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp)) 0
        (ltN_pop_lemma1 0 (exist (fun k : nat => (k <? 1) = true) x0 e)
           (exist (fun k : nat => (k <? 1) = true) cc pp) E1)
     else
      fun
        E1 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp) <?
              proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) =
             false =>
      ltN_of_nat
        (Init.Nat.pred
           (proj1_sig (exist (fun k : nat => (k <? 1) = true) cc pp))) 0
        (ltN_pop_lemma2 0 (exist (fun k : nat => (k <? 1) = true) x0 e)
           (exist (fun k : nat => (k <? 1) = true) cc pp) E1 E0)) eq_refl))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall f1 f2 : nat -> bool,
 (forall x : nat, f1 x = true -> f2 x = true) ->
 pr_outcome_sum l f1 < pr_outcome_sum l f2 \/
 pr_outcome_sum l f1 = pr_outcome_sum l f2)
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 1) = true) x1 e1) =?
 proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e))
then
(fun
   _ : (proj1_sig (exist (fun k : nat => (k <? 1) = true) x1 e1) =?
        proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = true =>
 AA tt)
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) x1 e1) =?
         proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = false =>
 BB
   ((if
      proj1_sig (exist (fun k : nat => (k <? 1) = true) x1 e1) <?
      proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e) as b1
      return
        ((proj1_sig (exist (fun k : nat => (k <? 1) = true) x1 e1) <?
          proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = b1 ->
         ltN 0)
     then
      fun
        E1 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) x1 e1) <?
              proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) = true
      =>
      ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? 1) = true) x1 e1)) 0
        (ltN_pop_lemma1 0 (exist (fun k : nat => (k <? 1) = true) x0 e)
           (exist (fun k : nat => (k <? 1) = true) x1 e1) E1)
     else
      fun
        E1 : (proj1_sig (exist (fun k : nat => (k <? 1) = true) x1 e1) <?
              proj1_sig (exist (fun k : nat => (k <? 1) = true) x0 e)) =
             false =>
      ltN_of_nat
        (Init.Nat.pred
           (proj1_sig (exist (fun k : nat => (k <? 1) = true) x1 e1))) 0
        (ltN_pop_lemma2 0 (exist (fun k : nat => (k <? 1) = true) x0 e)
           (exist (fun k : nat => (k <? 1) = true) x1 e1) E1 E0)) eq_refl))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H15 ϕ λ) † x y * rotation H15 ϕ λ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 (rotation H15 ϕ λ) † × rotation H15 ϕ λ)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
find_witness Control.TimeoutCrunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
Crunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
Crunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
find_witness Control.TimeoutCrunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
Case compile_stmt_correct/SLoop
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall x y : nat, fswap l x y x = l y)
find_witness Control.TimeoutCrunching: ((a + b) * (a ^ c + b ^ c) <= 2 * (a * a ^ c + b * b ^ c))
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 0.003 secs (0.002u,0.s) (success)
Crunching:
(forall f1 : list R,
 Forall (fun x : R => 0 <= x) f1 ->
 forall f2 : nat -> bool,
 (forall x : nat, f2 x = true -> Hl x = true) ->
 pr_outcome_sum f1 f2 <= pr_outcome_sum f1 Hl)
Crunching: (fswap a n y n = a y)
Crunching: (a y = fswap a n y n)
Crunching: (fswap a n y n = a y)
Crunching: (a y = fswap a n y n)
Crunching: (fswap a n y n = a y)
Crunching: (a y = fswap a n y n)
Crunching: (fswap a n y n = a y)
Crunching: (a y = fswap a n y n)
Crunching: (fswap a n y n = a y)
Crunching: (a y = fswap a n y n)
Crunching: (fswap a n y n = a y)
Crunching: (a y = fswap a n y n)
find_witness Control.TimeoutCrunching: (fswap a n y n = a y)
Crunching: (fswap a n y n = a y)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H4 r ϕ y x) ^* * rotation H4 r ϕ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.TimeoutCrunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H4 r ϕ) † x y * rotation H4 r ϕ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (rotation H4 r ϕ) † × rotation H4 r ϕ)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H4 r λ) † x y * rotation H4 r λ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.TimeoutCrunching:
((forall x0 : nat, n x0 = true -> x x0 = true) ->
 pr_outcome_sum GT n <= pr_outcome_sum GT x)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H4 r HP2) † x y * rotation H4 r HP2 y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 (rotation H4 r HP2) † × rotation H4 r HP2)
Crunching: (forall y : nat, fswap f (S x) y (S x) = f y)
Crunching:
(forall f1 f2 : nat -> bool,
 (forall x : nat, f1 x = true -> f2 x = true) ->
 pr_outcome_sum l f1 < pr_outcome_sum l f2 \/
 pr_outcome_sum l f1 = pr_outcome_sum l f2)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(forall f1 f2 : nat -> bool,
 (forall x : nat, f1 x = true -> f2 x = true) ->
 pr_outcome_sum l f1 < pr_outcome_sum l f2 \/
 pr_outcome_sum l f1 = pr_outcome_sum l f2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 (rotation H4 r H0) † × rotation H4 r H0)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H4 r λ) † x y * rotation H4 r λ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H4 ϕ λ) † x y * rotation H4 ϕ λ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (rotation H4 ϕ λ) † × rotation H4 ϕ λ)
find_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H4 H1 ϕ y x) ^* * rotation H4 H1 ϕ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
find_witness Fun.Finally_raised: Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (rotation θ ϕ λ) † × rotation θ ϕ λ)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
Crunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
Crunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
Crunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
Crunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
find_witness Control.TimeoutCrunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
Crunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutCrunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
find_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (pr_outcome_sum H2 x <= pr_outcome_sum H2 n)
out of reach
Tactic call ran for 0.008 secs (0.007u,0.001s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((fun x z : nat =>
  Σ (fun y : nat => (rotation H15 ϕ λ) † x y * rotation H15 ϕ λ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((if y =? Hr then Hl y else if y =? y then Hl Hr else Hl y) = Hl Hr)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] =
 (rotation H15 ϕ λ) † × rotation H15 ϕ λ)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(forall x y : nat,
 (if y =? x then LE y else if y =? y then LE x else LE y) = LE x)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (rotation n m H) † × rotation n m H)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(WF_Matrix (rotation a0 a H6) /\
 (rotation a0 a H6) † × rotation a0 a H6 = I 2)
find_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.TimeoutCrunching:
((if y =? Hr then Hl y else if y =? y then Hl Hr else Hl y) = Hl Hr)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall y : nat, fswap Hy p y y = Hy p)
Crunching: (forall x y : nat, fswap l x y y = l x)
Crunching: ((if y =? H then LE y else LE H) = LE H)
find_witness Control.TimeoutCrunching:
(forall f1 : list R,
 Forall (fun x : R => 0 <= x) f1 ->
 forall f2 : nat -> bool,
 (forall x : nat, f2 x = true -> Hl x = true) ->
 pr_outcome_sum f1 f2 <= pr_outcome_sum f1 Hl)
Crunching: (fswap m Hn Hn = m)
Crunching: (fswap m Hn Hn = m)
rewrite if_dtt
if (n =? S (proj1_sig k))
then
(fun E : (n =? S (proj1_sig k)) = true =>
 ltN_of_nat 0 n (ltN_S_mod_lemma1 k E))
else
(fun E : (n =? S (proj1_sig k)) = false =>
 ltN_of_nat (S (proj1_sig k)) n (ltN_S_mod_lemma2 k E))
FlattenExpr: flattenExpr_correct_aux done
Crunching: (fswap m Hn Hn = m)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (0%nat <> 2%nat -> -1 <= / 7 <= 1)
Crunching: (pr_outcome_sum eps LM1 <= pr_outcome_sum eps Hl)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (fswap m Hn Hn = m)
Crunching: (fswap m Hn Hn = m)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (?r1 < ?r2)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.001u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (x_rotation θ) † × x_rotation θ)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.007 secs (0.006u,0.001s) (failure)
Crunching: (?r13 < ?r23)
out of reach
Tactic call ran for 0.005 secs (0.003u,0.001s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (?r12 < ?r22)
Crunching: (?r11 < ?r21)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching: (forall z : C, HF - z = y -> HF - y - z = 0)
Crunching: (Forall (fun x : R => 0 <= x) X -> 0 <= pr_outcome_sum X p)
find_witness Control.TimeoutCrunching: (?r10 < ?r20)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (f_to_vec y z l yz = 0%R)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(Forall (fun x : R => 0 <= x) z' ->
 0 < pr_outcome_sum z' Hn \/ 0 = pr_outcome_sum z' Hn)
Crunching: (f_to_vec y z l yz = 0%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (forall z : C, HF - z = y -> HF - y - z = 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.TimeoutCrunching: (?r1 < ?r2)
Crunching: (forall z : C, Hn - z = Hapart -> Hn - Hapart - z = 0)
Crunching: (((forall k : nat, (0 < k)%nat -> n k) -> n 0%nat) -> n a)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(forall f : nat -> bool,
 Forall (fun x : R => 0 <= x) m -> 0 <= pr_outcome_sum m f)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching:
((forall k : nat, 0 < k -> a k) ->
 ((forall k : nat, 0 < k -> a k) -> a 0) -> a n)
Crunching: (forall z : C, HF - z = y -> HF - y - z = 0)
Crunching:
(forall P : nat -> Type,
 (forall k : nat, 0 < k -> P k) ->
 ((forall k : nat, 0 < k -> P k) -> P 0) -> P n)
out of reach
Tactic call ran for 0.005 secs (0.002u,0.001s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(forall P : nat -> Type,
 (forall k : nat, 0 < k -> P k) ->
 ((forall k : nat, 0 < k -> P k) -> P 0) -> P eq)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (forall x : nat, x < ?n -> ?f x = 0)
Crunching: (?r1 < ?r2)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (x_rotation θ) † × x_rotation θ)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (Forall (fun x : R => 0 <= x) X -> 0 <= pr_outcome_sum X p)
find_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.003u,0.s) (failure)
Case compile_stmt_correct/SSeq
find_witness Control.TimeoutCrunching: (?r111 < ?r211)
find_witness Control.TimeoutCrunching: (?r110 < ?r210)
Crunching:
(Forall (fun x : R => 0 <= x) z' ->
 0 < pr_outcome_sum z' Hn \/ 0 = pr_outcome_sum z' Hn)
Crunching: (?r19 < ?r29)
Crunching: (pr_outcome_sum z' Hm >= 0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: ((2 * 0)%R = (2 * pr_outcome_sum LS' f)%R)
Crunching: (forall z : C, HF - z = y -> HF - y - z = 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (?r18 < ?r28)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (y_rotation ϕ) † × y_rotation ϕ)
Crunching: (continuity_pt sqrt 1 -> WF_Unitary (y_rotation ϕ))
Case compile_stmt_correct/SSkip
Crunching:
(continue_in sqrt no_cond (IZR (Z.succ 0)) -> WF_Unitary (y_rotation ϕ))
Crunching:
(continue_in sqrt no_cond (IZR (Z.succ 0)) -> WF_Unitary (y_rotation ϕ))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (y_rotation ϕ) † x y * y_rotation ϕ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (y_rotation ϕ) † × y_rotation ϕ)
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (y_rotation ϕ y x) ^* * y_rotation ϕ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (y_rotation ϕ) † × y_rotation ϕ)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0) =
 (fun x z : nat =>
  Σ (fun y : nat => (y_rotation ϕ y x) ^* * y_rotation ϕ y z) 2))
Crunching:
((fun x z : nat =>
  Σ (fun y : nat => (y_rotation ϕ y x) ^* * y_rotation ϕ y z) 2) =
 (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (y_rotation ϕ) † × y_rotation ϕ)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0) =
 (fun x z : nat =>
  Σ (fun y : nat => (y_rotation ϕ y x) ^* * y_rotation ϕ y z) 2))
Crunching: (continuity_pt sqrt 1 -> WF_Unitary (y_rotation ϕ))
Crunching: (- PI / 2 < 0 < PI / 2)
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (y_rotation ϕ) † × y_rotation ϕ)
Crunching: (continuity_pt sin 0 -> (y_rotation ϕ) † × y_rotation ϕ = I 2)
Crunching: (continuity_pt sin 0 -> (y_rotation ϕ) † × y_rotation ϕ = I 2)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((forall i : nat, i < n -> p1 i = v i) -> f_to_vec n p1 = f_to_vec n v)
Crunching:
(continue_in sqrt no_cond (IZR (Z.succ 0)) -> WF_Unitary (y_rotation ϕ))
Crunching:
(continue_in sqrt no_cond (IZR (Z.succ 0)) -> WF_Unitary (y_rotation ϕ))
Crunching: (f_to_vec l a x y = f_to_vec l l1 x y)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = (y_rotation ϕ) † × y_rotation ϕ)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall x y z : R, Rmin x y > z <-> x > z /\ y > z)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 forall rr r a : R,
 interval_sum n q rr r ->
 interval_sum (fun x : R => n (x + - a)%R) (q + a) (rr + a) r)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 forall rr r a : R,
 interval_sum n q rr r ->
 interval_sum (fun x : R => n (x + - a)%R) (q + a) (rr + a) r)
Crunching: ((H14 >= 2)%nat \/ (x >= 2)%nat -> y_rotation ϕ H14 x = 0)
find_witness Control.TimeoutCrunching: (y_rotation ϕ H14 y = 0)
Crunching: (y_rotation ϕ b Hb = 0)
find_witness Control.TimeoutCrunching:
(forall P : nat -> Type,
 (forall k : nat, 0 < k -> P k) ->
 ((forall k : nat, 0 < k -> P k) -> P 0) -> P n)
find_witness Control.TimeoutCrunching:
(forall a : R,
 interval_sum n q H1 env ->
 interval_sum (fun x : R => n (x + - a)%R) (q + a) (H1 + a) env)
Crunching:
((forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 forall rr r a : R,
 interval_sum n q rr r ->
 interval_sum (fun x : R => n (x + - a)%R) (q + a) (rr + a) r)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((forall i : nat, i < n -> p1 i = v i) -> f_to_vec n p1 = f_to_vec n v)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((1 + 0)%R = 1 ->
 (0 + 1)%R = 1 -> continue_in sqrt no_cond 1 -> WF_Unitary (y_rotation ϕ))
Crunching:
(WF_Matrix (y_rotation ϕ) /\ (y_rotation ϕ) † × y_rotation ϕ = I 2)
Crunching:
(forall a : R,
 interval_sum n q H1 env ->
 interval_sum (fun x : R => n (x + - a)%R) (q + a) (H1 + a) env)
find_witness Control.TimeoutCrunching: (x < y -> f_to_vec 0 a x y = (f_to_vec 0 l1 x y + 0%R)%C)
Crunching: (interval_sum P2 rl rr r)
Crunching: (Hx1 < Hx2 - f -> f + Hx1 < Hx2)
find_witness Control.TimeoutCrunching: (f_to_vec l a x y = f_to_vec l l1 x y)
Crunching: (Hx1 < Hx2 - f -> f + Hx1 < Hx2)
find_witness Control.TimeoutCrunching: (f_to_vec l a x y = f_to_vec l l1 x y)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (interval_sum P2 rl rr r)
find_witness Control.TimeoutCrunching: (forall y : nat, 0 >= n \/ y >= 1 -> basis_vector n Hn 0 y = 0%R)
find_witness Control.TimeoutFlattenExpr: flattenExprs_correct done
Crunching: (cos (7 / 4) < 0)
find_witness Control.TimeoutCrunching: (x <= ?x < rr)
Crunching: (x <= ?x < rr)
Crunching:
(forall (n : nat) (P : nat -> Type),
 (forall k : nat, (0 < k)%nat -> P k) ->
 ((forall k : nat, (0 < k)%nat -> P k) -> P 0%nat) -> P n)
Crunching: (Hl l)
Crunching:
((forall k : nat, (0 < k)%nat -> Hl k) ->
 ((forall k : nat, (0 < k)%nat -> Hl k) -> Hl 0%nat) -> Hl l)
Crunching: (basis_vector a n x H3 = 0%R)
Crunching: (False -> ?B)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(forall H : interval_sum X x rr (r2 - r1), x <= ?x@{r:=r2 - r1} < rr)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (a - c = b -> a - b - c = 0)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (basis_vector a n x H3 = 0%R)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: (basis_vector a q1 M H4 = 0%R)
Crunching: (p >= a \/ q >= 1 -> basis_vector a q1 p q = 0%R)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.013 secs (0.009u,0.002s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.001u,0.003s) (failure)
Crunching: (cos (IPR 7 / IPR 4) < R0)
Crunching: (forall y : nat, 0 >= n \/ y >= 1 -> basis_vector n Hn 0 y = 0%R)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (interval_sum n IH H a)
Crunching: (cos (IPR 7 / IPR 4) < R0)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.TimeoutCrunching: (WF_Unitary (cm) †)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (interval_sum n IH H r)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S H1) H1) † × basis_vector (S H1) H1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector D' H4 y 0) ^* * basis_vector D' H4 y 0)%C) D']] = 
 I 1)
Crunching: (interval_sum n IH H a)
Crunching:
(forall d n : nat, n < d -> (basis_vector d n) † × basis_vector d n = I 1)
Crunching: (pk < k -> (basis_vector k pk) † × basis_vector k pk = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l H1) † × basis_vector l H1)
find_witness Control.TimeoutCrunching: (cos (IPR 7 / IPR 4) < R0)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S H1) H1) † × basis_vector (S H1) H1)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector D' H4 y 0) ^* * basis_vector D' H4 y 0)%C) D']] = 
 I 1)
Crunching: (forall y : nat, (0 <= q)%nat \/ (0 <= y)%nat -> (A y q) ^* = 0)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector D' H4 y 0) ^* * basis_vector D' H4 y 0)%C) D']] = 
 I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching: (cos (IPR 7 / IPR 4) < R0)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector D' H4 y 0) ^* * basis_vector D' H4 y 0)%C) D']] = 
 I 1)
Crunching: (forall x y : nat, (x >= n)%nat \/ (y >= n)%nat -> (A y x) ^* = 0)
Crunching: (H0 < N1 -> (basis_vector N1 H0) † × basis_vector N1 H0 = I 1)
find_witness Control.TimeoutCrunching: (H < l2 -> (basis_vector l2 H) † × basis_vector l2 H = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l2 nna) † × basis_vector l2 nna)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector l2 nna y 0) ^* * basis_vector l2 nna y 0)%C) l2]] =
 I 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l2 nna) † × basis_vector l2 nna)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector l2 nna y 0) ^* * basis_vector l2 nna y 0)%C) l2]] =
 I 1)
find_witness Control.TimeoutCrunching: (cos (IPR 7 / IPR 4) < R0)
out of reach
Tactic call ran for 0.006 secs (0.003u,0.003s) (failure)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((let (a, _) :=
    exist_cos
      ((R1 + (R1 + R1) * (R1 + (R1 + R1))) * (/ 2 * / (R1 + R1)) *
       ((R1 + (R1 + R1) * (R1 + (R1 + R1))) * (/ 2 * / (R1 + R1)))) in
  a) < R0)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector (S H1) H1) † × basis_vector (S H1) H1)
find_witness Control.TimeoutCrunching:
((let (a, _) :=
    exist_cos
      ((R1 + (R1 + R1) * (R1 + (R1 + R1))) * (/ 2 * / (R1 + R1)) *
       ((R1 + (R1 + R1) * (R1 + (R1 + R1))) * (/ 2 * / (R1 + R1)))) in
  a) < R0)
Crunching:
(forall d n : nat, n < d -> (basis_vector d n) † × basis_vector d n = I 1)
Crunching: (pk < k -> (basis_vector k pk) † × basis_vector k pk = I 1)
Crunching:
(lf < alpf -> (basis_vector alpf lf) † × basis_vector alpf lf = I 1)
find_witness Control.TimeoutCrunching:
(forall d n : nat, n < d -> (basis_vector d n) † × basis_vector d n = I 1)
Crunching: (pk < k -> (basis_vector k pk) † × basis_vector k pk = I 1)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector (S pk) pk) † × basis_vector (S pk) pk)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.001s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
Crunching:
(abs < Hpr -> (basis_vector Hpr abs) † × basis_vector Hpr abs = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l H1) † × basis_vector l H1)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector l H1 y 0) ^* * basis_vector l H1 y 0)%C)
       l]] = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l H1) † × basis_vector l H1)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector l H1 y 0) ^* * basis_vector l H1 y 0)%C)
       l]] = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l H1) † × basis_vector l H1)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector l H1 y 0) ^* * basis_vector l H1 y 0)%C)
       l]] = I 1)
Crunching:
(H1 < S l -> (basis_vector (S l) H1) † × basis_vector (S l) H1 = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l H1) † × basis_vector l H1)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector l H1 y 0) ^* * basis_vector l H1 y 0)%C)
       l]] = I 1)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector (S H1) H1) † × basis_vector (S H1) H1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector D' H4 y 0)
         ^*Crunching:
           (list2D_to_matrix [[e]] =
            (basis_vector D' H4) † × basis_vector D' H4)
         Crunching: (forall y : nat, (0 <= q)%nat \/ (0 <= y)%nat -> (A y q) ^* = 0)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector D' H4 y 0) ^* * basis_vector D' H4 y 0)%C) D']] = 
 I 1)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching: (forall x y : nat, (x >= n)%nat \/ (y >= n)%nat -> (A y x) ^* = 0)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector D' H4 y 0) ^* * basis_vector D' H4 y 0)%C) D']] = 
 I 1)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector D' H4 y 0) ^* * basis_vector D' H4 y 0)%C) D']] = 
 I 1)
Crunching: (H0 < N1 -> (basis_vector N1 H0) † × basis_vector N1 H0 = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S H0) H0) † × basis_vector (S H0) H0)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l2 n) † × basis_vector l2 n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector l2 n y 0) ^* * basis_vector l2 n y 0)%C)
       l2]] = I 1)
Crunching:
(forall n : nat, n < l2 -> (basis_vector l2 n) † × basis_vector l2 n = I 1)
Crunching: (H < l2 -> (basis_vector l2 H) † × basis_vector l2 H = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l2 H) † × basis_vector l2 H)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l2 nna) † × basis_vector l2 nna)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector l2 nna y 0) ^* * basis_vector l2 nna y 0)%C) l2]] =
 I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l2 nna) † × basis_vector l2 nna)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector l2 nna y 0) ^* * basis_vector l2 nna y 0)%C) l2]] =
 I 1)
Crunching:
((fun x z : nat =>
  Σ
    (fun y : nat =>
     ((basis_vector l2 nna y x) ^* * basis_vector l2 nna y z)%C) l2) =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
((fun x z : nat =>
  Σ
    (fun y : nat =>
     ((basis_vector l2 nna y x) ^* * basis_vector l2 nna y z)%C) l2) =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
((fun x z : nat =>
  Σ
    (fun y : nat =>
     ((basis_vector l2 nna y x) ^* * basis_vector l2 nna y z)%C) l2) =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching: (forall y : nat, (0 <= q)%nat \/ (0 <= y)%nat -> (A y q) ^* = 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall n : nat, n < m -> (basis_vector m n) † × basis_vector m n = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
Crunching: (interval_sum n IH H r)
Crunching: (forall x y : nat, (x >= n)%nat \/ (y >= n)%nat -> (A y x) ^* = 0)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l H1) † × basis_vector l H1)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat => ((basis_vector l H1 y 0) ^* * basis_vector l H1 y 0)%C)
       l]] = I 1)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector (S H1) H1) † × basis_vector (S H1) H1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector D' H4 y 0) ^* * basis_vector D' H4 y 0)%C) D']] = 
 I 1)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector D' H4 y 0) ^* * basis_vector D' H4 y 0)%C) D']] = 
 I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector D' H4) † × basis_vector D' H4)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector D' H4 y 0) ^* * basis_vector D' H4 y 0)%C) D']] = 
 I 1)
Crunching: (H0 < N1 -> (basis_vector N1 H0) † × basis_vector N1 H0 = I 1)
Crunching: (H < l2 -> (basis_vector l2 H) † × basis_vector l2 H = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector l2 nna) † × basis_vector l2 nna)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector l2 nna y 0) ^* * basis_vector l2 nna y 0)%C) l2]] =
 I 1)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector l2 nna) † × basis_vector l2 nna)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector l2 nna y 0) ^* * basis_vector l2 nna y 0)%C) l2]] =
 I 1)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S H1) H1) † × basis_vector (S H1) H1)
Crunching:
(forall d n : nat, n < d -> (basis_vector d n) † × basis_vector d n = I 1)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(lf < alpf -> (basis_vector alpf lf) † × basis_vector alpf lf = I 1)
Crunching:
(forall d n : nat, n < d -> (basis_vector d n) † × basis_vector d n = I 1)
Crunching: (pk < k -> (basis_vector k pk) † × basis_vector k pk = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S pk) pk) † × basis_vector (S pk) pk)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (n < a -> (basis_vector a n) † × basis_vector a n = I 1)
Crunching:
(lf < alpf -> (basis_vector alpf lf) † × basis_vector alpf lf = I 1)
Crunching:
(forall d n : nat, n < d -> (basis_vector d n) † × basis_vector d n = I 1)
Crunching: (pk < k -> (basis_vector k pk) † × basis_vector k pk = I 1)
Crunching: (forall x y : nat, (x >= n)%nat \/ (y >= n)%nat -> (A y x) ^* = 0)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S pk) pk) † × basis_vector (S pk) pk)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (r >= 0)
Crunching:
((fun x z : nat => Σ (fun y : nat => (cnot) † x y * cnot y z) 4) =
 (fun x y : nat => if (x =? y) && (x <? 4) then C1 else 0))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (p2 >= 0)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = (cnot) † × cnot)
Crunching: (forall rr r : R, interval_sum l1 l2 rr r -> r >= 0)
Crunching: (r >= 0)
find_witness Control.TimeoutCrunching:
((fun x z : nat => Σ (fun y : nat => (cnot) † x y * cnot y z) 4) =
 (fun x y : nat => if (x =? y) && (x <? 4) then C1 else 0))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = (cnot) † × cnot)
Crunching:
((fun x z : nat => Σ (fun y : nat => (cnot) † x y * cnot y z) 4) =
 (fun x y : nat => if (x =? y) && (x <? 4) then C1 else 0))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = (cnot) † × cnot)
Crunching:
(forall d n : nat, n < d -> (basis_vector d n) † × basis_vector d n = I 1)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.001s) (failure)
Crunching: (r2 - r1 > 0 \/ (r2 - r1)%R = 0)
Crunching: (r > 0 \/ r = 0)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S pk) pk) † × basis_vector (S pk) pk)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S pk) pk) † × basis_vector (S pk) pk)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
Crunching:
(forall d n : nat, n < d -> (basis_vector d n) † × basis_vector d n = I 1)
Crunching: (Ha < a -> (basis_vector a Ha) † × basis_vector a Ha = I 1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.001s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (Pure_State_Vector (basis_vector h n))
Crunching:
((fun x z : nat => Σ (fun y : nat => (cnot) † x y * cnot y z) 4) =
 (fun x y : nat => if (x =? y) && (x <? 4) then C1 else 0))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall rl rr r3 r4 : R,
 rl <= r3 <= r4 /\ r4 <= rr ->
 (forall r : R, r3 < r < r4 -> x r) ->
 (forall r : R, rl < r < r3 -> ~ x r) ->
 (forall r : R, r4 < r < rr -> ~ x r) -> r2 - r1 >= 0)
Crunching:
(forall rl rr r3 r4 : R,
 rl <= r3 <= r4 /\ r4 <= rr ->
 (forall r : R, r3 < r < r4 -> x r) ->
 (forall r : R, rl < r < r3 -> ~ x r) ->
 (forall r : R, r4 < r < rr -> ~ x r) -> r2 - r1 >= 0)
Crunching: (forall r : R, interval_sum x l y_encad4 r -> r >= 0)
Crunching: (r >= 0)
Crunching: (r >= 0)
Crunching: (r >= 0)
Crunching: (r >= 0)
Crunching: (interval_sum x l y r -> r >= 0)
Crunching: (Pure_State_Vector (basis_vector h n))
out of reach
Tactic call ran for 0.01 secs (0.002u,0.007s) (failure)
Crunching:
(WF_Matrix (basis_vector (S H3) H3) /\
 (basis_vector (S H3) H3) † × basis_vector (S H3) H3 = I 1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall rl rr r3 r4 : R,
 rl <= r3 <= r4 /\ r4 <= rr ->
 (forall r : R, r3 < r < r4 -> x r) ->
 (forall r : R, rl < r < r3 -> ~ x r) ->
 (forall r : R, r4 < r < rr -> ~ x r) -> r2 - r1 >= 0)
Crunching:
(forall rl rr r3 r4 : R,
 rl <= r3 <= r4 /\ r4 <= rr ->
 (forall r : R, r3 < r < r4 -> x r) ->
 (forall r : R, rl < r < r3 -> ~ x r) ->
 (forall r : R, r4 < r < rr -> ~ x r) -> r2 - r1 >= 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (p2 >= 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = (cnot) † × cnot)
Crunching: (a > 0)
Crunching: positive
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (forall rr r : R, interval_sum l1 l2 rr r -> r >= 0)
Crunching: positive
Crunching:
((fun x z : nat => Σ (fun y : nat => (cnot) † x y * cnot y z) 4) =
 (fun x y : nat => if (x =? y) && (x <? 4) then C1 else 0))
Crunching: (0 <> 2 -> positive)
Crunching: positive
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = (cnot) † × cnot)
Finished transaction in 16.682 secs (16.624u,0.035s) (successful)
Crunching: ((- C1 * basis_vector h 0 a n)%C = basis_vector h 0 a n)
Crunching:
(x' <= Hxx' ->
 Hxx' <= y ->
 exists r1 r2 : R,
   interval_sum x x' Hxx' r1 /\ interval_sum x Hxx' y r2 /\ y' = (r1 + r2)%R)
Crunching: (Pure_State_Vector (basis_vector h n))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(WF_Matrix (basis_vector (S H3) H3) /\
 (basis_vector (S H3) H3) † × basis_vector (S H3) H3 = I 1)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(H1 <= x <= p ->
 exists r1 r2 : R,
   interval_sum a0 H1 x r1 /\ interval_sum a0 x p r2 /\ q = (r1 + r2)%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(x' <= Hxx' ->
 Hxx' <= y ->
 exists r1 r2 : R,
   interval_sum x x' Hxx' r1 /\ interval_sum x Hxx' y r2 /\ y' = (r1 + r2)%R)
Crunching:
(x' <= Hxx' ->
 Hxx' <= y ->
 exists r1 r2 : R,
   interval_sum x x' Hxx' r1 /\ interval_sum x Hxx' y r2 /\ y' = (r1 + r2)%R)
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
Crunching:
(exists r1 r2 : R,
   interval_sum n Hn p r1 /\ interval_sum n p a r2 /\ b = (r1 + r2)%R)
Crunching:
(exists r1 r2 : R,
   interval_sum n Hn p r1 /\ interval_sum n p a r2 /\ b = (r1 + r2)%R)
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
Crunching:
(forall rr r : R,
 interval_sum H1 q rr r ->
 q <= abs <= rr ->
 exists r1 r2 : R,
   interval_sum H1 q abs r1 /\ interval_sum H1 abs rr r2 /\ r = (r1 + r2)%R)
Crunching:
(y < n /\
 ((if (y =? i) && (x =? 0) then C1 else 0%R) ^* *
  (if (y =? i) && (y =? 0) then C1 else 0%R))%C = C1 /\
 (forall x' : nat,
  x' < n ->
  y <> x' ->
  ((if (x' =? i) && (x =? 0) then C1 else 0%R) ^* *
   (if (x' =? i) && (y =? 0) then C1 else 0%R))%C = 0))
Crunching:
(interval_sum H1 q H n ->
 q <= EQ <= H ->
 exists r1 r2 : R,
   interval_sum H1 q EQ r1 /\ interval_sum H1 EQ H r2 /\ n = (r1 + r2)%R)
Crunching: (1 < 1 -> False)
Crunching: ((notc) † × notc = I (2 * 2))
Crunching: ((notc) † × notc = I (2 * 2))
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
find_witness Control.TimeoutCrunching: ((notc) † × notc = I (2 * 2))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: ((notc) † × notc = I (2 * 2))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]] = (basis_vector a b) † × basis_vector a c)
Tactic call ran for 0.033 secs (0.033u,0.s) (success)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector a b y 0) ^* * basis_vector a c y 0)%C)
       a]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S c) b) † × basis_vector (S c) c)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S c) b) † × basis_vector (S c) c)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S c) b) † × basis_vector (S c) c)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S c) b) † × basis_vector (S c) c)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector (S b) b) † × basis_vector (S b) c)
Crunching:
(cos PI2 = 0%R -> (basis_vector (S b) b) † × basis_vector (S b) c = Zero)
Crunching: (list2D_to_matrix [[e]] = (basis_vector a b) † × basis_vector a c)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector H1 H2) † × basis_vector H1 H3)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector H1 H2 y 0) ^* * basis_vector H1 H3 y 0)%C) H1]] = Zero)
find_witness Control.TimeoutCrunching:
(((basis_vector (S H2) H2) † × basis_vector (S H2) H3) x y = Zero x y)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector (S H2) H2) † × basis_vector (S H2) H3)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(list2D_to_matrix [[e]] = (basis_vector θ htemp) † × basis_vector θ cond)
Crunching:
(Set ->
 forall n : nat,
 lm < c ->
 n < c -> lm <> n -> (basis_vector c lm) † × basis_vector c n = Zero)
Crunching:
(Ha < c -> lm <> Ha -> (basis_vector c lm) † × basis_vector c Ha = Zero)
Crunching:
(r < c -> lm <> r -> (basis_vector c lm) † × basis_vector c r = Zero)
Crunching: (ConstructiveCauchyReals.CRealEq (Rrepr r1) (Rrepr r2))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = (notc) † × notc)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (ConstructiveCauchyReals.CRealEq (Rrepr r1) (Rrepr r2))
find_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall rl rr r1 r3 : R,
 rl <= r1 <= r3 /\ r3 <= rr ->
 (forall r : R, r1 < r < r3 -> x r) ->
 (forall r : R, rl < r < r1 -> ~ x r) ->
 (forall r : R, r3 < r < rr -> ~ x r) -> (r3 + - r1)%R = r2)
Crunching:
(forall rl rr r1 r3 : R,
 rl <= r1 <= r3 /\ r3 <= rr ->
 (forall r : R, r1 < r < r3 -> x r) ->
 (forall r : R, rl < r < r1 -> ~ x r) ->
 (forall r : R, r3 < r < rr -> ~ x r) -> (r3 + - r1)%R = r2)
Crunching: (list2D_to_matrix [[e]] = (basis_vector a b) † × basis_vector a c)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector a b y 0) ^* * basis_vector a c y 0)%C)
       a]] = Zero)
Crunching: (list2D_to_matrix [[e]] = (basis_vector a b) † × basis_vector a c)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector a b y 0) ^* * basis_vector a c y 0)%C)
       a]] = Zero)
Crunching: (list2D_to_matrix [[e]] = (basis_vector a b) † × basis_vector a c)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector a b y 0) ^* * basis_vector a c y 0)%C)
       a]] = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S c) b) † × basis_vector (S c) c)
Crunching: ((notc) † × notc = I (2 * 2))
Crunching:
(cos PI2 = 0%R -> (basis_vector (S c) b) † × basis_vector (S c) c = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S c) b) † × basis_vector (S c) c)
Crunching: (r1 = r2)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S c) b) † × basis_vector (S c) c)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S c) b) † × basis_vector (S c) c)
Crunching:
((fun x z : nat => Σ (fun y : nat => (notc) † x y * notc y z) 4) =
 (fun x y : nat => if (x =? y) && (x <? 4) then C1 else 0))
Crunching: (forall x : R, - PI / 2 < x < PI / 2 -> derivable_pt tan x)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = (notc) † × notc)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = (notc) † × notc)
Crunching: ((notc) † × notc = I (2 * 2))
Crunching: (WF_Unitary notc)
Finished transaction in 68.173 secs (27.323u,0.44s) (successful)
Crunching:
(forall r2 : R, interval_sum x a b c0 -> interval_sum x a b r2 -> c0 = r2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (r1 = r2)
Crunching:
(forall y : nat,
 H11 >= 1 \/ y >= 1 ->
 ((basis_vector (S b) b) † × basis_vector (S b) c) H11 y = 0%R)
Crunching: (ConstructiveCauchyReals.CRealEq (Rrepr r1) (Rrepr r2))
Crunching: (Hnm - d1 <= Hpq <= Hnm + d2)
clear  IHn  :  (False -> 1 <= 0 /\ y = y)
Finished transaction in 7.179 secs (7.045u,0.085s) (successful)
Crunching:
(env > 0 ->
 t > 0 -> Rabs (Hpq - Hnm) < Rmin env t -> Hnm - env <= Hpq <= Hnm + t)
Finished transaction in 0.022 secs (0.022u,0.s) (successful)
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
Crunching:
(forall y : nat,
 H11 >= 1 \/ y >= 1 ->
 ((basis_vector (S b) b) † × basis_vector (S b) c) H11 y = 0%R)
Finished transaction in 1.771 secs (1.759u,0.007s) (successful)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S b) b) † × basis_vector (S b) c)
Tactic call ran for 0.015 secs (0.011u,0.003s) (success)
Crunching:
(cos PI2 = 0%R -> (basis_vector (S b) b) † × basis_vector (S b) c = Zero)
Crunching:
(Σ (fun y0 : nat => (notc) † x y0 * notc y0 (S y)) (2 * 2) =
 (if (x =? S y) && (x <? 2 * 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S b) b) † × basis_vector (S b) c)
Crunching: (list2D_to_matrix [[e]] = (basis_vector a b) † × basis_vector a c)
Crunching: ((r3 - r0)%R = r2)
Crunching: (list2D_to_matrix [[e]] = (basis_vector a b) † × basis_vector a c)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector a b y 0) ^* * basis_vector a c y 0)%C)
       a]] = Zero)
Crunching:
((if (x =? S y) && (x <? 2 * 2) then C1 else 0) =
 Σ (fun y0 : nat => (notc) † x y0 * notc y0 (S y)) (2 * 2))
Crunching:
(frac_part r1 >= 0 ->
 frac_part r1 < 1 ->
 (forall r : R, Compat < r < P -> ~ x r) -> (Compat - l)%R = r2)
Crunching:
(Σ (fun y0 : nat => (notc) † x y0 * notc y0 (S y)) (2 * 2) =
 (if (x =? S y) && (x <? 2 * 2) then C1 else 0))
Crunching:
(((basis_vector (S H2) H2) † × basis_vector (S H2) H3) x y = Zero x y)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector H1 H2) † × basis_vector H1 H3)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector H1 H2 y 0) ^* * basis_vector H1 H3 y 0)%C) H1]] = Zero)
clear  IHn  :  (False -> 1 <= 0 /\ x = y)
Crunching:
(((basis_vector (S H2) H2) † × basis_vector (S H2) H3) x y = Zero x y)
Crunching:
(((basis_vector (S H2) H2) † × basis_vector (S H2) H3) x y = Zero x y)
Crunching: (WF_Unitary (I H10))
Crunching:
(forall r3 : R,
 Hyp2 <= l <= r3 /\ r3 <= P ->
 (forall r : R, l < r < r3 -> x r) ->
 (forall r : R, Hyp2 < r < l -> ~ x r) ->
 (forall r : R, r3 < r < P -> ~ x r) -> (r3 - l)%R = r2)
Crunching:
(forall r3 : R,
 Hyp2 <= l <= r3 /\ r3 <= P ->
 (forall r : R, l < r < r3 -> x r) ->
 (forall r : R, Hyp2 < r < l -> ~ x r) ->
 (forall r : R, r3 < r < P -> ~ x r) -> (r3 - l)%R = r2)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (WF_Unitary (I H10))
Crunching:
(((basis_vector (S H2) H2) † × basis_vector (S H2) H3) x y = Zero x y)
find_witness Control.TimeoutCrunching: (WF_Unitary (I H10))
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S H2) H2) † × basis_vector (S H2) H3)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector H1 H2) † × basis_vector H1 H3)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector H1 H2) † × basis_vector H1 H3)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector H1 H2 y 0) ^* * basis_vector H1 H3 y 0)%C) H1]] = Zero)
Crunching: (H2 <> H3 -> (basis_vector H1 H2) † × basis_vector H1 H3 = Zero)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.TimeoutCrunching: (WF_Unitary (I H10))
Crunching:
((forall r : R, H1 < r < H3 -> x r) ->
 (forall r : R, H'0 < r < H1 -> ~ x r) ->
 (forall r : R, H3 < r < l -> ~ x r) -> (H3 - H1)%R = r2)
Crunching: (forall x : nat, x < n -> (A i x * basis_vector n j x 0)%C = 0)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Crunching:
(k <= greater <= Hx /\ Hx <= pk ->
 (forall r : R, greater < r < Hx -> x r) ->
 (forall r : R, k < r < greater -> ~ x r) ->
 (forall r : R, Hx < r < pk -> ~ x r) -> (Hx - greater)%R = r2)
Crunching: (WF_Unitary (I 0))
Tactic call ran for 0.013 secs (0.013u,0.s) (success)
Tactic call ran for 0.011 secs (0.011u,0.s) (success)
Axioms:
ClassicalDedekindReals.sig_not_dec : forall P : Prop, {~ ~ P} + {~ P}
ClassicalDedekindReals.sig_forall_dec
  : forall P : nat -> Prop,
    (forall n : nat, {P n} + {~ P n}) ->
    {n : nat | ~ P n} + {forall n : nat, P n}
prop_ext : ClassicalFacts.prop_extensionality
lib.Axioms.proof_irr : ClassicalFacts.proof_irrelevance
Clight_core.inline_external_call_mem_events
  : forall (ef : external_function) (ge : Senv.t) 
      (vargs : list val) (m : mem) (t : Events.trace) 
      (vres : val) (m' : mem),
    ef_inline ef = true ->
    Events.external_call ef ge vargs m t vres m' ->
    {trace : list event_semantics.mem_event
    | event_semantics.ev_elim m trace m'}
Events.inline_assembly_sem : string -> signature -> Events.extcall_sem
functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Events.external_functions_sem : string -> signature -> Events.extcall_sem
Eqdep.Eq_rect_eq.eq_rect_eq
  : forall (U : Type) (p : U) (Q : U -> Type) (x : Q p) (h : p = p),
    x = eq_rect p Q x p h
Classical_Prop.classic : forall P : Prop, P \/ ~ P
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: ((I n) † × I n = I n)
Crunching: ((I q) † × I q = I q)
Tactic call ran for 0.011 secs (0.011u,0.s) (success)
find_witness Control.TimeoutCrunching: ((I H7) † × I H7 = I H7)
find_witness Control.TimeoutCrunching: (WF_Unitary (I H10))
Crunching: ((I b) † × I b = I b)
find_witness Control.TimeoutCrunching: ((A i z * basis_vector n j z 0)%C = 0)
find_witness Control.TimeoutCrunching: (forall x : nat, x < n -> (A i x * basis_vector n j x 0)%C = 0)
Crunching: ((A i z * basis_vector n j z 0)%C = 0)
Crunching: (forall x : nat, x < n -> (A i x * basis_vector n j x 0)%C = 0)
test : forall a b : word, foo a b = foo b a

test is not universe polymorphic
Arguments test a b
test is opaque
Expands to: Constant bedrock2Examples.LiveVerif.swap.LiveVerif.test
Crunching: ((A i z * basis_vector n j z 0)%C = 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (forall x : nat, x < n -> (A i x * basis_vector n j x 0)%C = 0)
find_witness Control.TimeoutCrunching: ((A i z * basis_vector n j z 0)%C = 0)
Crunching: (forall x : nat, x < n -> (A i x * basis_vector n j x 0)%C = 0)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: ((swap) † × swap = I (2 * 2))
Crunching: ((A i z * basis_vector n j z 0)%C = 0)
Crunching:
((fun x z : nat =>
  0 + (swap) † x 0%nat * match z with
                         | 0%nat => C1
                         | S _ => 0
                         end +
  (swap) † x 1%nat * match z with
                     | 2%nat => C1
                     | _ => 0
                     end +
  (swap) † x 2%nat * match z with
                     | 1%nat => C1
                     | _ => 0
                     end +
  (swap) † x 3%nat * match z with
                     | 3%nat => C1
                     | _ => 0
                     end) =
 (fun x y : nat => if (x =? y) && (x <? 4) then C1 else 0))
Crunching: ((swap) † × swap = I (2 * 2))
Crunching: (forall x : nat, x < n -> (A i x * basis_vector n j x 0)%C = 0)
Crunching:
((fun x z : nat =>
  0 + (swap) † x 0%nat * match z with
                         | 0%nat => C1
                         | S _ => 0
                         end +
  (swap) † x 1%nat * match z with
                     | 2%nat => C1
                     | _ => 0
                     end +
  (swap) † x 2%nat * match z with
                     | 1%nat => C1
                     | _ => 0
                     end +
  (swap) † x 3%nat * match z with
                     | 3%nat => C1
                     | _ => 0
                     end) =
 (fun x y : nat => if (x =? y) && (x <? 4) then C1 else 0))
Crunching: ((swap) † × swap = I (2 * 2))
Crunching: (forall x : nat, x < n -> (A i x * basis_vector n j x 0)%C = 0)
test :
forall {word : word 32}, word.ok word -> forall a b : word, foo a b = foo b a

test is not universe polymorphic
Arguments test {word word_ok} a b
test is opaque
Expands to: Constant bedrock2Examples.LiveVerif.swap.test
Crunching: ((swap) † × swap = I (2 * 2))
Crunching: ((/ √ 2)%R = 0)
Crunching:
((fun x z : nat =>
  0 + (swap) † x 0%nat * match z with
                         | 0%nat => C1
                         | S _ => 0
                         end +
  (swap) † x 1%nat * match z with
                     | 2%nat => C1
                     | _ => 0
                     end +
  (swap) † x 2%nat * match z with
                     | 1%nat => C1
                     | _ => 0
                     end +
  (swap) † x 3%nat * match z with
                     | 3%nat => C1
                     | _ => 0
                     end) =
 (fun x y : nat => if (x =? y) && (x <? 4) then C1 else 0))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: ((swap) † × swap = I (2 * 2))
find_witness Control.TimeoutCrunching:
(Morphisms.respectful ?R2 eq (Σ (fun y : nat => (swap) † x y * swap y 0%nat))
   (I (2 * 2) x))
Crunching:
(WF_Matrix Ha ->
 (forall k : nat, k < a -> b × basis_vector a k = Ha × basis_vector a k) ->
 b = Ha)
Crunching: (∣1⟩ = basis_vector 2 1)
find_witness Control.TimeoutCrunching: (c0 = p)
Crunching: (0 < 0)
Crunching: (0 < 0)
Crunching: (0 < 0)
Crunching:
(interval_sum (fun rnd : R => HA (sample H rnd) = true) 
   (√ 0) r (pr_outcome_sum H HA))
Crunching:
(interval_sum (fun rnd : R => HA (sample H rnd) = true) 
   (√ 0) r (pr_outcome_sum H HA))
Crunching:
(interval_sum (fun rnd : R => HA (sample H rnd) = true) 
   (√ 0) r (pr_outcome_sum H HA))
Crunching:
(interval_sum (fun rnd : R => HA (sample H rnd) = true) 
   (√ 0) r (pr_outcome_sum H HA))
Crunching:
(interval_sum (fun rnd : R => HA (sample H rnd) = true) 
   (√ 0) r (pr_outcome_sum H HA))
Crunching:
(interval_sum (fun rnd : R => HA (sample H rnd) = true) 
   (√ 0) r (pr_outcome_sum H HA))
find_witness Control.TimeoutCrunching:
(interval_sum (fun rnd : R => HA (sample H rnd) = true) 
   (/ 2 * 0) r (pr_outcome_sum H HA))
out of reach
Tactic call ran for 0.018 secs (0.008u,0.01s) (failure)
out of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.013 secs (0.011u,0.002s) (failure)
Crunching: (Rabs q < Rabs x -> x > 0 -> q < x)
Crunching: (forall x y : R, Rabs x < Rabs y -> y > 0 -> x < y)
out of reach
Tactic call ran for 0.01 secs (0.009u,0.s) (failure)
out of reach
Tactic call ran for 0.013 secs (0.012u,0.s) (failure)
out of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
Crunching: ((swap) † × swap = I (2 * 2))
out of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
out of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
out of reach
Tactic call ran for 0.01 secs (0.009u,0.s) (failure)
out of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
out of reach
Tactic call ran for 0.009 secs (0.009u,0.s) (failure)
Crunching:
(0 + (swap) † x 0%nat * match x with
                        | 0%nat => C1
                        | S _ => 0
                        end +
 (swap) † x 1%nat * match x with
                    | 2%nat => C1
                    | _ => 0
                    end +
 (swap) † x 2%nat * match x with
                    | 1%nat => C1
                    | _ => 0
                    end +
 (swap) † x 3%nat * match x with
                    | 3%nat => C1
                    | _ => 0
                    end = (if true && (x <? 4) then C1 else 0))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
out of reach
Tactic call ran for 0.01 secs (0.009u,0.s) (failure)
Crunching:
(0 + (swap) † y 0%nat * match y with
                        | 0%nat => C1
                        | S _ => 0
                        end +
 (swap) † y 1%nat * match y with
                    | 2%nat => C1
                    | _ => 0
                    end +
 (swap) † y 2%nat * match y with
                    | 1%nat => C1
                    | _ => 0
                    end +
 (swap) † y 3%nat * match y with
                    | 3%nat => C1
                    | _ => 0
                    end = (if (y =? y) && (y <? 4) then C1 else 0))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(forall A B : Matrix Hy k,
 (forall x y : nat, x >= Hy \/ y >= k -> A x y = 0%R) ->
 (forall x y : nat, x >= Hy \/ y >= k -> B x y = 0%R) ->
 (forall k0 : nat, k0 < k -> A × basis_vector k k0 = B × basis_vector k k0) ->
 A = B)
Crunching: (forall n : nat, ~ WF_Unitary Zero)
Crunching: (HF = B)
Crunching: (forall n : nat, ~ WF_Unitary Zero)
Crunching: (forall n : nat, ~ WF_Unitary Zero)
Crunching:
(interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 r
   (pr_outcome_sum f Hf))
find_witness Control.TimeoutCrunching: (sum_over_list f <> N0)
out of reach
Tactic call ran for 0.012 secs (0.011u,0.001s) (failure)
out of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
Crunching:
(0 < 0 ->
 interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 l
   (pr_outcome_sum f Hf))
Crunching: (forall n : nat, ~ WF_Unitary Zero)
find_witness Control.TimeoutFinished transaction in 117.988 secs (117.662u,0.314s) (successful)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(distribution l1 ->
 pr_P (fun rnd : R => l2 (sample l1 rnd) = true) (pr_outcome_sum l1 l2))
Crunching:
(forall f : nat -> bool,
 distribution [] ->
 pr_P (fun rnd : R => f (sample [] rnd) = true) (pr_outcome_sum [] f))
Crunching:
(distribution l1 ->
 pr_P (fun rnd : R => l2 (sample l1 rnd) = true) (pr_outcome_sum l1 l2))
Crunching:
(forall f : nat -> bool,
 distribution [] ->
 pr_P (fun rnd : R => f (sample [] rnd) = true) (pr_outcome_sum [] f))
Crunching: (Nat.odd n = true -> n = x * z + y <-> n / z = x /\ n mod z = y)
Crunching:
(forall f : nat -> bool,
 distribution [] ->
 pr_P (fun rnd : R => f (sample [] rnd) = true) (pr_outcome_sum [] f))
Crunching:
(forall f : nat -> bool,
 distribution H ->
 pr_P (fun rnd : R => f (sample H rnd) = true) (pr_outcome_sum H f))
FlattenExpr: flattenBooleanExpr_correct_aux done
out of reach
Tactic call ran for 0.011 secs (0.01u,0.s) (failure)
out of reach
Tactic call ran for 0.01 secs (0.01u,0.s) (failure)
Crunching:
(distribution l1 ->
 pr_P (fun rnd : R => l2 (sample l1 rnd) = true) (pr_outcome_sum l1 l2))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(interval_sum (fun _ : R => Hb 0%nat = true) 0 1
   (big_sum (fun i : nat => if Hb i then nth i [] 0 else 0) (length [])))
Crunching:
(forall f : nat -> bool,
 distribution [] ->
 pr_P (fun rnd : R => f (sample [] rnd) = true) (pr_outcome_sum [] f))
Crunching: (a = b * Ha + q <-> a / Ha = b /\ a mod Ha = q)
out of reach
Tactic call ran for 0.005 secs (0.004u,0.s) (failure)
Crunching:
(forall f : nat -> bool,
 distribution [] ->
 pr_P (fun rnd : R => f (sample [] rnd) = true) (pr_outcome_sum [] f))
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
find_witness Control.TimeoutCrunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
find_witness Control.TimeoutCrunching:
(distribution H ->
 pr_P (fun rnd : R => IHP' (sample H rnd) = true) (pr_outcome_sum H IHP'))
Crunching:
(forall f : nat -> bool,
 distribution H ->
 pr_P (fun rnd : R => f (sample H rnd) = true) (pr_outcome_sum H f))
Crunching: (m / r = n /\ m mod r = H)
Crunching: (m / r = n /\ m mod r = H)
Crunching: (m / r = n /\ m mod r = H)
Crunching: ((fun _ : cos_in 0 1 => False) a)
Crunching: (forall n : nat, ~ WF_Unitary Zero)
Crunching:
((forall x y : nat, (1 <= x)%nat \/ (1 <= y)%nat -> (R0, R0) = (R0, R0)) /\
 (fun _ _ : nat =>
  ((R0 + (R0 * R0 + - (- R0 * R0)))%R, (R0 + (R0 * R0 + - R0 * R0))%R)) =
 (fun x y : nat =>
  if
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0%nat => match m with
                  | 0%nat => true
                  | S _ => false
                  end
       | S n' => match m with
                 | 0%nat => false
                 | S m' => eqb n' m'
                 end
       end) x y
   then
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0%nat => true
       | S n' => match m with
                 | 0%nat => false
                 | S m' => leb n' m'
                 end
       end) x 0%nat
   else false
  then (R1, R0)
  else (R0, R0)) -> False)
find_witness Control.TimeoutCrunching:
(distribution l1 ->
 pr_P (fun rnd : R => l2 (sample l1 rnd) = true) (pr_outcome_sum l1 l2))
Crunching:
(forall (A : Square m) (B : Square X_enc),
 WF_Unitary A ->
 WF_Unitary B -> WF_Matrix (A ⊗ B) /\ (A ⊗ B) † × (A ⊗ B) = I (m * X_enc))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(interval_sum (fun _ : R => Hb 0%nat = true) 0 1
   (big_sum (fun i : nat => if Hb i then nth i [] 0 else 0) (length [])))
Crunching:
(forall f : nat -> bool,
 distribution [] ->
 pr_P (fun rnd : R => f (sample [] rnd) = true) (pr_outcome_sum [] f))
Crunching:
(forall (A : Square m) (B : Square X_enc),
 WF_Unitary A ->
 WF_Unitary B -> WF_Matrix (A ⊗ B) /\ (A ⊗ B) † × (A ⊗ B) = I (m * X_enc))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching:
(WF_Unitary n -> WF_Matrix (H1 ⊗ n) /\ (H1 ⊗ n) † × (H1 ⊗ n) = I (m * X_enc))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching:
(WF_Unitary H ->
 WF_Unitary B -> WF_Matrix (H ⊗ B) /\ (H ⊗ B) † × (H ⊗ B) = I (m * X_enc))
Crunching:
(WF_Unitary x -> WF_Matrix (H ⊗ x) /\ (H ⊗ x) † × (H ⊗ x) = I (m * X_enc))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching:
(WF_Unitary H ->
 WF_Unitary Hfalse ->
 WF_Matrix (H ⊗ Hfalse) /\ (H ⊗ Hfalse) † × (H ⊗ Hfalse) = I (m * X_enc))
Crunching:
(WF_Unitary x0 -> WF_Matrix (H ⊗ x0) /\ (H ⊗ x0) † × (H ⊗ x0) = I (m * X_enc))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching:
(WF_Unitary Hc ->
 WF_Unitary n0 ->
 WF_Matrix (Hc ⊗ n0) /\ (Hc ⊗ n0) † × (Hc ⊗ n0) = I (m * X_enc))
Crunching:
(WF_Unitary env ->
 WF_Matrix (Hc ⊗ env) /\ (Hc ⊗ env) † × (Hc ⊗ env) = I (m * X_enc))
Crunching:
(WF_Unitary a -> WF_Matrix (Hc ⊗ a) /\ (Hc ⊗ a) † × (Hc ⊗ a) = I (m * X_enc))
Crunching:
(WF_Unitary A ->
 WF_Unitary H -> WF_Matrix (A ⊗ H) /\ (A ⊗ H) † × (A ⊗ H) = I (m * X_enc))
Crunching:
(WF_Unitary H -> WF_Matrix (A ⊗ H) /\ (A ⊗ H) † × (A ⊗ H) = I (m * X_enc))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching:
(WF_Unitary H -> WF_Matrix (A ⊗ H) /\ (A ⊗ H) † × (A ⊗ H) = I (m * X_enc))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching: (interval_sum ?P1 0 1 (pr_outcome_sum H IHP'))
Crunching:
(WF_Matrix b -> (b) † × b = I X_enc -> 0%nat <> 2%nat -> WF_Unitary (a ⊗ b))
Crunching: (WF_Unitary (a ⊗ b))
Crunching:
((forall n : nat, S n = n + 1) ->
 basis_vector (2 ^ (m + n)) (x * 2 ^ n + y) =
 basis_vector (S x) x ⊗ basis_vector (2 ^ n) y)
Crunching:
(exists r0 : R,
   0 <= r0 <= r /\ pr_P (fun rnd : R => RS' (sample x rnd) = true) r0)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: ((n ⊗ NEQ) h hn0 = 0)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (WF_Matrix Hn -> (Hn) † × Hn = I b -> WF_Unitary (n ⊗ Hn))
find_witness Control.TimeoutCrunching:
(pr_outcome_sum [] f <= r ->
 exists r0 : R,
   0 <= r0 <= r /\ pr_P (fun rnd : R => f (sample [] rnd) = true) r0)
Crunching:
((if
   if
    (fix Ffix (x x0 : nat) {struct x} : bool :=
       match x with
       | 0 => match x0 with
              | 0 => true
              | S _ => false
              end
       | S x1 => match x0 with
                 | 0 => false
                 | S x2 => Ffix x1 x2
                 end
       end) H2
      ((fix Ffix (x x0 : nat) {struct x} : nat :=
          match x with
          | 0 => x0
          | S x1 => S (Ffix x1 x0)
          end)
         ((fix Ffix (x x0 : nat) {struct x} : nat :=
             match x with
             | 0 => 0
             | S x1 =>
                 (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                    match x2 with
                    | 0 => x3
                    | S x4 => S (Ffix0 x4 x3)
                    end) x0 (Ffix x1 x0)
             end) x 1) 0)
   then
    (fix Ffix (x x0 : nat) {struct x} : bool :=
       match x with
       | 0 => match x0 with
              | 0 => true
              | S _ => false
              end
       | S x1 => match x0 with
                 | 0 => false
                 | S x2 => Ffix x1 x2
                 end
       end) y 0
   else false
  then (R1, R0)
  else (R0, R0)) = (R0, R0))
Crunching: (basis_vector (2 ^ m * 2 ^ 0) (x * 2 ^ 0 + 0) H2 y = 0%R)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(pr_outcome_sum Hc x <= a ->
 exists r0 : R,
   0 <= r0 <= a /\ pr_P (fun rnd : R => x (sample Hc rnd) = true) r0)
Crunching: (WF_Unitary (⨂ n))
Crunching: (basis_vector (2 ^ m * 2 ^ 0) (x * 2 ^ 0 + 0) H2 y = 0%R)
Crunching: (basis_vector (2 ^ m * 2 ^ 0) (x * 2 ^ 0 + 0) H2 y = 0%R)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.TimeoutCrunching: (WF_Unitary (⨂ n))
Crunching:
(forall y : nat,
 (lm >= r3 ^ length ls)%nat \/ (y >= r3 ^ length ls)%nat -> (⨂ ls) lm y = 0)
find_witness Control.TimeoutCrunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(exists r0 : R,
   0 <= r0 <= b /\ pr_P (fun rnd : R => n (sample l' rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= b /\ pr_P (fun rnd : R => n (sample l' rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= b /\ pr_P (fun rnd : R => n (sample l' rnd) = true) r0)
Tactic call ran for 0.009 secs (0.001u,0.008s) (success)
Crunching:
(exists r0 : R,
   0 <= r0 <= r /\ pr_P (fun rnd : R => RS' (sample x rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= r /\ pr_P (fun rnd : R => RS' (sample x rnd) = true) r0)
Crunching:
(forall r : R,
 distribution x ->
 pr_outcome_sum x RS' <= r ->
 exists r0 : R,
   0 <= r0 <= r /\ pr_P (fun rnd : R => RS' (sample x rnd) = true) r0)
Crunching: (forall f : nat -> bool, funbool_to_nat ϕ f < 2 ^ ϕ)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (WF_Unitary (⨂ n))
Crunching:
(forall y : nat,
 (lm >= r3 ^ length ls)%nat \/ (y >= r3 ^ length ls)%nat -> (⨂ ls) lm y = 0)
Crunching: (funbool_to_nat LT n < S (1 * 1) ^ LT)
Crunching: (z2 = H)
Crunching: (forall y : R, H0 <> y <-> y <> H0)
Crunching: (continuity_pt sqrt R1 -> pr_P a Hyp -> n = Hyp)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Crunching:
(forall y : nat,
 (H3 >= r3 ^ length Hnd)%nat \/ (y >= r3 ^ length Hnd)%nat -> a H3 y = 0)
find_witness Control.TimeoutCrunching:
(S
   ((fix Ffix (x : list bool) : nat :=
       match x with
       | [] => 0
       | x0 :: x1 =>
           (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (if x0 then 1 else 0)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1)
                ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                    match x2 with
                    | 0 => x3
                    | S x4 => S (Ffix0 x4 x3)
                    end) (Ffix x1) 0))
       end)
      ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
          match x with
          | 0 => []
          | S x1 => x0 x1 :: Ffix x1 x0
          end) LS' HP)) <=
 (fix Ffix (x x0 : nat) {struct x0} : nat :=
    match x0 with
    | 0 => 1
    | S x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => 0
           | S x4 =>
               (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                  match x5 with
                  | 0 => x6
                  | S x7 => S (Ffix1 x7 x6)
                  end) x3 (Ffix0 x4 x3)
           end) x (Ffix x x1)
    end) 2 LS')
Crunching: (forall f : nat -> bool, funbool_to_nat ϕ f < 2 ^ ϕ)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(forall r2 : R,
 0 <= An <= r2 /\ r2 <= 1 ->
 (forall r : R, An < r < r2 -> Un r) ->
 (forall r : R, r2 < r < 1 -> ~ Un r) -> (r2 - An)%R = l2 -> l1 = (r2 - An)%R)
Crunching: (l1 = (r2 - r1)%R)
Crunching: ((l1 + 0)%R = l2)
Crunching: ((l1 + 0)%R = l2)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (l1 = (r2 - r1)%R)
Crunching: ((l1 + 0)%R = l2)
Crunching:
(forall y : nat,
 (lm >= r3 ^ length ls)%nat \/ (y >= r3 ^ length ls)%nat -> (⨂ ls) lm y = 0)
find_witness Control.TimeoutCrunching: ((l1 + 0)%R = l2)
Crunching: ((l1 + 0)%R = l2)
Crunching: ((l1 + 0)%R = l2)
Crunching: ((l1 + 0)%R = l2)
Crunching: (r1 = (- - r2)%R)
Crunching: (z2 = H)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (m = Hm)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (forall y : R, H0 <> y <-> y <> H0)
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (continuity_pt sqrt R1 -> pr_P a Hyp -> n = Hyp)
Crunching: (continuity_pt sqrt R1 -> pr_P a Hyp -> n = Hyp)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (0 < - (l / 2) -> ~ X <= l1 -> X > l1)
Crunching: (0 < - (l / 2) -> ~ X <= l1 -> X > l1)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(pr_outcome_sum l t = delta ->
 interval_sum (fun rnd : R => t (sample l rnd) = true) 0 1 delta)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (funbool_to_nat n m = funbool_to_nat n H1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (∣1⟩ = basis_vector 2 1)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (∣1⟩ = basis_vector 2 1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (WF_Matrix (I 1))
Crunching:
(distribution l ->
 pr_outcome_sum l t = n <-> pr_P (fun rnd : R => t (sample l rnd) = true) n)
Crunching:
(pr_outcome_sum l t = delta ->
 interval_sum (fun rnd : R => t (sample l rnd) = true) 0 1 delta)
Crunching: (WF_Matrix (I 1))
Crunching:
(pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
find_witness Control.TimeoutCrunching:
(forall B : Square e1,
 WF_Matrix e2 /\ (e2) † × e2 = I e1 ->
 WF_Matrix B /\ (B) † × B = I e1 ->
 WF_Matrix (e2 × B) /\ (e2 × B) † × (e2 × B) = I e1)
Crunching:
(pr_outcome_sum [] f = r -> pr_P (fun rnd : R => f (sample [] rnd) = true) r)
Crunching:
(pr_outcome_sum Ryx y = H2 <->
 pr_P (fun rnd : R => y (sample Ryx rnd) = true) H2)
Crunching:
(pr_outcome_sum Ryx y = alp_f2 <->
 pr_P (fun rnd : R => y (sample Ryx rnd) = true) alp_f2)
Crunching: (Forall (fun x : R => 0 <= x) (Cmod2 a :: map Cmod2 l))
Crunching: (Forall (fun x : R => 0 <= x) (map Cmod2 (a :: l)))
Crunching: (Forall (fun x : R => 0 <= x) (Cmod2 a :: map Cmod2 l))
Crunching: (Forall (fun x : R => 0 <= x) (map Cmod2 (a :: l)))
find_witness Control.TimeoutCrunching: (Forall (fun x : R => 0 - 0 - (0 - 0) <= x) (map Cmod2 (a :: l)))
Crunching: (Forall (fun x : R => 0 <= x) (Cmod2 a :: map Cmod2 l))
Crunching: (Forall (fun x : R => 0 <= x) (map Cmod2 (a :: l)))
Crunching: (Forall (fun x : R => 0 <= x) (Cmod2 a :: map Cmod2 l))
Tactic call ran for 0.014 secs (0.009u,0.005s) (success)
Crunching: (Forall (fun x : R => 0 <= x) (map Cmod2 Maj1))
     = ("swap",
        (["c1"; "c2"], [], bedrock_func_body:(
           $"v1" = load($"c1");
           $"v2" = load($"c2");
           store($"c1", $"v2");
           store($"c2", $"v1"))))
     : bedrock_func
Crunching: (Forall (fun x : R => 0 - 0 - (0 - 0) <= x) (map Cmod2 (a :: l)))
Tactic call ran for 0.007 secs (0.006u,0.s) (success)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (Forall (fun x : R => 0 <= x) (Cmod2 a :: map Cmod2 l))
Crunching: (Forall (fun x : R => 0 <= x) (map Cmod2 (a :: l)))
Crunching: (Forall (fun x : R => 0 <= x) (Cmod2 a :: map Cmod2 l))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (Forall (fun x : R => 0 <= x) (Cmod2 a :: map Cmod2 l))
Crunching: (Forall (fun x : R => 0 <= x) (map Cmod2 (a :: l)))
Crunching: (Forall (fun x : R => 0 <= x) (Cmod2 a :: map Cmod2 l))
find_witness Control.TimeoutCrunching: (Forall (fun x : R => 0 <= x) (Cmod2 a :: map Cmod2 l))
Crunching: (Forall (fun x : R => 0 <= x) (map Cmod2 (a :: l)))
Crunching: (Forall (fun x : R => 0 <= x) (Cmod2 a :: map Cmod2 l))
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Tactic call ran for 0.01 secs (0.008u,0.002s) (success)
find_witness Control.TimeoutCrunching:
(forall A : Square 0, WF_Unitary A -> a * a ^* = C1 -> WF_Unitary (a .* A))
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
find_witness Control.TimeoutCrunching: (0 < m -> S EQ + S m <= S EQ * S m)
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
find_witness Control.TimeoutCrunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching: (Forall (fun x : R => 0 <= x) (map Cmod2 Maj1))
Crunching: (Forall (fun x : R => 0 <= x) (map Cmod2 Maj1))
Crunching: (Forall (fun x : R => 0 <= x) (map Cmod2 Maj1))
Crunching: (Forall (fun x : R => 0 - 0 - (0 - 0) <= x) (map Cmod2 (a :: l)))
     = ("nondet_sum",
        (["b"], ["out"], bedrock_func_body:(
           $"x" = load($"b");
           $"y" = load($"b");
           $"out" = $"x" + $"y")))
     : bedrock_func
Crunching:
((fix f_to_vec (n : nat) (f : nat -> bool) {struct n} :
      nat -> nat -> R * R :=
    match n with
    | 0 =>
        fun x y : nat =>
        if
         if
          (fix eqb (n0 m : nat) {struct n0} : bool :=
             match n0 with
             | 0 => match m with
                    | 0 => true
                    | S _ => false
                    end
             | S n' => match m with
                       | 0 => false
                       | S m' => eqb n' m'
                       end
             end) x y
         then
          (fix leb (n0 m : nat) {struct n0} : bool :=
             match n0 with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) x 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S n' =>
        fun x y : nat =>
        (((let (x0, _) :=
             f_to_vec n' f
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) x 1%nat 0%nat 1%nat in
                x0)
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) y 0%nat 0%nat 0%nat in
                x0) in
           x0) *
          (let (x0, _) :=
             (if
               (fix eqb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => match m with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S n'0 =>
                      match m with
                      | 0%nat => false
                      | S m' => eqb n'0 m'
                      end
                  end) (if f n' then 1%nat else 0%nat) 0%nat
              then
               fun x0 y0 : nat =>
               match x0 with
               | 0%nat =>
                   match y0 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match y0 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x0 y0 : nat =>
               match x0 with
               | 0%nat => match y0 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match y0 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, y0) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) x 1%nat 0%nat 1%nat in
                  y0)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           x0) +
          -
          ((let (_, y0) :=
              f_to_vec n' f
                (let (x0, _) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 x0)
                (let (x0, _) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) y 0%nat 0%nat 0%nat in
                 x0) in
            y0) *
           (let (_, y0) :=
              (if
                (fix eqb (n0 m : nat) {struct n0} : bool :=
                   match n0 with
                   | 0%nat => match m with
                              | 0%nat => true
                              | S _ => false
                              end
                   | S n'0 =>
                       match m with
                       | 0%nat => false
                       | S m' => eqb n'0 m'
                       end
                   end) (if f n' then 1%nat else 0%nat) 0%nat
               then
                fun x0 y0 : nat =>
                match x0 with
                | 0%nat =>
                    match y0 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match y0 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x0 y0 : nat =>
                match x0 with
                | 0%nat => match y0 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match y0 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, y0) :=
                     (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                        match x0 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y0 (S q) y0
                            | S u' => divmod x' y0 q u'
                            end
                        end) x 1%nat 0%nat 1%nat in
                   y0)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            y0)))%R,
         ((let (x0, _) :=
             f_to_vec n' f
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) x 1%nat 0%nat 1%nat in
                x0)
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) y 0%nat 0%nat 0%nat in
                x0) in
           x0) *
          (let (_, y0) :=
             (if
               (fix eqb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => match m with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S n'0 =>
                      match m with
                      | 0%nat => false
                      | S m' => eqb n'0 m'
                      end
                  end) (if f n' then 1%nat else 0%nat) 0%nat
              then
               fun x0 y0 : nat =>
               match x0 with
               | 0%nat =>
                   match y0 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match y0 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x0 y0 : nat =>
               match x0 with
               | 0%nat => match y0 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match y0 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, y0) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) x 1%nat 0%nat 1%nat in
                  y0)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           y0) +
          (let (_, y0) :=
             f_to_vec n' f
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) x 1%nat 0%nat 1%nat in
                x0)
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) y 0%nat 0%nat 0%nat in
                x0) in
           y0) *
          (let (x0, _) :=
             (if
               (fix eqb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => match m with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S n'0 =>
                      match m with
                      | 0%nat => false
                      | S m' => eqb n'0 m'
                      end
                  end) (if f n' then 1%nat else 0%nat) 0%nat
              then
               fun x0 y0 : nat =>
               match x0 with
               | 0%nat =>
                   match y0 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match y0 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x0 y0 : nat =>
               match x0 with
               | 0%nat => match y0 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match y0 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, y0) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) x 1%nat 0%nat 1%nat in
                  y0)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           x0))%R)
    end) psi3 H0 x x =
 (if
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) x
      ((fix binlist_to_nat (l : list bool) : nat :=
          match l with
          | [] => 0
          | b :: l' =>
              (fix add (n m : nat) {struct n} : nat :=
                 match n with
                 | 0 => m
                 | S p => S (add p m)
                 end) (if b then 1 else 0)
                ((fix add (n m : nat) {struct n} : nat :=
                    match n with
                    | 0 => m
                    | S p => S (add p m)
                    end) (binlist_to_nat l')
                   ((fix add (n m : nat) {struct n} : nat :=
                       match n with
                       | 0 => m
                       | S p => S (add p m)
                       end) (binlist_to_nat l') 0))
          end)
         ((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
               list bool :=
             match len with
             | 0 => []
             | S len' => f len' :: funbool_to_list len' f
             end) psi3 H0))
   then
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) x (2 * Nat.div2 0 + Nat.odd 0)
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching: (sum_over_list (map Cmod2 (vec_to_list' d l)) = 0)
Crunching: (xP - Hsin = yP -> xP - yP - Hsin = 0)
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching: (forall b : R, 0 <= M <= b -> b * M + M * b <= M * M + b * b)
Crunching:
(forall A : Square 0, WF_Unitary A -> a * a ^* = C1 -> WF_Unitary (a .* A))
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching:
(forall l : Vector p,
 sum_over_list (map Cmod2 (vec_to_list' x l)) =
 big_sum (fun i : nat => (Cmod (l (i + p - x)%nat 0%nat) ^ 2)%R) x)
Crunching:
(forall l : Vector p,
 sum_over_list (map Cmod2 (vec_to_list' x l)) =
 big_sum (fun i : nat => (Cmod (l (i + p - x)%nat 0%nat) ^ 2)%R) x)
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching: ((hadamard) ⊤ x y = hadamard x y)
Crunching: ((hadamard) ⊤ x y = hadamard x y)
Crunching:
(sum_over_list (map Cmod2 (vec_to_list' a Hab)) =
 big_sum (fun i : nat => (Cmod (Hab (i + e - a)%nat 0%nat) ^ 2)%R) a)
find_witness Control.TimeoutCrunching: (sum_over_list (map Cmod2 (vec_to_list' d l)) = 0)
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching: ((hadamard) ⊤ x y = hadamard x y)
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching:
(f_to_vec psi3 H0 x y =
 (if (x =? funbool_to_nat psi3 H0) && (y =? 0) then C1 else 0%R))
Crunching: ((hadamard) ⊤ x y = hadamard x y)
Crunching: (0%nat <> 0%nat)
     = ("hello_world",
        (["y"], ["out"], bedrock_func_body:(
           $"x" = $1;
           $"putchars"($104, $101, $108, $108, $111, $44, $32, $119, $111,
                      $114, $108, $100, $33);
           $"out" = $1 + $"y")))
     : bedrock_func
     = "uintptr_t hello_world(uintptr_t y) {
  uintptr_t x, out;
  x = (uintptr_t)1ULL;
  putchars((uintptr_t)104ULL, (uintptr_t)101ULL, (uintptr_t)108ULL, (uintptr_t)108ULL, (uintptr_t)111ULL, (uintptr_t)44ULL, (uintptr_t)32ULL, (uintptr_t)119ULL, (uintptr_t)111ULL, (uintptr_t)114ULL, (uintptr_t)108ULL, (uintptr_t)100ULL, (uintptr_t)33ULL);
  out = ((uintptr_t)1ULL)+(y);
  return out;
}
"
     : string
find_witness Control.Timeout     = ("nondet_xor",
        (["w"], ["out"], bedrock_func_body:(
           stackalloc 8 as $"bs";
           $"idx" = $0;
           $"undef" = load1($"bs" + $1 * $0);
           $"out" = $"w";
           $"out" = $"undef" ^ $"out";
           $"out" = $"undef" ^ $"out")))
     : bedrock_func
Crunching: (n' <= (ReprFunChoice + P) / 2 <= x)
Crunching: (Hz <= (ReprFunChoice + P) / 2 <= a)
Crunching: (N0 <= (ReprFunChoice + P) / 2 <= H1)
Crunching: (N0 <= (ReprFunChoice + P) / 2 <= H1)
Crunching: (C2 * INR (Pos.to_nat p) = IPR_2 p)
Crunching:
(forall ub : nat,
 H3 <= ReprFunChoice <= ub /\ H3 <= P <= ub ->
 H3 <= (ReprFunChoice + P) / 2 <= ub)
Crunching:
(sum_over_list (map Cmod2 (vec_to_list pol)) =
 big_sum (fun i : nat => (Cmod (pol i 0%nat) * (Cmod (pol i 0%nat) * 1))%R) A)
fun (args : \<< A, word, word \>>) (tr' : Semantics.trace) 
  (mem' : mem) (locals' : locals) =>
tr' = tr /\
locals' =
#{ "v" => P2.car (P2.cdr args); "ptr" => ptr; "y" => P2.cdr (P2.cdr args) }# /\
(rp ptr (P2.car args) ⋆ R) mem'
     : \<< A, word, word \>> -> Semantics.trace -> mem -> locals -> Prop
Crunching:
(big_sum (fun i : nat => nth i (map Cmod2 (vec_to_list m)) 0)
   (length (map Cmod2 (vec_to_list m))) =
 big_sum (fun i : nat => (Cmod (m i 0%nat) ^ 2)%R) A)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (H8 <= (EQ + m) / 2)
Crunching: (H8 <= (m + EQ) / 2)
Crunching: (H8 <= (EQ + m) / 2)
find_witness Control.Timeoutfind_witness Control.TimeoutFlattenExpr: flattenStmt_correct_aux done
Crunching: ((hadamard) ⊤ = hadamard)
Crunching: ((hadamard) † = hadamard)
Crunching: ((hadamard) † = hadamard)
Crunching: ((hadamard) † = hadamard)
Crunching: ((hadamard) † = hadamard)
Crunching: ((hadamard) † = hadamard)
Crunching: ((hadamard) † = hadamard)
Crunching: ((hadamard) † = hadamard)
Crunching: ((hadamard) † = hadamard)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
find_witness Control.TimeoutTactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Crunching: (binlist_to_nat (repeat false p) = 0)
Crunching: (binlist_to_nat (repeat false p) = 0)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: ((hadamard) † = hadamard)
Crunching: ((hadamard) † = hadamard)
Crunching: (binlist_to_nat (repeat false p) = 0)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (forall z : R, l <= z - x -> x + l <= z)
Crunching: (x < x)%nat
Crunching: (binlist_to_nat (repeat false p) = 0)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.011 secs (0.009u,0.001s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: ((hadamard) † = hadamard)
Crunching: (forall z : R, l <= z - x -> x + l <= z)
Crunching: ((hadamard) † = hadamard)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: False
Crunching:
(forall q : positive, Z.abs_N (Z.pos p~1 ÷ Z.pos q) = (N.pos p~1 / N.pos q)%N)
Crunching: (y <> y)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (y <> y)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: ((σx) † = σx)
Crunching: ((σx) † = σx)
Crunching: (binlist_to_nat (repeat false p) = 0)
find_witness Control.Timeoutfind_witness Control.TimeoutEnd of FlattenExpr.v
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(S (binlist_to_nat (repeat true n) + (binlist_to_nat (repeat true n) + 0)) =
 2 ^ n + (2 ^ n + 0) - 1)
find_witness Control.TimeoutCrunching:
(S (binlist_to_nat (repeat true n) + (binlist_to_nat (repeat true n) + 0)) =
 2 ^ n + (2 ^ n + 0) - 1)
     = ("indirect_add_three'",
        (["out"; "a"; "b"; "c"], [],
         cmd.stackalloc "v" size_in_bytes
           (cmd.seq (cmd.call [] "indirect_add" ["v"; "a"; "b"])
              (cmd.call [] "indirect_add" ["out"; "v"; "c"]))))
     : bedrock_func
Crunching: (binlist_to_nat (repeat true n) = 2 ^ n - 1)
Crunching: ((control U) † = control (U) †)
Crunching: (forall z : C, eps - z = ep -> eps - ep - z = 0)
Crunching: (eps - H6 = ep -> eps - ep - H6 = 0)
find_witness Control.TimeoutCrunching:
(2 ^ n + (2 ^ n + 0) - 1 =
 S (binlist_to_nat (repeat true n) + (binlist_to_nat (repeat true n) + 0)))
Crunching:
(S (binlist_to_nat (repeat true n) + (binlist_to_nat (repeat true n) + 0)) =
 2 ^ n + (2 ^ n + 0) - 1)
Crunching:
(S (binlist_to_nat (repeat true n) + (binlist_to_nat (repeat true n) + 0)) =
 2 ^ n + (2 ^ n + 0) - 1)
Crunching:
(S (binlist_to_nat (repeat true n) + (binlist_to_nat (repeat true n) + 0)) =
 2 ^ n + (2 ^ n + 0) - 1)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (x <= y -> Rmin x y > z -> x > z /\ y > z)
Crunching:
(2 ^ n + (2 ^ n + 0) - 1 =
 S (binlist_to_nat (repeat true n) + (binlist_to_nat (repeat true n) + 0)))
Crunching:
(S (binlist_to_nat (repeat true n) + (binlist_to_nat (repeat true n) + 0)) =
 2 ^ n + (2 ^ n + 0) - 1)
Crunching: ((control b) † = control (b) †)
Crunching:
(S (binlist_to_nat (repeat true n) + (binlist_to_nat (repeat true n) + 0)) =
 2 ^ n + (2 ^ n + 0) - 1)
Crunching:
(S (binlist_to_nat (repeat true n) + (binlist_to_nat (repeat true n) + 0)) =
 2 ^ n + (2 ^ n + 0) - 1)
Crunching: (binlist_to_nat (repeat true n) = 2 ^ n - 1)
Crunching:
(binlist_to_nat (repeat true q) = match 2 ^ q with
                                  | 0 => 1
                                  | S _ => 0
                                  end)
Crunching:
(binlist_to_nat (repeat true q) = match 2 ^ q with
                                  | 0 => 1
                                  | S _ => 0
                                  end)
Tactic call ran for 0.006 secs (0.005u,0.s) (success)
Crunching:
(binlist_to_nat (repeat true q) = match 2 ^ q with
                                  | 0 => 1
                                  | S _ => 0
                                  end)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(binlist_to_nat (repeat true q) = match 2 ^ q with
                                  | 0 => 1
                                  | S _ => 0
                                  end)
Crunching:
((if (y <? n) && true
  then C1
  else if (n <=? y) && (n <=? 0) then U (y - n)%nat (0 - n)%nat else 0) =
 (if (0 <? n) && (y =? 0)
  then C1
  else if (n <=? 0) && (n <=? y) then (U) † (0 - n)%nat (y - n)%nat else 0))
Crunching:
(binlist_to_nat (repeat true q) = match 2 ^ q with
                                  | 0 => 1
                                  | S _ => 0
                                  end)
Crunching:
(binlist_to_nat (repeat true q) = match 2 ^ q with
                                  | 0 => 1
                                  | S _ => 0
                                  end)
find_witness Control.TimeoutCrunching:
(binlist_to_nat (repeat true q) = match 2 ^ q with
                                  | 0 => 1
                                  | S _ => 0
                                  end)
Crunching:
((if (y <? n) && (x =? y)
  then C1
  else if (n <=? y) && (n <=? x) then (A (x - n)%nat (y - n)%nat) ^* else 0)
 ^* =
 (if (x <? n) && true
  then C1
  else if (n <=? x) && (n <=? y) then (A (y - n)%nat (x - n)%nat) ^* else 0))
Crunching:
((fun x y : nat =>
  (if (y <? del) && (x =? y)
   then C1
   else
    if (del <=? y) && (del <=? x) then H2 (y - del)%nat (x - del)%nat else 0)
  ^*) =
 (fun x y : nat =>
  if (x <? del) && (y =? x)
  then C1
  else
   if (del <=? x) && (del <=? y) then H2 (x - del)%nat (y - del)%nat else 0))
Crunching:
((fun x y : nat =>
  (if (y <? del) && (x =? y)
   then C1
   else
    if (del <=? y) && (del <=? x) then H2 (y - del)%nat (x - del)%nat else 0)
  ^*) =
 (fun x y : nat =>
  if (x <? del) && (y =? x)
  then C1
  else
   if (del <=? x) && (del <=? y) then H2 (x - del)%nat (y - del)%nat else 0))
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching:
((fun x y : nat =>
  (if (y <? 0) && (x =? y)
   then C1
   else if (0 <=? y) && (0 <=? x) then (A (x - 0)%nat (y - 0)%nat) ^* else 0)
  ^*) =
 (fun x y : nat =>
  if (x <? 0) && (y =? x)
  then C1
  else if (0 <=? x) && (0 <=? y) then (A (y - 0)%nat (x - 0)%nat) ^* else 0))
Crunching:
(binlist_to_nat (nat_to_binlist a 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching:
(forall n : nat,
 binlist_to_nat (nat_to_binlist p n) = binlist_to_nat (nat_to_binlist' n))
Crunching: (x <= y -> Rmin x y > z -> x > z /\ y > z)
find_witness Control.TimeoutCrunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching:
((H < 2 ^ H2)%nat ->
 WF_Matrix y ->
 nth H (apply_u y) 0 =
 probability_of_outcome (basis_vector (2 ^ H2) H)
   (y × basis_vector (2 ^ H2) 0))
Crunching:
((H < 2 ^ H2)%nat ->
 WF_Matrix y ->
 nth H (apply_u y) R0 =
 probability_of_outcome (basis_vector (2 ^ H2) H)
   (y × basis_vector (2 ^ H2) 0))
Crunching:
((if (y <? n) && (x =? y)
  then C1
  else if (n <=? y) && (n <=? x) then (A (x - n)%nat (y - n)%nat) ^* else 0)
 ^* =
 (if (x <? n) && true
  then C1
  else if (n <=? x) && (n <=? y) then (A (y - n)%nat (x - n)%nat) ^* else 0))
Crunching:
((H < 2 ^ H2)%nat ->
 WF_Matrix p ->
 nth H (apply_u p) 0 =
 probability_of_outcome (basis_vector (2 ^ H2) H)
   (p × basis_vector (2 ^ H2) 0))
Crunching: (1 < a)
Crunching:
(binlist_to_nat (nat_to_binlist a 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching:
(forall n : nat,
 binlist_to_nat (nat_to_binlist p n) = binlist_to_nat (nat_to_binlist' n))
find_witness Control.TimeoutCrunching:
(nth d (apply_u q) 0 =
 (Cmod ⟨ basis_vector (2 ^ 0) d, q × basis_vector (2 ^ 0) 0 ⟩ *
  (Cmod ⟨ basis_vector (2 ^ 0) d, q × basis_vector (2 ^ 0) 0 ⟩ * 1))%R)
Crunching:
((if (y <? n) && (y =? x)
  then C1
  else if (n <=? y) && (n <=? x) then (A (x - n)%nat (y - n)%nat) ^* else 0)
 ^* =
 (if (x <? n) && true
  then C1
  else if (n <=? x) && (n <=? y) then (A (y - n)%nat (x - n)%nat) ^* else 0))
Crunching:
((if (y <? n) && (x =? y)
  then C1
  else if (n <=? y) && (n <=? x) then (A (x - n)%nat (y - n)%nat) ^* else 0)
 ^* =
 (if (x <? n) && true
  then C1
  else if (n <=? x) && (n <=? y) then (A (y - n)%nat (x - n)%nat) ^* else 0))
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching:
((if match n with
     | 0%nat => false
     | S m' => y <=? m'
     end && true
  then C1
  else if (n <=? y) && (n <=? x) then (A (x - n)%nat (y - n)%nat) ^* else 0)
 ^* =
 (if match n with
     | 0%nat => false
     | S m' => x <=? m'
     end && true
  then C1
  else if (n <=? x) && (n <=? y) then (A (y - n)%nat (x - n)%nat) ^* else 0))
Crunching:
((if (y <? n) && (x =? y)
  then C1
  else if (n <=? y) && (n <=? x) then (A (x - n)%nat (y - n)%nat) ^* else 0)
 ^* =
 (if (x <? n) && true
  then C1
  else if (n <=? x) && (n <=? y) then (A (y - n)%nat (x - n)%nat) ^* else 0))
Crunching:
((if (y <? n) && (y =? x)
  then C1
  else if (n <=? y) && (n <=? x) then (A (x - n)%nat (y - n)%nat) ^* else 0)
 ^* =
 (if (x <? n) && true
  then C1
  else if (n <=? x) && (n <=? y) then (A (y - n)%nat (x - n)%nat) ^* else 0))
find_witness Control.TimeoutCrunching:
((if (y <? n) && (x =? y)
  then C1
  else if (n <=? y) && (n <=? x) then (A (x - n)%nat (y - n)%nat) ^* else 0)
 ^* =
 (if (x <? n) && true
  then C1
  else if (n <=? x) && (n <=? y) then (A (y - n)%nat (x - n)%nat) ^* else 0))
find_witness Control.TimeoutCrunching:
((if (x <? 0) && true
  then C1
  else if (0 <=? x) && (0 <=? x) then (A (x - 0)%nat (x - 0)%nat) ^* else 0)
 ^* =
 (if (x <? 0) && true
  then C1
  else if (0 <=? x) && (0 <=? x) then (A (x - 0)%nat (x - 0)%nat) ^* else 0))
Crunching:
((H < 2 ^ H2)%nat ->
 WF_Matrix y ->
 nth H (apply_u y) 0 =
 probability_of_outcome (basis_vector (2 ^ H2) H)
   (y × basis_vector (2 ^ H2) 0))
Crunching:
((H < 2 ^ H2)%nat ->
 WF_Matrix y ->
 nth H (apply_u y) R0 =
 probability_of_outcome (basis_vector (2 ^ H2) H)
   (y × basis_vector (2 ^ H2) 0))
Crunching:
((fun x y : nat =>
  (if (y <? del) && (x =? y)
   then C1
   else
    if (del <=? y) && (del <=? x) then H2 (y - del)%nat (x - del)%nat else 0)
  ^*) =
 (fun x y : nat =>
  if (x <? del) && (y =? x)
  then C1
  else
   if (del <=? x) && (del <=? y) then H2 (x - del)%nat (y - del)%nat else 0))
Crunching:
((fun x y : nat =>
  (if (y <? del) && (x =? y)
   then C1
   else
    if (del <=? y) && (del <=? x) then H2 (y - del)%nat (x - del)%nat else 0)
  ^*) =
 (fun x y : nat =>
  if (x <? del) && (y =? x)
  then C1
  else
   if (del <=? x) && (del <=? y) then H2 (x - del)%nat (y - del)%nat else 0))
find_witness Control.TimeoutCrunching:
((H < 2 ^ H2)%nat ->
 WF_Matrix p ->
 nth H (apply_u p) 0 =
 probability_of_outcome (basis_vector (2 ^ H2) H)
   (p × basis_vector (2 ^ H2) 0))
Crunching:
((H < 2 ^ H2)%nat ->
 WF_Matrix p ->
 nth H (apply_u p) R0 =
 probability_of_outcome (basis_vector (2 ^ H2) H)
   (p × basis_vector (2 ^ H2) 0))
Crunching:
((fun x y : nat =>
  (if (y <? del) && (x =? y)
   then C1
   else
    if (del <=? y) && (del <=? x) then H2 (y - del)%nat (x - del)%nat else 0)
  ^*) =
 (fun x y : nat =>
  if (x <? del) && (y =? x)
  then C1
  else
   if (del <=? x) && (del <=? y) then H2 (x - del)%nat (y - del)%nat else 0))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (1 < a)
Crunching:
((if (y <? 0) && (x =? y)
  then IPR 1
  else if (0 <=? y) && (0 <=? x) then n (y - 0)%nat (x - 0)%nat else R0) ^* =
 (if (x <? 0) && true
  then IPR 1
  else if (0 <=? x) && (0 <=? y) then n (x - 0)%nat (y - 0)%nat else R0))
Crunching:
(binlist_to_nat (nat_to_binlist a 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching: Type
find_witness Control.TimeoutCrunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
find_witness Control.TimeoutCrunching: ((phase_shift a0) † = phase_shift (- a0))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
find_witness Control.TimeoutCrunching: ((phase_shift p0) † = phase_shift (- p0))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(binlist_to_nat (nat_to_binlist' n) + 2 ^ length (nat_to_binlist' n) * 0 = n)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: ((phase_shift a0) † = phase_shift (- a0))
find_witness Control.TimeoutCrunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (0 < 1 -> False)
Crunching: (0 < 1 -> False)
Crunching: (0 < 1 -> False)
Crunching:
((fun x y : nat =>
  match y with
  | 0%nat => match x with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match x with
             | 1%nat => Cexp Hyp
             | _ => 0
             end
  | S (S _) => 0
  end ^*) =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp (- Hyp)
             | _ => 0
             end
  | S (S _) => 0
  end))
Crunching: ((phase_shift p0) † = phase_shift (- p0))
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (Forall (fun x : R => 0 <= x) (repeat x Acc_0))
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching:
(n =
 binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))))
Crunching: (x + y0 < x)
Crunching:
(binlist_to_nat
   (nat_to_binlist' n ++ repeat false (a - length (nat_to_binlist' n))) = n)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
find_witness Control.TimeoutCrunching: (x + y0 < x)
find_witness Control.TimeoutCrunching: (x + y0 < x)
Crunching:
(binlist_to_nat (nat_to_binlist' def_n0) +
 2 ^ length (nat_to_binlist' def_n0) *
 binlist_to_nat (repeat false (le_mn2 - length (nat_to_binlist' def_n0))) =
 def_n0)
Crunching: (x + y0 < x)
Crunching: False
Crunching:
((let (x, _) :=
    match y with
    | 1%nat =>
        (let (a, _) := exist_cos (xxh * xxh) in a,
         let (a, _) :=
           Alembert_C3
             (fun n0 : nat =>
              ((fix pow (r : R) (n1 : nat) {struct n1} : R :=
                  match n1 with
                  | 0%nat => R1
                  | S n2 => r * pow r n2
                  end) (- R1) n0 *
               /
               (fix INR (n1 : nat) : R :=
                  match n1 with
                  | 0%nat => R0
                  | 1%nat => R1
                  | S (S _ as n2) => INR n2 + R1
                  end)
                 ((fix fact (n1 : nat) : nat :=
                     match n1 with
                     | 0%nat => 1%nat
                     | S n2 =>
                         (fix add (n3 m : nat) {struct n3} : nat :=
                            match n3 with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) (fact n2)
                           ((fix mul (n3 m : nat) {struct n3} : nat :=
                               match n3 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n4 m0 : nat) {struct n4} :
                                        nat :=
                                      match n4 with
                                      | 0%nat => m0
                                      | S p0 => S (add p0 m0)
                                      end) m (mul p m)
                               end) n2 (fact n2))
                     end)
                    ((fix add (n1 m : nat) {struct n1} : nat :=
                        match n1 with
                        | 0%nat => m
                        | S p => S (add p m)
                        end)
                       ((fix add (n1 m : nat) {struct n1} : nat :=
                           match n1 with
                           | 0%nat => m
                           | S p => S (add p m)
                           end) n0
                          ((fix add (n1 m : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n0 0%nat)) 1%nat)))%R) 
             (xxh * xxh) sin_no_R0 Alembert_sin in
         (xxh * a)%R)
    | _ => (R0, R0)
    end in
  x,
  (-
   (let (_, y) :=
      match y with
      | 1%nat =>
          (let (a, _) := exist_cos (xxh * xxh) in a,
           let (a, _) :=
             Alembert_C3
               (fun n0 : nat =>
                (fix pow (r : R) (n1 : nat) {struct n1} : R :=
                   match n1 with
                   | 0%nat => R1
                   | S n2 => r * pow r n2
                   end) (- R1) n0 *
                /
                (fix INR (n1 : nat) : R :=
                   match n1 with
                   | 0%nat => R0
                   | 1%nat => R1
                   | S (S _ as n2) => INR n2 + R1
                   end)
                  ((fix fact (n1 : nat) : nat :=
                      match n1 with
                      | 0%nat => 1%nat
                      | S n2 =>
                          (fix add (n3 m : nat) {struct n3} : nat :=
                             match n3 with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) (fact n2)
                            ((fix mul (n3 m : nat) {struct n3} : nat :=
                                match n3 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add (n4 m0 : nat) {struct n4} :
                                         nat :=
                                       match n4 with
                                       | 0%nat => m0
                                       | S p0 => S (add p0 m0)
                                       end) m (mul p m)
                                end) n2 (fact n2))
                      end)
                     ((fix add (n1 m : nat) {struct n1} : nat :=
                         match n1 with
                         | 0%nat => m
                         | S p => S (add p m)
                         end)
                        ((fix add (n1 m : nat) {struct n1} : nat :=
                            match n1 with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n0
                           ((fix add (n1 m : nat) {struct n1} : nat :=
                               match n1 with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n0 0%nat)) 1%nat))) 
               (xxh * xxh) sin_no_R0 Alembert_sin in
           xxh * a)
      | _ => (R0, R0)
      end in
    y))%R) =
 match y with
 | 1%nat =>
     (let (a, _) := exist_cos (- xxh * - xxh) in a,
      let (a, _) :=
        Alembert_C3
          (fun n : nat =>
           ((fix pow (r : R) (n1 : nat) {struct n1} : R :=
               match n1 with
               | 0%nat => R1
               | S n2 => r * pow r n2
               end) (- R1) n *
            /
            (fix INR (n1 : nat) : R :=
               match n1 with
               | 0%nat => R0
               | 1%nat => R1
               | S (S _ as n2) => INR n2 + R1
               end)
              ((fix fact (n1 : nat) : nat :=
                  match n1 with
                  | 0%nat => 1%nat
                  | S n2 =>
                      (fix add (n3 m : nat) {struct n3} : nat :=
                         match n3 with
                         | 0%nat => m
                         | S p => S (add p m)
                         end) (fact n2)
                        ((fix mul (n3 m : nat) {struct n3} : nat :=
                            match n3 with
                            | 0%nat => 0%nat
                            | S p =>
                                (fix add (n4 m0 : nat) {struct n4} : nat :=
                                   match n4 with
                                   | 0%nat => m0
                                   | S p0 => S (add p0 m0)
                                   end) m (mul p m)
                            end) n2 (fact n2))
                  end)
                 ((fix add (n1 m : nat) {struct n1} : nat :=
                     match n1 with
                     | 0%nat => m
                     | S p => S (add p m)
                     end)
                    ((fix add (n1 m : nat) {struct n1} : nat :=
                        match n1 with
                        | 0%nat => m
                        | S p => S (add p m)
                        end) n
                       ((fix add (n1 m : nat) {struct n1} : nat :=
                           match n1 with
                           | 0%nat => m
                           | S p => S (add p m)
                           end) n 0%nat)) 1%nat)))%R) 
          (- xxh * - xxh) sin_no_R0 Alembert_sin in
      (- xxh * a)%R)
 | _ => (R0, R0)
 end)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: ((phase_shift xxh) † x y = phase_shift (- xxh) x y)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching:
(binlist_to_nat (nat_to_binlist' n) + 2 ^ length (nat_to_binlist' n) * 0 = n)
Crunching: positive
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
Crunching: (x + y0 < x)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (nat_to_binlist' H8 = H7 -> binlist_to_nat H7 = H8)
Crunching:
((fun x y : nat => (rotation θ Hcase p y x) ^*) =
 rotation (- θ) (- p) (- Hcase))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall θ ϕ λ : R, (rotation θ ϕ λ) † = rotation (- θ) (- λ) (- ϕ))
Crunching: (forall n : nat, (forall m : nat, m < n -> 0 = m) -> 0 = n)
Crunching:
(forall ϕ λ : R,
 (fun x y : nat => (rotation θ ϕ λ y x) ^*) = rotation (- θ) (- λ) (- ϕ))
Crunching: (nat_to_binlist' H8 = H7 -> binlist_to_nat H7 = H8)
Crunching: ((rotation θ l n) † x y = rotation (- θ) (- n) (- l) x y)
Crunching:
(forall (m : nat) (x : R), sum_over_list (repeat x m) = (INR m * x)%R)
Crunching: (forall n : nat, (forall m : nat, m < n -> 0 = m) -> 0 = n)
Crunching: (forall x : R, sum_over_list (repeat x EQ) = (INR EQ * x)%R)
Crunching: ((rotation θ P ϕ) † = rotation (- θ) (- ϕ) (- P))
Crunching: ((rotation θ P m) † = rotation (- θ) (- m) (- P))
Crunching: ((rotation θ P λ) † = rotation (- θ) (- λ) (- P))
Crunching: (forall n : nat, (forall m : nat, m < n -> 0 = m) -> 0 = n)
Crunching: (forall n : nat, (forall m : nat, m < n -> 0 = m) -> 0 = n)
find_witness Control.TimeoutCrunching:
((fun x y : nat => (rotation θ Hcase p y x) ^*) =
 rotation (- θ) (- p) (- Hcase))
Crunching: (sum_over_list (repeat H6 Hnm) = (INR Hnm * H6)%R)
Crunching:
(forall p q : positive,
 Z.abs_N (Z.rem (Z.pos p) (Z.pos q)) = (N.pos p mod N.pos q)%N)
Crunching:
(forall (m : nat) (x : R), sum_over_list (repeat x m) = (INR m * x)%R)
Crunching: (forall x : R, sum_over_list (repeat x EQ) = (INR EQ * x)%R)
Crunching: (nat_to_binlist' H8 = H7 -> binlist_to_nat H7 = H8)
Crunching:
(forall θ ϕ λ : R, (rotation θ ϕ λ) † = rotation (- θ) (- λ) (- ϕ))
Crunching:
(forall ϕ λ : R,
 (fun x y : nat => (rotation θ ϕ λ y x) ^*) = rotation (- θ) (- λ) (- ϕ))
Crunching: ((Cmod q ^ 2)%R = fst (q ^* * q))
Crunching: (binlist_to_nat abs = a)
Crunching: (?y = binlist_to_nat abs)
Crunching: (binlist_to_nat abs = ?y)
Crunching: (0 = n)
Crunching: (forall n : nat, (forall m : nat, m < n -> 0 = m) -> 0 = n)
Crunching: (forall n : nat, (forall m : nat, m < n -> 0 = m) -> 0 = n)
Crunching: (∣1⟩ = basis_vector 2 1)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
find_witness Control.TimeoutCrunching: ((forall m : nat, m < l1 -> 0 = m) -> 0 = l1)
Crunching: (0 = n)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Crunching: (forall n : nat, (forall m : nat, m < n -> 0 = m) -> 0 = n)
Crunching: (forall n : nat, (forall m : nat, m < n -> 0 = m) -> 0 = n)
Crunching: (Z.abs_N (Z.rem (Z.pos p) (Z.pos q)) = (N.pos p mod N.pos q)%N)
Crunching: ((rotation θ l n) † x y = rotation (- θ) (- n) (- l) x y)
Crunching: ((rotation θ l n) † x y = rotation (- θ) (- n) (- l) x y)
Crunching: (forall n : nat, (forall m : nat, m < n -> 0 = m) -> 0 = n)
Crunching: (Z.abs_N (Z.rem (Z.pos p) (Z.pos q)) = (N.pos p mod N.pos q)%N)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
find_witness Control.TimeoutTactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching: (forall n : nat, (forall m : nat, m < n -> 0 = m) -> 0 = n)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = ∣0⟩⟨0∣)
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: (cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Tactic call ran for 0.006 secs (0.005u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.005 secs (0.002u,0.002s) (success)
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: (cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: ((sin PI)² = 0 -> ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: (cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: ((sin PI)² = 0 -> ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: ((sin PI)² = 0 -> ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: (cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching: (0 <= sample (uniform 0 u) r < u)%nat
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(∣1⟩⟨1∣
 ⊗ (fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 1%nat => C1
               | _ => 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | S (S _) => 0
    end) .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(~
 (Forall (fun b : bool => b = true) l0 ->
  length (incr_bin l0) = S (length l0)))
Crunching: ((sin PI)² = 0 -> ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: ((sin PI)² = 0 -> ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching:
(~
 (Forall (fun b : bool => b = true) l0 ->
  length (incr_bin l0) = S (length l0)))
Crunching: (cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching: ((sin PI)² = 0 -> cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(∣1⟩⟨1∣
 ⊗ (fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 1%nat => C1
               | _ => 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | S (S _) => 0
    end) .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
find_witness Control.TimeoutCrunching: ((sin PI)² = 0 -> ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: ((sin PI)² = 0 -> ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching: (cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching: ((sin PI)² = 0 -> cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching: ((sin PI)² = 0 -> cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
clear  H0a'  :  (False -> cmpA a a' <> Lt)
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: (cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching: (0 <= sample (uniform 0 u) r < u)%nat
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching: (r <= sample (uniform r n) x < n)%nat
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(∣1⟩⟨1∣
 ⊗ (fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 1%nat => C1
               | _ => 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | S (S _) => 0
    end) .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(∣1⟩⟨1∣
 ⊗ (fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 1%nat => C1
               | _ => 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | S (S _) => 0
    end) .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching:
(~
 (Forall (fun b : bool => b = true) l0 ->
  length (incr_bin l0) = S (length l0)))
Crunching:
(~
 (Forall (fun b : bool => b = true) l0 ->
  length (incr_bin l0) = S (length l0)))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(~
 (Forall (fun b : bool => b = true) l0 ->
  length (incr_bin l0) = S (length l0)))
Crunching:
(forall r : R,
 (p < Hp)%nat -> 0 <= r < 1 -> (p <= sample (uniform p Hp) r < Hp)%nat)
Crunching:
(~
 (Forall (fun b : bool => b = true) l0 ->
  length (incr_bin l0) = S (length l0)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching: ((sin PI)² = 0 -> ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: ((sin PI)² = 0 -> ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching: (cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching: ((sin PI)² = 0 -> cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching: ((sin PI)² = 0 -> cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
find_witness Control.TimeoutCrunching:
(list2D_to_matrix
   [[e; e0; e1; e2]; [e3; e4; e5; e6]; [e7; e8; e9; e10];
    [e11; e12; e13; e14]] = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: ((sin PI)² = 0 -> ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching: (cnot = ∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(∣1⟩⟨1∣
 ⊗ (fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 1%nat => C1
               | _ => 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | S (S _) => 0
    end) .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(∣1⟩⟨1∣
 ⊗ (fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 1%nat => C1
               | _ => 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | S (S _) => 0
    end) .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(∣1⟩⟨1∣
 ⊗ (fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 1%nat => C1
               | _ => 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => 0
               end
    | S (S _) => 0
    end) .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching:
(forall y : nat,
 (x >= 2 * 2)%nat \/ (y >= 2 * 2)%nat ->
 (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2) x y = 0)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(forall y : nat,
 (x >= 4)%nat \/ (y >= 4)%nat -> (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2) x y = 0)
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Crunching:
(length (if n then false :: incr_bin LT else true :: LT) = S (S (length LT)))
Transparent constants:
Z.to_nat : Z -> nat
Pos.to_nat : positive -> nat
Z.testbit : Z -> Z -> bool
Pos.testbit : positive -> N -> bool
N.testbit : N -> N -> bool
table_multicomb_positify : forall P : Type,
                           (P -> P -> P) ->
                           (P -> P) ->
                           (P -> P) ->
                           (Z -> P -> P) ->
                           P -> P -> Z -> Z -> Z -> Z -> Z -> Z -> P
table_lookup : forall P : Type,
               (P -> P -> P) ->
               (P -> P) -> (Z -> P -> P) -> P -> P -> Z -> Z -> Z -> Z -> P
table_entry : forall P : Type,
              (P -> P -> P) ->
              (Z -> P -> P) -> P -> P -> Z -> Z -> Z -> Z -> P
table_comb_positify : forall P : Type,
                      (P -> P -> P) ->
                      (P -> P) ->
                      (Z -> P -> P) ->
                      P -> P -> Z -> Z -> Z -> Z -> Z -> Z -> Z -> P
Z.succ_double : Z -> Z
Pos.succ : positive -> positive
Z.sub : Z -> Z -> Z
seq : nat -> nat -> list nat
Z.pred_double : Z -> Z
Pos.pred_double : positive -> positive
Pos.pred_N : positive -> N
Z.pow_pos : Z -> positive -> Z
Z.pow : Z -> Z -> Z
positify : Z -> Z -> Z -> Z
Z.pos_sub : positive -> positive -> Z
Z.pos_div_eucl : positive -> Z -> Z * Z
Z.opp : Z -> Z
Pos.of_succ_nat : nat -> positive
Z.of_nat : nat -> Z
oddify : Z -> Z -> Z
Z.odd : Z -> bool
negb : bool -> bool
Z.mul : Z -> Z -> Z
Pos.mul : positive -> positive -> positive
Z.modulo : Z -> Z -> Z
map : forall A B : Type, (A -> B) -> list A -> list B
Z.ltb : Z -> Z -> bool
Z.leb : Z -> Z -> bool
Pos.iter_op : forall A : Type, (A -> A -> A) -> positive -> A -> A
Pos.iter : forall A : Type, (A -> A) -> A -> positive -> A
fold_right : forall A B : Type, (B -> A -> A) -> A -> list B -> A
extract_bits_positify : Z -> Z -> Z -> Z -> Z -> Z -> Z
Z.double : Z -> Z
Z.div_eucl : Z -> Z -> Z * Z
Z.div : Z -> Z -> Z
Pos.compare_cont : comparison -> positive -> positive -> comparison
Z.compare : Z -> Z -> comparison
Pos.compare : positive -> positive -> comparison
Z.b2z : bool -> Z
Z.add : Z -> Z -> Z
Pos.add : positive -> positive -> positive
Init.Nat.add : nat -> nat -> nat
ZtoP : forall P : Type, (Z -> P -> P) -> P -> Z -> P
Zseq : Z -> Z -> list Z
CompOpp : comparison -> comparison
Crunching: (0 <= x < / 1 -> (i <= sample (uniform i H) x < H)%nat)
Crunching:
(Forall (fun b : bool => b = true) (true :: a) ->
 length (incr_bin (true :: a)) = S (length (true :: a)))
rewrite if_dtt
if (proj1_sig k1 + proj1_sig k2 <? n)
then
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = true =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2) n E)
else
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = false =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2 - n) n (ltN_plus_mod_lemma1 k1 k2 E))
find_witness Control.Timeout     = exist (fun z : Z => z = z mod 101) 8
         (ModularArithmeticPre.Z_mod_mod 8 101)
     : P
table_entry = 
fun (P : Type) (addP : P -> P -> P) (mulP : Z -> P -> P) 
  (O B : P) (s t bnum d : Z) =>
fold_right addP O
  (map
     (fun x : Z =>
      ZtoP P mulP B
        ((2 * Z.b2z (Z.testbit d (x - t * bnum)) - 1) * 2 ^ (s * x)))
     (Zseq (t * bnum) t))
     : forall P : Type,
       (P -> P -> P) -> (Z -> P -> P) -> P -> P -> Z -> Z -> Z -> Z -> P

Arguments table_entry P%type_scope (addP mulP)%function_scope 
  O B (s t bnum d)%Z_scope
     = exist (fun z : Z => z = z mod 101) 63
         (ModularArithmeticPre.Z_mod_mod 63 101)
     : P
extract_bits = 
fun s t D offset e : Z =>
fold_right Z.add 0
  (map (fun x : Z => sbit' D e (x * s + offset) * 2 ^ x) (Zseq 0 t))
     : Z -> Z -> Z -> Z -> Z -> Z

Arguments extract_bits (s t D offset e)%Z_scope
     = 4
     : Z
table_comb = 
fun (P : Type) (addP : P -> P -> P) (negP : P -> P) 
  (mulP : Z -> P -> P) (O B : P) (s t n D offset e : Z) =>
fold_right addP O
  (map
     (fun x : Z =>
      table_lookup P addP negP mulP O B s t x
        (extract_bits s t D (offset + x * s * t) e)) 
     (Zseq 0 n))
     : forall P : Type,
       (P -> P -> P) ->
       (P -> P) -> (Z -> P -> P) -> P -> P -> Z -> Z -> Z -> Z -> Z -> Z -> P

Arguments table_comb P%type_scope (addP negP mulP)%function_scope 
  O B (s t n D offset e)%Z_scope
     = exist (fun z : Z => z = z mod 101) 22
         (ModularArithmeticPre.Z_mod_mod 22 101)
     : P
table_multicomb = 
fun (P : Type) (addP : P -> P -> P) (doubleP negP : P -> P)
  (mulP : Z -> P -> P) (O B : P) (s t n D e : Z) =>
fold_right (fun x y : P => addP x (doubleP y)) O
  (map (fun x : Z => table_comb P addP negP mulP O B s t n D x e) (Zseq 0 s))
     : forall P : Type,
       (P -> P -> P) ->
       (P -> P) ->
       (P -> P) -> (Z -> P -> P) -> P -> P -> Z -> Z -> Z -> Z -> Z -> P

Arguments table_multicomb P%type_scope
  (addP doubleP negP mulP)%function_scope O B (s t n D e)%Z_scope
     = exist (fun z : Z => z = z mod 101) 87
         (ModularArithmeticPre.Z_mod_mod 87 101)
     : P
Crunching: (∣1⟩⟨1∣ ⊗ σx .+ ∣0⟩⟨0∣ ⊗ I 2 = cnot)
Crunching: (0 <= sample (uniform 0 u) r < u)%nat
Crunching: (σx ⊗ ∣1⟩⟨1∣ .+ I 2 ⊗ ∣0⟩⟨0∣ = notc)
Crunching: (0 <= sample (uniform 0 u) r < u)%nat
Crunching: (0 <= sample (uniform 0 u) r < u)%nat
Crunching:
((fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => C1
             | _ => 0
             end
  | S (S _) => 0
  end) = (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
((fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => C1
             | _ => 0
             end
  | S (S _) => 0
  end) = (fun x y : nat => if (x =? y) && (x <? 2) then C1 else 0))
Crunching:
(list2D_to_matrix [[e; e0]; [e1; e2]] = phase_shift θ × phase_shift θ')
Crunching:
(list2D_to_matrix [[C1; 0]; [0; Cexp θ * Cexp θ']] = phase_shift (θ + θ'))
Crunching: (~ 0 < 0)
Crunching: (list2D_to_matrix [[e]] = ⟨0∣ × ∣0⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = ⟨1∣ × ∣1⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (~ 0 < 0)
Crunching: (list2D_to_matrix [[e]] = (I 1) † × I 1)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]] = I 1 × (I 1) †)
Crunching: (I 1 = list2D_to_matrix [[C1]])
fun (idx : word) (args : \<< A, word \>>) (tr' : Semantics.trace)
  (mem' : mem) (locals' : locals) =>
tr' = tr /\
locals' = #{ "v" => P2.cdr args; "from" => idx; "ptr" => ptr }# /\
(rp ptr (P2.car args) ⋆ R) mem'
     : word -> \<< A, word \>> -> Semantics.trace -> mem -> locals -> Prop
Crunching: (swap × (q ⊗ q') = q' ⊗ q)
Crunching:
(∣0⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
find_witness Control.TimeoutTactic call ran for 0.015 secs (0.015u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Warning: gather_SEP with numeric arguments is deprecated
Tactic call ran for 0.011 secs (0.011u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
find_witness Control.Timeoutrewrite if_dtt
if (n =? S r)
then
(fun E : (n =? S r) = true =>
 ltN_of_nat 0 n
   (ltN_S_mod_lemma1 (exist (fun k : nat => (k <? n) = true) r Hr) E))
else
(fun E : (n =? S r) = false =>
 ltN_of_nat (S r) n
   (ltN_S_mod_lemma2 (exist (fun k : nat => (k <? n) = true) r Hr) E))
rewrite if_dtt
if (n =? proj1_sig r)
then
(fun E : (n =? proj1_sig r) = true =>
 ltN_of_nat 0 (S n) (ltN_S_mod_lemma1 r E))
else
(fun E : (n =? proj1_sig r) = false =>
 ltN_of_nat (S (proj1_sig r)) (S n) (ltN_S_mod_lemma2 r E))
rewrite if_dtt
if (n =? S (proj1_sig k))
then
(fun E : (n =? S (proj1_sig k)) = true =>
 ltN_of_nat 0 n (ltN_S_mod_lemma1 k E))
else
(fun E : (n =? S (proj1_sig k)) = false =>
 ltN_of_nat (S (proj1_sig k)) n (ltN_S_mod_lemma2 k E))
clear  H1  :  (False -> b1 = false)
find_witness Control.TimeoutCrunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
    [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
Crunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
Crunching: (positive -> False)
Crunching:
(length (if x then false :: incr_bin l else true :: l) = S (length l))
Finished transaction in 136.321 secs (133.5u,2.809s) (successful)
Crunching: (positive -> False)
Crunching:
(length (if x then false :: incr_bin l else true :: l) = S (length l))
out of reach
Tactic call ran for 0.003 secs (0.001u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(x <> true ->
 length (if x then false :: incr_bin b else true :: b) = S (length b))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall l : list bool,
 p2 <> true -> length (incr_bin (p2 :: l)) = length (p2 :: l))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(length (if k then false :: incr_bin A else true :: A) = S (length A))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: ((0 + 1)%R = 1 -> length (uniform b m) = m)
Crunching: ((0 + 1)%R = 1 -> length (uniform b m) = m)
Crunching: ((0 + 1)%R = 1 -> length (uniform b m) = m)
Crunching: (forall r : R, r <= 0 -> 0 <= r -> r = 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (x :: l = x :: repeat x (length l))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Finished transaction in 36.921 secs (36.594u,0.324s) (successful)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
clear  H0a'  :  (False -> cmpA a a' <> Lt)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Crunching: (∣0⟩ = basis_vector 2 0)
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Crunching: (∣0⟩ = basis_vector 2 0)
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Crunching: (∣0⟩ = basis_vector 2 0)
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Crunching: (∣0⟩ = basis_vector 2 0)
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Crunching: (∣0⟩ = basis_vector 2 0)
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Crunching: (∣0⟩ = basis_vector 2 0)
Building split_raw_ident_gen...
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Building invert_bind_args...
Crunching: (H' = length (uniform 0 H'))
Building invert_bind_args_unknown...
Crunching: (length (uniform 0 H') = H')
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Crunching: (H' = length (uniform 0 H'))
Crunching: (length (uniform 0 H') = H')
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Crunching: (x :: l = x :: repeat x (length l))
Building add_types_from_raw_sig...
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Building to_type_split_types_subst_default_eq...
Crunching: ((0 + 1)%R = 1 -> m = length (uniform b m))
Building projT1_add_types_from_raw_sig_eq...
Crunching: ((0 + 1)%R = 1 -> m = length (uniform b m))
Crunching: ((0 + 1)%R = 1 -> m = length (uniform b m))
Building arg_types_unfolded...
Crunching: (forall x y z : nat, y < z - x -> x + y < z)
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Crunching: ((1 + 0)%R = 1 -> length (uniform b m) = m)
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Crunching: ((0 + 1)%R = 1 -> length (uniform b m) = m)
find_witness Control.TimeoutCrunching: (x = q)
Crunching: (In x1 (true :: l) -> true = x1)
Tactic call ran for 0.58 secs (0.575u,0.003s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.363 secs (0.36u,0.002s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.027 secs (0.027u,0.s) (success)
Proving split_ident_to_ident...
Crunching: ((1 + 0)%R = 1 -> length (uniform b m) = m)
Tactic call ran for 0.023 secs (0.023u,0.s) (success)
Proving eq_indep_types_of_eq_types...
find_witness Control.TimeoutCrunching: ((0 + 1)%R = 1 -> length (uniform b m) = m)
Tactic call ran for 1.295 secs (1.259u,0.032s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
find_witness Control.Timeoutout of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 2.651 secs (2.577u,0.068s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Compiling decision tree...
Crunching: (fst (S n') 0 = 0%nat)
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Tactic call ran for 0.032 secs (0.032u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.123 secs (0.12u,0.002s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 21.037 secs (20.708u,0.278s) (successful)
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Crunching: (H14 < 2 ^ HC -> length (nat_to_binlist' H14) <= HC)
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Crunching: (fst (S n') 0 = 0%nat)
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Crunching: (0%nat = fst (S n') 0)
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Crunching: (H14 < 2 ^ HC -> length (nat_to_binlist' H14) <= HC)
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Finished transaction in 39.073 secs (38.682u,0.388s) (successful)
Building unify...
Crunching: (H14 < 2 ^ HC -> length (nat_to_binlist' H14) <= HC)
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.727 secs (0.709u,0.016s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.461 secs (0.434u,0.025s) (success)
Proving fold_invert_bind_args...
find_witness Control.TimeoutTactic call ran for 0.046 secs (0.045u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.034 secs (0.034u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Crunching: (H14 < 2 ^ HC -> length (nat_to_binlist' H14) <= HC)
Tactic call ran for 1.414 secs (1.386u,0.024s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Crunching: (H14 < 2 ^ HC -> length (nat_to_binlist' H14) <= HC)
Tactic call ran for 2.983 secs (2.949u,0.026s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Crunching: (H14 < 2 ^ HC -> length (nat_to_binlist' H14) <= HC)
Crunching: (H14 < 2 ^ HC -> length (nat_to_binlist' H14) <= HC)
Reifying...
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Crunching: (H14 < 2 ^ HC -> length (nat_to_binlist' H14) <= HC)
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Crunching: (H14 < 2 ^ HC -> length (nat_to_binlist' H14) <= HC)
Building base_eq_dec...
Building base_beq_and_reflect...
Crunching: (H14 < 2 ^ HC -> length (nat_to_binlist' H14) <= HC)
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Compiling decision tree...
Building try_make_base_transport_cps...
Splitting rewrite rules...
Building try_make_base_transport_cps_correct...
Building all_idents...
Assembling rewrite_head...
Reducing rewrite_head...
Building all_ident_and_interp...
Tactic call ran for 0.232 secs (0.229u,0.001s) (success)
Building buildEagerIdentAndInterpCorrect...
Tactic call ran for 0.345 secs (0.336u,0.008s) (success)
Tactic call ran for 0.145 secs (0.145u,0.s) (success)
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Building toRestrictedIdentAndCorrect...
find_witness Control.TimeoutProving Rewriter_Wf...
Tactic call ran for 0.143 secs (0.142u,0.001s) (success)
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Building buildIdent...
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Building buildInterpIdentCorrect...
Tactic call ran for 2.005 secs (1.947u,0.054s) (success)
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Proving Rewriter_Interp...
Building invertIdent...
Tactic call ran for 0.582 secs (0.574u,0.007s) (success)
Building buildInvertIdentCorrect...
Building base_default...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building package...
Tactic call ran for 1.2 secs (1.18u,0.017s) (success)
Building all_base...
Crunching: (fst SF Hab = S H3)
Building all_idents...
Building ident_index...
Assembling verified rewriter...
Refining with verified rewriter...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building eta_ident_cps...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building simple_idents...
Building all_raw_idents...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Building split_raw_ident_gen...
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building invert_bind_args...
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Crunching: (fst SF Hab = S H3)
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Crunching: (Z.of_nat (length (nat_to_binlist m Hm)) = Z.of_nat m)
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building eta_pattern_ident_cps_gen_expand_literal...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite if_dtt
if
((fix Ffix (x x0 : nat) {struct x} : bool :=
    match x with
    | 0 => true
    | S x1 => match x0 with
              | 0 => false
              | S x2 => Ffix x1 x2
              end
    end) (let (x, _) := H in x) x)
then
(fun
   x0 : (fix Ffix (x x0 : nat) {struct x} : bool :=
           match x with
           | 0 => true
           | S x1 => match x0 with
                     | 0 => false
                     | S x2 => Ffix x1 x2
                     end
           end) (let (x, _) := H in x) x = true =>
 exist
   (fun x : nat =>
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => true
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x 1 = true) (let (x, _) := H in x)
   (ltN_intro_lemma1 1 (exist (fun k : nat => (k <? 2) = true) (S x) e) H x0))
else
(fun
   x0 : (fix Ffix (x x0 : nat) {struct x} : bool :=
           match x with
           | 0 => true
           | S x1 => match x0 with
                     | 0 => false
                     | S x2 => Ffix x1 x2
                     end
           end) (let (x, _) := H in x) x = false =>
 exist
   (fun x : nat =>
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => true
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x 1 = true) (S (let (x, _) := H in x))
   (ltN_intro_lemma2 1 (exist (fun k : nat => (k <? 2) = true) (S x) e) H x0))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building split_types...
Building add_types_from_raw_sig...
find_witness Control.TimeoutCrunching: (fst SF Hab = S H3)
Building to_type_split_types_subst_default_eq...
Building index_of_base...
Building base_type_list...
Building projT1_add_types_from_raw_sig_eq...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Crunching: (f < 2 ^ x -> length (nat_to_binlist x f) = x)
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building arg_types_unfolded...
Building buildEagerIdentAndInterpCorrect...
destruct  p0  in  x
Building buildEagerIdent...
Building type_of_list_arg_types_beq_unfolded...
Building buildInterpEagerIdentCorrect...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building toRestrictedIdentAndCorrect...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building to_typed_unfolded...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building of_typed_ident_unfolded...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building arg_types_of_typed_ident_unfolded...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building all_base...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building unify...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite if_dtt
if
((fix Ffix (x x0 : nat) {struct x} : bool :=
    match x with
    | 0 => true
    | S x1 => match x0 with
              | 0 => false
              | S x2 => Ffix x1 x2
              end
    end) (let (x, _) := H in x) x)
then
(fun
   x0 : (fix Ffix (x x0 : nat) {struct x} : bool :=
           match x with
           | 0 => true
           | S x1 => match x0 with
                     | 0 => false
                     | S x2 => Ffix x1 x2
                     end
           end) (let (x, _) := H in x) x = true =>
 exist
   (fun x : nat =>
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => true
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x 1 = true) (let (x, _) := H in x)
   (ltN_intro_lemma1 1 (exist (fun k : nat => (k <? 2) = true) (S x) e) H x0))
else
(fun
   x0 : (fix Ffix (x x0 : nat) {struct x} : bool :=
           match x with
           | 0 => true
           | S x1 => match x0 with
                     | 0 => false
                     | S x2 => Ffix x1 x2
                     end
           end) (let (x, _) := H in x) x = false =>
 exist
   (fun x : nat =>
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => true
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x 1 = true) (S (let (x, _) := H in x))
   (ltN_intro_lemma2 1 (exist (fun k : nat => (k <? 2) = true) (S x) e) H x0))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
Tactic call ran for 0.014 secs (0.01u,0.004s) (success)
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building split_raw_ident_gen...
Crunching:
(forall x0 : R,
 (7 / 8 <= x0 <= 7 / 4)%R /\ (- cos x0)%R = 0%R ->
 (sum_f_R0 (tg_alt PI_tg) 1 < Alt_PI / 4)%R ->
 length (nat_to_binlist x r) = x)
Crunching:
(forall x0 : R,
 (7 / 8 <= x0 <= 7 / 4)%R /\ (- cos x0)%R = 0%R ->
 (tg_alt PI_tg 0 + tg_alt PI_tg 1 < Alt_PI / 4)%R ->
 length (nat_to_binlist x r) = x)
Building unify_unknown...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building final ident package...
find_witness Control.TimeoutProving is_simple_correct0...
Building invert_bind_args...
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Crunching: (length (nat_to_binlist x r) = x)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.969 secs (0.958u,0.009s) (success)
Proving invert_bind_args_raw_to_typed...
Crunching:
((Alt_PI / 4 < sum_f_R0 (tg_alt PI_tg) (2 * 0))%R ->
 length (nat_to_binlist x r) = x)
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite if_dtt
if
((fix Ffix (x x0 : nat) {struct x} : bool :=
    match x with
    | 0 => true
    | S x1 => match x0 with
              | 0 => false
              | S x2 => Ffix x1 x2
              end
    end) (let (x, _) := H in x) x)
then
(fun
   x0 : (fix Ffix (x x0 : nat) {struct x} : bool :=
           match x with
           | 0 => true
           | S x1 => match x0 with
                     | 0 => false
                     | S x2 => Ffix x1 x2
                     end
           end) (let (x, _) := H in x) x = true =>
 exist
   (fun x : nat =>
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => true
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x 1 = true) (let (x, _) := H in x)
   (ltN_intro_lemma1 1 (exist (fun k : nat => (k <? 2) = true) (S x) e) H x0))
else
(fun
   x0 : (fix Ffix (x x0 : nat) {struct x} : bool :=
           match x with
           | 0 => true
           | S x1 => match x0 with
                     | 0 => false
                     | S x2 => Ffix x1 x2
                     end
           end) (let (x, _) := H in x) x = false =>
 exist
   (fun x : nat =>
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => true
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x 1 = true) (S (let (x, _) := H in x))
   (ltN_intro_lemma2 1 (exist (fun k : nat => (k <? 2) = true) (S x) e) H x0))
Tactic call ran for 0.548 secs (0.537u,0.009s) (success)
Proving fold_invert_bind_args...
Building add_types_from_raw_sig...
Tactic call ran for 0.139 secs (0.137u,0.001s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.032 secs (0.032u,0.s) (success)
Proving eq_indep_types_of_eq_types...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite if_dtt
if
((fix Ffix (x x0 : nat) {struct x} : bool :=
    match x with
    | 0 => true
    | S x1 => match x0 with
              | 0 => false
              | S x2 => Ffix x1 x2
              end
    end) (let (x, _) := H in x) x)
then
(fun
   x0 : (fix Ffix (x x0 : nat) {struct x} : bool :=
           match x with
           | 0 => true
           | S x1 => match x0 with
                     | 0 => false
                     | S x2 => Ffix x1 x2
                     end
           end) (let (x, _) := H in x) x = true =>
 exist
   (fun x : nat =>
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => true
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x 1 = true) (let (x, _) := H in x)
   (ltN_intro_lemma1 1 (exist (fun k : nat => (k <? 2) = true) (S x) e) H x0))
else
(fun
   x0 : (fix Ffix (x x0 : nat) {struct x} : bool :=
           match x with
           | 0 => true
           | S x1 => match x0 with
                     | 0 => false
                     | S x2 => Ffix x1 x2
                     end
           end) (let (x, _) := H in x) x = false =>
 exist
   (fun x : nat =>
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => true
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x 1 = true) (S (let (x, _) := H in x))
   (ltN_intro_lemma2 1 (exist (fun k : nat => (k <? 2) = true) (S x) e) H x0))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Tactic call ran for 1.591 secs (1.554u,0.022s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Crunching: (length (nat_to_binlist x r) = x)
Crunching:
((Alt_PI / 4 < sum_f_R0 (tg_alt PI_tg) (2 * 0))%R ->
 length (nat_to_binlist x r) = x)
Crunching: (length (nat_to_binlist x r) = x)
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Crunching: (Nat.testbit (fst SF 0) m = Nat.testbit (S nna) m)
Crunching: (S H3 = fst SF Hab)
Crunching: (fst SF Hab = S H3)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Building unify...
Tactic call ran for 3.033 secs (3.006u,0.012s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
rewrite if_dtt
if
((fix leb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => true
    | S n' => match m with
              | 0 => false
              | S m' => leb n' m'
              end
    end) x (let (a, _) := H in a))
then
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) x (let (a, _) := H in a) = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S l2) = true) x
   (ltN_intro_lemma1 (S l2)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S l2) = true) (S (let (a, _) := H in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) l2 = true) := H in
          b))
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k l2 = true) x e) E1))
else
(fun
   E1 : (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m' => leb n' m'
                     end
           end) x (let (a, _) := H in a) = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S l2) = true) (S x)
   (ltN_intro_lemma2 (S l2)
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k (S l2) = true) (S (let (a, _) := H in a))
         (let
            (a, b) as e
             return
               ((fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0 => true
                   | S n' =>
                       match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
                   end) (let (a, _) := e in a) l2 = true) := H in
          b))
      (exist
         (fun k : nat =>
          (fix leb (n m : nat) {struct n} : bool :=
             match n with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) k l2 = true) x e) E1))
Building unify_unknown...
Building final ident package...
Crunching: (fst SF Hab = S H3)
Proving is_simple_correct0...
Tactic call ran for 0.722 secs (0.715u,0.005s) (success)
Proving invert_bind_args_raw_to_typed...
Crunching:
((Alt_PI / 4 < sum_f_R0 (tg_alt PI_tg) (S (0 + 1) * 0))%R ->
 length (nat_to_binlist x r) = x)
Tactic call ran for 0.459 secs (0.452u,0.006s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.055 secs (0.055u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.027 secs (0.027u,0.s) (success)
Proving eq_indep_types_of_eq_types...
find_witness Control.Timeoutfind_witness Control.TimeoutTactic call ran for 1.463 secs (1.449u,0.01s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.01 secs (0.008u,0.001s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Crunching: (∣1⟩ = basis_vector 2 1)
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Reifying...
Tactic call ran for 3.131 secs (3.11u,0.013s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
rewrite match_nat_dtt
match (let (x, _) := H in x) with
| 0 => (fun _ : (let (x, _) := H in x) = 0 => None)
| S m =>
(fun (H0 : nat) (x : (let (x, _) := H in x) = S H0) =>
 Some
   (exist
      (fun x0 : nat =>
       match n with
       | 0 => false
       | S x1 =>
           (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
              match x2 with
              | 0 => true
              | S x4 => match x3 with
                        | 0 => false
                        | S x5 => Ffix x4 x5
                        end
              end) x0 x1
       end = true) H0 (ltN_pred_lemma0 H H0 x)))
Crunching: (∣1⟩ = basis_vector 2 1)
Reifying...
Crunching: (0 < 0)%R
Tactic call ran for 0.006 secs (0.005u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (∣1⟩ = basis_vector 2 1)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Finished transaction in 16.988 secs (16.945u,0.023s) (successful)
Compiling decision tree...
Splitting rewrite rules...
Compiling decision tree...
Splitting rewrite rules...
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (n <= l -> funbool_to_list n (update P l v) = funbool_to_list n P)
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.242 secs (0.241u,0.s) (success)
Tactic call ran for 0.377 secs (0.375u,0.001s) (success)
Tactic call ran for 0.146 secs (0.146u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Crunching:
(S a <= Hz -> funbool_to_list (S a) (update x Hz n) = funbool_to_list (S a) x)
Tactic call ran for 0.155 secs (0.154u,0.001s) (success)
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.594 secs (0.582u,0.011s) (success)
Tactic call ran for 1.984 secs (1.952u,0.027s) (success)
Proving Rewriter_Interp...
Crunching: (∣1⟩ = basis_vector 2 1)
Tactic call ran for 0.557 secs (0.544u,0.011s) (success)
Crunching:
(update l n l1 a :: funbool_to_list a (update l n l1) =
 l a :: funbool_to_list a l)
Tactic call ran for 1.167 secs (1.144u,0.022s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 46.038 secs (45.385u,0.558s) (successful)
Tactic call ran for 6.238 secs (6.072u,0.159s) (success)
Tactic call ran for 0.256 secs (0.255u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.583 secs (0.576u,0.005s) (success)
Tactic call ran for 3.116 secs (3.061u,0.036s) (success)
Proving Rewriter_Interp...
Tactic call ran for 1.214 secs (1.2u,0.007s) (success)
find_witness Control.TimeoutTactic call ran for 1.757 secs (1.745u,0.007s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
find_witness Control.TimeoutCrunching: (n <= l -> funbool_to_list n (update P l v) = funbool_to_list n P)
Finished transaction in 101.426 secs (99.902u,1.219s) (successful)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.003u,0.001s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(Un_cv (fun N : nat => sum_f_R0 (tg_alt PI_tg) N) H5 ->
 x <= y ->
 (if Rle_dec x (tan (atan y)) then tan (atan y) else x) < z ->
 x < z /\ tan (atan y) < z)
Success: (dlet y0 : Z := e1 + e2 in
          [y; y + 1; y + 2; y + y0; y + (y0 + 1)])
Finished transaction in 3.282 secs (3.246u,0.03s) (successful)
Crunching:
(Un_cv (fun N : nat => sum_f_R0 (tg_alt PI_tg) N) H5 ->
 x <= y ->
 (if Rle_dec x (tan (atan y)) then tan (atan y) else x) < z ->
 x < z /\ tan (atan y) < z)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Success: [x1; x1; x1; x2; x2; x2; x3; x3; x3]
Finished transaction in 3.303 secs (3.212u,0.086s) (successful)
out of reach
Tactic call ran for 0.015 secs (0.007u,0.008s) (failure)
Crunching: (x - z <= HF)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
      list bool :=
    match len with
    | 0 => []
    | S len' => f len' :: funbool_to_list len' f
    end) Mxx
   ((fix list_to_funbool (len : nat) (l : list bool) {struct l} :
         nat -> bool :=
       match l with
       | [] => fun _ : nat => false
       | h :: t =>
           fun j : nat =>
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => match m with
                      | 0 => true
                      | S _ => false
                      end
               | S n' => match m with
                         | 0 => false
                         | S m' => eqb n' m'
                         end
               end) j
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1)
           then h
           else
            list_to_funbool
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1) t j
       end) Mxx H8) = H8)
Crunching:
((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
      list bool :=
    match len with
    | 0 => []
    | S len' => f len' :: funbool_to_list len' f
    end) Mxx
   ((fix list_to_funbool (len : nat) (l : list bool) {struct l} :
         nat -> bool :=
       match l with
       | [] => fun _ : nat => false
       | h :: t =>
           fun j : nat =>
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => match m with
                      | 0 => true
                      | S _ => false
                      end
               | S n' => match m with
                         | 0 => false
                         | S m' => eqb n' m'
                         end
               end) j
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1)
           then h
           else
            list_to_funbool
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1) t j
       end) Mxx H8) = H8)
Crunching: nat
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(Un_cv (fun N : nat => sum_f_R0 (tg_alt PI_tg) N) H5 ->
 x <= y ->
 (if Rle_dec x (tan (atan y)) then tan (atan y) else x) < z ->
 x < z /\ tan (atan y) < z)
Crunching:
((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
      list bool :=
    match len with
    | 0 => []
    | S len' => f len' :: funbool_to_list len' f
    end) Mxx
   ((fix list_to_funbool (len : nat) (l : list bool) {struct l} :
         nat -> bool :=
       match l with
       | [] => fun _ : nat => false
       | h :: t =>
           fun j : nat =>
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => match m with
                      | 0 => true
                      | S _ => false
                      end
               | S n' => match m with
                         | 0 => false
                         | S m' => eqb n' m'
                         end
               end) j
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1)
           then h
           else
            list_to_funbool
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1) t j
       end) Mxx H8) = H8)
Crunching:
((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
      list bool :=
    match len with
    | 0 => []
    | S len' => f len' :: funbool_to_list len' f
    end) Mxx
   ((fix list_to_funbool (len : nat) (l : list bool) {struct l} :
         nat -> bool :=
       match l with
       | [] => fun _ : nat => false
       | h :: t =>
           fun j : nat =>
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => match m with
                      | 0 => true
                      | S _ => false
                      end
               | S n' => match m with
                         | 0 => false
                         | S m' => eqb n' m'
                         end
               end) j
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1)
           then h
           else
            list_to_funbool
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1) t j
       end) Mxx H8) = H8)
Crunching:
(Un_cv (fun N : nat => sum_f_R0 (tg_alt PI_tg) N) H5 ->
 x <= y ->
 (if Rle_dec x (tan (atan y)) then tan (atan y) else x) < z ->
 x < z /\ tan (atan y) < z)
Crunching:
((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
      list bool :=
    match len with
    | 0 => []
    | S len' => f len' :: funbool_to_list len' f
    end) Mxx
   ((fix list_to_funbool (len : nat) (l : list bool) {struct l} :
         nat -> bool :=
       match l with
       | [] => fun _ : nat => false
       | h :: t =>
           fun j : nat =>
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => match m with
                      | 0 => true
                      | S _ => false
                      end
               | S n' => match m with
                         | 0 => false
                         | S m' => eqb n' m'
                         end
               end) j
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1)
           then h
           else
            list_to_funbool
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1) t j
       end) Mxx H8) = H8)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
      list bool :=
    match len with
    | 0 => []
    | S len' => f len' :: funbool_to_list len' f
    end) Mxx
   ((fix list_to_funbool (len : nat) (l : list bool) {struct l} :
         nat -> bool :=
       match l with
       | [] => fun _ : nat => false
       | h :: t =>
           fun j : nat =>
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => match m with
                      | 0 => true
                      | S _ => false
                      end
               | S n' => match m with
                         | 0 => false
                         | S m' => eqb n' m'
                         end
               end) j
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1)
           then h
           else
            list_to_funbool
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1) t j
       end) Mxx H8) = H8)
Crunching:
((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
      list bool :=
    match len with
    | 0 => []
    | S len' => f len' :: funbool_to_list len' f
    end) Mxx
   ((fix list_to_funbool (len : nat) (l : list bool) {struct l} :
         nat -> bool :=
       match l with
       | [] => fun _ : nat => false
       | h :: t =>
           fun j : nat =>
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => match m with
                      | 0 => true
                      | S _ => false
                      end
               | S n' => match m with
                         | 0 => false
                         | S m' => eqb n' m'
                         end
               end) j
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1)
           then h
           else
            list_to_funbool
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1) t j
       end) Mxx H8) = H8)
Crunching:
((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
      list bool :=
    match len with
    | 0 => []
    | S len' => f len' :: funbool_to_list len' f
    end) Mxx
   ((fix list_to_funbool (len : nat) (l : list bool) {struct l} :
         nat -> bool :=
       match l with
       | [] => fun _ : nat => false
       | h :: t =>
           fun j : nat =>
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => match m with
                      | 0 => true
                      | S _ => false
                      end
               | S n' => match m with
                         | 0 => false
                         | S m' => eqb n' m'
                         end
               end) j
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1)
           then h
           else
            list_to_funbool
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1) t j
       end) Mxx H8) = H8)
Crunching:
(Un_cv (fun N : nat => sum_f_R0 (tg_alt PI_tg) N) H5 ->
 x <= y ->
 (if Rle_dec x (tan (atan y)) then tan (atan y) else x) < z ->
 x < z /\ tan (atan y) < z)
Crunching:
((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
      list bool :=
    match len with
    | 0 => []
    | S len' => f len' :: funbool_to_list len' f
    end) Mxx
   ((fix list_to_funbool (len : nat) (l : list bool) {struct l} :
         nat -> bool :=
       match l with
       | [] => fun _ : nat => false
       | h :: t =>
           fun j : nat =>
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => match m with
                      | 0 => true
                      | S _ => false
                      end
               | S n' => match m with
                         | 0 => false
                         | S m' => eqb n' m'
                         end
               end) j
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1)
           then h
           else
            list_to_funbool
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1) t j
       end) Mxx H8) = H8)
Crunching:
((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
      list bool :=
    match len with
    | 0 => []
    | S len' => f len' :: funbool_to_list len' f
    end) Mxx
   ((fix list_to_funbool (len : nat) (l : list bool) {struct l} :
         nat -> bool :=
       match l with
       | [] => fun _ : nat => false
       | h :: t =>
           fun j : nat =>
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => match m with
                      | 0 => true
                      | S _ => false
                      end
               | S n' => match m with
                         | 0 => false
                         | S m' => eqb n' m'
                         end
               end) j
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1)
           then h
           else
            list_to_funbool
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1) t j
       end) Mxx H8) = H8)
Crunching:
((fix funbool_to_list (len : nat) (f : nat -> bool) {struct len} :
      list bool :=
    match len with
    | 0 => []
    | S len' => f len' :: funbool_to_list len' f
    end) Mxx
   ((fix list_to_funbool (len : nat) (l : list bool) {struct l} :
         nat -> bool :=
       match l with
       | [] => fun _ : nat => false
       | h :: t =>
           fun j : nat =>
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => match m with
                      | 0 => true
                      | S _ => false
                      end
               | S n' => match m with
                         | 0 => false
                         | S m' => eqb n' m'
                         end
               end) j
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1)
           then h
           else
            list_to_funbool
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0 => n
                  | S k => match m with
                           | 0 => n
                           | S l0 => sub k l0
                           end
                  end) len 1) t j
       end) Mxx H8) = H8)
find_witness Control.TimeoutCrunching: (x = y)
Crunching: (snd a 0 = 0%nat)
Crunching: (snd a 0 = 0%nat)
Crunching: (snd a 0 = 0%nat)
Crunching: (snd Hfalse x = x)
Crunching: (snd Hfalse x = x)
Crunching: (funbool_to_list Hn (list_to_funbool Hn l) = l)
Crunching:
(exists alp : R,
   (alp > 0)%R /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\ (dist R_met x 1 < alp)%R ->
    (dist R_met (atan x) (atan 1) < a)%R))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (snd a 0 = 0%nat)
Crunching: (snd Hfalse x = x)
Crunching: (snd Hfalse x = x)
Crunching: (snd b n = n)
Crunching: (- PI < - (PI * / 2) -> snd n m = m)
find_witness Control.TimeoutCrunching: (∣0⟩ = basis_vector 2 0)
Crunching: (snd Hfalse x = x)
Crunching: (snd Hfalse x = x)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
(combine l' n =
 list_rect (fun _ : list a => list m -> list (a * m)) 
   (fun _ : list m => [])
   (fun (x : a) (_ : list a) (r : list m -> list (a * m)) (lb : list m) =>
    list_case (fun _ : list m => list (a * m)) []
      (fun (y : m) (ys : list m) => (x, y) :: r ys) lb) l' n)
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.37 secs (0.36u,0.009s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.209 secs (0.206u,0.002s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.023 secs (0.023u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.014 secs (0.014u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Crunching: (funbool_to_nat EQ (nat_to_funbool EQ n) = n)
Tactic call ran for 0.772 secs (0.749u,0.016s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Crunching:
(forall n : nat, n < 2 ^ EQ -> funbool_to_nat EQ (nat_to_funbool EQ n) = n)
Crunching: (funbool_to_nat EQ (nat_to_funbool EQ n) = n)
Tactic call ran for 1.478 secs (1.451u,0.025s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.072 secs (0.072u,0.s) (success)
Tactic call ran for 0.04 secs (0.036u,0.003s) (success)
Tactic call ran for 0.05 secs (0.05u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.033 secs (0.032u,0.s) (success)
Tactic call ran for 0.453 secs (0.446u,0.005s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.157 secs (0.156u,0.s) (success)
Tactic call ran for 0.19 secs (0.186u,0.004s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 17.788 secs (17.461u,0.283s) (successful)
Crunching:
(forall x : nat,
 match
   (fix pow (n m : nat) {struct m} : nat :=
      match m with
      | 0%nat => 1%nat
      | S m0 =>
          (fix mul (n0 m1 : nat) {struct n0} : nat :=
             match n0 with
             | 0%nat => 0%nat
             | S p =>
                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                    match n1 with
                    | 0%nat => m2
                    | S p0 => S (add p0 m2)
                    end) m1 (mul p m1)
             end) n (pow n m0)
      end) 2%nat EQ
 with
 | 0%nat =>
     (fix add (n m : nat) {struct n} : nat :=
        match n with
        | 0%nat => m
        | S p => S (add p m)
        end)
       ((fix pow (n m : nat) {struct m} : nat :=
           match m with
           | 0%nat => 1%nat
           | S m0 =>
               (fix mul (n0 m1 : nat) {struct n0} : nat :=
                  match n0 with
                  | 0%nat => 0%nat
                  | S p =>
                      (fix add (n1 m2 : nat) {struct n1} : nat :=
                         match n1 with
                         | 0%nat => m2
                         | S p0 => S (add p0 m2)
                         end) m1 (mul p m1)
                  end) n (pow n m0)
           end) 2%nat EQ) x
 | S y' =>
     (fix sub (n m : nat) {struct n} : nat :=
        match n with
        | 0%nat => n
        | S k => match m with
                 | 0%nat => n
                 | S l => sub k l
                 end
        end) y'
       (let (_, y) :=
          (fix divmod (x0 y q u : nat) {struct x0} : nat * nat :=
             match x0 with
             | 0%nat => (q, u)
             | S x' =>
                 match u with
                 | 0%nat => divmod x' y (S q) y
                 | S u' => divmod x' y q u'
                 end
             end)
            ((fix add (n m : nat) {struct n} : nat :=
                match n with
                | 0%nat => m
                | S p => S (add p m)
                end)
               ((fix pow (n m : nat) {struct m} : nat :=
                   match m with
                   | 0%nat => 1%nat
                   | S m0 =>
                       (fix mul (n0 m1 : nat) {struct n0} : nat :=
                          match n0 with
                          | 0%nat => 0%nat
                          | S p =>
                              (fix add (n1 m2 : nat) {struct n1} : nat :=
                                 match n1 with
                                 | 0%nat => m2
                                 | S p0 => S (add p0 m2)
                                 end) m1 (mul p m1)
                          end) n (pow n m0)
                   end) 2%nat EQ) x) y' 0%nat y' in
        y)
 end =
 match
   (fix pow (n m : nat) {struct m} : nat :=
      match m with
      | 0%nat => 1%nat
      | S m0 =>
          (fix mul (n0 m1 : nat) {struct n0} : nat :=
             match n0 with
             | 0%nat => 0%nat
             | S p =>
                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                    match n1 with
                    | 0%nat => m2
                    | S p0 => S (add p0 m2)
                    end) m1 (mul p m1)
             end) n (pow n m0)
      end) 2%nat EQ
 with
 | 0%nat => x
 | S y' =>
     (fix sub (n m : nat) {struct n} : nat :=
        match n with
        | 0%nat => n
        | S k => match m with
                 | 0%nat => n
                 | S l => sub k l
                 end
        end) y'
       (let (_, y) :=
          (fix divmod (x0 y q u : nat) {struct x0} : nat * nat :=
             match x0 with
             | 0%nat => (q, u)
             | S x' =>
                 match u with
                 | 0%nat => divmod x' y (S q) y
                 | S u' => divmod x' y q u'
                 end
             end) x y' 0%nat y' in
        y)
 end)
find_witness Control.TimeoutFinished transaction in 5.069 secs (4.982u,0.083s) (successful)
Crunching:
(forall x : nat,
 match
   (fix pow (n m : nat) {struct m} : nat :=
      match m with
      | 0%nat => 1%nat
      | S m0 =>
          (fix mul (n0 m1 : nat) {struct n0} : nat :=
             match n0 with
             | 0%nat => 0%nat
             | S p =>
                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                    match n1 with
                    | 0%nat => m2
                    | S p0 => S (add p0 m2)
                    end) m1 (mul p m1)
             end) n (pow n m0)
      end) 2%nat EQ
 with
 | 0%nat =>
     (fix add (n m : nat) {struct n} : nat :=
        match n with
        | 0%nat => m
        | S p => S (add p m)
        end)
       ((fix pow (n m : nat) {struct m} : nat :=
           match m with
           | 0%nat => 1%nat
           | S m0 =>
               (fix mul (n0 m1 : nat) {struct n0} : nat :=
                  match n0 with
                  | 0%nat => 0%nat
                  | S p =>
                      (fix add (n1 m2 : nat) {struct n1} : nat :=
                         match n1 with
                         | 0%nat => m2
                         | S p0 => S (add p0 m2)
                         end) m1 (mul p m1)
                  end) n (pow n m0)
           end) 2%nat EQ) x
 | S y' =>
     (fix sub (n m : nat) {struct n} : nat :=
        match n with
        | 0%nat => n
        | S k => match m with
                 | 0%nat => n
                 | S l => sub k l
                 end
        end) y'
       (let (_, y) :=
          (fix divmod (x0 y q u : nat) {struct x0} : nat * nat :=
             match x0 with
             | 0%nat => (q, u)
             | S x' =>
                 match u with
                 | 0%nat => divmod x' y (S q) y
                 | S u' => divmod x' y q u'
                 end
             end)
            ((fix add (n m : nat) {struct n} : nat :=
                match n with
                | 0%nat => m
                | S p => S (add p m)
                end)
               ((fix pow (n m : nat) {struct m} : nat :=
                   match m with
                   | 0%nat => 1%nat
                   | S m0 =>
                       (fix mul (n0 m1 : nat) {struct n0} : nat :=
                          match n0 with
                          | 0%nat => 0%nat
                          | S p =>
                              (fix add (n1 m2 : nat) {struct n1} : nat :=
                                 match n1 with
                                 | 0%nat => m2
                                 | S p0 => S (add p0 m2)
                                 end) m1 (mul p m1)
                          end) n (pow n m0)
                   end) 2%nat EQ) x) y' 0%nat y' in
        y)
 end =
 match
   (fix pow (n m : nat) {struct m} : nat :=
      match m with
      | 0%nat => 1%nat
      | S m0 =>
          (fix mul (n0 m1 : nat) {struct n0} : nat :=
             match n0 with
             | 0%nat => 0%nat
             | S p =>
                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                    match n1 with
                    | 0%nat => m2
                    | S p0 => S (add p0 m2)
                    end) m1 (mul p m1)
             end) n (pow n m0)
      end) 2%nat EQ
 with
 | 0%nat => x
 | S y' =>
     (fix sub (n m : nat) {struct n} : nat :=
        match n with
        | 0%nat => n
        | S k => match m with
                 | 0%nat => n
                 | S l => sub k l
                 end
        end) y'
       (let (_, y) :=
          (fix divmod (x0 y q u : nat) {struct x0} : nat * nat :=
             match x0 with
             | 0%nat => (q, u)
             | S x' =>
                 match u with
                 | 0%nat => divmod x' y (S q) y
                 | S u' => divmod x' y q u'
                 end
             end) x y' 0%nat y' in
        y)
 end)
Crunching: (∣0⟩ = basis_vector 2 0)
Finished transaction in 3.048 secs (2.988u,0.051s) (successful)
Finished transaction in 116.189 secs (115.76u,0.283s) (successful)
rewrite if_dtt
if (proj1_sig k1 + proj1_sig k2 <? n)
then
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = true =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2) n E)
else
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = false =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2 - n) n (ltN_plus_mod_lemma1 k1 k2 E))
find_witness Control.TimeoutBuilding index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.75 secs (0.732u,0.016s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.486 secs (0.469u,0.016s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.052 secs (0.052u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.038 secs (0.038u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 1.446 secs (1.417u,0.026s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 3.057 secs (3.006u,0.044s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
simplified dependent [if true]
e : (x <? n1)  = true
if (x <? n1)
then (fun E0 : (x <? n1) = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : (x <? n1) = false =>
 BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 (ltN_plus_lemma1 e) E0)))
Crunching: (nat_to_binlist' (2 * S n + 1) = true :: nat_to_binlist' (S n))
Compiling decision tree...
Splitting rewrite rules...
((fix In (a : positive * Z) (l : list (positive * Z)) {struct l} : Prop :=
    match l with
    | [] => False
    | b :: m => b = a \/ In a m
    end) (n0, H2) consts_list)
find_witness Control.TimeoutAssembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.414 secs (0.408u,0.005s) (success)
Tactic call ran for 2.028 secs (2.011u,0.012s) (success)
Tactic call ran for 0.22 secs (0.22u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Crunching: (forall y : nat, (y < 2 ^ n)%nat -> snd n (HF * 2 ^ n + y) = y)
Proving Rewriter_Wf...
Tactic call ran for 0.353 secs (0.344u,0.007s) (success)
find_witness Control.TimeoutTactic call ran for 3.294 secs (3.254u,0.033s) (success)
Proving Rewriter_Interp...
Crunching: (nat_to_binlist' (2 * S n + 1) = true :: nat_to_binlist' (S n))
Crunching: (nat_to_binlist' (1 + 2 * S n) = true :: nat_to_binlist' (S n))
Crunching: (nat_to_binlist' (2 * S n + 1) = true :: nat_to_binlist' (S n))
Crunching: (forall y : nat, (y < 2 ^ n)%nat -> snd n (HF * 2 ^ n + y) = y)
Crunching: (nat_to_binlist' (1 + 2 * S n) = true :: nat_to_binlist' (S n))
Crunching: (snd n (HF * 2 ^ n + y) = y)
Crunching: (nat_to_binlist' (2 * S n + 1) = true :: nat_to_binlist' (S n))
Tactic call ran for 0.905 secs (0.898u,0.005s) (success)
Crunching: (snd a (b * S c + c) = c)
Tactic call ran for 2.423 secs (2.397u,0.02s) (success)
Finished transaction in 146.788 secs (144.737u,0.94s) (successful)
Crunching:
(forall i : nat,
 list_to_funbool n (nat_to_binlist' (binlist_to_nat [])) i =
 list_to_funbool n [] i)
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat (b :: a))) X =
 list_to_funbool n (b :: a) X)
Assembling verified rewriter...
Refining with verified rewriter...
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall i : nat,
 list_to_funbool n (nat_to_binlist' (binlist_to_nat [])) i =
 list_to_funbool n [] i)
rewrite if_dtt
if (n1 + x <? n1)
then (fun E0 : (n1 + x <? n1) = true => AA (ltN_of_nat (n1 + x) n1 E0))
else
(fun E0 : (n1 + x <? n1) = false =>
 BB (ltN_of_nat (n1 + x - n1) n2 (ltN_split_lemma1 (plus_ltN_lemma1 e) E0)))
Crunching:
(list_to_funbool x (nat_to_binlist' (binlist_to_nat (a :: l))) i =
 list_to_funbool x (a :: l) i)
Crunching: (PI <= 4 -> 1 - 1 / 6 <= sin 1)
Crunching: (PI <= 4 -> 1 - 1 / 6 <= sin 1)
Crunching: (forall n : nat, t0 ^ n * t0 = t0 ^ (n + 1))
Crunching: (PI <= 4 -> 1 - 1 / 6 <= sin 1)
Crunching: (PI <= 4 -> 1 - 1 / 6 <= sin 1)
Crunching:
(forall i : nat,
 list_to_funbool n (nat_to_binlist' (binlist_to_nat [])) i =
 list_to_funbool n [] i)
Crunching: (PI <= 4 -> 1 - 1 / 6 <= sin 1)
Crunching: (PI <= 4 -> 1 - 1 / 6 <= sin 1)
find_witness Control.TimeoutCrunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat (b :: a))) X =
 list_to_funbool n (b :: a) X)
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) He =
 list_to_funbool n a He)
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) He =
 list_to_funbool n a He)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.TimeoutCrunching:
(big_sum (fun i : nat => nth i (scale P3 H) 0) (length (scale P3 H)) =
 (P3 * big_sum (fun i : nat => nth i H 0) (length H))%R)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: False
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(big_sum (fun i : nat => nth i (scale P3 H) 0) (length (scale P3 H)) =
 (P3 * big_sum (fun i : nat => nth i H 0) (length H))%R)
Crunching:
(big_sum (fun i : nat => nth i (scale P3 H) 0) (length (scale P3 H)) =
 (P3 * big_sum (fun i : nat => nth i H 0) (length H))%R)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: (forall i : nat, list_to_funbool H7 (repeat false H7) i = false)
out of reach
Tactic call ran for 0.007 secs (0.006u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching: (sum_over_list (scale x l) = (x * sum_over_list l)%R)
Crunching: False
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (forall i : nat, list_to_funbool H7 (repeat false H7) i = false)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: False
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(big_sum (fun i : nat => nth i (scale P3 H) 0) (length (scale P3 H)) =
 (P3 * big_sum (fun i : nat => nth i H 0) (length H))%R)
Crunching:
(big_sum (fun i : nat => nth i (scale P3 H) 0) (length (scale P3 H)) =
 (P3 * big_sum (fun i : nat => nth i H 0) (length H))%R)
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (sum_over_list (scale P3 H) = IZR (Z.of_N 1))
find_witness Control.Timeoutout of reach
Tactic call ran for 0.006 secs (0.005u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: False
find_witness Control.Timeoutfind_witness Control.TimeoutCrunching:
((M < length H)%nat ->
 sum_over_list (firstn (S M) H) = (sum_over_list (firstn M H) + nth M H 0)%R)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: nat
(forall n0 : nat, make_ctx consts_list n~1 = Z.of_nat n0)
Crunching:
((M < length H)%nat ->
 sum_over_list (firstn (S M) H) = (sum_over_list (firstn M H) + nth M H 0)%R)
find_witness Control.TimeoutCrunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: nat
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (x m = false)
find_witness Control.Timeoutout of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(funbool_to_nat 0 Maj2 = 0 -> forall i : nat, i < 0 -> Maj2 i = false)
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Crunching: (l y = false)
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
find_witness Control.Timeoutrewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
out of reach
Tactic call ran for 0.007 secs (0.004u,0.s) (failure)
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (l' <? H1)
then
(fun E0 : (l' <? H1) = true =>
 AA (exist (fun k : nat => (k <? H1) = true) l' E0))
else
(fun E0 : (l' <? H1) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (l' - H1) (ltN_split_lemma1 HP E0)))
out of reach
Tactic call ran for 0.002 secs (0.001u,0.001s) (failure)
find_witness Control.Timeoutrewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (l' <? H1)
then
(fun E0 : (l' <? H1) = true =>
 AA (exist (fun k : nat => (k <? H1) = true) l' E0))
else
(fun E0 : (l' <? H1) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (l' - H1) (ltN_split_lemma1 HP E0)))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(0 <= H2 ->
 Forall (fun x : R => 0 <= x) H6 ->
 Forall (fun x : R => 0 <= x) (scale H2 H6))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
Crunching: False
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Crunching: False
rewrite if_dtt
if (l' <? H1)
then
(fun E0 : (l' <? H1) = true =>
 AA (exist (fun k : nat => (k <? H1) = true) l' E0))
else
(fun E0 : (l' <? H1) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (l' - H1) (ltN_split_lemma1 HP E0)))
Crunching: (0 <= Rabs m)
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
Crunching: (H10 0 = nat_to_funbool H (funbool_to_nat H H10) 0)
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
rewrite if_dtt
if (x0 <? n)
then
(fun E0 : (x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) x0 E0))
else
(fun E0 : (x0 <? n) = false =>
 BB (exist (fun k : nat => (k <? 0) = true) (x0 - n) (ltN_split_lemma1 e E0)))
destruct  (Nat.add_0_r n)  in  x
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
find_witness Control.TimeoutCrunching:
(0 <= H2 ->
 Forall (fun x : R => 0 <= x) H6 ->
 Forall (fun x : R => 0 <= x) (scale H2 H6))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
find_witness Control.TimeoutCrunching:
(Forall (fun x : R => 0 <= x) alp_1 ->
 Forall (fun x : R => 0 <= x) (scale E1 alp_1))
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
Crunching: (nat_to_funbool q (funbool_to_nat q f) i = f i)
Crunching:
(Forall (fun x : R => 0 <= x) H8 ->
 (forall i : nat, (i < length H8)%nat -> Forall (fun x : R => 0 <= x) (s1 i)) ->
 Forall (fun x : R => 0 <= x) (join H8 s1))
Crunching: False
Crunching:
(Forall (fun x : R => 0 <= x) f ->
 (forall i : nat, (i < length f)%nat -> Forall (fun x : R => 0 <= x) (l i)) ->
 Forall (fun x : R => 0 <= x) (join f l))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(Forall (fun x : R => 0 <= x) H8 ->
 (forall i : nat, (i < length H8)%nat -> Forall (fun x : R => 0 <= x) (s1 i)) ->
 Forall (fun x : R => 0 <= x) (join H8 s1))
Crunching: (Forall (fun x : R => 0 <= x) (join H8 Hr1))
Crunching: (Forall (fun x : R => 0 <= x) (join H8 Hr1))
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
Crunching: (H10 0 = nat_to_funbool H (funbool_to_nat H H10) 0)
Crunching: (nat_to_funbool H (funbool_to_nat H H10) 0 = H10 0)
Crunching: False
Crunching: False
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
((fun i j : nat => if (i =? n) && (j =? 0) then C1 else 0%R) =
 f_to_vec len (nat_to_funbool len n))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
((fun i j : nat => if (i =? n) && (j =? 0) then C1 else 0%R) =
 f_to_vec len (nat_to_funbool len n))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching: (y <> 0)
Crunching:
(Forall (fun x : R => 0 <= x) f ->
 (forall i : nat, (i < length f)%nat -> Forall (fun x : R => 0 <= x) (l i)) ->
 Forall (fun x : R => 0 <= x) (join f l))
Crunching:
((fun i j : nat => if (i =? 0) && (j =? 0) then C1 else 0%R) =
 f_to_vec len (nat_to_funbool len 0))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall n : nat,
 n < 2 ^ x ->
 (fun i j : nat => if (i =? n) && (j =? 0) then C1 else 0%R) =
 f_to_vec x (nat_to_funbool x n))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
((fun i j : nat => if (i =? y) && (j =? 0) then IZR (Z.succ 0) else 0%R) =
 f_to_vec Hocc (nat_to_funbool Hocc y))
Crunching: (forall a b : C, a / b - / b = (-1 + a) / b)
Crunching:
((fun i j : nat => if (i =? y) && (j =? 0) then IZR (Z.succ 0) else 0%R) =
 f_to_vec Hocc (nat_to_funbool Hocc y))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
out of reach
Tactic call ran for 0.005 secs (0.002u,0.s) (failure)
Crunching: (forall a b : C, a / b - / b = (-1 + a) / b)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching: (basis_vector 1 m = I 1)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching: (forall a b : C, a / b - / b = (-1 + a) / b)
Crunching: (forall a b : C, a / b - / b = (-1 + a) / b)
Crunching:
(Forall (fun x : R => 0 <= x) H8 ->
 (forall i : nat, (i < length H8)%nat -> Forall (fun x : R => 0 <= x) (s1 i)) ->
 Forall (fun x : R => 0 <= x) (join H8 s1))
Crunching:
(basis_vector (2 ^ len) n =
 f_to_vec len (list_to_funbool len (nat_to_binlist len n)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching: (Forall (fun x : R => 0 <= x) (join H8 Hr1))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (Forall (fun x : R => 0 <= x) (join H8 Hr1))
Crunching: (Forall (fun x : R => 0 <= x) (join H8 Hr1))
Crunching:
((fun i j : nat => if (i =? n) && (j =? 0) then C1 else 0%R) =
 f_to_vec len (nat_to_funbool len n))
Crunching:
(forall l2 : nat -> list R,
 Forall (fun x : R => 0 <= x) z ->
 (forall i : nat, (i < length z)%nat -> Forall (fun x : R => 0 <= x) (l2 i)) ->
 Forall (fun x : R => 0 <= x) (join z l2))
Crunching: (Forall (fun x : R => 0 <= x) (join H l2))
