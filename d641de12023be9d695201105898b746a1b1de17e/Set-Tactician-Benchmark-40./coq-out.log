find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
H : m < k + 1
l : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match l0 with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l0 with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
find_witness Control.TimeoutDebug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
a : m < k + 1
H : k < n + 1
e : forall (T : Type) (n n0 : nat), 'rV_(n * n0) -> 'I_n -> 'I_n0 -> T
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R; 
        (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R;
         c n k; d n k m]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match match l with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
find_witness Control.TimeoutDebug:
In environment
n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf2 n;
         annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf0 n; b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match match l with
                | [::] => [::]
                | _ :: x0 => x0
                end with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
n : nat
k, m : int
a : 0 <= k
b : 1 <= m
Ha : m < k + 1
H : k < n + 1
e : forall (T : Type) (n n0 : nat), 'rV_(n * n0) -> 'I_n -> 'I_n0 -> T
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R; 
        (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R;
         c n k; d n k m]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match match l with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
ihn : 2%:~R <= n -> ba_casoratian n = 6%:~R / (n%:~R + 1) ^ 3
nilG : 2%:~R <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n.+1; n%:R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add one
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end) one) zero))" (cannot unify "false" and 
"true").
find_witness Control.TimeoutDebug:
In environment
n : nat
ihn : 2%:~R <= n -> ba_casoratian n = 6%:~R / (n%:~R + 1) ^ 3
ltnT : forall n m p : nat, (m < n)%N -> (n < p)%N -> (m < p)%N
Ncmn : 2%:~R <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n.+1; n%:R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add one
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end) one) zero))" (cannot unify "false" and 
"true").
find_witness Control.TimeoutDebug:
In environment
n : nat
k, m : int
H : true
H1 : (0 <= k) = true
t0 : 1 <= m
d2 := d n k m : rat
leGn : m < k + 1
srd : k < 0%Z + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c 0%Z k; d2; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz 0%Z k)%:~R; (binomialz (0%Z + k) k)%:~R;
         (binomialz (0%Z - m) (0%Z - k))%:~R;
         (binomialz (0%Z + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
ihn : 2%:~R <= n.+1 -> ba_casoratian n.+1 = 6%:~R / (n.+1%:~R + 1) ^ 3
ltnT : forall n m p : nat, (m < n)%N -> (n < p)%N -> (m < p)%N
Ncmn : 2%:~R <= n.+2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n.+2; n%:R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add (F_of_nat 2%N)
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end) one) zero))" (cannot unify "false" and 
"true").
Debug:
In environment
ihn : 2%:~R <= 1%Z -> ba_casoratian 1%Z = 6%:~R / (1 + 1) ^ 3
ltnT : forall n m p : nat, (m < n)%N -> (n < p)%N -> (m < p)%N
Ncmn : 2%:~R <= 2%Z
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian 2%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
k, m : int
H : true
H1 : (0 <= k) = true
t0 : 1 <= m
d2 := d n k m : rat
leGn : m < k + 1
Pxs : k < 0%Z + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c 0%Z k; d2; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz 0%Z k)%:~R; (binomialz (0%Z + k) k)%:~R;
         (binomialz (0%Z - m) (0%Z - k))%:~R;
         (binomialz (0%Z + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
H : true
H1 : (0 <= k) = true
t0 : 1 <= m
d2 := d n k m : rat
leGn : m < k + 1
LS' : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d2; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
ihn : 2%:~R <= n -> ba_casoratian n = 6%:~R / (n%:~R + 1) ^ 3
f_dec : 2%:~R <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n.+1; n%:R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add one
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end) one) zero))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
ihn : 2%:~R <= n -> ba_casoratian n = 6%:~R / (n%:~R + 1) ^ 3
Ncmn : 2%:~R <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n.+1; n%:R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add one
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end) one) zero))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
H : true
H1 : (0 <= k) = true
p1 : 1 <= m
d2 := d n k m : rat
leGn : m < k + 1
srd : k < 0%Z + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c 0%Z k; d2; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz 0%Z k)%:~R; (binomialz (0%Z + k) k)%:~R;
         (binomialz (0%Z - m) (0%Z - k))%:~R;
         (binomialz (0%Z + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
H : true
H1 : (0 <= k) = true
p1 : 1 <= m
d2 := d n k m : rat
leGn : m < k + 1
Pxs : k < 0%Z + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c 0%Z k; d2; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz 0%Z k)%:~R; (binomialz (0%Z + k) k)%:~R;
         (binomialz (0%Z - m) (0%Z - k))%:~R;
         (binomialz (0%Z + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
H : true
H1 : (0 <= k) = true
p1 : 1 <= m
d2 := d n k m : rat
leGn : m < k + 1
LS' : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d2; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
x : 0 <= k
y : 1 <= m
rxy : m < k + 1
p_pr : k < n + 1
e : forall (T : Type) (n n0 : nat), 'rV_(n * n0) -> 'I_n -> 'I_n0 -> T
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R; 
        (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R;
         c n k; d n k m]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match match l with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
find_witness Control.TimeoutDebug:
In environment
n : nat
ihn : 2%:~R <= n -> ba_casoratian n = 6%:~R / (n%:~R + 1) ^ 3
nilG : 2%:~R <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n.+1; n%:R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add one
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end) one) zero))" (cannot unify "false" and 
"true").
find_witness Control.TimeoutDebug:
In environment
n : nat
ihn : 2%:~R <= n -> ba_casoratian n = 6%:~R / (n%:~R + 1) ^ 3
ltnT : forall n m p : nat, (m < n)%N -> (n < p)%N -> (m < p)%N
HF : 2%:~R <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n.+1; n%:R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add one
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end) one) zero))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
ihn : 2%:~R <= n -> ba_casoratian n = 6%:~R / (n%:~R + 1) ^ 3
ltnT : forall n m p : nat, (m < n)%N -> (n < p)%N -> (m < p)%N
Ncmn : 2%:~R <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n.+1; n%:R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add one
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end) one) zero))" (cannot unify "false" and 
"true").
find_witness Control.TimeoutDebug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
H : m < k + 1
l : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match l0 with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l0 with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
H : m < k + 1
l : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match l0 with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l0 with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
find_witness Control.TimeoutDebug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
ihn : 2%:~R <= n -> ba_casoratian n = 6%:~R / (n%:~R + 1) ^ 3
f_dec : 2%:~R <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n.+1; n%:R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add one
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end) one) zero))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
ihn : 2%:~R <= n -> ba_casoratian n = 6%:~R / (n%:~R + 1) ^ 3
Ncmn : 2%:~R <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n.+1; n%:R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add one
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end) one) zero))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
find_witness Control.TimeoutDebug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
k, m : int
_Hyp_ : 0 <= k
_Hyp1_ : 1 <= m
d_nmk := d n k m : rat
LT : m < k + 1
EQ : k < n + 1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n k; d_nmk; (-1) ^ (m + 1); m%:~R; (binomialz k m)%:~R;
         (binomialz n k)%:~R; (binomialz (n + k) k)%:~R;
         (binomialz (n - m) (n - k))%:~R; (binomialz (n + k) (k - m))%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
HP, HIS : int
H1 : annotated_recs_c.precond.Sn HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c (int.shift 1 HP) HIS; annotated_recs_c.Sn_cf0_0 HP HIS; c HP HIS]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
c, u : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
u_ann : u.Ann u
u_Sn2 := u.Sn2_ u_ann : u.Sn2 u
u_SnSk := u.SnSk_ u_ann : u.SnSk u
u_Sk2 := u.Sk2_ u_ann : u.Sk2 u
v := fun n k : int => c n k * u n k : int -> int -> rat_Ring
a, b : int
Ha : precond.Sn2 a b
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v (int.shift 2 a) b; Sn2_cf0_0 a b; v a b; 
        Sn2_cf1_0 a b; v (int.shift 1 a) b; Sn2_cf0_1 a b;
         v a (int.shift 1 b)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeout'C[[::]]
     : nat
'C[[:: 8]]
     : nat
Debug:
In environment
Hnat : forall m : nat, Z.of_nat m = m%:R
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
c, u : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
u_ann : u.Ann u
u_Sn2 := u.Sn2_ u_ann : u.Sn2 u
u_SnSk := u.SnSk_ u_ann : u.SnSk u
u_Sk2 := u.Sk2_ u_ann : u.Sk2 u
v := fun n k : int => c n k * u n k : int -> int -> rat_Ring
x, a : int
n : precond.Sn2 x a
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c (int.shift 2 x) a; u (int.shift 2 x) a; 
        Sn2_cf0_0 x a; c x a; u x a; Sn2_cf1_0 x a; 
        c (int.shift 1 x) a; u (int.shift 1 x) a; 
        Sn2_cf0_1 x a; c x (int.shift 1 a); u x (int.shift 1 a)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Hnat : forall m : nat, Z.of_nat m = m%:R
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
'exp_seqpoly_R' is now a registered translation.
find_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
Hnat : forall m : nat, Z.of_nat m = m%:R
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
find_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
Hnat : forall m : nat, Z.of_nat m = m%:R
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
Hnat : forall m : nat, Z.of_nat m = m%:R
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
Hnat : forall m : nat, Z.of_nat m = m%:R
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
x, m : int
Hm : annotated_recs_c.precond.Sk x m
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c x (int.shift 1 m); annotated_recs_c.Sk_cf0_0 x m; c x m]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Hnat : forall m : nat, Z.of_nat m = m%:R
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
find_witness Control.TimeoutDebug:
In environment
c, u : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
u_ann : u.Ann u
u_Sn2 := u.Sn2_ u_ann : u.Sn2 u
u_SnSk := u.SnSk_ u_ann : u.SnSk u
u_Sk2 := u.Sk2_ u_ann : u.Sk2 u
v := fun n k : int => c n k * u n k : int -> int -> rat_Ring
a, b : int
Ha : precond.Sn2 a b
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v (int.shift 2 a) b; Sn2_cf0_0 a b; v a b; 
        Sn2_cf1_0 a b; v (int.shift 1 a) b; Sn2_cf0_1 a b;
         v a (int.shift 1 b)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
Hnat : forall m : nat, Z.of_nat m = m%:R
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
i, j : nat
F := fun i : nat =>
     6%:~R / (i%:~R + 1) ^ 3 / (seq_defs.a (int.shift 1 i) * seq_defs.a i)
 : nat -> rat_Ring
a : (1 < j)%N
b : true
p : (j <= i)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq i; b_over_a_seq j;
         \big[GRing.add_monoid rat_Ring/0]_(j <= elpi_ctx_entry_6_ < i)
            F elpi_ctx_entry_6_]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
find_witness Control.Timeout'exp_hpoly_R' is now a registered translation.
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
Hnat : forall m : nat, Z.of_nat m = m%:R
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
c, u : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
u_ann : u.Ann u
u_Sn2 := u.Sn2_ u_ann : u.Sn2 u
u_SnSk := u.SnSk_ u_ann : u.SnSk u
u_Sk2 := u.Sk2_ u_ann : u.Sk2 u
v := fun n k : int => c n k * u n k : int -> int -> rat_Ring
x, a : int
n : precond.Sn2 x a
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c (int.shift 2 x) a; u (int.shift 2 x) a; 
        Sn2_cf0_0 x a; c x a; u x a; Sn2_cf1_0 x a; 
        c (int.shift 1 x) a; u (int.shift 1 x) a; 
        Sn2_cf0_1 x a; c x (int.shift 1 a); u x (int.shift 1 a)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
'expQnat_R' is now a registered translation.
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
find_witness Control.TimeoutDebug:
In environment
c, u : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
u_ann : u.Ann u
u_Sn2 := u.Sn2_ u_ann : u.Sn2 u
u_SnSk := u.SnSk_ u_ann : u.SnSk u
u_Sk2 := u.Sk2_ u_ann : u.Sk2 u
v := fun n k : int => c n k * u n k : int -> int -> rat_Ring
x, a : int
n : precond.Sn2 x a
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: Sn2_cf0_0 x a; c x a; u x a; Sn2_cf1_0 x a; 
        c (int.shift 1 x) a; u (int.shift 1 x) a; 
        Sn2_cf0_1 x a; c x (int.shift 1 a); u x (int.shift 1 a);
         c (int.shift 2 x) a; u (int.shift 2 x) a]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
Hnat : forall m : nat, Z.of_nat m = m%:R
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
i, j : nat
F := fun i : nat =>
     6%:~R / (i%:~R + 1) ^ 3 / (seq_defs.a (int.shift 1 i) * seq_defs.a i)
 : nat -> rat_Ring
a : (1 < j)%N
b : true
p : (j <= i)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq i; b_over_a_seq j;
         \big[GRing.add_monoid rat_Ring/0]_(j <= elpi_ctx_entry_6_ < i)
            F elpi_ctx_entry_6_]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Hnat : forall m : nat, Z.of_nat m = m%:R
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
i, j : nat
F := fun i : nat => 6%:~R / (i%:~R + 1) ^ 3 / (a (int.shift 1 i) * a i)
 : nat -> rat_Ring
x : (1 < j)%N
a_ge0 : true
b_ge0 : (j <= i)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq i; b_over_a_seq j;
         \big[GRing.add_monoid rat_Ring/0]_(j <= elpi_ctx_entry_6_ < i)
            F elpi_ctx_entry_6_]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i, j : nat
F := fun i : nat => 6%:~R / (i%:~R + 1) ^ 3 / (a (int.shift 1 i) * a i)
 : nat -> rat_Ring
H : (1 < j)%N
H0 : true
H1 : (j <= i)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq i; b_over_a_seq j;
         \big[GRing.add_monoid rat_Ring/0]_(j <= elpi_ctx_entry_6_ < i)
            F elpi_ctx_entry_6_]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 1%Z; b 1; annotated_recs_c.P_cf1 1%Z;
         annotated_recs_c.P_cf0 0%Z; b 0; annotated_recs_c.P_cf1 0%Z;
         annotated_recs_c.P_cf2 0%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match l with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
find_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
q, le_p_n : int
Aee' : nat
Ae'e : d.not_D4 q le_p_n Aee'
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d Aee') q le_p_n;
         d.Q4_flat d q le_p_n (int.shift 1 Aee'); 
        d.Q4_flat d q le_p_n Aee']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
ex_u : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
ex_u : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i, j : nat
B : rat_Ring
H : (j <= i)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: B;
         \sum_(j <= k < i)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
ex_u : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
valq : int * int
i : is_true ((0 < valq.2) && coprime `|valq.1| `|valq.2|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 2%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; b 1; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf1 2%Z; annotated_recs_c.P_cf0 1%Z;
         annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf2 1%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match ...
                                   ...
                                   ...
                                   end with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match l with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
n : int
H : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
ex_u : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
ex_u : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
i, j : nat
F := fun i : nat => 6%:~R / (i%:~R + 1) ^ 3 / (a (int.shift 1 i) * a i)
 : nat -> rat_Ring
HOSS : (1 < j)%N
a_ge0 : true
b_ge0 : (j <= i)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq i; b_over_a_seq j;
         \big[GRing.add_monoid rat_Ring/0]_(j <= elpi_ctx_entry_6_ < i)
            F elpi_ctx_entry_6_]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i, j : nat
F := fun i : nat =>
     6%:~R / (i%:~R + 1) ^ 3 / (seq_defs.a (int.shift 1 i) * seq_defs.a i)
 : nat -> rat_Ring
a : (1 < j)%N
b : true
p : (j <= i)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq i; b_over_a_seq j;
         \big[GRing.add_monoid rat_Ring/0]_(j <= elpi_ctx_entry_6_ < i)
            F elpi_ctx_entry_6_]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
defG : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i, j : nat
F := fun i : nat =>
     6%:~R / (i%:~R + 1) ^ 3 / (seq_defs.a (int.shift 1 i) * seq_defs.a i)
 : nat -> rat_Ring
a : (1 < j)%N
b : true
p : (j <= i)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq i; b_over_a_seq j;
         \big[GRing.add_monoid rat_Ring/0]_(j <= elpi_ctx_entry_6_ < i)
            F elpi_ctx_entry_6_]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
i, j : nat
F := fun i : nat => 6%:~R / (i%:~R + 1) ^ 3 / (a (int.shift 1 i) * a i)
 : nat -> rat_Ring
x : (1 < j)%N
a_ge0 : true
b_ge0 : (j <= i)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq i; b_over_a_seq j;
         \big[GRing.add_monoid rat_Ring/0]_(j <= elpi_ctx_entry_6_ < i)
            F elpi_ctx_entry_6_]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i, j : nat
F := fun i : nat => 6%:~R / (i%:~R + 1) ^ 3 / (a (int.shift 1 i) * a i)
 : nat -> rat_Ring
H : (1 < j)%N
H0 : true
H1 : (j <= i)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq i; b_over_a_seq j;
         \big[GRing.add_monoid rat_Ring/0]_(j <= elpi_ctx_entry_6_ < i)
            F elpi_ctx_entry_6_]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n, i : nat
Hain : (a i <= n)%N
c := (exp_quo (n%:~R / (a i)%:~R) n (a i) /
      exp_quo ((n.+1 - a i)%N%:~R / (a i)%:~R) (n.+1 - a i) (a i)) ^+ 
     a i : algC
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : algCnumField
one : algCnumField
add : algCnumField -> algCnumField -> algCnumField
mul : algCnumField -> algCnumField -> algCnumField
sub : algCnumField -> algCnumField -> algCnumField
opp : algCnumField -> algCnumField
Feqb : rel algCnumField
F_of_nat : nat -> algCnumField
exp : algCnumField -> nat -> algCnumField
l : seq algCnumField
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : algCnumField => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=algCnumField)
lE : l =
     [:: c;
         exp_quo (1 + (a i - 1)%N%:~R / (n.+1 - a i)%N%:~R) 
           (n.+1 - a i) (a i) ^+ a i;
         ratr_rmorphism algCnumField ((n%:~R / (a i)%:~R) ^ (a i - 1)%N)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
'diag_seqmx_R' is now a registered translation.
Debug:
In environment
n, i : nat
Hain : (a i <= n)%N
c := (exp_quo (n%:~R / (a i)%:~R) n (a i) /
      exp_quo ((n.+1 - a i)%N%:~R / (a i)%:~R) (n.+1 - a i) (a i)) ^+ 
     a i : algC
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : algCnumField
one : algCnumField
add : algCnumField -> algCnumField -> algCnumField
mul : algCnumField -> algCnumField -> algCnumField
sub : algCnumField -> algCnumField -> algCnumField
opp : algCnumField -> algCnumField
Feqb : rel algCnumField
F_of_nat : nat -> algCnumField
exp : algCnumField -> nat -> algCnumField
l : seq algCnumField
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : algCnumField => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=algCnumField)
lE : l =
     [:: c;
         exp_quo (1 + (a i - 1)%N%:~R / (n.+1 - a i)%N%:~R) 
           (n.+1 - a i) (a i) ^+ a i;
         ratr_rmorphism algCnumField ((n%:~R / (a i)%:~R) ^ (a i - 1)%N)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
n : int
ex_u : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
defG : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n, i : nat
Hain : (a i <= n)%N
c := (exp_quo (n%:~R / (a i)%:~R) n (a i) /
      exp_quo ((n.+1 - a i)%N%:~R / (a i)%:~R) (n.+1 - a i) (a i)) ^+ 
     a i : algC
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : algCnumField
one : algCnumField
add : algCnumField -> algCnumField -> algCnumField
mul : algCnumField -> algCnumField -> algCnumField
sub : algCnumField -> algCnumField -> algCnumField
opp : algCnumField -> algCnumField
Feqb : rel algCnumField
F_of_nat : nat -> algCnumField
exp : algCnumField -> nat -> algCnumField
l : seq algCnumField
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : algCnumField => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=algCnumField)
lE : l =
     [:: c;
         exp_quo (1 + (a i - 1)%N%:~R / (n.+1 - a i)%N%:~R) 
           (n.+1 - a i) (a i) ^+ a i;
         ratr_rmorphism algCnumField ((n%:~R / (a i)%:~R) ^ (a i - 1)%N)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n, i : nat
Hain : (a i <= n)%N
c := (exp_quo (n%:~R / (a i)%:~R) n (a i) /
      exp_quo ((n.+1 - a i)%N%:~R / (a i)%:~R) (n.+1 - a i) (a i)) ^+ 
     a i : algC
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : algCnumField
one : algCnumField
add : algCnumField -> algCnumField -> algCnumField
mul : algCnumField -> algCnumField -> algCnumField
sub : algCnumField -> algCnumField -> algCnumField
opp : algCnumField -> algCnumField
Feqb : rel algCnumField
F_of_nat : nat -> algCnumField
exp : algCnumField -> nat -> algCnumField
l : seq algCnumField
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : algCnumField => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=algCnumField)
lE : l =
     [:: c;
         exp_quo (1 + (a i - 1)%N%:~R / (n.+1 - a i)%N%:~R) 
           (n.+1 - a i) (a i) ^+ a i;
         ratr_rmorphism algCnumField ((n%:~R / (a i)%:~R) ^ (a i - 1)%N)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n, i : nat
Hain : (a i <= n)%N
c := (exp_quo (n%:~R / (a i)%:~R) n (a i) /
      exp_quo ((n.+1 - a i)%N%:~R / (a i)%:~R) (n.+1 - a i) (a i)) ^+ 
     a i : algC
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : algCnumField
one : algCnumField
add : algCnumField -> algCnumField -> algCnumField
mul : algCnumField -> algCnumField -> algCnumField
sub : algCnumField -> algCnumField -> algCnumField
opp : algCnumField -> algCnumField
Feqb : rel algCnumField
F_of_nat : nat -> algCnumField
exp : algCnumField -> nat -> algCnumField
l : seq algCnumField
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : algCnumField => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=algCnumField)
lE : l =
     [:: c;
         exp_quo (1 + (a i - 1)%N%:~R / (n.+1 - a i)%N%:~R) 
           (n.+1 - a i) (a i) ^+ a i;
         ratr_rmorphism algCnumField ((n%:~R / (a i)%:~R) ^ (a i - 1)%N)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
z_x : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
q, le_p_n : int
Aee' : nat
Ae'e : d.not_D4 q le_p_n Aee'
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d.P4_horner (punk.pfun2 d Aee') q le_p_n;
         d.Q4_flat d q le_p_n (int.shift 1 Aee'); 
        d.Q4_flat d q le_p_n Aee']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
n : int
ex_u : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
n : int
defG : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeout'leq_R' is now a registered translation.
'nilp_R' is now a registered translation.
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
l, l1, l2 : int
Heq : annotated_recs_d.precond.Sn l l1 l2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: d (int.shift 1 l) l1 l2; annotated_recs_d.Sn_cf0_0_0 l l1 l2;
         d l l1 l2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
n, i : nat
Hain : (a i <= n)%N
c := (exp_quo (n%:~R / (a i)%:~R) n (a i) /
      exp_quo ((n.+1 - a i)%N%:~R / (a i)%:~R) (n.+1 - a i) (a i)) ^+ 
     a i : algC
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : algCnumField
one : algCnumField
add : algCnumField -> algCnumField -> algCnumField
mul : algCnumField -> algCnumField -> algCnumField
sub : algCnumField -> algCnumField -> algCnumField
opp : algCnumField -> algCnumField
Feqb : rel algCnumField
F_of_nat : nat -> algCnumField
exp : algCnumField -> nat -> algCnumField
l : seq algCnumField
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : algCnumField => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=algCnumField)
lE : l =
     [:: c;
         exp_quo (1 + (a i - 1)%N%:~R / (n.+1 - a i)%N%:~R) 
           (n.+1 - a i) (a i) ^+ a i;
         ratr_rmorphism algCnumField ((n%:~R / (a i)%:~R) ^ (a i - 1)%N)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Az, RS : int
b : int * int
hf : (0 < b.2) && coprime `|b.1| `|b.2|
m : int
H1 : annotated_recs_d.precond.Sn Az RS m
valq : int * int
i : (0 < valq.2) && coprime `|valq.1| `|valq.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: Rat i; annotated_recs_d.Sn_cf0_0_0 Az RS m; d Az RS m]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
l, l1, l2 : int
Heq : annotated_recs_d.precond.Sn l l1 l2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: d (int.shift 1 l) l1 l2; annotated_recs_d.Sn_cf0_0_0 l l1 l2;
         d l l1 l2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
Az, RS : int
b : int * int
hf : (0 < b.2) && coprime `|b.1| `|b.2|
m : int
H1 : annotated_recs_d.precond.Sn Az RS m
valq : int * int
i : (0 < valq.2) && coprime `|valq.1| `|valq.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: Rat i; annotated_recs_d.Sn_cf0_0_0 Az RS m; d Az RS m]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
Az, RS : int
b : int * int
hf : (0 < b.2) && coprime `|b.1| `|b.2|
eq_ss : int
d_nmk := d (int.shift 1 Az) RS eq_ss : rat
Ha : annotated_recs_d.precond.Sn Az RS eq_ss
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: d_nmk; annotated_recs_d.Sn_cf0_0_0 Az RS eq_ss; d Az RS eq_ss]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Az, RS : int
b : int * int
hf : (0 < b.2) && coprime `|b.1| `|b.2|
eq_ss : int
d_nmk := d (int.shift 1 Az) RS eq_ss : rat
abelG : annotated_recs_d.precond.Sn Az RS eq_ss
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: d_nmk; annotated_recs_d.Sn_cf0_0_0 Az RS eq_ss; d Az RS eq_ss]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
k : int
s := fun n k0 : int => \sum_(1 <= m < k0 + 1 :> int | 0 < k) d n k0 m
 : int -> int -> rat
n : k < 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P2_horner s 0 k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
k : int
s := fun n k0 : int => \sum_(1 <= m < k0 + 1 :> int | 0 < k) d n k0 m
 : int -> int -> rat
n : k < 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P2_horner s 0 k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
w : int -> rat
l2 : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
n : nat
Qp : is_true (2 <= Posz n)
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
c30 := v (int.shift 3 (Posz n)) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 (Posz n)); annotated_recs_v.P_cf0 (Posz n);
         w (Posz n); annotated_recs_v.P_cf1 (Posz n);
         w (int.shift 1 (Posz n)); annotated_recs_v.P_cf2 (Posz n);
         w (int.shift 2 (Posz n)); annotated_recs_v.P_cf3 (Posz n);
         w (int.shift 3 (Posz n)); annotated_recs_v.P_cf4 (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match
                        match
                          match
                            match ... with
                            | ... => [::]
                            | ... => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
k : int
s := fun n k0 : int => \sum_(1 <= m < k0 + 1 :> int | 0 < k) d n k0 m
 : int -> int -> rat
n : k < 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P2_horner s 0 k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
w : int -> rat
H : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
n : nat
Qp : is_true (2 <= Posz n)
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
c30 := v (int.shift 3 (Posz n)) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 (Posz n)); annotated_recs_v.P_cf0 (Posz n);
         w (Posz n); annotated_recs_v.P_cf1 (Posz n);
         w (int.shift 1 (Posz n)); annotated_recs_v.P_cf2 (Posz n);
         w (int.shift 2 (Posz n)); annotated_recs_v.P_cf3 (Posz n);
         w (int.shift 3 (Posz n)); annotated_recs_v.P_cf4 (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match
                        match
                          match
                            match ... with
                            | ... => [::]
                            | ... => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
x, a, b : int
H : annotated_recs_d.precond.Sk x a b
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: d x (int.shift 1 a) b; d x a b]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
find_witness Control.TimeoutDebug:
In environment
w : int -> rat
l2 : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
n : nat
Qp : is_true (2 <= Posz n)
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
c30 := v (int.shift 3 (Posz n)) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 (Posz n)); annotated_recs_v.P_cf0 (Posz n);
         w (Posz n); annotated_recs_v.P_cf1 (Posz n);
         w (int.shift 1 (Posz n)); annotated_recs_v.P_cf2 (Posz n);
         w (int.shift 2 (Posz n)); annotated_recs_v.P_cf3 (Posz n);
         w (int.shift 3 (Posz n)); annotated_recs_v.P_cf4 (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match
                        match
                          match
                            match ... with
                            | ... => [::]
                            | ... => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
Hn, Hm, m_ : int
H : annotated_recs_d.precond.Sk Hn Hm m_
Unable to unify "true" with "false".
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
w : int -> rat
l2 : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
n : nat
Qp : is_true (2 <= Posz n)
c01 := v (Posz n) 1 : rat
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
c30 := v (int.shift 3 (Posz n)) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 (Posz n)); annotated_recs_v.P_cf0 (Posz n);
         w (Posz n); annotated_recs_v.P_cf1 (Posz n);
         w (int.shift 1 (Posz n)); annotated_recs_v.P_cf2 (Posz n);
         w (int.shift 2 (Posz n)); annotated_recs_v.P_cf3 (Posz n);
         w (int.shift 3 (Posz n)); annotated_recs_v.P_cf4 (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match
                        match
                          match
                            match ... with
                            | ... => [::]
                            | ... => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
k : int
s := fun n k0 : int => \sum_(1 <= m < k0 + 1 :> int | 0 < k) d n k0 m
 : int -> int -> rat
n : k < 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P2_horner s 0 k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
w : int -> rat
H : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
n : nat
Qp : is_true (2 <= Posz n)
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
c30 := v (int.shift 3 (Posz n)) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 (Posz n)); annotated_recs_v.P_cf0 (Posz n);
         w (Posz n); annotated_recs_v.P_cf1 (Posz n);
         w (int.shift 1 (Posz n)); annotated_recs_v.P_cf2 (Posz n);
         w (int.shift 2 (Posz n)); annotated_recs_v.P_cf3 (Posz n);
         w (int.shift 3 (Posz n)); annotated_recs_v.P_cf4 (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match
                        match
                          match
                            match ... with
                            | ... => [::]
                            | ... => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
k : int
s := fun n k0 : int => \sum_(1 <= m < k0 + 1 :> int | 0 < k) d n k0 m
 : int -> int -> rat
n : k < 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P2_horner s 0 k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
w : int -> rat
n : forall n : int,
    is_true ((2 : int) <= (n : int)) -> annotated_recs_v.P_horner w n = 0
m : int
f : is_true ((2 : int) <= (m : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 m); annotated_recs_v.P_cf0 m; 
        w m; annotated_recs_v.P_cf1 m; w (int.shift 1 m);
         annotated_recs_v.P_cf2 m; w (int.shift 2 m);
         annotated_recs_v.P_cf3 m; w (int.shift 3 m);
         annotated_recs_v.P_cf4 m]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match
                        match
                          match
                            match ... with
                            | ... => [::]
                            | ... => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
x, a, b : int
H : annotated_recs_d.precond.Sk x a b
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: d x (int.shift 1 a) b; d x a b]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.TimeoutDebug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
find_witness Control.TimeoutDebug:
In environment
w : int -> rat
l2 : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
n : nat
Qp : is_true (2 <= Posz n)
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
rhs := -
       (annotated_recs_v.P_cf0 (Posz n) * w (Posz n) +
        annotated_recs_v.P_cf1 (Posz n) * w (int.shift 1 (Posz n)) +
        annotated_recs_v.P_cf2 (Posz n) * w (int.shift 2 (Posz n)) +
        annotated_recs_v.P_cf3 (Posz n) * w (int.shift 3 (Posz n))) /
       annotated_recs_v.P_cf4 (Posz n) : GRing.Ring.sort rat_Ring
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: rhs; w (int.shift 4 (Posz n))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Hn, Hm, Ur : int
pG : annotated_recs_d.precond.Sk Hn Hm Ur
d1 := d Hn (int.shift 1 Hm) Ur : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: d1; d Hn Hm Ur]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
Hn, Hm, Ur : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: d Hn (int.shift 1 Hm) Ur; d Hn Hm Ur]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
w : int -> rat
l2 : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
n : nat
Qp : is_true (2 <= Posz n)
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
rhs := -
       (annotated_recs_v.P_cf0 (Posz n) * w (Posz n) +
        annotated_recs_v.P_cf1 (Posz n) * w (int.shift 1 (Posz n)) +
        annotated_recs_v.P_cf2 (Posz n) * w (int.shift 2 (Posz n)) +
        annotated_recs_v.P_cf3 (Posz n) * w (int.shift 3 (Posz n))) /
       annotated_recs_v.P_cf4 (Posz n) : GRing.Ring.sort rat_Ring
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: w (int.shift 4 (Posz n)); rhs]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
Hn, Hm, Ry : int
cfg : annotated_recs_d.precond.Sk Hn Hm Ry
Unable to unify "true" with "false".
Debug:
In environment
Hn, Hm, Ry : int
cfg : annotated_recs_d.precond.Sk Hn Hm Ry
Unable to unify "true" with "false".
Debug:
In environment
Hn, Hm, Ry : int
cfg : annotated_recs_d.precond.Sk Hn Hm Ry
Unable to unify "true" with "false".
find_witness Control.TimeoutDebug:
In environment
Hn, Hm, m_ : int
H : annotated_recs_d.precond.Sk Hn Hm m_
Unable to unify "true" with "false".
find_witness Control.TimeoutDebug:
In environment
w : int -> rat
l2 : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
n : nat
Qp : is_true (2 <= Posz n)
c02 := v (Posz n) (int.shift 2 0) : rat
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 (Posz n)); annotated_recs_v.P_cf0 (Posz n);
         w (Posz n); annotated_recs_v.P_cf1 (Posz n);
         w (int.shift 1 (Posz n)); annotated_recs_v.P_cf2 (Posz n);
         w (int.shift 2 (Posz n)); annotated_recs_v.P_cf3 (Posz n);
         w (int.shift 3 (Posz n)); annotated_recs_v.P_cf4 (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match
                        match
                          match
                            match ... with
                            | ... => [::]
                            | ... => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
w : int -> rat
l2 : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
n : nat
Qp : is_true (2 <= Posz n)
c02 := v (Posz n) (int.shift 2 0) : rat
c01 := v (Posz n) 1 : rat
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 (Posz n)); annotated_recs_v.P_cf0 (Posz n);
         w (Posz n); annotated_recs_v.P_cf1 (Posz n);
         w (int.shift 1 (Posz n)); annotated_recs_v.P_cf2 (Posz n);
         w (int.shift 2 (Posz n)); annotated_recs_v.P_cf3 (Posz n);
         w (int.shift 3 (Posz n)); annotated_recs_v.P_cf4 (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match
                        match
                          match
                            match ... with
                            | ... => [::]
                            | ... => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
w : int -> rat
l2 : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
n : nat
Qp : is_true (2 <= Posz n)
c02 := v (Posz n) (int.shift 2 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 (Posz n)); annotated_recs_v.P_cf0 (Posz n);
         w (Posz n); annotated_recs_v.P_cf1 (Posz n);
         w (int.shift 1 (Posz n)); annotated_recs_v.P_cf2 (Posz n);
         w (int.shift 2 (Posz n)); annotated_recs_v.P_cf3 (Posz n);
         w (int.shift 3 (Posz n)); annotated_recs_v.P_cf4 (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match
                        match
                          match
                            match ... with
                            | ... => [::]
                            | ... => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
w : int -> rat
l2 : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
n : nat
Qp : is_true (2 <= Posz n)
c01 := v (Posz n) 1 : rat
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
c30 := v (int.shift 3 (Posz n)) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 (Posz n)); annotated_recs_v.P_cf0 (Posz n);
         w (Posz n); annotated_recs_v.P_cf1 (Posz n);
         w (int.shift 1 (Posz n)); annotated_recs_v.P_cf2 (Posz n);
         w (int.shift 2 (Posz n)); annotated_recs_v.P_cf3 (Posz n);
         w (int.shift 3 (Posz n)); annotated_recs_v.P_cf4 (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match
                        match
                          match
                            match ... with
                            | ... => [::]
                            | ... => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
w : int -> rat
l2 : forall n : int, is_true (2 <= n) -> annotated_recs_v.P_horner w n = 0
Qp : is_true (2 <= 0%Z)
c01 := v 0%Z 1 : rat
c11 := v (int.shift 1 0%Z) (int.shift 1 0) : rat
c30 := v (int.shift 3 0%Z) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 0%Z); annotated_recs_v.P_cf0 0%Z; 
        w 0%Z; annotated_recs_v.P_cf1 0%Z; w (int.shift 1 0%Z);
         annotated_recs_v.P_cf2 0%Z; w (int.shift 2 0%Z);
         annotated_recs_v.P_cf3 0%Z; w (int.shift 3 0%Z);
         annotated_recs_v.P_cf4 0%Z]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match
                        match
                          match
                            match ... with
                            | ... => [::]
                            | ... => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
b, g, x : int
H : annotated_recs_d.precond.Sm b g x
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d b g (int.shift 1 x); annotated_recs_d.Sm_cf0_0_0 b g x; d b g x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
a, eqfg, l1 : int
l2 : annotated_recs_d.precond.Sm a eqfg l1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d a eqfg (int.shift 1 l1); annotated_recs_d.Sm_cf0_0_0 a eqfg l1;
         d a eqfg l1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
k : int
inj_f : is_true ((2 : int) <= (k : int))
H : b' k = b k
H0 : b' (intZmod.addz k 1%Z) = b (intZmod.addz k 1%Z)
H1 : b' (intZmod.addz k 2%Z) = b (intZmod.addz k 2%Z)
H2 : b' (intZmod.addz k 3%Z) = b (intZmod.addz k 3%Z)
n : nat
H3 : is_true (intOrdered.lez k (Posz n))
c02 := v (Posz n) (int.shift 2 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b'_rec n; b (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
k : int
inj_f : is_true ((2 : int) <= (k : int))
H : b' k = b k
H0 : b' (intZmod.addz k 1%Z) = b (intZmod.addz k 1%Z)
H1 : b' (intZmod.addz k 2%Z) = b (intZmod.addz k 2%Z)
H2 : b' (intZmod.addz k 3%Z) = b (intZmod.addz k 3%Z)
n : nat
Rx : is_true (intOrdered.lez k (Posz n) == true)
c02 := v (Posz n) (int.shift 2 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b'_rec n; b (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
k : int
inj_f : is_true ((2 : int) <= (k : int))
H : b' k = b k
H0 : b' (intZmod.addz k 1%Z) = b (intZmod.addz k 1%Z)
H1 : b' (intZmod.addz k 2%Z) = b (intZmod.addz k 2%Z)
H2 : b' (intZmod.addz k 3%Z) = b (intZmod.addz k 3%Z)
n : nat
_view_subject_ : is_true (intOrdered.lez k (Posz n) == true)
c02 := v (Posz n) (int.shift 2 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b'_rec n; b (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
k : int
inj_f : is_true ((2 : int) <= (k : int))
H : b' k = b k
H0 : b' (intZmod.addz k 1%Z) = b (intZmod.addz k 1%Z)
H1 : b' (intZmod.addz k 2%Z) = b (intZmod.addz k 2%Z)
H2 : b' (intZmod.addz k 3%Z) = b (intZmod.addz k 3%Z)
n : nat
Hl : is_true (intOrdered.lez k (Posz n) == true)
c02 := v (Posz n) (int.shift 2 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b'_rec n; b (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
k : int
n : nat
p : is_true (intOrdered.lez k (Posz n) == true)
EQ : nat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b'_rec n; b (Posz EQ)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
k : int
n : nat
p : is_true (intOrdered.lez k (Posz n) == true)
n0 : nat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b'_rec n;
         reducebig 0 (bigopz.index_iotaz 0 (Posz (n0 + 1)%Nrec))
           (fun elpi_ctx_entry_4_ : int =>
            BigBody elpi_ctx_entry_4_ +%R true
              (match elpi_ctx_entry_4_ with
               | Posz m1 => binomial_rec n0 m1 true true
               | Negz m1 => binomial_rec n0 m1 true false
               end%:~R ^ 2 *
               match Posz n0 + elpi_ctx_entry_4_ with
               | Posz n1 =>
                   match elpi_ctx_entry_4_ with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match elpi_ctx_entry_4_ with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (Posz (n0 + 1)%Nrec))
                  (fun elpi_ctx_entry_5_ : int =>
                   BigBody elpi_ctx_entry_5_ +%R true
                     (elpi_ctx_entry_5_%:~R ^ 3%Z)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (elpi_ctx_entry_4_ + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      (2%:~R * m%:~R ^ 3 *
                       match m with
                       | Posz m1 => binomial_rec n0 m1 true true
                       | Negz m1 => binomial_rec n0 m1 true false
                       end%:~R *
                       match Posz n0 + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
k : int
inj_f : is_true ((2 : int) <= (k : int))
H : b' k = b k
H0 : b' (intZmod.addz k 1%Z) = b (intZmod.addz k 1%Z)
H1 : b' (intZmod.addz k 2%Z) = b (intZmod.addz k 2%Z)
H2 : b' (intZmod.addz k 3%Z) = b (intZmod.addz k 3%Z)
n : nat
pG : is_true (intOrdered.lez k (Posz n) == true)
c02 := v (Posz n) (int.shift 2 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' (Posz n); b (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
k : int
inj_f : is_true ((2 : int) <= (k : int))
H : b' k = b k
H0 : b' (intZmod.addz k 1%Z) = b (intZmod.addz k 1%Z)
H1 : b' (intZmod.addz k 2%Z) = b (intZmod.addz k 2%Z)
H2 : b' (intZmod.addz k 3%Z) = b (intZmod.addz k 3%Z)
n : nat
pG : is_true (intOrdered.lez k (Posz n) == true)
c02 := v (Posz n) (int.shift 2 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' (Posz n); b (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ 3%Z)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      (2%:~R * m%:~R ^ 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
pi12 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
l, k_ : int
H : 0 <= k_
H0 : k_ < l
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: annotated_recs_s.SnSk_cf0_0 l k_; s l k_; 
        s (int.shift 1 l) k_; annotated_recs_s.SnSk_cf0_1 l k_;
         s l (int.shift 1 k_); s (int.shift 1 l) (int.shift 1 k_)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ 3%Z)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      (2%:~R * m%:~R ^ 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
pi12 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
pi12 : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
nge2 : is_true (2%Z <= Posz n)
c40 := v (int.shift 4 (Posz n)) 0 : rat
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' (Posz n); b (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c01 := v n 1 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ 3%Z)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      (2%:~R * m%:~R ^ 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
p_x : is_true ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ 3%Z)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      (2%:~R * m%:~R ^ 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
n : int
pi12 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
pi12 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
pi12 : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
fx : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
l, k_ : int
H : annotated_recs_s.precond.SnSk l k_
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: annotated_recs_s.SnSk_cf0_0 l k_; s l k_; 
        s (int.shift 1 l) k_; annotated_recs_s.SnSk_cf0_1 l k_;
         s l (int.shift 1 k_); s (int.shift 1 l) (int.shift 1 k_)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
l, k_ : int
H : 0 <= k_
H0 : k_ < l
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: annotated_recs_s.SnSk_cf0_0 l k_; s l k_; 
        s (int.shift 1 l) k_; annotated_recs_s.SnSk_cf0_1 l k_;
         s l (int.shift 1 k_); s (int.shift 1 l) (int.shift 1 k_)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
l, k_ : int
H : 0 <= k_
H0 : k_ < l
c, Hc : int
i : (0 < Hc) && coprime `|c| `|Hc|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: annotated_recs_s.SnSk_cf0_0 l k_; s l k_; 
        s (int.shift 1 l) k_; annotated_recs_s.SnSk_cf0_1 l k_;
         s l (int.shift 1 k_); s (int.shift 1 l) (int.shift 1 k_)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
nge2 : is_true (2%Z <= Posz n)
c10 := v (int.shift 1 (Posz n)) 0 : rat
c20 := v (int.shift 2 (Posz n)) 0 : rat
x, y : int
H : x = y
c30 := v (int.shift 3 (Posz n)) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' x; b y]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b n; b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
c01 := v n 1 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.ZmoduleDebug:
                   In environment
                   n : nat
                   nge2 : is_true (2%Z <= Posz n)
                   c40 := v (int.shift 4 (Posz n)) 0 : rat
                   c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
                   is_true_ : bool -> Prop
                   negb_ : bool -> bool
                   andb_ : bool -> bool -> bool
                   zero : GRing.Zmodule.sort
                            (GRing.Ring.zmodType
                               (Num.NumField.ringType rat_numFieldType))
                   one : GRing.Ring.sort
                           (Num.NumField.ringType rat_numFieldType)
                   add : GRing.Zmodule.sort
                           (GRing.Ring.zmodType
                              (Num.NumField.ringType rat_numFieldType)) ->
                         GRing.Zmodule.sort
                           (GRing.Ring.zmodType
                              (Num.NumField.ringType rat_numFieldType)) ->
                         GRing.Zmodule.sort
                           (GRing.Ring.zmodType
                              (Num.NumField.ringType rat_numFieldType))
                   mul : GRing.Ring.sort
                           (Num.NumField.ringType rat_numFieldType) ->
                         GRing.Ring.sort
                           (Num.NumField.ringType rat_numFieldType) ->
                         GRing.Ring.sort
                           (Num.NumField.ringType rat_numFieldType)
                   sub : GRing.Zmodule.sort
                           (GRing.Ring.zmodType
                              (Num.NumField.ringType rat_numFieldType)) ->
                         GRing.Zmodule.sort
                           (GRing.Ring.zmodType
                              (Num.NumField.ringType rat_numFieldType)) ->
                         GRing.Zmodule.sort
                           (GRing.Ring.zmodType
                              (Num.NumField.ringType rat_numFieldType))
                   opp : GRing.Zmodule.sort
                           (GRing.Ring.zmodType
                              (Num.NumField.ringType rat_numFieldType)) ->
                         GRing.Zmodule.sort
                           (GRing.Ring.zmodType
                              (Num.NumField.ringType rat_numFieldType))
                   Feqb : rel
                            (Equality.sort
                               (GRing.Zmodule.eqType
                                  (GRing.Ring.zmodType
                                     (Num.NumField.ringType rat_numFieldType))))
                   F_of_nat : nat ->
                              GRing.Zmodule.sort
                                (GRing.Ring.zmodType
                                   (Num.NumField.ringType rat_numFieldType))
                   exp : GRing.Ring.sort
                           (Num.NumField.ringType rat_numFieldType) ->
                         nat ->
                         GRing.Ring.sort
                           (Num.NumField.ringType rat_numFieldType)
                   l : seq (Num.NumField.sort rat_numFieldType)
                   is_trueE : is_true_ = is_true
                   negbE : negb_ = negb
                   andbE : andb_ = andb
                   zeroE : zero = 0
                   oneE : one = 1
                   addE : add = +%R
                   mulE : mul =  *%R
                   subE : sub =
                          (fun
                             x
                              y : GRing.Zmodule.sort
                                    (GRing.Ring.zmodType
                                       (Num.NumField.ringType
                                          rat_numFieldType)) => 
                           x - y)
                   oppE : opp = -%R
                   FeqbE : Feqb = eq_op
                   F_of_natE : F_of_nat = GRing.natmul 1
                   expE : exp =
                          GRing.exp
                            (R:=Num.NumField.ringType rat_numFieldType)
                   lE : l = [:: b' (Posz n); b (Posz n)]
                   The term "conj (erefl false) ?y" has type
                    "false = false /\ ?B" while it is expected to have type
                    "false = true /\ is_true_ true" (cannot unify 
                   "false" and "true").
        Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c01 := v n 1 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
c02 := v n (int.shift 2 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true (2%Z <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ 3%Z)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      (2%:~R * m%:~R ^ 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 =>
                       Debug:
                       In environment
                       n : int
                       p_x : is_true ?Goal
                       is_true_ : bool -> Prop
                       negb_ : bool -> bool
                       andb_ : bool -> bool -> bool
                       zero : GRing.Zmodule.sort
                                (GRing.Ring.zmodType
                                   (Num.NumField.ringType rat_numFieldType))
                       one : GRing.Ring.sort
                               (Num.NumField.ringType rat_numFieldType)
                       add : GRing.Zmodule.sort
                               (GRing.Ring.zmodType
                                  (Num.NumField.ringType rat_numFieldType)) ->
                             GRing.Zmodule.sort
                               (GRing.Ring.zmodType
                                  (Num.NumField.ringType rat_numFieldType)) ->
                             GRing.Zmodule.sort
                               (GRing.Ring.zmodType
                                  (Num.NumField.ringType rat_numFieldType))
                       mul : GRing.Ring.sort
                               (Num.NumField.ringType rat_numFieldType) ->
                             GRing.Ring.sort
                               (Num.NumField.ringType rat_numFieldType) ->
                             GRing.Ring.sort
                               (Num.NumField.ringType rat_numFieldType)
                       sub : GRing.Zmodule.sort
                               (GRing.Ring.zmodType
                                  (Num.NumField.ringType rat_numFieldType)) ->
                             GRing.Zmodule.sort
                               (GRing.Ring.zmodType
                                  (Num.NumField.ringType rat_numFieldType)) ->
                             GRing.Zmodule.sort
                               (GRing.Ring.zmodType
                                  (Num.NumField.ringType rat_numFieldType))
                       opp : GRing.Zmodule.sort
                               (GRing.Ring.zmodType
                                  (Num.NumField.ringType rat_numFieldType)) ->
                             GRing.Zmodule.sort
                               (GRing.Ring.zmodType
                                  (Num.NumField.ringType rat_numFieldType))
                       Feqb : rel
                                (Equality.sort
                                   (GRing.Zmodule.eqType
                                      (GRing.Ring.zmodType
                                         (Num.NumField.ringType
                                            rat_numFieldType))))
                       F_of_nat : nat ->
                                  GRing.Zmodule.sort
                                    (GRing.Ring.zmodType
                                       (Num.NumField.ringType
                                          rat_numFieldType))
                       exp : GRing.Ring.sort
                               (Num.NumField.ringType rat_numFieldType) ->
                             nat ->
                             GRing.Ring.sort
                               (Num.NumField.ringType rat_numFieldType)
                       l : seq (Num.NumField.sort rat_numFieldType)
                       is_trueE : is_true_ = is_true
                       negbE : negb_ = negb
                       andbE : andb_ = andb
                       zeroE : zero = 0
                       oneE : one = 1
                       addE : add = +%R
                       mulE : mul =  *%R
                       subE : sub =
                              (fun
                                 x
                                  y : GRing.Zmodule.sort
                                        (GRing.Ring.zmodType
                                           (Num.NumField.ringType
                                              rat_numFieldType)) => 
                               x - y)
                       oppE : opp = -%R
                       FeqbE : Feqb = eq_op
                       F_of_natE : F_of_nat = GRing.natmul 1
                       expE : exp =
                              GRing.exp
                                (R:=Num.NumField.ringType rat_numFieldType)
                       lE : l =
                            [:: b' n;
                                reducebig 0 (bigopz.index_iotaz 0 (n + 1))
                                  (fun k : int =>
                                   BigBody k +%R true
                                     (match n with
                                      | Posz n1 =>
                                          match k with
                                          | Posz m1 =>
                                              binomial_rec n1 m1 true true
                                          | Negz m1 =>
                                              binomial_rec n1 m1 true false
                                          end
                                      | Negz n1 =>
                                          match k with
                                          | Posz m1 =>
                                              binomial_rec n1 m1 false true
                                          | Negz m1 =>
                                              binomial_rec n1 m1 false false
                                          end
                                      end%:~R ^ 2 *
                                      match n + k with
                                      | Posz n1 =>
                                          match k with
                                          | Posz m1 =>
                                              binomial_rec n1 m1 true true
                                          | Negz m1 =>
                                              binomial_rec n1 m1 true false
                                          end
                                      | Negz n1 =>
                                          match k with
                                          | Posz m1 =>
                                              binomial_rec n1 m1 false true
                                          | Negz m1 =>
                                              binomial_rec n1 m1 false false
                                          end
                                      end%:~R ^ 2 *
                                      (reducebig 0
                                         (bigopz.index_iotaz 1 (n + 1))
                                         (fun k0 : int =>
                                          BigBody k0 +%R true
                                            (k0%:~R ^ 3%Z)^-1) +
                                       reducebig 0
                                         (bigopz.index_iotaz 1 (k + 1))
                                         (fun m : int =>
                                          BigBody m +%R true
                                            ((-1) ^ (m + 1) /
                                             (2%:~R * m%:~R ^ 3 *
                                              match n with
                                              | Posz n1 =>
                                                 match m with
                                                 | Posz m1 =>
                                                 binomial_rec n1 m1 true true
                                                 | Negz m1 =>
                                                 binomial_rec n1 m1 true
                                                 false
                                                 end
                                              | Negz n1 =>
                                                 match m with
                                                 | Posz m1 =>
                                                 binomial_rec n1 m1 false
                                                 true
                                                 | Negz m1 =>
                                                 binomial_rec n1 m1 false
                                                 false
                                                 end
                                              end%:~R *
                                              match n + m with
                                              | Posz n1 =>
                                                 match m with
                                                 | Posz m1 =>
                                                 binomial_rec n1 m1 true true
                                                 | Negz m1 =>
                                                 binomial_rec n1 m1 true
                                                 false
                                                 end
                                              | Negz n1 =>
                                                 match m with
                                                 | Posz m1 =>
                                                 binomial_rec n1 m1 false
                                                 true
                                                 | Negz m1 =>
                                                 binomial_rec n1 m1 false
                                                 false
                                                 end
                                              end%:~R))))))]
                       The term "conj (erefl false) ?y" has type
                        "false = false /\ ?B"
                       while it is expected to have type
                        "false = true /\ is_true_ true" (cannot unify 
                       "false" and "true").
                         Debug:
In environment
n : int
pi12 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
pi12 : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
pi12 : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
fx : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
fx : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c40 := v (int.shift 4 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
Dec : is_true (2%Z <= Posz n)
c40 := v (int.shift 4 (Posz n)) 0 : rat
c11 := v (int.shift 1 (Posz n)) (int.shift 1 0) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' (Posz n); b (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Dec : is_true (2%Z <= n)
c01 := v n 1 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
n : nat
nge2 : is_true (2%Z <= Posz n)
c10 := v (int.shift 1 (Posz n)) 0 : rat
c20 := v (int.shift 2 (Posz n)) 0 : rat
x, y : int
H : x = y
c30 := v (int.shift 3 (Posz n)) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: b' x; b y]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
s2 := s (int.shift 1 (int.shift 1 (int.shift 1 n))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 n))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s2 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
s5 := s (int.shift 1 (int.shift 1 (int.shift 1 n))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s5 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
Unable to unify "true" with "false".
Debug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
Unable to unify "true" with "false".
Debug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 n))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
s2 := s (int.shift 1 (int.shift 1 (int.shift 1 n))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
Unable to unify "true" with "false".
find_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 n))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
Unable to unify "true" with "false".
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 n))) k : rat
s5 := s (int.shift 1 (int.shift 1 n)) k : rat
s2 := s (int.shift 1 n) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 n))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
t0 := annotated_recs_c.P_cf0 n * b n : GRing.Ring.sort rat_Ring
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n * b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n); t0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
t0 := annotated_recs_c.P_cf0 n * b n : GRing.Ring.sort rat_Ring
H : nat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 (Posz H);
         b (int.shift 1 (int.shift 1 (Posz H)));
         annotated_recs_c.P_cf1 (Posz H); b (int.shift 1 (Posz H)); t0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
find_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
t0 := annotated_recs_c.P_cf0 n * b n : GRing.Ring.sort rat_Ring
valq : int * int
i : is_true ((0 < valq.2) && coprime `|valq.1| `|valq.2|)
c21 := v (int.shift 2 n) (int.shift 1 0) : rat
c30 := v (int.shift 3 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 0%Z; b (int.shift 1 (int.shift 1 0%Z));
         annotated_recs_c.P_cf1 0%Z; b (int.shift 1 0%Z); t0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
t0 := annotated_recs_c.P_cf0 n * b n : GRing.Ring.sort rat_Ring
valq : int * int
i : is_true ((0 < valq.2) && coprime `|valq.1| `|valq.2|)
valq0 : int * int
i0 : is_true ((0 < valq0.2) && coprime `|valq0.1| `|valq0.2|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 0%Z; b (int.shift 1 (int.shift 1 0%Z));
         annotated_recs_c.P_cf1 0%Z; b (int.shift 1 0%Z); t0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
find_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
s1 := s (int.shift 1 (int.shift 1 (int.shift 1 0%Z))) k : rat
Unable to unify "true" with "false".
find_witness Control.TimeoutDebug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
t0 := annotated_recs_c.P_cf0 n * b n : GRing.Ring.sort rat_Ring
inj_f : nat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 (Posz inj_f);
         b (int.shift 1 (int.shift 1 (Posz inj_f)));
         annotated_recs_c.P_cf1 (Posz inj_f); b (int.shift 1 (Posz inj_f));
         t0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
lt_n : int
H : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
lt_n : int
lm : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
find_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
lt_n : int
H : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
lt_n : int
Rx : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
lt_n : int
lm : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
find_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
find_witness Control.Timeoutfind_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
find_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
find_witness Control.TimeoutDebug:
In environment
n : int
Hm : is_true ((2 : int) <= (n : int))
Unable to unify "true" with "false".
Debug:
In environment
lt_n : int
H : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
lt_n : int
Rx : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
lt_n : int
lm : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
x : is_true ((2 : int) <= (n : int))
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
n : int
e : is_true ((2 : int) <= (n : int))
t0 := annotated_recs_c.P_cf0 n * b n : GRing.Ring.sort rat_Ring
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n * b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n); t0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
lt_n : int
H : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
lt_n : int
Rx : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
lt_n : int
HE : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
lt_n : int
H : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
lt_n : int
lm : annotated_recs_z.precond.Sn2 lt_n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 lt_n); annotated_recs_z.Sn2_cf0 lt_n; 
        ghn3 lt_n; annotated_recs_z.Sn2_cf1 lt_n; 
        ghn3 (int.shift 1 lt_n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
find_witness Control.TimeoutDebug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
find_witness Control.Timeoutfind_witness Control.TimeoutDebug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0Debug:
                <in exception printer>:<original exception:
                Anomaly "Uncaught exception Control.Timeout."
                Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; b (int.shift 1 (int.shift 1 1));
         annotated_recs_c.P_cf1 1; b (int.shift 1 1);
         annotated_recs_c.P_cf0 1; b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
find_witness Control.TimeoutDebug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; b (int.shift 1 (int.shift 1 1));
         annotated_recs_c.P_cf1 1; b (int.shift 1 1);
         annotated_recs_c.P_cf0 1; b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c. 1%Z; 
        b 1;
         annotated_recs_cDebug:
                         In environment
                         is_true_ : bool -> Prop
                         negb_ : bool -> bool
                         andb_ : bool -> bool -> bool
                         zero : GRing.Zmodule.sort
                                  (GRing.Ring.zmodType
                                     (Num.NumField.ringType
                                        rat_numFieldType))
                         one : GRing.Ring.sort
                                 (Num.NumField.ringType rat_numFieldType)
                         add : GRing.Zmodule.sort
                                 (GRing.Ring.zmodType
                                    (Num.NumField.ringType
                                       rat_numFieldType)) ->
                               GRing.Zmodule.sort
                                 (GRing.Ring.zmodType
                                    (Num.NumField.ringType
                                       rat_numFieldType)) ->
                               GRing.Zmodule.sort
                                 (GRing.Ring.zmodType
                                    (Num.NumField.ringType
                                       rat_numFieldType))
                         mul : GRing.Ring.sort
                                 (Num.NumField.ringType rat_numFieldType) ->
                               GRing.Ring.sort
                                 (Num.NumField.ringType rat_numFieldType) ->
                               GRing.Ring.sort
                                 (Num.NumField.ringType rat_numFieldType)
                         sub : GRing.Zmodule.sort
                                 (GRing.Ring.zmodType
                                    (Num.NumField.ringType
                                       rat_numFieldType)) ->
                               GRing.Zmodule.sort
                                 (GRing.Ring.zmodType
                                    (Num.NumField.ringType
                                       rat_numFieldType)) ->
                               GRing.Zmodule.sort
                                 (GRing.Ring.zmodType
                                    (Num.NumField.ringType
                                       rat_numFieldType))
                         opp : GRing.Zmodule.sort
                                 (GRing.Ring.zmodType
                                    (Num.NumField.ringType
                                       rat_numFieldType)) ->
                               GRing.Zmodule.sort
                                 (GRing.Ring.zmodType
                                    (Num.NumField.ringType
                                       rat_numFieldType))
                         Feqb : rel
                                  (Equality.sort
                                     (GRing.Zmodule.eqType
                                        (GRing.Ring.zmodType
                                           (Num.NumField.ringType
                                              rat_numFieldType))))
                         F_of_nat : nat ->
                                    GRing.Zmodule.sort
                                      (GRing.Ring.zmodType
                                         (Num.NumField.ringType
                                            rat_numFieldType))
                         exp : GRing.Ring.sort
                                 (Num.NumField.ringType rat_numFieldType) ->
                               nat ->
                               GRing.Ring.sort
                                 (Num.NumField.ringType rat_numFieldType)
                         l : seq (Num.NumField.sort rat_numFieldType)
                         is_trueE : is_true_ = is_true
                         negbE : negb_ = negb
                         andbE : andb_ = andb
                         zeroE : zero = 0
                         oneE : one = 1
                         addE : add = +%R
                         mulE : mul =  *%R
                         subE : sub =
                                (fun
                                   x
                                    y : GRing.Zmodule.sort
                                          (GRing.Ring.zmodType
                                             (Num.NumField.ringType
                                                rat_numFieldType)) =>
                                 x - y)
                         oppE : opp = -%R
                         FeqbE : Feqb = eq_op
                         F_of_natE : F_of_nat = GRing.natmul 1
                         expE : exp =
                                GRing.exp
                                  (R:=Num.NumField.ringType
                                        rat_numFieldType)
                         lE : l =
                              [:: annotated_recs_c.P_cf2 1;
                                  annotated_recs_c.P_cf0 1%Z; 
                                 b 1; annotated_recs_c.P_cf1 1%Z;
                                  annotated_recs_c.P_cf0 0%Z; 
                                 b 0; annotated_recs_c.P_cf1 0%Z;
                                  annotated_recs_c.P_cf2 0%Z;
                                  annotated_recs_c.P_cf2 1%Z;
                                  annotated_recs_c.P_cf1 1;
                                  annotated_recs_c.P_cf0 1]
                         The term "conj (erefl false) ?y" has type
                          "false = false /\ ?B"
                         while it is expected to have type
                          "false = true /\
                           is_true_
                             (andb_
                                (negb_
                                   (Feqb
                                      match
                                        match
                                          match
                                            match
                                              match
                                                match
                                                 match
                                                 match l with
                                                 | [::] => [::]
                                                 | ... => x0
                                                 end
                                                 with
                                                 | [::] => [::]
                                                 | _ :: x0 => x0
                                                 end
                                                with
                                                | [::] => [::]
                                                | _ :: x0 => x0
                                                end
                                              with
                                              | [::] => [::]
                                              | _ :: x0 => x0
                                              end
                                            with
                                            | [::] => [::]
                                            | _ :: x0 => x0
                                            end
                                          with
                                          | [::] => [::]
                                          | _ :: x0 => x0
                                          end
                                        with
                                        | [::] => [::]
                                        | _ :: x0 => x0
                                        end
                                      with
                                      | [::] => zero
                                      | x :: _ => x
                                      end zero))
                                (negb_
                                   (Feqb
                                      match
                                        match
                                          match
                                            match
                                              match
                                                match
                                                 match
                                                 match ... with
                                                 | [::] => [::]
                                                 | ... => x0
                                                 end
                                                 with
                                                 | [::] => [::]
                                                 | _ :: x0 => x0
                                                 end
                                                with
                                                | [::] => [::]
                                                | _ :: x0 => x0
                                                end
                                              with
                                              | [::] => [::]
                                              | _ :: x0 => x0
                                              end
                                            with
                                            | [::] => [::]
                                            | _ :: x0 => x0
                                            end
                                          with
                                          | [::] => [::]
                                          | _ :: x0 => x0
                                          end
                                        with
                                        | [::] => [::]
                                        | _ :: x0 => x0
                                        end
                                      with
                                      | [::] => zero
                                      | x :: _ => x
                                      end zero)))" (cannot unify 
                         "false" and "true").
           Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
find_witness Control.TimeoutDebug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; b (int.shift 1 (int.shift 1 1));
         annotated_recs_c.P_cf1 1; b (int.shift 1 1);
         annotated_recs_c.P_cf0 1; b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; b (int.shift 1 (int.shift 1 1));
         annotated_recs_c.P_cf1 1; b (int.shift 1 1);
         annotated_recs_c.P_cf0 1; b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: ((((match rat_of_Z 2 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | 1%Z =>
                        match y1 with
                        | 0%Z => (1%Z, 1%Z)
                        | 1%Z => (2%Z, 1%Z)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%Z)
                        | Negz _ =>
                            (match y1 with
                             | Posz n' => Posz n'.+1
                             | Negz n' =>
                                 if eqn (n' - 0)%Nrec 0
                                 then 0%Z
                                 else Negz (n' - 1)%Nrec
                             end, 1%Z)
                        end
                    | _ =>
                        (intZmod.addz
                           match y2 with
                           | Posz n' => Posz (n' + 0)%coq_nat
                           | Negz n' => Negz (n' + 0)%coq_nat
                           end y1, y2)
                    end)
             end *
             (match rat_of_Z 2 with
              | {| valq := y |} =>
                  fracq
                    (let (y1, y2) := y in
                     match y2 with
                     | 1%Z =>
                         match y1 with
                         | 0%Z => (1%Z, 1%Z)
                         | 1%Z => (2%Z, 1%Z)
                         | Posz (_.+2 as n) => (Posz n.+1, 1%Z)
                         | Negz _ =>
                             (match y1 with
                              | Posz n' => Posz n'.+1
                              | Negz n' =>
                                  if eqn (n' - 0)%Nrec 0
                                  then 0%Z
                                  else Negz (n' - 1)%Nrec
                              end, 1%Z)
                         end
                     | _ =>
                         (intZmod.addz
                            match y2 with
                            | Posz n' => Posz (n' + 0)%coq_nat
                            | Negz n' => Negz (n' + 0)%coq_nat
                            end y1, y2)
                     end)
              end *
              match rat_of_Z 2 with
              | {| valq := y |} =>
                  fracq
                    (let (y1, y2) := y in
                     match y2 with
                     | 1%Z =>
                         match y1 with
                         | 0%Z => (1%Z, 1%Z)
                         | 1%Z => (2%Z, 1%Z)
                         | Posz (_.+2 as n) => (Posz n.+1, 1%Z)
                         | Negz _ =>
                             (match y1 with
                              | Posz n' => Posz n'.+1
                              | Negz n' =>
                                  if eqn (n' - 0)%Nrec 0
                                  then 0%Z
                                  else Negz (n' - 1)%Nrec
                              end, 1%Z)
                         end
                     | _ =>
                         (intZmod.addz
                            match y2 with
                            | Posz n' => Posz (n' + 0)%coq_nat
                            | Negz n' => Negz (n' + 0)%coq_nat
                            end y1, y2)
                     end)
              end)%Q)%Q * b 3%Z)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * fracq (1%Z, 1%Z))%Q + (rat_of_Z 51 * oneq)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * oneq)%Q + rat_of_Z 3)%Q)%Q *
            b 2%Z)%Q)%Q +
          ((match rat_of_Z 1 with
            | {| valq := y |} =>
                fracq
                  (let (y1, y2) := y in
                   match y2 with
                   | 1%Z =>
                       match y1 with
                       | 0%Z => (1%Z, 1%Z)
                       | 1%Z => (2%Z, 1%Z)
                       | Posz (_.+2 as n) => (Posz n.+1, 1%Z)
                       | Negz _ =>
                           (match y1 with
                            | Posz n' => Posz n'.+1
                            | Negz n' =>
                                if eqn (n' - 0)%Nrec 0
                                then 0%Z
                                else Negz (n' - 1)%Nrec
                            end, 1%Z)
                       end
                   | _ =>
                       (intZmod.addz
                          match y2 with
                          | Posz n' => Posz (n' + 0)%coq_nat
                          | Negz n' => Negz (n' + 0)%coq_nat
                          end y1, y2)
                   end)
            end *
            (match rat_of_Z 1 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | 1%Z =>
                        match y1 with
                        | 0%Z => (1%Z, 1%Z)
                        | 1%Z => (2%Z, 1%Z)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%Z)
                        | Negz _ =>
                            (match y1 with
                             | Posz n' => Posz n'.+1
                             | Negz n' =>
                                 if eqn (n' - 0)%Nrec 0
                                 then 0%Z
                                 else Negz (n' - 1)%Nrec
                             end, 1%Z)
                        end
                    | _ =>
                        (intZmod.addz
                           match y2 with
                           | Posz n' => Posz (n' + 0)%coq_nat
                           | Negz n' => Negz (n' + 0)%coq_nat
                           end y1, y2)
                    end)
             end *
             match rat_of_Z 1 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | 1%Z =>
                        match y1 with
                        | 0%Z => (1%Z, 1%Z)
                        | 1%Z => (2%Z, 1%Z)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%Z)
                        | Negz _ =>
                            (match y1 with
                             | Posz n' => Posz n'.+1
                             | Negz n' =>
                                 if eqn (n' - 0)%Nrec 0
                                 then 0%Z
                                 else Negz (n' - 1)%Nrec
                             end, 1%Z)
                        end
                    | _ =>
                        (intZmod.addz
                           match y2 with
                           | Posz n' => Posz (n' + 0)%coq_nat
                           | Negz n' => Negz (n' + 0)%coq_nat
                           end y1, y2)
                    end)
             end)%Q)%Q * b 1%Z)%Q)%Q; zeroq]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 1; annotated_recs_c.P_cf0 1%Z; 
        b 1; annotated_recs_c.P_cf1 1%Z; annotated_recs_c.P_cf0 0%Z; 
        b 0; annotated_recs_c.P_cf1 0%Z; annotated_recs_c.P_cf2 0%Z;
         annotated_recs_c.P_cf2 1%Z; annotated_recs_c.P_cf1 1;
         annotated_recs_c.P_cf0 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match l with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match l with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero)))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
In environment
l, x : int
H1 : annotated_recs_s.precond.SnSk l x
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: u (int.shift 1 l) (int.shift 1 x); l%:~R; x%:~R; 
        u l x; u (int.shift 1 l) x; annotated_recs_s.SnSk_cf0_1 l x;
         u l (int.shift 1 x)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add
                match match l0 with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2%N))
             match
               match match l0 with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end) zero))" (cannot unify "false" and 
"true").
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
Debug:
<in exception printer>:<original exception:Anomaly
                                           "Uncaught exception Control.Timeout."
Please report at http://coq.inria.fr/bugs/.
find_witness Control.Timeoutfind_witness Control.Timeoutfind_witness Control.Timeoutzeta_3_irrational : ~ (exists r : rat, (z3 == r%:CR)%CR)

zeta_3_irrational is not universe polymorphic
zeta_3_irrational is opaque
Expands to: Constant mathcomp.apery.z3irrational.zeta_3_irrational
Debug:
In environment
n : int
m := n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 m; b (int.shift 1 (int.shift 1 m));
         annotated_recs_c.P_cf1 m; b (int.shift 1 m);
         annotated_recs_c.P_cf0 m; b m]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: n%:R; b' (int.shift 1 (int.shift 1 (Posz n)));
         b' (int.shift 1 (Posz n)); b' (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
telQ := annotated_recs_c.P_cf2 n *
        (-
         (annotated_recs_c.P_cf0 n * b' n +
          annotated_recs_c.P_cf1 n * b' (int.shift 1 n)) /
         annotated_recs_c.P_cf2 n) : GRing.Ring.sort rat_Ring
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: telQ; n%:~R; b' (int.shift 1 n); b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
m := n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 m; b (int.shift 1 (int.shift 1 m));
         annotated_recs_c.P_cf1 m; b (int.shift 1 m);
         annotated_recs_c.P_cf0 m; b m]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: n%:R; b' (int.shift 1 (int.shift 1 (Posz n)));
         b' (int.shift 1 (Posz n)); b' (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutClosed under the global context
find_witness Control.TimeoutDebug:
In environment
_Hyp_ : annotated_recs_z.Ann ghn3
x, x' : int
Hxx' : annotated_recs_s.precond.Sk2 x x'
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u x (int.shift 2 x'); annotated_recs_s.Sk2_cf0_0 x x'; 
        u x x'; annotated_recs_s.Sk2_cf0_1 x x'; u x (int.shift 1 x')]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.TimeoutDebug:
In environment
l, q1 : int
q2 : annotated_recs_s.precond.Sk2 l q1
u1 := u l (int.shift 2 q1) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: u1; annotated_recs_s.Sk2_cf0_0 l q1; u l q1;
         annotated_recs_s.Sk2_cf0_1 l q1; u l (int.shift 1 q1)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
m : int
H1 : 0 <= m
H2 : m + 1 < n
a : ?Goal@{n:=Posz n} ?Goal0@{n:=Posz n} /\
    (forall B : {set ?elpi_evar@{n:=Posz n}},
     ?Goal@{n:=Posz n} B ->
     ?Goal0@{n:=Posz n} \subset B -> B = ?Goal0@{n:=Posz n})
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u n (int.shift 2 m); annotated_recs_s.Sk2_cf0_0 n m; 
        u n m; annotated_recs_s.Sk2_cf0_1 n m; u n (int.shift 1 m)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
m : int
H1 : 0 <= m
H2 : m + 1 < n
f : ?Goal@{n:=Posz n} ?Goal0@{n:=Posz n} /\
    (forall B : {set ?elpi_evar@{n:=Posz n}},
     ?Goal@{n:=Posz n} B ->
     ?Goal0@{n:=Posz n} \subset B -> B = ?Goal0@{n:=Posz n})
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u n (int.shift 2 m); annotated_recs_s.Sk2_cf0_0 n m; 
        u n m; annotated_recs_s.Sk2_cf0_1 n m; u n (int.shift 1 m)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
_Hyp_ : annotated_recs_z.Ann ghn3
x, x' : int
Hxx' : annotated_recs_s.precond.Sk2 x x'
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u x (int.shift 2 x'); annotated_recs_s.Sk2_cf0_0 x x'; 
        u x x'; annotated_recs_s.Sk2_cf0_1 x x'; u x (int.shift 1 x')]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
_Hyp_ : annotated_recs_z.Ann ghn3
x, x' : int
Hxx' : annotated_recs_s.precond.Sk2 x x'
d : int * int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u x (int.shift 2 x'); annotated_recs_s.Sk2_cf0_0 x x'; 
        u x x'; annotated_recs_s.Sk2_cf0_1 x x'; u x (int.shift 1 x')]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Fun.Finally_raised: Control.TimeoutDebug:
In environment
l, ucG : int
H : annotated_recs_s.precond.Sk2 l ucG
u1 := u l (int.shift 2 ucG) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: u1; annotated_recs_s.Sk2_cf0_0 l ucG; u l ucG;
         annotated_recs_s.Sk2_cf0_1 l ucG; u l (int.shift 1 ucG)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
l, ucG : int
H : annotated_recs_s.precond.Sk2 l ucG
Unable to unify "true" with "false".
find_witness Control.TimeoutDebug:
In environment
l, q1 : int
q2 : annotated_recs_s.precond.Sk2 l q1
u1 := u l (int.shift 2 q1) : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: u1; annotated_recs_s.Sk2_cf0_0 l q1; u l q1;
         annotated_recs_s.Sk2_cf0_1 l q1; u l (int.shift 1 q1)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
m : int
H1 : 0 <= m
H2 : m + 1 < n
a : ?Goal@{n:=Posz n} ?Goal0@{n:=Posz n} /\
    (forall B : {set ?elpi_evar@{n:=Posz n}},
     ?Goal@{n:=Posz n} B ->
     ?Goal0@{n:=Posz n} \subset B -> B = ?Goal0@{n:=Posz n})
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u n (int.shift 2 m); annotated_recs_s.Sk2_cf0_0 n m; 
        u n m; annotated_recs_s.Sk2_cf0_1 n m; u n (int.shift 1 m)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
m : int
H1 : 0 <= m
H2 : m + 1 < n
a : ?Goal@{n:=Posz n} ?Goal0@{n:=Posz n} /\
    (forall B : {set ?elpi_evar@{n:=Posz n}},
     ?Goal@{n:=Posz n} B ->
     ?Goal0@{n:=Posz n} \subset B -> B = ?Goal0@{n:=Posz n})
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u 0%Z (int.shift 2 m); annotated_recs_s.Sk2_cf0_0 0%Z m; 
        u 0%Z m; annotated_recs_s.Sk2_cf0_1 0%Z m; 
        u 0%Z (int.shift 1 m)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
m : int
H1 : 0 <= m
H2 : m + 1 < n
f : ?Goal@{n:=Posz n} ?Goal0@{n:=Posz n} /\
    (forall B : {set ?elpi_evar@{n:=Posz n}},
     ?Goal@{n:=Posz n} B ->
     ?Goal0@{n:=Posz n} \subset B -> B = ?Goal0@{n:=Posz n})
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u n (int.shift 2 m); annotated_recs_s.Sk2_cf0_0 n m; 
        u n m; annotated_recs_s.Sk2_cf0_1 n m; u n (int.shift 1 m)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
_Hyp_ : annotated_recs_z.Ann ghn3
x, x' : int
Hxx' : annotated_recs_s.precond.Sk2 x x'
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u x (int.shift 2 x'); annotated_recs_s.Sk2_cf0_0 x x'; 
        u x x'; annotated_recs_s.Sk2_cf0_1 x x'; u x (int.shift 1 x')]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
_Hyp_ : annotated_recs_z.Ann ghn3
x, x' : int
Hxx' : annotated_recs_s.precond.Sk2 x x'
d : int * int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u x (int.shift 2 x'); annotated_recs_s.Sk2_cf0_0 x x'; 
        u x x'; annotated_recs_s.Sk2_cf0_1 x x'; u x (int.shift 1 x')]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
_Hyp_ : annotated_recs_z.Ann ghn3
x, x' : int
Hxx' : annotated_recs_s.precond.Sk2 x x'
d : int * int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u x (int.shift 2 x'); annotated_recs_s.Sk2_cf0_0 x x'; 
        u x x'; annotated_recs_s.Sk2_cf0_1 x x'; u x (int.shift 1 x')]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
find_witness Control.Timeout